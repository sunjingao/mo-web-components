import { Fragment as Fe, isVNode as In, Comment as Nx, Text as pf, defineComponent as Z, reactive as xt, getCurrentInstance as Wn, onMounted as Ke, onUpdated as co, onUnmounted as uo, watch as ie, computed as P, inject as tt, provide as Je, ref as Y, unref as hn, shallowRef as Q, watchEffect as Le, onBeforeUnmount as et, triggerRef as Rx, createVNode as f, h as vr, nextTick as rt, Transition as yn, withDirectives as Tn, resolveDirective as oT, cloneVNode as tr, render as yl, toRef as Te, withModifiers as Ay, vShow as Hn, onBeforeMount as vf, Teleport as Jm, createTextVNode as Ot, isRef as kx, toRefs as Qo, toRaw as Yt, useAttrs as rT, onBeforeUpdate as eh, getCurrentScope as lT, onScopeDispose as aT, TransitionGroup as gf, onActivated as th, onDeactivated as iT, createApp as sT, resolveComponent as st, openBlock as Ne, createBlock as Et, withCtx as pt, toDisplayString as dn, createElementVNode as rn, mergeProps as Ft, createSlots as Sr, renderList as ln, renderSlot as Bn, createElementBlock as it, createCommentVNode as ht, normalizeClass as aa, normalizeStyle as Fr, resolveDynamicComponent as Dy, normalizeProps as cT, pushScopeId as uT, popScopeId as dT } from "vue";
const Bx = {
  // Options.jsx
  items_per_page: "条/页",
  jump_to: "跳至",
  jump_to_confirm: "确定",
  page: "页",
  // Pagination.jsx
  prev_page: "上一页",
  next_page: "下一页",
  prev_5: "向前 5 页",
  next_5: "向后 5 页",
  prev_3: "向前 3 页",
  next_3: "向后 3 页"
};
function m() {
  return m = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        ({}).hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, m.apply(null, arguments);
}
const fT = {
  locale: "zh_CN",
  today: "今天",
  now: "此刻",
  backToToday: "返回今天",
  ok: "确定",
  timeSelect: "选择时间",
  dateSelect: "选择日期",
  weekSelect: "选择周",
  clear: "清除",
  month: "月",
  year: "年",
  previousMonth: "上个月 (翻页上键)",
  nextMonth: "下个月 (翻页下键)",
  monthSelect: "选择月份",
  yearSelect: "选择年份",
  decadeSelect: "选择年代",
  yearFormat: "YYYY年",
  dayFormat: "D日",
  dateFormat: "YYYY年M月D日",
  dateTimeFormat: "YYYY年M月D日 HH时mm分ss秒",
  previousYear: "上一年 (Control键加左方向键)",
  nextYear: "下一年 (Control键加右方向键)",
  previousDecade: "上一年代",
  nextDecade: "下一年代",
  previousCentury: "上一世纪",
  nextCentury: "下一世纪"
}, Fx = {
  placeholder: "请选择时间",
  rangePlaceholder: ["开始时间", "结束时间"]
}, pg = {
  lang: m({
    placeholder: "请选择日期",
    yearPlaceholder: "请选择年份",
    quarterPlaceholder: "请选择季度",
    monthPlaceholder: "请选择月份",
    weekPlaceholder: "请选择周",
    rangePlaceholder: ["开始日期", "结束日期"],
    rangeYearPlaceholder: ["开始年份", "结束年份"],
    rangeMonthPlaceholder: ["开始月份", "结束月份"],
    rangeQuarterPlaceholder: ["开始季度", "结束季度"],
    rangeWeekPlaceholder: ["开始周", "结束周"]
  }, fT),
  timePickerLocale: m({}, Fx)
};
pg.lang.ok = "确定";
const po = "${label}不是一个有效的${type}", pT = {
  locale: "zh-cn",
  Pagination: Bx,
  DatePicker: pg,
  TimePicker: Fx,
  Calendar: pg,
  // locales for all components
  global: {
    placeholder: "请选择"
  },
  Table: {
    filterTitle: "筛选",
    filterConfirm: "确定",
    filterReset: "重置",
    filterEmptyText: "无筛选项",
    filterCheckall: "全选",
    filterSearchPlaceholder: "在筛选项中搜索",
    selectAll: "全选当页",
    selectInvert: "反选当页",
    selectNone: "清空所有",
    selectionAll: "全选所有",
    sortTitle: "排序",
    expand: "展开行",
    collapse: "关闭行",
    triggerDesc: "点击降序",
    triggerAsc: "点击升序",
    cancelSort: "取消排序"
  },
  Tour: {
    Next: "下一步",
    Previous: "上一步",
    Finish: "结束导览"
  },
  Modal: {
    okText: "确定",
    cancelText: "取消",
    justOkText: "知道了"
  },
  Popconfirm: {
    cancelText: "取消",
    okText: "确定"
  },
  Transfer: {
    searchPlaceholder: "请输入搜索内容",
    itemUnit: "项",
    itemsUnit: "项",
    remove: "删除",
    selectCurrent: "全选当页",
    removeCurrent: "删除当页",
    selectAll: "全选所有",
    removeAll: "删除全部",
    selectInvert: "反选当页"
  },
  Upload: {
    uploading: "文件上传中",
    removeFile: "删除文件",
    uploadError: "上传错误",
    previewFile: "预览文件",
    downloadFile: "下载文件"
  },
  Empty: {
    description: "暂无数据"
  },
  Icon: {
    icon: "图标"
  },
  Text: {
    edit: "编辑",
    copy: "复制",
    copied: "复制成功",
    expand: "展开"
  },
  PageHeader: {
    back: "返回"
  },
  Form: {
    optional: "（可选）",
    defaultValidateMessages: {
      default: "字段验证错误${label}",
      required: "请输入${label}",
      enum: "${label}必须是其中一个[${enum}]",
      whitespace: "${label}不能为空字符",
      date: {
        format: "${label}日期格式无效",
        parse: "${label}不能转换为日期",
        invalid: "${label}是一个无效日期"
      },
      types: {
        string: po,
        method: po,
        array: po,
        object: po,
        number: po,
        date: po,
        boolean: po,
        integer: po,
        float: po,
        regexp: po,
        email: po,
        url: po,
        hex: po
      },
      string: {
        len: "${label}须为${len}个字符",
        min: "${label}最少${min}个字符",
        max: "${label}最多${max}个字符",
        range: "${label}须在${min}-${max}字符之间"
      },
      number: {
        len: "${label}必须等于${len}",
        min: "${label}最小值为${min}",
        max: "${label}最大值为${max}",
        range: "${label}须在${min}-${max}之间"
      },
      array: {
        len: "须为${len}个${label}",
        min: "最少${min}个${label}",
        max: "最多${max}个${label}",
        range: "${label}数量须在${min}-${max}之间"
      },
      pattern: {
        mismatch: "${label}与模式不匹配${pattern}"
      }
    }
  },
  Image: {
    preview: "预览"
  },
  QRCode: {
    expired: "二维码已过期",
    refresh: "点击刷新",
    scanned: "已扫描"
  }
}, $fe = pT;
function As(e) {
  "@babel/helpers - typeof";
  return As = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, As(e);
}
function vT(e, t) {
  if (As(e) != "object" || !e)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var o = n.call(e, t || "default");
    if (As(o) != "object")
      return o;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function gT(e) {
  var t = vT(e, "string");
  return As(t) == "symbol" ? t : t + "";
}
function mT(e, t, n) {
  return (t = gT(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Ny(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function D(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ny(Object(n), !0).forEach(function(o) {
      mT(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ny(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
const vg = (e) => typeof e == "function", hT = Array.isArray, bT = (e) => typeof e == "string", yT = (e) => e !== null && typeof e == "object", ST = /^on[^a-z]/, CT = (e) => ST.test(e), nh = (e) => {
  const t = /* @__PURE__ */ Object.create(null);
  return (n) => t[n] || (t[n] = e(n));
}, $T = /-(\w)/g, Oi = nh((e) => e.replace($T, (t, n) => n ? n.toUpperCase() : "")), wT = /\B([A-Z])/g, xT = nh((e) => e.replace(wT, "-$1").toLowerCase()), OT = nh((e) => e.charAt(0).toUpperCase() + e.slice(1)), PT = Object.prototype.hasOwnProperty, Ry = (e, t) => PT.call(e, t);
function IT(e, t, n, o) {
  const r = e[n];
  if (r != null) {
    const l = Ry(r, "default");
    if (l && o === void 0) {
      const a = r.default;
      o = r.type !== Function && vg(a) ? a() : a;
    }
    r.type === Boolean && (!Ry(t, n) && !l ? o = !1 : o === "" && (o = !0));
  }
  return o;
}
function ET(e) {
  return Object.keys(e).reduce((t, n) => ((n.startsWith("data-") || n.startsWith("aria-")) && (t[n] = e[n]), t), {});
}
function jl(e) {
  return typeof e == "number" ? `${e}px` : e;
}
function Ga(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 ? arguments[2] : void 0;
  return typeof e == "function" ? e(t) : e ?? n;
}
function TT(e) {
  let t;
  const n = new Promise((r) => {
    t = e(() => {
      r(!0);
    });
  }), o = () => {
    t == null || t();
  };
  return o.then = (r, l) => n.then(r, l), o.promise = n, o;
}
function ee() {
  const e = [];
  for (let t = 0; t < arguments.length; t++) {
    const n = t < 0 || arguments.length <= t ? void 0 : arguments[t];
    if (n) {
      if (bT(n))
        e.push(n);
      else if (hT(n))
        for (let o = 0; o < n.length; o++) {
          const r = ee(n[o]);
          r && e.push(r);
        }
      else if (yT(n))
        for (const o in n)
          n[o] && e.push(o);
    }
  }
  return e.join(" ");
}
var Lx = function() {
  if (typeof Map < "u")
    return Map;
  function e(t, n) {
    var o = -1;
    return t.some(function(r, l) {
      return r[0] === n ? (o = l, !0) : !1;
    }), o;
  }
  return (
    /** @class */
    function() {
      function t() {
        this.__entries__ = [];
      }
      return Object.defineProperty(t.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: !0,
        configurable: !0
      }), t.prototype.get = function(n) {
        var o = e(this.__entries__, n), r = this.__entries__[o];
        return r && r[1];
      }, t.prototype.set = function(n, o) {
        var r = e(this.__entries__, n);
        ~r ? this.__entries__[r][1] = o : this.__entries__.push([n, o]);
      }, t.prototype.delete = function(n) {
        var o = this.__entries__, r = e(o, n);
        ~r && o.splice(r, 1);
      }, t.prototype.has = function(n) {
        return !!~e(this.__entries__, n);
      }, t.prototype.clear = function() {
        this.__entries__.splice(0);
      }, t.prototype.forEach = function(n, o) {
        o === void 0 && (o = null);
        for (var r = 0, l = this.__entries__; r < l.length; r++) {
          var a = l[r];
          n.call(o, a[1], a[0]);
        }
      }, t;
    }()
  );
}(), gg = typeof window < "u" && typeof document < "u" && window.document === document, id = function() {
  return typeof global < "u" && global.Math === Math ? global : typeof self < "u" && self.Math === Math ? self : typeof window < "u" && window.Math === Math ? window : Function("return this")();
}(), MT = function() {
  return typeof requestAnimationFrame == "function" ? requestAnimationFrame.bind(id) : function(e) {
    return setTimeout(function() {
      return e(Date.now());
    }, 1e3 / 60);
  };
}(), _T = 2;
function AT(e, t) {
  var n = !1, o = !1, r = 0;
  function l() {
    n && (n = !1, e()), o && i();
  }
  function a() {
    MT(l);
  }
  function i() {
    var s = Date.now();
    if (n) {
      if (s - r < _T)
        return;
      o = !0;
    } else
      n = !0, o = !1, setTimeout(a, t);
    r = s;
  }
  return i;
}
var DT = 20, NT = ["top", "right", "bottom", "left", "width", "height", "size", "weight"], RT = typeof MutationObserver < "u", kT = (
  /** @class */
  function() {
    function e() {
      this.connected_ = !1, this.mutationEventsAdded_ = !1, this.mutationsObserver_ = null, this.observers_ = [], this.onTransitionEnd_ = this.onTransitionEnd_.bind(this), this.refresh = AT(this.refresh.bind(this), DT);
    }
    return e.prototype.addObserver = function(t) {
      ~this.observers_.indexOf(t) || this.observers_.push(t), this.connected_ || this.connect_();
    }, e.prototype.removeObserver = function(t) {
      var n = this.observers_, o = n.indexOf(t);
      ~o && n.splice(o, 1), !n.length && this.connected_ && this.disconnect_();
    }, e.prototype.refresh = function() {
      var t = this.updateObservers_();
      t && this.refresh();
    }, e.prototype.updateObservers_ = function() {
      var t = this.observers_.filter(function(n) {
        return n.gatherActive(), n.hasActive();
      });
      return t.forEach(function(n) {
        return n.broadcastActive();
      }), t.length > 0;
    }, e.prototype.connect_ = function() {
      !gg || this.connected_ || (document.addEventListener("transitionend", this.onTransitionEnd_), window.addEventListener("resize", this.refresh), RT ? (this.mutationsObserver_ = new MutationObserver(this.refresh), this.mutationsObserver_.observe(document, {
        attributes: !0,
        childList: !0,
        characterData: !0,
        subtree: !0
      })) : (document.addEventListener("DOMSubtreeModified", this.refresh), this.mutationEventsAdded_ = !0), this.connected_ = !0);
    }, e.prototype.disconnect_ = function() {
      !gg || !this.connected_ || (document.removeEventListener("transitionend", this.onTransitionEnd_), window.removeEventListener("resize", this.refresh), this.mutationsObserver_ && this.mutationsObserver_.disconnect(), this.mutationEventsAdded_ && document.removeEventListener("DOMSubtreeModified", this.refresh), this.mutationsObserver_ = null, this.mutationEventsAdded_ = !1, this.connected_ = !1);
    }, e.prototype.onTransitionEnd_ = function(t) {
      var n = t.propertyName, o = n === void 0 ? "" : n, r = NT.some(function(l) {
        return !!~o.indexOf(l);
      });
      r && this.refresh();
    }, e.getInstance = function() {
      return this.instance_ || (this.instance_ = new e()), this.instance_;
    }, e.instance_ = null, e;
  }()
), zx = function(e, t) {
  for (var n = 0, o = Object.keys(t); n < o.length; n++) {
    var r = o[n];
    Object.defineProperty(e, r, {
      value: t[r],
      enumerable: !1,
      writable: !1,
      configurable: !0
    });
  }
  return e;
}, pi = function(e) {
  var t = e && e.ownerDocument && e.ownerDocument.defaultView;
  return t || id;
}, Hx = mf(0, 0, 0, 0);
function sd(e) {
  return parseFloat(e) || 0;
}
function ky(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return t.reduce(function(o, r) {
    var l = e["border-" + r + "-width"];
    return o + sd(l);
  }, 0);
}
function BT(e) {
  for (var t = ["top", "right", "bottom", "left"], n = {}, o = 0, r = t; o < r.length; o++) {
    var l = r[o], a = e["padding-" + l];
    n[l] = sd(a);
  }
  return n;
}
function FT(e) {
  var t = e.getBBox();
  return mf(0, 0, t.width, t.height);
}
function LT(e) {
  var t = e.clientWidth, n = e.clientHeight;
  if (!t && !n)
    return Hx;
  var o = pi(e).getComputedStyle(e), r = BT(o), l = r.left + r.right, a = r.top + r.bottom, i = sd(o.width), s = sd(o.height);
  if (o.boxSizing === "border-box" && (Math.round(i + l) !== t && (i -= ky(o, "left", "right") + l), Math.round(s + a) !== n && (s -= ky(o, "top", "bottom") + a)), !HT(e)) {
    var c = Math.round(i + l) - t, u = Math.round(s + a) - n;
    Math.abs(c) !== 1 && (i -= c), Math.abs(u) !== 1 && (s -= u);
  }
  return mf(r.left, r.top, i, s);
}
var zT = /* @__PURE__ */ function() {
  return typeof SVGGraphicsElement < "u" ? function(e) {
    return e instanceof pi(e).SVGGraphicsElement;
  } : function(e) {
    return e instanceof pi(e).SVGElement && typeof e.getBBox == "function";
  };
}();
function HT(e) {
  return e === pi(e).document.documentElement;
}
function jT(e) {
  return gg ? zT(e) ? FT(e) : LT(e) : Hx;
}
function VT(e) {
  var t = e.x, n = e.y, o = e.width, r = e.height, l = typeof DOMRectReadOnly < "u" ? DOMRectReadOnly : Object, a = Object.create(l.prototype);
  return zx(a, {
    x: t,
    y: n,
    width: o,
    height: r,
    top: n,
    right: t + o,
    bottom: r + n,
    left: t
  }), a;
}
function mf(e, t, n, o) {
  return { x: e, y: t, width: n, height: o };
}
var WT = (
  /** @class */
  function() {
    function e(t) {
      this.broadcastWidth = 0, this.broadcastHeight = 0, this.contentRect_ = mf(0, 0, 0, 0), this.target = t;
    }
    return e.prototype.isActive = function() {
      var t = jT(this.target);
      return this.contentRect_ = t, t.width !== this.broadcastWidth || t.height !== this.broadcastHeight;
    }, e.prototype.broadcastRect = function() {
      var t = this.contentRect_;
      return this.broadcastWidth = t.width, this.broadcastHeight = t.height, t;
    }, e;
  }()
), KT = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, n) {
      var o = VT(n);
      zx(this, { target: t, contentRect: o });
    }
    return e;
  }()
), GT = (
  /** @class */
  function() {
    function e(t, n, o) {
      if (this.activeObservations_ = [], this.observations_ = new Lx(), typeof t != "function")
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      this.callback_ = t, this.controller_ = n, this.callbackCtx_ = o;
    }
    return e.prototype.observe = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof pi(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) || (n.set(t, new WT(t)), this.controller_.addObserver(this), this.controller_.refresh());
      }
    }, e.prototype.unobserve = function(t) {
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      if (!(typeof Element > "u" || !(Element instanceof Object))) {
        if (!(t instanceof pi(t).Element))
          throw new TypeError('parameter 1 is not of type "Element".');
        var n = this.observations_;
        n.has(t) && (n.delete(t), n.size || this.controller_.removeObserver(this));
      }
    }, e.prototype.disconnect = function() {
      this.clearActive(), this.observations_.clear(), this.controller_.removeObserver(this);
    }, e.prototype.gatherActive = function() {
      var t = this;
      this.clearActive(), this.observations_.forEach(function(n) {
        n.isActive() && t.activeObservations_.push(n);
      });
    }, e.prototype.broadcastActive = function() {
      if (this.hasActive()) {
        var t = this.callbackCtx_, n = this.activeObservations_.map(function(o) {
          return new KT(o.target, o.broadcastRect());
        });
        this.callback_.call(t, n, t), this.clearActive();
      }
    }, e.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    }, e.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    }, e;
  }()
), jx = typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : new Lx(), Vx = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      if (!(this instanceof e))
        throw new TypeError("Cannot call a class as a function.");
      if (!arguments.length)
        throw new TypeError("1 argument required, but only 0 present.");
      var n = kT.getInstance(), o = new GT(t, n, this);
      jx.set(this, o);
    }
    return e;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(e) {
  Vx.prototype[e] = function() {
    var t;
    return (t = jx.get(this))[e].apply(t, arguments);
  };
});
var oh = function() {
  return typeof id.ResizeObserver < "u" ? id.ResizeObserver : Vx;
}();
const mg = (e) => e != null && e !== "", Qe = (e, t) => {
  const n = m({}, e);
  return Object.keys(t).forEach((o) => {
    const r = n[o];
    if (r)
      r.type || r.default ? r.default = t[o] : r.def ? r.def(t[o]) : n[o] = {
        type: r,
        default: t[o]
      };
    else
      throw new Error(`not have ${o} prop`);
  }), n;
}, rh = (e) => {
  const t = Object.keys(e), n = {}, o = {}, r = {};
  for (let l = 0, a = t.length; l < a; l++) {
    const i = t[l];
    CT(i) ? (n[i[2].toLowerCase() + i.slice(3)] = e[i], o[i] = e[i]) : r[i] = e[i];
  }
  return {
    onEvents: o,
    events: n,
    extraAttrs: r
  };
}, XT = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = {}, o = /;(?![^(]*\))/g, r = /:(.+)/;
  return typeof e == "object" ? e : (e.split(o).forEach(function(l) {
    if (l) {
      const a = l.split(r);
      if (a.length > 1) {
        const i = t ? Oi(a[0].trim()) : a[0].trim();
        n[i] = a[1].trim();
      }
    }
  }), n);
}, Rr = (e, t) => e[t] !== void 0, Wx = Symbol("skipFlatten"), It = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  const n = Array.isArray(e) ? e : [e], o = [];
  return n.forEach((r) => {
    Array.isArray(r) ? o.push(...It(r, t)) : r && r.type === Fe ? r.key === Wx ? o.push(r) : o.push(...It(r.children, t)) : r && In(r) ? t && !nc(r) ? o.push(r) : t || o.push(r) : mg(r) && o.push(r);
  }), o;
}, hf = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (In(e))
    return e.type === Fe ? t === "default" ? It(e.children) : [] : e.children && e.children[t] ? It(e.children[t](n)) : [];
  {
    const o = e.$slots[t] && e.$slots[t](n);
    return It(o);
  }
}, qn = (e) => {
  var t;
  let n = ((t = e == null ? void 0 : e.vnode) === null || t === void 0 ? void 0 : t.el) || e && (e.$el || e);
  for (; n && !n.tagName; )
    n = n.nextSibling;
  return n;
}, Kx = (e) => {
  const t = {};
  if (e.$ && e.$.vnode) {
    const n = e.$.vnode.props || {};
    Object.keys(e.$props).forEach((o) => {
      const r = e.$props[o], l = xT(o);
      (r !== void 0 || l in n) && (t[o] = r);
    });
  } else if (In(e) && typeof e.type == "object") {
    const n = e.props || {}, o = {};
    Object.keys(n).forEach((l) => {
      o[Oi(l)] = n[l];
    });
    const r = e.type.props || {};
    Object.keys(r).forEach((l) => {
      const a = IT(r, o, l, o[l]);
      (a !== void 0 || l in o) && (t[l] = a);
    });
  }
  return t;
}, Gx = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "default", n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : e, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !0, r;
  if (e.$) {
    const l = e[t];
    if (l !== void 0)
      return typeof l == "function" && o ? l(n) : l;
    r = e.$slots[t], r = o && r ? r(n) : r;
  } else if (In(e)) {
    const l = e.props && e.props[t];
    if (l !== void 0 && e.props !== null)
      return typeof l == "function" && o ? l(n) : l;
    e.type === Fe ? r = e.children : e.children && e.children[t] && (r = e.children[t], r = o && r ? r(n) : r);
  }
  return Array.isArray(r) && (r = It(r), r = r.length === 1 ? r[0] : r, r = r.length === 0 ? void 0 : r), r;
};
function By() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0, n = {};
  return e.$ ? n = m(m({}, n), e.$attrs) : n = m(m({}, n), e.props), rh(n)[t ? "onEvents" : "events"];
}
function UT(e) {
  const n = ((In(e) ? e.props : e.$attrs) || {}).class || {};
  let o = {};
  return typeof n == "string" ? n.split(" ").forEach((r) => {
    o[r.trim()] = !0;
  }) : Array.isArray(n) ? ee(n).split(" ").forEach((r) => {
    o[r.trim()] = !0;
  }) : o = m(m({}, o), n), o;
}
function Xx(e, t) {
  let o = ((In(e) ? e.props : e.$attrs) || {}).style || {};
  return typeof o == "string" && (o = XT(o, t)), o;
}
function YT(e) {
  return e.length === 1 && e[0].type === Fe;
}
function qT(e) {
  return e == null || e === "" || Array.isArray(e) && e.length === 0;
}
function nc(e) {
  return e && (e.type === Nx || e.type === Fe && e.children.length === 0 || e.type === pf && e.children.trim() === "");
}
function ZT(e) {
  return e && e.type === pf;
}
function Lt() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const t = [];
  return e.forEach((n) => {
    Array.isArray(n) ? t.push(...n) : (n == null ? void 0 : n.type) === Fe ? t.push(...Lt(n.children)) : t.push(n);
  }), t.filter((n) => !nc(n));
}
function Ki(e) {
  if (e) {
    const t = Lt(e);
    return t.length ? t : void 0;
  } else
    return e;
}
function Gt(e) {
  return Array.isArray(e) && e.length === 1 && (e = e[0]), e && e.__v_isVNode && typeof e.type != "symbol";
}
function an(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "default";
  var o, r;
  return (o = t[n]) !== null && o !== void 0 ? o : (r = e[n]) === null || r === void 0 ? void 0 : r.call(e);
}
const Fo = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ResizeObserver",
  props: {
    disabled: Boolean,
    onResize: Function
  },
  emits: ["resize"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = xt({
      width: 0,
      height: 0,
      offsetHeight: 0,
      offsetWidth: 0
    });
    let r = null, l = null;
    const a = () => {
      l && (l.disconnect(), l = null);
    }, i = (u) => {
      const {
        onResize: d
      } = e, p = u[0].target, {
        width: v,
        height: h
      } = p.getBoundingClientRect(), {
        offsetWidth: g,
        offsetHeight: b
      } = p, y = Math.floor(v), S = Math.floor(h);
      if (o.width !== y || o.height !== S || o.offsetWidth !== g || o.offsetHeight !== b) {
        const C = {
          width: y,
          height: S,
          offsetWidth: g,
          offsetHeight: b
        };
        m(o, C), d && Promise.resolve().then(() => {
          d(m(m({}, C), {
            offsetWidth: g,
            offsetHeight: b
          }), p);
        });
      }
    }, s = Wn(), c = () => {
      const {
        disabled: u
      } = e;
      if (u) {
        a();
        return;
      }
      const d = qn(s);
      d !== r && (a(), r = d), !l && d && (l = new oh(i), l.observe(d));
    };
    return Ke(() => {
      c();
    }), co(() => {
      c();
    }), uo(() => {
      a();
    }), ie(() => e.disabled, () => {
      c();
    }, {
      flush: "post"
    }), () => {
      var u;
      return (u = n.default) === null || u === void 0 ? void 0 : u.call(n)[0];
    };
  }
});
let Ux = (e) => setTimeout(e, 16), Yx = (e) => clearTimeout(e);
typeof window < "u" && "requestAnimationFrame" in window && (Ux = (e) => window.requestAnimationFrame(e), Yx = (e) => window.cancelAnimationFrame(e));
let Fy = 0;
const lh = /* @__PURE__ */ new Map();
function qx(e) {
  lh.delete(e);
}
function Ze(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  Fy += 1;
  const n = Fy;
  function o(r) {
    if (r === 0)
      qx(n), e();
    else {
      const l = Ux(() => {
        o(r - 1);
      });
      lh.set(n, l);
    }
  }
  return o(t), n;
}
Ze.cancel = (e) => {
  const t = lh.get(e);
  return qx(t), Yx(t);
};
function hg(e) {
  let t;
  const n = (r) => () => {
    t = null, e(...r);
  }, o = function() {
    if (t == null) {
      for (var r = arguments.length, l = new Array(r), a = 0; a < r; a++)
        l[a] = arguments[a];
      t = Ze(n(l));
    }
  };
  return o.cancel = () => {
    Ze.cancel(t), t = null;
  }, o;
}
const Mn = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t;
}, QT = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t;
}, kt = (e) => {
  const t = e;
  return t.install = function(n) {
    n.component(t.displayName || t.name, e);
  }, e;
};
function ia() {
  return {
    type: [Function, Array]
  };
}
function Re(e) {
  return {
    type: Object,
    default: e
  };
}
function ve(e) {
  return {
    type: Boolean,
    default: e
  };
}
function le(e) {
  return {
    type: Function,
    default: e
  };
}
function _t(e, t) {
  return {
    validator: () => !0,
    default: e
  };
}
function Rn() {
  return {
    validator: () => !0
  };
}
function vt(e) {
  return {
    type: Array,
    default: e
  };
}
function ke(e) {
  return {
    type: String,
    default: e
  };
}
function je(e, t) {
  return e ? {
    type: e,
    default: t
  } : _t(t);
}
let on = !1;
try {
  const e = Object.defineProperty({}, "passive", {
    get() {
      on = !0;
    }
  });
  window.addEventListener("testPassive", null, e), window.removeEventListener("testPassive", null, e);
} catch {
}
function Bt(e, t, n, o) {
  if (e && e.addEventListener) {
    let r = o;
    r === void 0 && on && (t === "touchstart" || t === "touchmove" || t === "wheel") && (r = {
      passive: !1
    }), e.addEventListener(t, n, r);
  }
  return {
    remove: () => {
      e && e.removeEventListener && e.removeEventListener(t, n);
    }
  };
}
function Tc(e) {
  return e !== window ? e.getBoundingClientRect() : {
    top: 0,
    bottom: window.innerHeight
  };
}
function Ly(e, t, n) {
  if (n !== void 0 && t.top > e.top - n)
    return `${n + t.top}px`;
}
function zy(e, t, n) {
  if (n !== void 0 && t.bottom < e.bottom + n) {
    const o = window.innerHeight - t.bottom;
    return `${n + o}px`;
  }
}
const Zx = ["resize", "scroll", "touchstart", "touchmove", "touchend", "pageshow", "load"];
let us = [];
function Hy(e, t) {
  if (!e)
    return;
  let n = us.find((o) => o.target === e);
  n ? n.affixList.push(t) : (n = {
    target: e,
    affixList: [t],
    eventHandlers: {}
  }, us.push(n), Zx.forEach((o) => {
    n.eventHandlers[o] = Bt(e, o, () => {
      n.affixList.forEach((r) => {
        const {
          lazyUpdatePosition: l
        } = r.exposed;
        l();
      }, (o === "touchstart" || o === "touchmove") && on ? {
        passive: !0
      } : !1);
    });
  }));
}
function jy(e) {
  const t = us.find((n) => {
    const o = n.affixList.some((r) => r === e);
    return o && (n.affixList = n.affixList.filter((r) => r !== e)), o;
  });
  t && t.affixList.length === 0 && (us = us.filter((n) => n !== t), Zx.forEach((n) => {
    const o = t.eventHandlers[n];
    o && o.remove && o.remove();
  }));
}
const ah = "anticon", Qx = Symbol("GlobalFormContextKey"), JT = (e) => {
  Je(Qx, e);
}, e8 = () => tt(Qx, {
  validateMessages: P(() => {
  })
}), t8 = () => ({
  iconPrefixCls: String,
  getTargetContainer: {
    type: Function
  },
  getPopupContainer: {
    type: Function
  },
  prefixCls: String,
  getPrefixCls: {
    type: Function
  },
  renderEmpty: {
    type: Function
  },
  transformCellText: {
    type: Function
  },
  csp: Re(),
  input: Re(),
  autoInsertSpaceInButton: {
    type: Boolean,
    default: void 0
  },
  locale: Re(),
  pageHeader: Re(),
  componentSize: {
    type: String
  },
  componentDisabled: {
    type: Boolean,
    default: void 0
  },
  direction: {
    type: String,
    default: "ltr"
  },
  space: Re(),
  virtual: {
    type: Boolean,
    default: void 0
  },
  dropdownMatchSelectWidth: {
    type: [Number, Boolean],
    default: !0
  },
  form: Re(),
  pagination: Re(),
  theme: Re(),
  select: Re(),
  wave: Re()
}), ih = Symbol("configProvider"), Jx = {
  getPrefixCls: (e, t) => t || (e ? `ant-${e}` : "ant"),
  iconPrefixCls: P(() => ah),
  getPopupContainer: P(() => () => document.body),
  direction: P(() => "ltr")
}, oc = () => tt(ih, Jx), n8 = (e) => Je(ih, e), e2 = Symbol("DisabledContextKey"), so = () => tt(e2, Y(void 0)), t2 = (e) => {
  const t = so();
  return Je(e2, P(() => {
    var n;
    return (n = e.value) !== null && n !== void 0 ? n : t.value;
  })), e;
}, n2 = {
  // Options.jsx
  items_per_page: "/ page",
  jump_to: "Go to",
  jump_to_confirm: "confirm",
  page: "",
  // Pagination.jsx
  prev_page: "Previous Page",
  next_page: "Next Page",
  prev_5: "Previous 5 Pages",
  next_5: "Next 5 Pages",
  prev_3: "Previous 3 Pages",
  next_3: "Next 3 Pages"
}, o8 = {
  locale: "en_US",
  today: "Today",
  now: "Now",
  backToToday: "Back to today",
  ok: "Ok",
  clear: "Clear",
  month: "Month",
  year: "Year",
  timeSelect: "select time",
  dateSelect: "select date",
  weekSelect: "Choose a week",
  monthSelect: "Choose a month",
  yearSelect: "Choose a year",
  decadeSelect: "Choose a decade",
  yearFormat: "YYYY",
  dateFormat: "M/D/YYYY",
  dayFormat: "D",
  dateTimeFormat: "M/D/YYYY HH:mm:ss",
  monthBeforeYear: !0,
  previousMonth: "Previous month (PageUp)",
  nextMonth: "Next month (PageDown)",
  previousYear: "Last year (Control + left)",
  nextYear: "Next year (Control + right)",
  previousDecade: "Last decade",
  nextDecade: "Next decade",
  previousCentury: "Last century",
  nextCentury: "Next century"
}, o2 = {
  placeholder: "Select time",
  rangePlaceholder: ["Start time", "End time"]
}, Ds = {
  lang: m({
    placeholder: "Select date",
    yearPlaceholder: "Select year",
    quarterPlaceholder: "Select quarter",
    monthPlaceholder: "Select month",
    weekPlaceholder: "Select week",
    rangePlaceholder: ["Start date", "End date"],
    rangeYearPlaceholder: ["Start year", "End year"],
    rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
    rangeMonthPlaceholder: ["Start month", "End month"],
    rangeWeekPlaceholder: ["Start week", "End week"]
  }, o8),
  timePickerLocale: m({}, o2)
}, vo = "${label} is not a valid ${type}", Zn = {
  locale: "en",
  Pagination: n2,
  DatePicker: Ds,
  TimePicker: o2,
  Calendar: Ds,
  global: {
    placeholder: "Please select"
  },
  Table: {
    filterTitle: "Filter menu",
    filterConfirm: "OK",
    filterReset: "Reset",
    filterEmptyText: "No filters",
    filterCheckall: "Select all items",
    filterSearchPlaceholder: "Search in filters",
    emptyText: "No data",
    selectAll: "Select current page",
    selectInvert: "Invert current page",
    selectNone: "Clear all data",
    selectionAll: "Select all data",
    sortTitle: "Sort",
    expand: "Expand row",
    collapse: "Collapse row",
    triggerDesc: "Click to sort descending",
    triggerAsc: "Click to sort ascending",
    cancelSort: "Click to cancel sorting"
  },
  Tour: {
    Next: "Next",
    Previous: "Previous",
    Finish: "Finish"
  },
  Modal: {
    okText: "OK",
    cancelText: "Cancel",
    justOkText: "OK"
  },
  Popconfirm: {
    okText: "OK",
    cancelText: "Cancel"
  },
  Transfer: {
    titles: ["", ""],
    searchPlaceholder: "Search here",
    itemUnit: "item",
    itemsUnit: "items",
    remove: "Remove",
    selectCurrent: "Select current page",
    removeCurrent: "Remove current page",
    selectAll: "Select all data",
    removeAll: "Remove all data",
    selectInvert: "Invert current page"
  },
  Upload: {
    uploading: "Uploading...",
    removeFile: "Remove file",
    uploadError: "Upload error",
    previewFile: "Preview file",
    downloadFile: "Download file"
  },
  Empty: {
    description: "No data"
  },
  Icon: {
    icon: "icon"
  },
  Text: {
    edit: "Edit",
    copy: "Copy",
    copied: "Copied",
    expand: "Expand"
  },
  PageHeader: {
    back: "Back"
  },
  Form: {
    optional: "(optional)",
    defaultValidateMessages: {
      default: "Field validation error for ${label}",
      required: "Please enter ${label}",
      enum: "${label} must be one of [${enum}]",
      whitespace: "${label} cannot be a blank character",
      date: {
        format: "${label} date format is invalid",
        parse: "${label} cannot be converted to a date",
        invalid: "${label} is an invalid date"
      },
      types: {
        string: vo,
        method: vo,
        array: vo,
        object: vo,
        number: vo,
        date: vo,
        boolean: vo,
        integer: vo,
        float: vo,
        regexp: vo,
        email: vo,
        url: vo,
        hex: vo
      },
      string: {
        len: "${label} must be ${len} characters",
        min: "${label} must be at least ${min} characters",
        max: "${label} must be up to ${max} characters",
        range: "${label} must be between ${min}-${max} characters"
      },
      number: {
        len: "${label} must be equal to ${len}",
        min: "${label} must be minimum ${min}",
        max: "${label} must be maximum ${max}",
        range: "${label} must be between ${min}-${max}"
      },
      array: {
        len: "Must be ${len} ${label}",
        min: "At least ${min} ${label}",
        max: "At most ${max} ${label}",
        range: "The amount of ${label} must be between ${min}-${max}"
      },
      pattern: {
        mismatch: "${label} does not match the pattern ${pattern}"
      }
    }
  },
  Image: {
    preview: "Preview"
  },
  QRCode: {
    expired: "QR code expired",
    refresh: "Refresh",
    scanned: "Scanned"
  }
}, ma = Z({
  compatConfig: {
    MODE: 3
  },
  name: "LocaleReceiver",
  props: {
    componentName: String,
    defaultLocale: {
      type: [Object, Function]
    },
    children: {
      type: Function
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = tt("localeData", {}), r = P(() => {
      const {
        componentName: a = "global",
        defaultLocale: i
      } = e, s = i || Zn[a || "global"], {
        antLocale: c
      } = o, u = a && c ? c[a] : {};
      return m(m({}, typeof s == "function" ? s() : s), u || {});
    }), l = P(() => {
      const {
        antLocale: a
      } = o, i = a && a.locale;
      return a && a.exist && !i ? Zn.locale : i;
    });
    return () => {
      const a = e.children || n.default, {
        antLocale: i
      } = o;
      return a == null ? void 0 : a(r.value, l.value, i);
    };
  }
});
function jo(e, t, n) {
  const o = tt("localeData", {});
  return [P(() => {
    const {
      antLocale: l
    } = o, a = hn(t) || Zn[e || "global"], i = e && l ? l[e] : {};
    return m(m(m({}, typeof a == "function" ? a() : a), i || {}), hn(n) || {});
  })];
}
function sh(e) {
  for (var t = 0, n, o = 0, r = e.length; r >= 4; ++o, r -= 4)
    n = e.charCodeAt(o) & 255 | (e.charCodeAt(++o) & 255) << 8 | (e.charCodeAt(++o) & 255) << 16 | (e.charCodeAt(++o) & 255) << 24, n = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16), n ^= /* k >>> r: */
    n >>> 24, t = /* Math.imul(k, m): */
    (n & 65535) * 1540483477 + ((n >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  switch (r) {
    case 3:
      t ^= (e.charCodeAt(o + 2) & 255) << 16;
    case 2:
      t ^= (e.charCodeAt(o + 1) & 255) << 8;
    case 1:
      t ^= e.charCodeAt(o) & 255, t = /* Math.imul(h, m): */
      (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16);
  }
  return t ^= t >>> 13, t = /* Math.imul(h, m): */
  (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), ((t ^ t >>> 15) >>> 0).toString(36);
}
const Vy = "%";
class r8 {
  constructor(t) {
    this.cache = /* @__PURE__ */ new Map(), this.instanceId = t;
  }
  get(t) {
    return this.cache.get(Array.isArray(t) ? t.join(Vy) : t) || null;
  }
  update(t, n) {
    const o = Array.isArray(t) ? t.join(Vy) : t, r = this.cache.get(o), l = n(r);
    l === null ? this.cache.delete(o) : this.cache.set(o, l);
  }
}
const r2 = "data-token-hash", Zl = "data-css-hash", l8 = "data-cache-path", Xa = "__cssinjs_instance__";
function Ns() {
  const e = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    const t = document.body.querySelectorAll(`style[${Zl}]`) || [], {
      firstChild: n
    } = document.head;
    Array.from(t).forEach((r) => {
      r[Xa] = r[Xa] || e, r[Xa] === e && document.head.insertBefore(r, n);
    });
    const o = {};
    Array.from(document.querySelectorAll(`style[${Zl}]`)).forEach((r) => {
      var l;
      const a = r.getAttribute(Zl);
      o[a] ? r[Xa] === e && ((l = r.parentNode) === null || l === void 0 || l.removeChild(r)) : o[a] = !0;
    });
  }
  return new r8(e);
}
const l2 = Symbol("StyleContextKey"), a8 = () => {
  var e, t, n;
  const o = Wn();
  let r;
  if (o && o.appContext) {
    const l = (n = (t = (e = o.appContext) === null || e === void 0 ? void 0 : e.config) === null || t === void 0 ? void 0 : t.globalProperties) === null || n === void 0 ? void 0 : n.__ANTDV_CSSINJS_CACHE__;
    l ? r = l : (r = Ns(), o.appContext.config.globalProperties && (o.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = r));
  } else
    r = Ns();
  return r;
}, a2 = {
  cache: Ns(),
  defaultCache: !0,
  hashPriority: "low"
}, bf = () => {
  const e = a8();
  return tt(l2, Q(m(m({}, a2), {
    cache: e
  })));
}, i8 = (e) => {
  const t = bf(), n = Q(m(m({}, a2), {
    cache: Ns()
  }));
  return ie([() => hn(e), t], () => {
    const o = m({}, t.value), r = hn(e);
    Object.keys(r).forEach((a) => {
      const i = r[a];
      r[a] !== void 0 && (o[a] = i);
    });
    const {
      cache: l
    } = r;
    o.cache = o.cache || Ns(), o.defaultCache = !l && t.value.defaultCache, n.value = o;
  }, {
    immediate: !0
  }), Je(l2, n), n;
}, s8 = () => ({
  autoClear: ve(),
  /** @private Test only. Not work in production. */
  mock: ke(),
  /**
   * Only set when you need ssr to extract style on you own.
   * If not provided, it will auto create <style /> on the end of Provider in server side.
   */
  cache: Re(),
  /** Tell children that this context is default generated context */
  defaultCache: ve(),
  /** Use `:where` selector to reduce hashId css selector priority */
  hashPriority: ke(),
  /** Tell cssinjs where to inject style in */
  container: je(),
  /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
  ssrInline: ve(),
  /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
  transformers: vt(),
  /**
   * Linters to lint css before inject in document.
   * Styles will be linted after transforming.
   * Please note that `linters` do not support dynamic update.
   */
  linters: vt()
});
kt(Z({
  name: "AStyleProvider",
  inheritAttrs: !1,
  props: s8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return i8(e), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}));
function c8() {
  return !1;
}
let bg = !1;
function u8() {
  return bg;
}
const d8 = process.env.NODE_ENV === "production" ? c8 : u8;
if (process.env.NODE_ENV !== "production" && typeof module < "u" && module && module.hot && typeof window < "u") {
  const e = window;
  if (typeof e.webpackHotUpdate == "function") {
    const t = e.webpackHotUpdate;
    e.webpackHotUpdate = function() {
      return bg = !0, setTimeout(() => {
        bg = !1;
      }, 0), t(...arguments);
    };
  }
}
function i2(e, t, n, o) {
  const r = bf(), l = Q(""), a = Q();
  Le(() => {
    l.value = [e, ...t.value].join("%");
  });
  const i = d8(), s = (c) => {
    r.value.cache.update(c, (u) => {
      const [d = 0, p] = u || [];
      return d - 1 === 0 ? (o == null || o(p, !1), null) : [d - 1, p];
    });
  };
  return ie(l, (c, u) => {
    u && s(u), r.value.cache.update(c, (d) => {
      const [p = 0, v] = d || [];
      let h = v;
      process.env.NODE_ENV !== "production" && v && i && (o == null || o(h, i), h = null);
      const g = h || n();
      return [p + 1, g];
    }), a.value = r.value.cache.get(l.value)[1];
  }, {
    immediate: !0
  }), et(() => {
    s(l.value);
  }), a;
}
function jn() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function sl(e, t) {
  return e && e.contains ? e.contains(t) : !1;
}
const Wy = "data-vc-order", f8 = "vc-util-key", yg = /* @__PURE__ */ new Map();
function s2() {
  let {
    mark: e
  } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  return e ? e.startsWith("data-") ? e : `data-${e}` : f8;
}
function yf(e) {
  return e.attachTo ? e.attachTo : document.querySelector("head") || document.body;
}
function p8(e) {
  return e === "queue" ? "prependQueue" : e ? "prepend" : "append";
}
function c2(e) {
  return Array.from((yg.get(e) || e).children).filter((t) => t.tagName === "STYLE");
}
function u2(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!jn())
    return null;
  const {
    csp: n,
    prepend: o
  } = t, r = document.createElement("style");
  r.setAttribute(Wy, p8(o)), n != null && n.nonce && (r.nonce = n == null ? void 0 : n.nonce), r.innerHTML = e;
  const l = yf(t), {
    firstChild: a
  } = l;
  if (o) {
    if (o === "queue") {
      const i = c2(l).filter((s) => ["prepend", "prependQueue"].includes(s.getAttribute(Wy)));
      if (i.length)
        return l.insertBefore(r, i[i.length - 1].nextSibling), r;
    }
    l.insertBefore(r, a);
  } else
    l.appendChild(r);
  return r;
}
function d2(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = yf(t);
  return c2(n).find((o) => o.getAttribute(s2(t)) === e);
}
function cd(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const n = d2(e, t);
  n && yf(t).removeChild(n);
}
function v8(e, t) {
  const n = yg.get(e);
  if (!n || !sl(document, n)) {
    const o = u2("", t), {
      parentNode: r
    } = o;
    yg.set(e, r), e.removeChild(o);
  }
}
function Rs(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var o, r, l;
  const a = yf(n);
  v8(a, n);
  const i = d2(t, n);
  if (i)
    return !((o = n.csp) === null || o === void 0) && o.nonce && i.nonce !== ((r = n.csp) === null || r === void 0 ? void 0 : r.nonce) && (i.nonce = (l = n.csp) === null || l === void 0 ? void 0 : l.nonce), i.innerHTML !== e && (i.innerHTML = e), i;
  const s = u2(e, n);
  return s.setAttribute(s2(n), t), s;
}
function g8(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
class vi {
  constructor() {
    this.cache = /* @__PURE__ */ new Map(), this.keys = [], this.cacheCallTimes = 0;
  }
  size() {
    return this.keys.length;
  }
  internalGet(t) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, o = {
      map: this.cache
    };
    return t.forEach((r) => {
      var l;
      o ? o = (l = o == null ? void 0 : o.map) === null || l === void 0 ? void 0 : l.get(r) : o = void 0;
    }), o != null && o.value && n && (o.value[1] = this.cacheCallTimes++), o == null ? void 0 : o.value;
  }
  get(t) {
    var n;
    return (n = this.internalGet(t, !0)) === null || n === void 0 ? void 0 : n[0];
  }
  has(t) {
    return !!this.internalGet(t);
  }
  set(t, n) {
    if (!this.has(t)) {
      if (this.size() + 1 > vi.MAX_CACHE_SIZE + vi.MAX_CACHE_OFFSET) {
        const [r] = this.keys.reduce((l, a) => {
          const [, i] = l;
          return this.internalGet(a)[1] < i ? [a, this.internalGet(a)[1]] : l;
        }, [this.keys[0], this.cacheCallTimes]);
        this.delete(r);
      }
      this.keys.push(t);
    }
    let o = this.cache;
    t.forEach((r, l) => {
      if (l === t.length - 1)
        o.set(r, {
          value: [n, this.cacheCallTimes++]
        });
      else {
        const a = o.get(r);
        a ? a.map || (a.map = /* @__PURE__ */ new Map()) : o.set(r, {
          map: /* @__PURE__ */ new Map()
        }), o = o.get(r).map;
      }
    });
  }
  deleteByPath(t, n) {
    var o;
    const r = t.get(n[0]);
    if (n.length === 1)
      return r.map ? t.set(n[0], {
        map: r.map
      }) : t.delete(n[0]), (o = r.value) === null || o === void 0 ? void 0 : o[0];
    const l = this.deleteByPath(r.map, n.slice(1));
    return (!r.map || r.map.size === 0) && !r.value && t.delete(n[0]), l;
  }
  delete(t) {
    if (this.has(t))
      return this.keys = this.keys.filter((n) => !g8(n, t)), this.deleteByPath(this.cache, t);
  }
}
vi.MAX_CACHE_SIZE = 20;
vi.MAX_CACHE_OFFSET = 5;
let Sg = {};
function ct(e, t) {
  process.env.NODE_ENV !== "production" && !e && console !== void 0 && console.error(`Warning: ${t}`);
}
function f2(e, t) {
  process.env.NODE_ENV !== "production" && !e && console !== void 0 && console.warn(`Note: ${t}`);
}
function m8() {
  Sg = {};
}
function p2(e, t, n) {
  !t && !Sg[n] && (e(!1, n), Sg[n] = !0);
}
function lo(e, t) {
  p2(ct, e, t);
}
function Cg(e, t) {
  p2(f2, e, t);
}
function h8() {
}
let Mt = h8;
process.env.NODE_ENV !== "production" && (Mt = (e, t, n) => {
  lo(e, `[ant-design-vue: ${t}] ${n}`), process.env.NODE_ENV === "test" && m8();
});
let Ky = 0;
class v2 {
  constructor(t) {
    this.derivatives = Array.isArray(t) ? t : [t], this.id = Ky, t.length === 0 && Mt(t.length > 0, "[Ant Design Vue CSS-in-JS] Theme should have at least one derivative function."), Ky += 1;
  }
  getDerivativeToken(t) {
    return this.derivatives.reduce((n, o) => o(t, n), void 0);
  }
}
const zp = new vi();
function g2(e) {
  const t = Array.isArray(e) ? e : [e];
  return zp.has(t) || zp.set(t, new v2(t)), zp.get(t);
}
const Gy = /* @__PURE__ */ new WeakMap();
function ud(e) {
  let t = Gy.get(e) || "";
  return t || (Object.keys(e).forEach((n) => {
    const o = e[n];
    t += n, o instanceof v2 ? t += o.id : o && typeof o == "object" ? t += ud(o) : t += o;
  }), Gy.set(e, t)), t;
}
function b8(e, t) {
  return sh(`${t}_${ud(e)}`);
}
const ds = `random-${Date.now()}-${Math.random()}`.replace(/\./g, ""), m2 = "_bAmBoO_";
function y8(e, t, n) {
  var o, r;
  if (jn()) {
    Rs(e, ds);
    const l = document.createElement("div");
    l.style.position = "fixed", l.style.left = "0", l.style.top = "0", t == null || t(l), document.body.appendChild(l), process.env.NODE_ENV !== "production" && (l.innerHTML = "Test", l.style.zIndex = "9999999");
    const a = n ? n(l) : (o = getComputedStyle(l).content) === null || o === void 0 ? void 0 : o.includes(m2);
    return (r = l.parentNode) === null || r === void 0 || r.removeChild(l), cd(ds), a;
  }
  return !1;
}
let Hp;
function S8() {
  return Hp === void 0 && (Hp = y8(`@layer ${ds} { .${ds} { content: "${m2}"!important; } }`, (e) => {
    e.className = ds;
  })), Hp;
}
const Xy = {}, C8 = process.env.NODE_ENV === "production", $8 = process.env.NODE_ENV === "prerender", w8 = !C8 && !$8 ? "css-dev-only-do-not-override" : "css", Vl = /* @__PURE__ */ new Map();
function x8(e) {
  Vl.set(e, (Vl.get(e) || 0) + 1);
}
function O8(e, t) {
  typeof document < "u" && document.querySelectorAll(`style[${r2}="${e}"]`).forEach((o) => {
    var r;
    o[Xa] === t && ((r = o.parentNode) === null || r === void 0 || r.removeChild(o));
  });
}
const P8 = 0;
function I8(e, t) {
  Vl.set(e, (Vl.get(e) || 0) - 1);
  const n = Array.from(Vl.keys()), o = n.filter((r) => (Vl.get(r) || 0) <= 0);
  n.length - o.length > P8 && o.forEach((r) => {
    O8(r, t), Vl.delete(r);
  });
}
const E8 = (e, t, n, o) => {
  const r = n.getDerivativeToken(e);
  let l = m(m({}, r), t);
  return o && (l = o(l)), l;
};
function T8(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Y({});
  const o = bf(), r = P(() => m({}, ...t.value)), l = P(() => ud(r.value)), a = P(() => ud(n.value.override || Xy));
  return i2("token", P(() => [n.value.salt || "", e.value.id, l.value, a.value]), () => {
    const {
      salt: s = "",
      override: c = Xy,
      formatToken: u,
      getComputedToken: d
    } = n.value, p = d ? d(r.value, c, e.value) : E8(r.value, c, e.value, u), v = b8(p, s);
    p._tokenKey = v, x8(v);
    const h = `${w8}-${sh(v)}`;
    return p._hashId = h, [p, h];
  }, (s) => {
    var c;
    I8(s[0]._tokenKey, (c = o.value) === null || c === void 0 ? void 0 : c.cache.instanceId);
  });
}
var M8 = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, h2 = "comm", b2 = "rule", y2 = "decl", _8 = "@import", A8 = "@keyframes", D8 = "@layer", S2 = Math.abs, ch = String.fromCharCode;
function C2(e) {
  return e.trim();
}
function pu(e, t, n) {
  return e.replace(t, n);
}
function N8(e, t, n) {
  return e.indexOf(t, n);
}
function ks(e, t) {
  return e.charCodeAt(t) | 0;
}
function Bs(e, t, n) {
  return e.slice(t, n);
}
function Nr(e) {
  return e.length;
}
function R8(e) {
  return e.length;
}
function Mc(e, t) {
  return t.push(e), e;
}
var Sf = 1, gi = 1, $2 = 0, Lo = 0, vn = 0, Pi = "";
function uh(e, t, n, o, r, l, a, i) {
  return { value: e, root: t, parent: n, type: o, props: r, children: l, line: Sf, column: gi, length: a, return: "", siblings: i };
}
function k8() {
  return vn;
}
function B8() {
  return vn = Lo > 0 ? ks(Pi, --Lo) : 0, gi--, vn === 10 && (gi = 1, Sf--), vn;
}
function Jo() {
  return vn = Lo < $2 ? ks(Pi, Lo++) : 0, gi++, vn === 10 && (gi = 1, Sf++), vn;
}
function Ql() {
  return ks(Pi, Lo);
}
function vu() {
  return Lo;
}
function Cf(e, t) {
  return Bs(Pi, e, t);
}
function $g(e) {
  switch (e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function F8(e) {
  return Sf = gi = 1, $2 = Nr(Pi = e), Lo = 0, [];
}
function L8(e) {
  return Pi = "", e;
}
function jp(e) {
  return C2(Cf(Lo - 1, wg(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function z8(e) {
  for (; (vn = Ql()) && vn < 33; )
    Jo();
  return $g(e) > 2 || $g(vn) > 3 ? "" : " ";
}
function H8(e, t) {
  for (; --t && Jo() && !(vn < 48 || vn > 102 || vn > 57 && vn < 65 || vn > 70 && vn < 97); )
    ;
  return Cf(e, vu() + (t < 6 && Ql() == 32 && Jo() == 32));
}
function wg(e) {
  for (; Jo(); )
    switch (vn) {
      case e:
        return Lo;
      case 34:
      case 39:
        e !== 34 && e !== 39 && wg(vn);
        break;
      case 40:
        e === 41 && wg(e);
        break;
      case 92:
        Jo();
        break;
    }
  return Lo;
}
function j8(e, t) {
  for (; Jo() && e + vn !== 57; )
    if (e + vn === 84 && Ql() === 47)
      break;
  return "/*" + Cf(t, Lo - 1) + "*" + ch(e === 47 ? e : Jo());
}
function V8(e) {
  for (; !$g(Ql()); )
    Jo();
  return Cf(e, Lo);
}
function W8(e) {
  return L8(gu("", null, null, null, [""], e = F8(e), 0, [0], e));
}
function gu(e, t, n, o, r, l, a, i, s) {
  for (var c = 0, u = 0, d = a, p = 0, v = 0, h = 0, g = 1, b = 1, y = 1, S = 0, C = "", w = r, $ = l, O = o, x = C; b; )
    switch (h = S, S = Jo()) {
      case 40:
        if (h != 108 && ks(x, d - 1) == 58) {
          N8(x += pu(jp(S), "&", "&\f"), "&\f", S2(c ? i[c - 1] : 0)) != -1 && (y = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        x += jp(S);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        x += z8(h);
        break;
      case 92:
        x += H8(vu() - 1, 7);
        continue;
      case 47:
        switch (Ql()) {
          case 42:
          case 47:
            Mc(K8(j8(Jo(), vu()), t, n, s), s);
            break;
          default:
            x += "/";
        }
        break;
      case 123 * g:
        i[c++] = Nr(x) * y;
      case 125 * g:
      case 59:
      case 0:
        switch (S) {
          case 0:
          case 125:
            b = 0;
          case 59 + u:
            y == -1 && (x = pu(x, /\f/g, "")), v > 0 && Nr(x) - d && Mc(v > 32 ? Yy(x + ";", o, n, d - 1, s) : Yy(pu(x, " ", "") + ";", o, n, d - 2, s), s);
            break;
          case 59:
            x += ";";
          default:
            if (Mc(O = Uy(x, t, n, c, u, r, i, C, w = [], $ = [], d, l), l), S === 123)
              if (u === 0)
                gu(x, t, O, O, w, l, d, i, $);
              else
                switch (p === 99 && ks(x, 3) === 110 ? 100 : p) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    gu(e, O, O, o && Mc(Uy(e, O, O, 0, 0, r, i, C, r, w = [], d, $), $), r, $, d, i, o ? w : $);
                    break;
                  default:
                    gu(x, O, O, O, [""], $, 0, i, $);
                }
        }
        c = u = v = 0, g = y = 1, C = x = "", d = a;
        break;
      case 58:
        d = 1 + Nr(x), v = h;
      default:
        if (g < 1) {
          if (S == 123)
            --g;
          else if (S == 125 && g++ == 0 && B8() == 125)
            continue;
        }
        switch (x += ch(S), S * g) {
          case 38:
            y = u > 0 ? 1 : (x += "\f", -1);
            break;
          case 44:
            i[c++] = (Nr(x) - 1) * y, y = 1;
            break;
          case 64:
            Ql() === 45 && (x += jp(Jo())), p = Ql(), u = d = Nr(C = x += V8(vu())), S++;
            break;
          case 45:
            h === 45 && Nr(x) == 2 && (g = 0);
        }
    }
  return l;
}
function Uy(e, t, n, o, r, l, a, i, s, c, u, d) {
  for (var p = r - 1, v = r === 0 ? l : [""], h = R8(v), g = 0, b = 0, y = 0; g < o; ++g)
    for (var S = 0, C = Bs(e, p + 1, p = S2(b = a[g])), w = e; S < h; ++S)
      (w = C2(b > 0 ? v[S] + " " + C : pu(C, /&\f/g, v[S]))) && (s[y++] = w);
  return uh(e, t, n, r === 0 ? b2 : i, s, c, u, d);
}
function K8(e, t, n, o) {
  return uh(e, t, n, h2, ch(k8()), Bs(e, 2, -2), 0, o);
}
function Yy(e, t, n, o, r) {
  return uh(e, t, n, y2, Bs(e, 0, o), Bs(e, o + 1, -1), o, r);
}
function xg(e, t) {
  for (var n = "", o = 0; o < e.length; o++)
    n += t(e[o], o, e, t) || "";
  return n;
}
function G8(e, t, n, o) {
  switch (e.type) {
    case D8:
      if (e.children.length)
        break;
    case _8:
    case y2:
      return e.return = e.return || e.value;
    case h2:
      return "";
    case A8:
      return e.return = e.value + "{" + xg(e.children, o) + "}";
    case b2:
      if (!Nr(e.value = e.props.join(",")))
        return "";
  }
  return Nr(n = xg(e.children, o)) ? e.return = e.value + "{" + n + "}" : "";
}
function w2(e, t) {
  const {
    path: n,
    parentSelectors: o
  } = t;
  lo(!1, `[Ant Design Vue CSS-in-JS] ${n ? `Error in '${n}': ` : ""}${e}${o.length ? ` Selector info: ${o.join(" -> ")}` : ""}`);
}
const X8 = (e, t, n) => {
  if (e === "content") {
    const o = /(attr|counters?|url|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
    (typeof t != "string" || ["normal", "none", "initial", "inherit", "unset"].indexOf(t) === -1 && !o.test(t) && (t.charAt(0) !== t.charAt(t.length - 1) || t.charAt(0) !== '"' && t.charAt(0) !== "'")) && w2(`You seem to be using a value for 'content' without quotes, try replacing it with \`content: '"${t}"'\`.`, n);
  }
}, U8 = (e, t, n) => {
  e === "animation" && n.hashId && t !== "none" && w2(`You seem to be using hashed animation '${t}', in which case 'animationName' with Keyframe as value is recommended.`, n);
}, qy = "data-ant-cssinjs-cache-path", Y8 = "_FILE_STYLE__";
let Jl, x2 = !0;
function q8() {
  var e;
  if (!Jl && (Jl = {}, jn())) {
    const t = document.createElement("div");
    t.className = qy, t.style.position = "fixed", t.style.visibility = "hidden", t.style.top = "-9999px", document.body.appendChild(t);
    let n = getComputedStyle(t).content || "";
    n = n.replace(/^"/, "").replace(/"$/, ""), n.split(";").forEach((r) => {
      const [l, a] = r.split(":");
      Jl[l] = a;
    });
    const o = document.querySelector(`style[${qy}]`);
    o && (x2 = !1, (e = o.parentNode) === null || e === void 0 || e.removeChild(o)), document.body.removeChild(t);
  }
}
function Z8(e) {
  return q8(), !!Jl[e];
}
function Q8(e) {
  const t = Jl[e];
  let n = null;
  if (t && jn())
    if (x2)
      n = Y8;
    else {
      const o = document.querySelector(`style[${Zl}="${Jl[e]}"]`);
      o ? n = o.innerHTML : delete Jl[e];
    }
  return [n, t];
}
const Zy = jn(), O2 = "_skip_check_", P2 = "_multi_value_";
function Qy(e) {
  return xg(W8(e), G8).replace(/\{%%%\:[^;];}/g, ";");
}
function J8(e) {
  return typeof e == "object" && e && (O2 in e || P2 in e);
}
function e5(e, t, n) {
  if (!t)
    return e;
  const o = `.${t}`, r = n === "low" ? `:where(${o})` : o;
  return e.split(",").map((a) => {
    var i;
    const s = a.trim().split(/\s+/);
    let c = s[0] || "";
    const u = ((i = c.match(/^\w+/)) === null || i === void 0 ? void 0 : i[0]) || "";
    return c = `${u}${r}${c.slice(u.length)}`, [c, ...s.slice(1)].join(" ");
  }).join(",");
}
const Og = /* @__PURE__ */ new Set();
process.env.NODE_ENV;
const Pg = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    root: n,
    injectHash: o,
    parentSelectors: r
  } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
    root: !0,
    parentSelectors: []
  };
  const {
    hashId: l,
    layer: a,
    path: i,
    hashPriority: s,
    transformers: c = [],
    linters: u = []
  } = t;
  let d = "", p = {};
  function v(b) {
    const y = b.getName(l);
    if (!p[y]) {
      const [S] = Pg(b.style, t, {
        root: !1,
        parentSelectors: r
      });
      p[y] = `@keyframes ${b.getName(l)}${S}`;
    }
  }
  function h(b) {
    let y = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    return b.forEach((S) => {
      Array.isArray(S) ? h(S, y) : S && y.push(S);
    }), y;
  }
  if (h(Array.isArray(e) ? e : [e]).forEach((b) => {
    const y = typeof b == "string" && !n ? {} : b;
    if (typeof y == "string")
      d += `${y}
`;
    else if (y._keyframe)
      v(y);
    else {
      const S = c.reduce((C, w) => {
        var $;
        return (($ = w == null ? void 0 : w.visit) === null || $ === void 0 ? void 0 : $.call(w, C)) || C;
      }, y);
      Object.keys(S).forEach((C) => {
        var w;
        const $ = S[C];
        if (typeof $ == "object" && $ && (C !== "animationName" || !$._keyframe) && !J8($)) {
          let O = !1, x = C.trim(), I = !1;
          (n || o) && l ? x.startsWith("@") ? O = !0 : x = e5(C, l, s) : n && !l && (x === "&" || x === "") && (x = "", I = !0);
          const [E, _] = Pg($, t, {
            root: I,
            injectHash: O,
            parentSelectors: [...r, x]
          });
          p = m(m({}, p), _), d += `${x}${E}`;
        } else {
          let O = function(I, E) {
            process.env.NODE_ENV !== "production" && (typeof $ != "object" || !($ != null && $[O2])) && [X8, U8, ...u].forEach((R) => R(I, E, {
              path: i,
              hashId: l,
              parentSelectors: r
            }));
            const _ = I.replace(/[A-Z]/g, (R) => `-${R.toLowerCase()}`);
            let M = E;
            !M8[I] && typeof M == "number" && M !== 0 && (M = `${M}px`), I === "animationName" && (E != null && E._keyframe) && (v(E), M = E.getName(l)), d += `${_}:${M};`;
          };
          const x = (w = $ == null ? void 0 : $.value) !== null && w !== void 0 ? w : $;
          typeof $ == "object" && ($ != null && $[P2]) && Array.isArray(x) ? x.forEach((I) => {
            O(C, I);
          }) : O(C, x);
        }
      });
    }
  }), !n)
    d = `{${d}}`;
  else if (a && S8()) {
    const b = a.split(",");
    d = `@layer ${b[b.length - 1].trim()} {${d}}`, b.length > 1 && (d = `@layer ${a}{%%%:%}${d}`);
  }
  return [d, p];
};
function t5(e, t) {
  return sh(`${e.join("%")}${t}`);
}
function Ig(e, t) {
  const n = bf(), o = P(() => e.value.token._tokenKey), r = P(() => [o.value, ...e.value.path]);
  let l = Zy;
  return process.env.NODE_ENV !== "production" && n.value.mock !== void 0 && (l = n.value.mock === "client"), i2(
    "style",
    r,
    // Create cache if needed
    () => {
      const {
        path: a,
        hashId: i,
        layer: s,
        nonce: c,
        clientOnly: u,
        order: d = 0
      } = e.value, p = r.value.join("|");
      if (Z8(p)) {
        const [x, I] = Q8(p);
        if (x)
          return [x, o.value, I, {}, u, d];
      }
      const v = t(), {
        hashPriority: h,
        container: g,
        transformers: b,
        linters: y,
        cache: S
      } = n.value, [C, w] = Pg(v, {
        hashId: i,
        hashPriority: h,
        layer: s,
        path: a.join("-"),
        transformers: b,
        linters: y
      }), $ = Qy(C), O = t5(r.value, $);
      if (l) {
        const x = {
          mark: Zl,
          prepend: "queue",
          attachTo: g,
          priority: d
        }, I = typeof c == "function" ? c() : c;
        I && (x.csp = {
          nonce: I
        });
        const E = Rs($, O, x);
        E[Xa] = S.instanceId, E.setAttribute(r2, o.value), process.env.NODE_ENV !== "production" && E.setAttribute(l8, r.value.join("|")), Object.keys(w).forEach((_) => {
          Og.has(_) || (Og.add(_), Rs(Qy(w[_]), `_effect-${_}`, {
            mark: Zl,
            prepend: "queue",
            attachTo: g
          }));
        });
      }
      return [$, o.value, O, w, u, d];
    },
    // Remove cache if no need
    (a, i) => {
      let [, , s] = a;
      (i || n.value.autoClear) && Zy && cd(s, {
        mark: Zl
      });
    }
  ), (a) => a;
}
class lt {
  constructor(t, n) {
    this._keyframe = !0, this.name = t, this.style = n;
  }
  getName() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return t ? `${t}-${this.name}` : this.name;
  }
}
const n5 = "4.2.6", Fs = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
function En(e, t) {
  o5(e) && (e = "100%");
  var n = r5(e);
  return e = t === 360 ? e : Math.min(t, Math.max(0, parseFloat(e))), n && (e = parseInt(String(e * t), 10) / 100), Math.abs(e - t) < 1e-6 ? 1 : (t === 360 ? e = (e < 0 ? e % t + t : e % t) / parseFloat(String(t)) : e = e % t / parseFloat(String(t)), e);
}
function _c(e) {
  return Math.min(1, Math.max(0, e));
}
function o5(e) {
  return typeof e == "string" && e.indexOf(".") !== -1 && parseFloat(e) === 1;
}
function r5(e) {
  return typeof e == "string" && e.indexOf("%") !== -1;
}
function I2(e) {
  return e = parseFloat(e), (isNaN(e) || e < 0 || e > 1) && (e = 1), e;
}
function Ac(e) {
  return e <= 1 ? "".concat(Number(e) * 100, "%") : e;
}
function Ul(e) {
  return e.length === 1 ? "0" + e : String(e);
}
function l5(e, t, n) {
  return {
    r: En(e, 255) * 255,
    g: En(t, 255) * 255,
    b: En(n, 255) * 255
  };
}
function Jy(e, t, n) {
  e = En(e, 255), t = En(t, 255), n = En(n, 255);
  var o = Math.max(e, t, n), r = Math.min(e, t, n), l = 0, a = 0, i = (o + r) / 2;
  if (o === r)
    a = 0, l = 0;
  else {
    var s = o - r;
    switch (a = i > 0.5 ? s / (2 - o - r) : s / (o + r), o) {
      case e:
        l = (t - n) / s + (t < n ? 6 : 0);
        break;
      case t:
        l = (n - e) / s + 2;
        break;
      case n:
        l = (e - t) / s + 4;
        break;
    }
    l /= 6;
  }
  return { h: l, s: a, l: i };
}
function Vp(e, t, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * (6 * n) : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function a5(e, t, n) {
  var o, r, l;
  if (e = En(e, 360), t = En(t, 100), n = En(n, 100), t === 0)
    r = n, l = n, o = n;
  else {
    var a = n < 0.5 ? n * (1 + t) : n + t - n * t, i = 2 * n - a;
    o = Vp(i, a, e + 1 / 3), r = Vp(i, a, e), l = Vp(i, a, e - 1 / 3);
  }
  return { r: o * 255, g: r * 255, b: l * 255 };
}
function Eg(e, t, n) {
  e = En(e, 255), t = En(t, 255), n = En(n, 255);
  var o = Math.max(e, t, n), r = Math.min(e, t, n), l = 0, a = o, i = o - r, s = o === 0 ? 0 : i / o;
  if (o === r)
    l = 0;
  else {
    switch (o) {
      case e:
        l = (t - n) / i + (t < n ? 6 : 0);
        break;
      case t:
        l = (n - e) / i + 2;
        break;
      case n:
        l = (e - t) / i + 4;
        break;
    }
    l /= 6;
  }
  return { h: l, s, v: a };
}
function i5(e, t, n) {
  e = En(e, 360) * 6, t = En(t, 100), n = En(n, 100);
  var o = Math.floor(e), r = e - o, l = n * (1 - t), a = n * (1 - r * t), i = n * (1 - (1 - r) * t), s = o % 6, c = [n, a, l, l, i, n][s], u = [i, n, n, a, l, l][s], d = [l, l, i, n, n, a][s];
  return { r: c * 255, g: u * 255, b: d * 255 };
}
function Tg(e, t, n, o) {
  var r = [
    Ul(Math.round(e).toString(16)),
    Ul(Math.round(t).toString(16)),
    Ul(Math.round(n).toString(16))
  ];
  return o && r[0].startsWith(r[0].charAt(1)) && r[1].startsWith(r[1].charAt(1)) && r[2].startsWith(r[2].charAt(1)) ? r[0].charAt(0) + r[1].charAt(0) + r[2].charAt(0) : r.join("");
}
function s5(e, t, n, o, r) {
  var l = [
    Ul(Math.round(e).toString(16)),
    Ul(Math.round(t).toString(16)),
    Ul(Math.round(n).toString(16)),
    Ul(c5(o))
  ];
  return r && l[0].startsWith(l[0].charAt(1)) && l[1].startsWith(l[1].charAt(1)) && l[2].startsWith(l[2].charAt(1)) && l[3].startsWith(l[3].charAt(1)) ? l[0].charAt(0) + l[1].charAt(0) + l[2].charAt(0) + l[3].charAt(0) : l.join("");
}
function c5(e) {
  return Math.round(parseFloat(e) * 255).toString(16);
}
function e1(e) {
  return ho(e) / 255;
}
function ho(e) {
  return parseInt(e, 16);
}
function u5(e) {
  return {
    r: e >> 16,
    g: (e & 65280) >> 8,
    b: e & 255
  };
}
var Mg = {
  aliceblue: "#f0f8ff",
  antiquewhite: "#faebd7",
  aqua: "#00ffff",
  aquamarine: "#7fffd4",
  azure: "#f0ffff",
  beige: "#f5f5dc",
  bisque: "#ffe4c4",
  black: "#000000",
  blanchedalmond: "#ffebcd",
  blue: "#0000ff",
  blueviolet: "#8a2be2",
  brown: "#a52a2a",
  burlywood: "#deb887",
  cadetblue: "#5f9ea0",
  chartreuse: "#7fff00",
  chocolate: "#d2691e",
  coral: "#ff7f50",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cyan: "#00ffff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  darkgreen: "#006400",
  darkgrey: "#a9a9a9",
  darkkhaki: "#bdb76b",
  darkmagenta: "#8b008b",
  darkolivegreen: "#556b2f",
  darkorange: "#ff8c00",
  darkorchid: "#9932cc",
  darkred: "#8b0000",
  darksalmon: "#e9967a",
  darkseagreen: "#8fbc8f",
  darkslateblue: "#483d8b",
  darkslategray: "#2f4f4f",
  darkslategrey: "#2f4f4f",
  darkturquoise: "#00ced1",
  darkviolet: "#9400d3",
  deeppink: "#ff1493",
  deepskyblue: "#00bfff",
  dimgray: "#696969",
  dimgrey: "#696969",
  dodgerblue: "#1e90ff",
  firebrick: "#b22222",
  floralwhite: "#fffaf0",
  forestgreen: "#228b22",
  fuchsia: "#ff00ff",
  gainsboro: "#dcdcdc",
  ghostwhite: "#f8f8ff",
  goldenrod: "#daa520",
  gold: "#ffd700",
  gray: "#808080",
  green: "#008000",
  greenyellow: "#adff2f",
  grey: "#808080",
  honeydew: "#f0fff0",
  hotpink: "#ff69b4",
  indianred: "#cd5c5c",
  indigo: "#4b0082",
  ivory: "#fffff0",
  khaki: "#f0e68c",
  lavenderblush: "#fff0f5",
  lavender: "#e6e6fa",
  lawngreen: "#7cfc00",
  lemonchiffon: "#fffacd",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lightcyan: "#e0ffff",
  lightgoldenrodyellow: "#fafad2",
  lightgray: "#d3d3d3",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightpink: "#ffb6c1",
  lightsalmon: "#ffa07a",
  lightseagreen: "#20b2aa",
  lightskyblue: "#87cefa",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  lightsteelblue: "#b0c4de",
  lightyellow: "#ffffe0",
  lime: "#00ff00",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  magenta: "#ff00ff",
  maroon: "#800000",
  mediumaquamarine: "#66cdaa",
  mediumblue: "#0000cd",
  mediumorchid: "#ba55d3",
  mediumpurple: "#9370db",
  mediumseagreen: "#3cb371",
  mediumslateblue: "#7b68ee",
  mediumspringgreen: "#00fa9a",
  mediumturquoise: "#48d1cc",
  mediumvioletred: "#c71585",
  midnightblue: "#191970",
  mintcream: "#f5fffa",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  navajowhite: "#ffdead",
  navy: "#000080",
  oldlace: "#fdf5e6",
  olive: "#808000",
  olivedrab: "#6b8e23",
  orange: "#ffa500",
  orangered: "#ff4500",
  orchid: "#da70d6",
  palegoldenrod: "#eee8aa",
  palegreen: "#98fb98",
  paleturquoise: "#afeeee",
  palevioletred: "#db7093",
  papayawhip: "#ffefd5",
  peachpuff: "#ffdab9",
  peru: "#cd853f",
  pink: "#ffc0cb",
  plum: "#dda0dd",
  powderblue: "#b0e0e6",
  purple: "#800080",
  rebeccapurple: "#663399",
  red: "#ff0000",
  rosybrown: "#bc8f8f",
  royalblue: "#4169e1",
  saddlebrown: "#8b4513",
  salmon: "#fa8072",
  sandybrown: "#f4a460",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  skyblue: "#87ceeb",
  slateblue: "#6a5acd",
  slategray: "#708090",
  slategrey: "#708090",
  snow: "#fffafa",
  springgreen: "#00ff7f",
  steelblue: "#4682b4",
  tan: "#d2b48c",
  teal: "#008080",
  thistle: "#d8bfd8",
  tomato: "#ff6347",
  turquoise: "#40e0d0",
  violet: "#ee82ee",
  wheat: "#f5deb3",
  white: "#ffffff",
  whitesmoke: "#f5f5f5",
  yellow: "#ffff00",
  yellowgreen: "#9acd32"
};
function za(e) {
  var t = { r: 0, g: 0, b: 0 }, n = 1, o = null, r = null, l = null, a = !1, i = !1;
  return typeof e == "string" && (e = p5(e)), typeof e == "object" && (Er(e.r) && Er(e.g) && Er(e.b) ? (t = l5(e.r, e.g, e.b), a = !0, i = String(e.r).substr(-1) === "%" ? "prgb" : "rgb") : Er(e.h) && Er(e.s) && Er(e.v) ? (o = Ac(e.s), r = Ac(e.v), t = i5(e.h, o, r), a = !0, i = "hsv") : Er(e.h) && Er(e.s) && Er(e.l) && (o = Ac(e.s), l = Ac(e.l), t = a5(e.h, o, l), a = !0, i = "hsl"), Object.prototype.hasOwnProperty.call(e, "a") && (n = e.a)), n = I2(n), {
    ok: a,
    format: e.format || i,
    r: Math.min(255, Math.max(t.r, 0)),
    g: Math.min(255, Math.max(t.g, 0)),
    b: Math.min(255, Math.max(t.b, 0)),
    a: n
  };
}
var d5 = "[-\\+]?\\d+%?", f5 = "[-\\+]?\\d*\\.\\d+%?", dl = "(?:".concat(f5, ")|(?:").concat(d5, ")"), Wp = "[\\s|\\(]+(".concat(dl, ")[,|\\s]+(").concat(dl, ")[,|\\s]+(").concat(dl, ")\\s*\\)?"), Kp = "[\\s|\\(]+(".concat(dl, ")[,|\\s]+(").concat(dl, ")[,|\\s]+(").concat(dl, ")[,|\\s]+(").concat(dl, ")\\s*\\)?"), Uo = {
  CSS_UNIT: new RegExp(dl),
  rgb: new RegExp("rgb" + Wp),
  rgba: new RegExp("rgba" + Kp),
  hsl: new RegExp("hsl" + Wp),
  hsla: new RegExp("hsla" + Kp),
  hsv: new RegExp("hsv" + Wp),
  hsva: new RegExp("hsva" + Kp),
  hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
  hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
  hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
};
function p5(e) {
  if (e = e.trim().toLowerCase(), e.length === 0)
    return !1;
  var t = !1;
  if (Mg[e])
    e = Mg[e], t = !0;
  else if (e === "transparent")
    return { r: 0, g: 0, b: 0, a: 0, format: "name" };
  var n = Uo.rgb.exec(e);
  return n ? { r: n[1], g: n[2], b: n[3] } : (n = Uo.rgba.exec(e), n ? { r: n[1], g: n[2], b: n[3], a: n[4] } : (n = Uo.hsl.exec(e), n ? { h: n[1], s: n[2], l: n[3] } : (n = Uo.hsla.exec(e), n ? { h: n[1], s: n[2], l: n[3], a: n[4] } : (n = Uo.hsv.exec(e), n ? { h: n[1], s: n[2], v: n[3] } : (n = Uo.hsva.exec(e), n ? { h: n[1], s: n[2], v: n[3], a: n[4] } : (n = Uo.hex8.exec(e), n ? {
    r: ho(n[1]),
    g: ho(n[2]),
    b: ho(n[3]),
    a: e1(n[4]),
    format: t ? "name" : "hex8"
  } : (n = Uo.hex6.exec(e), n ? {
    r: ho(n[1]),
    g: ho(n[2]),
    b: ho(n[3]),
    format: t ? "name" : "hex"
  } : (n = Uo.hex4.exec(e), n ? {
    r: ho(n[1] + n[1]),
    g: ho(n[2] + n[2]),
    b: ho(n[3] + n[3]),
    a: e1(n[4] + n[4]),
    format: t ? "name" : "hex8"
  } : (n = Uo.hex3.exec(e), n ? {
    r: ho(n[1] + n[1]),
    g: ho(n[2] + n[2]),
    b: ho(n[3] + n[3]),
    format: t ? "name" : "hex"
  } : !1)))))))));
}
function Er(e) {
  return !!Uo.CSS_UNIT.exec(String(e));
}
var Ct = (
  /** @class */
  function() {
    function e(t, n) {
      t === void 0 && (t = ""), n === void 0 && (n = {});
      var o;
      if (t instanceof e)
        return t;
      typeof t == "number" && (t = u5(t)), this.originalInput = t;
      var r = za(t);
      this.originalInput = t, this.r = r.r, this.g = r.g, this.b = r.b, this.a = r.a, this.roundA = Math.round(100 * this.a) / 100, this.format = (o = n.format) !== null && o !== void 0 ? o : r.format, this.gradientType = n.gradientType, this.r < 1 && (this.r = Math.round(this.r)), this.g < 1 && (this.g = Math.round(this.g)), this.b < 1 && (this.b = Math.round(this.b)), this.isValid = r.ok;
    }
    return e.prototype.isDark = function() {
      return this.getBrightness() < 128;
    }, e.prototype.isLight = function() {
      return !this.isDark();
    }, e.prototype.getBrightness = function() {
      var t = this.toRgb();
      return (t.r * 299 + t.g * 587 + t.b * 114) / 1e3;
    }, e.prototype.getLuminance = function() {
      var t = this.toRgb(), n, o, r, l = t.r / 255, a = t.g / 255, i = t.b / 255;
      return l <= 0.03928 ? n = l / 12.92 : n = Math.pow((l + 0.055) / 1.055, 2.4), a <= 0.03928 ? o = a / 12.92 : o = Math.pow((a + 0.055) / 1.055, 2.4), i <= 0.03928 ? r = i / 12.92 : r = Math.pow((i + 0.055) / 1.055, 2.4), 0.2126 * n + 0.7152 * o + 0.0722 * r;
    }, e.prototype.getAlpha = function() {
      return this.a;
    }, e.prototype.setAlpha = function(t) {
      return this.a = I2(t), this.roundA = Math.round(100 * this.a) / 100, this;
    }, e.prototype.isMonochrome = function() {
      var t = this.toHsl().s;
      return t === 0;
    }, e.prototype.toHsv = function() {
      var t = Eg(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, v: t.v, a: this.a };
    }, e.prototype.toHsvString = function() {
      var t = Eg(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.v * 100);
      return this.a === 1 ? "hsv(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsva(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHsl = function() {
      var t = Jy(this.r, this.g, this.b);
      return { h: t.h * 360, s: t.s, l: t.l, a: this.a };
    }, e.prototype.toHslString = function() {
      var t = Jy(this.r, this.g, this.b), n = Math.round(t.h * 360), o = Math.round(t.s * 100), r = Math.round(t.l * 100);
      return this.a === 1 ? "hsl(".concat(n, ", ").concat(o, "%, ").concat(r, "%)") : "hsla(".concat(n, ", ").concat(o, "%, ").concat(r, "%, ").concat(this.roundA, ")");
    }, e.prototype.toHex = function(t) {
      return t === void 0 && (t = !1), Tg(this.r, this.g, this.b, t);
    }, e.prototype.toHexString = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex(t);
    }, e.prototype.toHex8 = function(t) {
      return t === void 0 && (t = !1), s5(this.r, this.g, this.b, this.a, t);
    }, e.prototype.toHex8String = function(t) {
      return t === void 0 && (t = !1), "#" + this.toHex8(t);
    }, e.prototype.toHexShortString = function(t) {
      return t === void 0 && (t = !1), this.a === 1 ? this.toHexString(t) : this.toHex8String(t);
    }, e.prototype.toRgb = function() {
      return {
        r: Math.round(this.r),
        g: Math.round(this.g),
        b: Math.round(this.b),
        a: this.a
      };
    }, e.prototype.toRgbString = function() {
      var t = Math.round(this.r), n = Math.round(this.g), o = Math.round(this.b);
      return this.a === 1 ? "rgb(".concat(t, ", ").concat(n, ", ").concat(o, ")") : "rgba(".concat(t, ", ").concat(n, ", ").concat(o, ", ").concat(this.roundA, ")");
    }, e.prototype.toPercentageRgb = function() {
      var t = function(n) {
        return "".concat(Math.round(En(n, 255) * 100), "%");
      };
      return {
        r: t(this.r),
        g: t(this.g),
        b: t(this.b),
        a: this.a
      };
    }, e.prototype.toPercentageRgbString = function() {
      var t = function(n) {
        return Math.round(En(n, 255) * 100);
      };
      return this.a === 1 ? "rgb(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%)") : "rgba(".concat(t(this.r), "%, ").concat(t(this.g), "%, ").concat(t(this.b), "%, ").concat(this.roundA, ")");
    }, e.prototype.toName = function() {
      if (this.a === 0)
        return "transparent";
      if (this.a < 1)
        return !1;
      for (var t = "#" + Tg(this.r, this.g, this.b, !1), n = 0, o = Object.entries(Mg); n < o.length; n++) {
        var r = o[n], l = r[0], a = r[1];
        if (t === a)
          return l;
      }
      return !1;
    }, e.prototype.toString = function(t) {
      var n = !!t;
      t = t ?? this.format;
      var o = !1, r = this.a < 1 && this.a >= 0, l = !n && r && (t.startsWith("hex") || t === "name");
      return l ? t === "name" && this.a === 0 ? this.toName() : this.toRgbString() : (t === "rgb" && (o = this.toRgbString()), t === "prgb" && (o = this.toPercentageRgbString()), (t === "hex" || t === "hex6") && (o = this.toHexString()), t === "hex3" && (o = this.toHexString(!0)), t === "hex4" && (o = this.toHex8String(!0)), t === "hex8" && (o = this.toHex8String()), t === "name" && (o = this.toName()), t === "hsl" && (o = this.toHslString()), t === "hsv" && (o = this.toHsvString()), o || this.toHexString());
    }, e.prototype.toNumber = function() {
      return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
    }, e.prototype.clone = function() {
      return new e(this.toString());
    }, e.prototype.lighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l += t / 100, n.l = _c(n.l), new e(n);
    }, e.prototype.brighten = function(t) {
      t === void 0 && (t = 10);
      var n = this.toRgb();
      return n.r = Math.max(0, Math.min(255, n.r - Math.round(255 * -(t / 100)))), n.g = Math.max(0, Math.min(255, n.g - Math.round(255 * -(t / 100)))), n.b = Math.max(0, Math.min(255, n.b - Math.round(255 * -(t / 100)))), new e(n);
    }, e.prototype.darken = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.l -= t / 100, n.l = _c(n.l), new e(n);
    }, e.prototype.tint = function(t) {
      return t === void 0 && (t = 10), this.mix("white", t);
    }, e.prototype.shade = function(t) {
      return t === void 0 && (t = 10), this.mix("black", t);
    }, e.prototype.desaturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s -= t / 100, n.s = _c(n.s), new e(n);
    }, e.prototype.saturate = function(t) {
      t === void 0 && (t = 10);
      var n = this.toHsl();
      return n.s += t / 100, n.s = _c(n.s), new e(n);
    }, e.prototype.greyscale = function() {
      return this.desaturate(100);
    }, e.prototype.spin = function(t) {
      var n = this.toHsl(), o = (n.h + t) % 360;
      return n.h = o < 0 ? 360 + o : o, new e(n);
    }, e.prototype.mix = function(t, n) {
      n === void 0 && (n = 50);
      var o = this.toRgb(), r = new e(t).toRgb(), l = n / 100, a = {
        r: (r.r - o.r) * l + o.r,
        g: (r.g - o.g) * l + o.g,
        b: (r.b - o.b) * l + o.b,
        a: (r.a - o.a) * l + o.a
      };
      return new e(a);
    }, e.prototype.analogous = function(t, n) {
      t === void 0 && (t = 6), n === void 0 && (n = 30);
      var o = this.toHsl(), r = 360 / n, l = [this];
      for (o.h = (o.h - (r * t >> 1) + 720) % 360; --t; )
        o.h = (o.h + r) % 360, l.push(new e(o));
      return l;
    }, e.prototype.complement = function() {
      var t = this.toHsl();
      return t.h = (t.h + 180) % 360, new e(t);
    }, e.prototype.monochromatic = function(t) {
      t === void 0 && (t = 6);
      for (var n = this.toHsv(), o = n.h, r = n.s, l = n.v, a = [], i = 1 / t; t--; )
        a.push(new e({ h: o, s: r, v: l })), l = (l + i) % 1;
      return a;
    }, e.prototype.splitcomplement = function() {
      var t = this.toHsl(), n = t.h;
      return [
        this,
        new e({ h: (n + 72) % 360, s: t.s, l: t.l }),
        new e({ h: (n + 216) % 360, s: t.s, l: t.l })
      ];
    }, e.prototype.onBackground = function(t) {
      var n = this.toRgb(), o = new e(t).toRgb(), r = n.a + o.a * (1 - n.a);
      return new e({
        r: (n.r * n.a + o.r * o.a * (1 - n.a)) / r,
        g: (n.g * n.a + o.g * o.a * (1 - n.a)) / r,
        b: (n.b * n.a + o.b * o.a * (1 - n.a)) / r,
        a: r
      });
    }, e.prototype.triad = function() {
      return this.polyad(3);
    }, e.prototype.tetrad = function() {
      return this.polyad(4);
    }, e.prototype.polyad = function(t) {
      for (var n = this.toHsl(), o = n.h, r = [this], l = 360 / t, a = 1; a < t; a++)
        r.push(new e({ h: (o + a * l) % 360, s: n.s, l: n.l }));
      return r;
    }, e.prototype.equals = function(t) {
      return this.toRgbString() === new e(t).toRgbString();
    }, e;
  }()
), Dc = 2, t1 = 0.16, v5 = 0.05, g5 = 0.05, m5 = 0.15, E2 = 5, T2 = 4, h5 = [{
  index: 7,
  opacity: 0.15
}, {
  index: 6,
  opacity: 0.25
}, {
  index: 5,
  opacity: 0.3
}, {
  index: 5,
  opacity: 0.45
}, {
  index: 5,
  opacity: 0.65
}, {
  index: 5,
  opacity: 0.85
}, {
  index: 4,
  opacity: 0.9
}, {
  index: 3,
  opacity: 0.95
}, {
  index: 2,
  opacity: 0.97
}, {
  index: 1,
  opacity: 0.98
}];
function n1(e) {
  var t = e.r, n = e.g, o = e.b, r = Eg(t, n, o);
  return {
    h: r.h * 360,
    s: r.s,
    v: r.v
  };
}
function Nc(e) {
  var t = e.r, n = e.g, o = e.b;
  return "#".concat(Tg(t, n, o, !1));
}
function b5(e, t, n) {
  var o = n / 100, r = {
    r: (t.r - e.r) * o + e.r,
    g: (t.g - e.g) * o + e.g,
    b: (t.b - e.b) * o + e.b
  };
  return r;
}
function o1(e, t, n) {
  var o;
  return Math.round(e.h) >= 60 && Math.round(e.h) <= 240 ? o = n ? Math.round(e.h) - Dc * t : Math.round(e.h) + Dc * t : o = n ? Math.round(e.h) + Dc * t : Math.round(e.h) - Dc * t, o < 0 ? o += 360 : o >= 360 && (o -= 360), o;
}
function r1(e, t, n) {
  if (e.h === 0 && e.s === 0)
    return e.s;
  var o;
  return n ? o = e.s - t1 * t : t === T2 ? o = e.s + t1 : o = e.s + v5 * t, o > 1 && (o = 1), n && t === E2 && o > 0.1 && (o = 0.1), o < 0.06 && (o = 0.06), Number(o.toFixed(2));
}
function l1(e, t, n) {
  var o;
  return n ? o = e.v + g5 * t : o = e.v - m5 * t, o > 1 && (o = 1), Number(o.toFixed(2));
}
function sa(e) {
  for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = [], o = za(e), r = E2; r > 0; r -= 1) {
    var l = n1(o), a = Nc(za({
      h: o1(l, r, !0),
      s: r1(l, r, !0),
      v: l1(l, r, !0)
    }));
    n.push(a);
  }
  n.push(Nc(o));
  for (var i = 1; i <= T2; i += 1) {
    var s = n1(o), c = Nc(za({
      h: o1(s, i),
      s: r1(s, i),
      v: l1(s, i)
    }));
    n.push(c);
  }
  return t.theme === "dark" ? h5.map(function(u) {
    var d = u.index, p = u.opacity, v = Nc(b5(za(t.backgroundColor || "#141414"), za(n[d]), p * 100));
    return v;
  }) : n;
}
var ei = {
  red: "#F5222D",
  volcano: "#FA541C",
  orange: "#FA8C16",
  gold: "#FAAD14",
  yellow: "#FADB14",
  lime: "#A0D911",
  green: "#52C41A",
  cyan: "#13C2C2",
  blue: "#1890FF",
  geekblue: "#2F54EB",
  purple: "#722ED1",
  magenta: "#EB2F96",
  grey: "#666666"
}, fs = {}, Gp = {};
Object.keys(ei).forEach(function(e) {
  fs[e] = sa(ei[e]), fs[e].primary = fs[e][5], Gp[e] = sa(ei[e], {
    theme: "dark",
    backgroundColor: "#141414"
  }), Gp[e].primary = Gp[e][5];
});
var y5 = fs.gold, S5 = fs.blue;
const C5 = (e) => {
  const {
    controlHeight: t
  } = e;
  return {
    controlHeightSM: t * 0.75,
    controlHeightXS: t * 0.5,
    controlHeightLG: t * 1.25
  };
};
function $5(e) {
  const {
    sizeUnit: t,
    sizeStep: n
  } = e;
  return {
    sizeXXL: t * (n + 8),
    sizeXL: t * (n + 4),
    sizeLG: t * (n + 2),
    sizeMD: t * (n + 1),
    sizeMS: t * n,
    size: t * n,
    sizeSM: t * (n - 1),
    sizeXS: t * (n - 2),
    sizeXXS: t * (n - 3)
    // 4
  };
}
const M2 = {
  blue: "#1677ff",
  purple: "#722ED1",
  cyan: "#13C2C2",
  green: "#52C41A",
  magenta: "#EB2F96",
  pink: "#eb2f96",
  red: "#F5222D",
  orange: "#FA8C16",
  yellow: "#FADB14",
  volcano: "#FA541C",
  geekblue: "#2F54EB",
  gold: "#FAAD14",
  lime: "#A0D911"
}, $f = m(m({}, M2), {
  // Color
  colorPrimary: "#1677ff",
  colorSuccess: "#52c41a",
  colorWarning: "#faad14",
  colorError: "#ff4d4f",
  colorInfo: "#1677ff",
  colorTextBase: "",
  colorBgBase: "",
  // Font
  fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
  fontSize: 14,
  // Line
  lineWidth: 1,
  lineType: "solid",
  // Motion
  motionUnit: 0.1,
  motionBase: 0,
  motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
  motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
  motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
  motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
  motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
  motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
  motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
  motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
  // Radius
  borderRadius: 6,
  // Size
  sizeUnit: 4,
  sizeStep: 4,
  sizePopupArrow: 16,
  // Control Base
  controlHeight: 32,
  // zIndex
  zIndexBase: 0,
  zIndexPopupBase: 1e3,
  // Image
  opacityImage: 1,
  // Wireframe
  wireframe: !1
});
function w5(e, t) {
  let {
    generateColorPalettes: n,
    generateNeutralColorPalettes: o
  } = t;
  const {
    colorSuccess: r,
    colorWarning: l,
    colorError: a,
    colorInfo: i,
    colorPrimary: s,
    colorBgBase: c,
    colorTextBase: u
  } = e, d = n(s), p = n(r), v = n(l), h = n(a), g = n(i), b = o(c, u);
  return m(m({}, b), {
    colorPrimaryBg: d[1],
    colorPrimaryBgHover: d[2],
    colorPrimaryBorder: d[3],
    colorPrimaryBorderHover: d[4],
    colorPrimaryHover: d[5],
    colorPrimary: d[6],
    colorPrimaryActive: d[7],
    colorPrimaryTextHover: d[8],
    colorPrimaryText: d[9],
    colorPrimaryTextActive: d[10],
    colorSuccessBg: p[1],
    colorSuccessBgHover: p[2],
    colorSuccessBorder: p[3],
    colorSuccessBorderHover: p[4],
    colorSuccessHover: p[4],
    colorSuccess: p[6],
    colorSuccessActive: p[7],
    colorSuccessTextHover: p[8],
    colorSuccessText: p[9],
    colorSuccessTextActive: p[10],
    colorErrorBg: h[1],
    colorErrorBgHover: h[2],
    colorErrorBorder: h[3],
    colorErrorBorderHover: h[4],
    colorErrorHover: h[5],
    colorError: h[6],
    colorErrorActive: h[7],
    colorErrorTextHover: h[8],
    colorErrorText: h[9],
    colorErrorTextActive: h[10],
    colorWarningBg: v[1],
    colorWarningBgHover: v[2],
    colorWarningBorder: v[3],
    colorWarningBorderHover: v[4],
    colorWarningHover: v[4],
    colorWarning: v[6],
    colorWarningActive: v[7],
    colorWarningTextHover: v[8],
    colorWarningText: v[9],
    colorWarningTextActive: v[10],
    colorInfoBg: g[1],
    colorInfoBgHover: g[2],
    colorInfoBorder: g[3],
    colorInfoBorderHover: g[4],
    colorInfoHover: g[4],
    colorInfo: g[6],
    colorInfoActive: g[7],
    colorInfoTextHover: g[8],
    colorInfoText: g[9],
    colorInfoTextActive: g[10],
    colorBgMask: new Ct("#000").setAlpha(0.45).toRgbString(),
    colorWhite: "#fff"
  });
}
const x5 = (e) => {
  let t = e, n = e, o = e, r = e;
  return e < 6 && e >= 5 ? t = e + 1 : e < 16 && e >= 6 ? t = e + 2 : e >= 16 && (t = 16), e < 7 && e >= 5 ? n = 4 : e < 8 && e >= 7 ? n = 5 : e < 14 && e >= 8 ? n = 6 : e < 16 && e >= 14 ? n = 7 : e >= 16 && (n = 8), e < 6 && e >= 2 ? o = 1 : e >= 6 && (o = 2), e > 4 && e < 8 ? r = 4 : e >= 8 && (r = 6), {
    borderRadius: e > 16 ? 16 : e,
    borderRadiusXS: o,
    borderRadiusSM: n,
    borderRadiusLG: t,
    borderRadiusOuter: r
  };
};
function O5(e) {
  const {
    motionUnit: t,
    motionBase: n,
    borderRadius: o,
    lineWidth: r
  } = e;
  return m({
    // motion
    motionDurationFast: `${(n + t).toFixed(1)}s`,
    motionDurationMid: `${(n + t * 2).toFixed(1)}s`,
    motionDurationSlow: `${(n + t * 3).toFixed(1)}s`,
    // line
    lineWidthBold: r + 1
  }, x5(o));
}
const Tr = (e, t) => new Ct(e).setAlpha(t).toRgbString(), Gi = (e, t) => new Ct(e).darken(t).toHexString(), P5 = (e) => {
  const t = sa(e);
  return {
    1: t[0],
    2: t[1],
    3: t[2],
    4: t[3],
    5: t[4],
    6: t[5],
    7: t[6],
    8: t[4],
    9: t[5],
    10: t[6]
    // 8: colors[7],
    // 9: colors[8],
    // 10: colors[9],
  };
}, I5 = (e, t) => {
  const n = e || "#fff", o = t || "#000";
  return {
    colorBgBase: n,
    colorTextBase: o,
    colorText: Tr(o, 0.88),
    colorTextSecondary: Tr(o, 0.65),
    colorTextTertiary: Tr(o, 0.45),
    colorTextQuaternary: Tr(o, 0.25),
    colorFill: Tr(o, 0.15),
    colorFillSecondary: Tr(o, 0.06),
    colorFillTertiary: Tr(o, 0.04),
    colorFillQuaternary: Tr(o, 0.02),
    colorBgLayout: Gi(n, 4),
    colorBgContainer: Gi(n, 0),
    colorBgElevated: Gi(n, 0),
    colorBgSpotlight: Tr(o, 0.85),
    colorBorder: Gi(n, 15),
    colorBorderSecondary: Gi(n, 6)
  };
};
function E5(e) {
  const t = new Array(10).fill(null).map((n, o) => {
    const r = o - 1, l = e * Math.pow(2.71828, r / 5), a = o > 1 ? Math.floor(l) : Math.ceil(l);
    return Math.floor(a / 2) * 2;
  });
  return t[1] = e, t.map((n) => {
    const o = n + 8;
    return {
      size: n,
      lineHeight: o / n
    };
  });
}
const T5 = (e) => {
  const t = E5(e), n = t.map((r) => r.size), o = t.map((r) => r.lineHeight);
  return {
    fontSizeSM: n[0],
    fontSize: n[1],
    fontSizeLG: n[2],
    fontSizeXL: n[3],
    fontSizeHeading1: n[6],
    fontSizeHeading2: n[5],
    fontSizeHeading3: n[4],
    fontSizeHeading4: n[3],
    fontSizeHeading5: n[2],
    lineHeight: o[1],
    lineHeightLG: o[2],
    lineHeightSM: o[0],
    lineHeightHeading1: o[6],
    lineHeightHeading2: o[5],
    lineHeightHeading3: o[4],
    lineHeightHeading4: o[3],
    lineHeightHeading5: o[2]
  };
};
function M5(e) {
  const t = Object.keys(M2).map((n) => {
    const o = sa(e[n]);
    return new Array(10).fill(1).reduce((r, l, a) => (r[`${n}-${a + 1}`] = o[a], r), {});
  }).reduce((n, o) => (n = m(m({}, n), o), n), {});
  return m(m(m(m(m(m(m({}, e), t), w5(e, {
    generateColorPalettes: P5,
    generateNeutralColorPalettes: I5
  })), T5(e.fontSize)), $5(e)), C5(e)), O5(e));
}
function Xp(e) {
  return e >= 0 && e <= 255;
}
function Rc(e, t) {
  const {
    r: n,
    g: o,
    b: r,
    a: l
  } = new Ct(e).toRgb();
  if (l < 1)
    return e;
  const {
    r: a,
    g: i,
    b: s
  } = new Ct(t).toRgb();
  for (let c = 0.01; c <= 1; c += 0.01) {
    const u = Math.round((n - a * (1 - c)) / c), d = Math.round((o - i * (1 - c)) / c), p = Math.round((r - s * (1 - c)) / c);
    if (Xp(u) && Xp(d) && Xp(p))
      return new Ct({
        r: u,
        g: d,
        b: p,
        a: Math.round(c * 100) / 100
      }).toRgbString();
  }
  return new Ct({
    r: n,
    g: o,
    b: r,
    a: 1
  }).toRgbString();
}
var _5 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function A5(e) {
  const {
    override: t
  } = e, n = _5(e, ["override"]), o = m({}, t);
  Object.keys($f).forEach((v) => {
    delete o[v];
  });
  const r = m(m({}, n), o), l = 480, a = 576, i = 768, s = 992, c = 1200, u = 1600, d = 2e3;
  return m(m(m({}, r), {
    colorLink: r.colorInfoText,
    colorLinkHover: r.colorInfoHover,
    colorLinkActive: r.colorInfoActive,
    // ============== Background ============== //
    colorFillContent: r.colorFillSecondary,
    colorFillContentHover: r.colorFill,
    colorFillAlter: r.colorFillQuaternary,
    colorBgContainerDisabled: r.colorFillTertiary,
    // ============== Split ============== //
    colorBorderBg: r.colorBgContainer,
    colorSplit: Rc(r.colorBorderSecondary, r.colorBgContainer),
    // ============== Text ============== //
    colorTextPlaceholder: r.colorTextQuaternary,
    colorTextDisabled: r.colorTextQuaternary,
    colorTextHeading: r.colorText,
    colorTextLabel: r.colorTextSecondary,
    colorTextDescription: r.colorTextTertiary,
    colorTextLightSolid: r.colorWhite,
    colorHighlight: r.colorError,
    colorBgTextHover: r.colorFillSecondary,
    colorBgTextActive: r.colorFill,
    colorIcon: r.colorTextTertiary,
    colorIconHover: r.colorText,
    colorErrorOutline: Rc(r.colorErrorBg, r.colorBgContainer),
    colorWarningOutline: Rc(r.colorWarningBg, r.colorBgContainer),
    // Font
    fontSizeIcon: r.fontSizeSM,
    // Control
    lineWidth: r.lineWidth,
    controlOutlineWidth: r.lineWidth * 2,
    // Checkbox size and expand icon size
    controlInteractiveSize: r.controlHeight / 2,
    controlItemBgHover: r.colorFillTertiary,
    controlItemBgActive: r.colorPrimaryBg,
    controlItemBgActiveHover: r.colorPrimaryBgHover,
    controlItemBgActiveDisabled: r.colorFill,
    controlTmpOutline: r.colorFillQuaternary,
    controlOutline: Rc(r.colorPrimaryBg, r.colorBgContainer),
    lineType: r.lineType,
    borderRadius: r.borderRadius,
    borderRadiusXS: r.borderRadiusXS,
    borderRadiusSM: r.borderRadiusSM,
    borderRadiusLG: r.borderRadiusLG,
    fontWeightStrong: 600,
    opacityLoading: 0.65,
    linkDecoration: "none",
    linkHoverDecoration: "none",
    linkFocusDecoration: "none",
    controlPaddingHorizontal: 12,
    controlPaddingHorizontalSM: 8,
    paddingXXS: r.sizeXXS,
    paddingXS: r.sizeXS,
    paddingSM: r.sizeSM,
    padding: r.size,
    paddingMD: r.sizeMD,
    paddingLG: r.sizeLG,
    paddingXL: r.sizeXL,
    paddingContentHorizontalLG: r.sizeLG,
    paddingContentVerticalLG: r.sizeMS,
    paddingContentHorizontal: r.sizeMS,
    paddingContentVertical: r.sizeSM,
    paddingContentHorizontalSM: r.size,
    paddingContentVerticalSM: r.sizeXS,
    marginXXS: r.sizeXXS,
    marginXS: r.sizeXS,
    marginSM: r.sizeSM,
    margin: r.size,
    marginMD: r.sizeMD,
    marginLG: r.sizeLG,
    marginXL: r.sizeXL,
    marginXXL: r.sizeXXL,
    boxShadow: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
    screenXS: l,
    screenXSMin: l,
    screenXSMax: a - 1,
    screenSM: a,
    screenSMMin: a,
    screenSMMax: i - 1,
    screenMD: i,
    screenMDMin: i,
    screenMDMax: s - 1,
    screenLG: s,
    screenLGMin: s,
    screenLGMax: c - 1,
    screenXL: c,
    screenXLMin: c,
    screenXLMax: u - 1,
    screenXXL: u,
    screenXXLMin: u,
    screenXXLMax: d - 1,
    screenXXXL: d,
    screenXXXLMin: d,
    // FIXME: component box-shadow, should be removed
    boxShadowPopoverArrow: "3px 3px 7px rgba(0, 0, 0, 0.1)",
    boxShadowCard: `
      0 1px 2px -2px ${new Ct("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new Ct("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new Ct("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
    boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
    boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
    boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
  }), o);
}
const wf = (e) => ({
  // FIXME: This use link but is a operation unit. Seems should be a colorPrimary.
  // And Typography use this to generate link style which should not do this.
  color: e.colorLink,
  textDecoration: "none",
  outline: "none",
  cursor: "pointer",
  transition: `color ${e.motionDurationSlow}`,
  "&:focus, &:hover": {
    color: e.colorLinkHover
  },
  "&:active": {
    color: e.colorLinkActive
  }
}), dh = (e, t, n, o, r) => {
  const l = e / 2, a = 0, i = l, s = n * 1 / Math.sqrt(2), c = l - n * (1 - 1 / Math.sqrt(2)), u = l - t * (1 / Math.sqrt(2)), d = n * (Math.sqrt(2) - 1) + t * (1 / Math.sqrt(2)), p = 2 * l - u, v = d, h = 2 * l - s, g = c, b = 2 * l - a, y = i, S = l * Math.sqrt(2) + n * (Math.sqrt(2) - 2), C = n * (Math.sqrt(2) - 1);
  return {
    pointerEvents: "none",
    width: e,
    height: e,
    overflow: "hidden",
    "&::after": {
      content: '""',
      position: "absolute",
      width: S,
      height: S,
      bottom: 0,
      insetInline: 0,
      margin: "auto",
      borderRadius: {
        _skip_check_: !0,
        value: `0 0 ${t}px 0`
      },
      transform: "translateY(50%) rotate(-135deg)",
      boxShadow: r,
      zIndex: 0,
      background: "transparent"
    },
    "&::before": {
      position: "absolute",
      bottom: 0,
      insetInlineStart: 0,
      width: e,
      height: e / 2,
      background: o,
      clipPath: {
        _multi_value_: !0,
        value: [`polygon(${C}px 100%, 50% ${C}px, ${2 * l - C}px 100%, ${C}px 100%)`, `path('M ${a} ${i} A ${n} ${n} 0 0 0 ${s} ${c} L ${u} ${d} A ${t} ${t} 0 0 1 ${p} ${v} L ${h} ${g} A ${n} ${n} 0 0 0 ${b} ${y} Z')`]
      },
      content: '""'
    }
  };
};
function dd(e, t) {
  return Fs.reduce((n, o) => {
    const r = e[`${o}-1`], l = e[`${o}-3`], a = e[`${o}-6`], i = e[`${o}-7`];
    return m(m({}, n), t(o, {
      lightColor: r,
      lightBorderColor: l,
      darkColor: a,
      textColor: i
    }));
  }, {});
}
const tn = {
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis"
}, qe = (e) => ({
  boxSizing: "border-box",
  margin: 0,
  padding: 0,
  color: e.colorText,
  fontSize: e.fontSize,
  // font-variant: @font-variant-base;
  lineHeight: e.lineHeight,
  listStyle: "none",
  // font-feature-settings: @font-feature-settings-base;
  fontFamily: e.fontFamily
}), ha = () => ({
  display: "inline-flex",
  alignItems: "center",
  color: "inherit",
  fontStyle: "normal",
  lineHeight: 0,
  textAlign: "center",
  textTransform: "none",
  // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
  verticalAlign: "-0.125em",
  textRendering: "optimizeLegibility",
  "-webkit-font-smoothing": "antialiased",
  "-moz-osx-font-smoothing": "grayscale",
  "> *": {
    lineHeight: 1
  },
  svg: {
    display: "inline-block"
  }
}), nr = () => ({
  // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
  "&::before": {
    display: "table",
    content: '""'
  },
  "&::after": {
    // https://github.com/ant-design/ant-design/issues/21864
    display: "table",
    clear: "both",
    content: '""'
  }
}), D5 = (e) => ({
  a: {
    color: e.colorLink,
    textDecoration: e.linkDecoration,
    backgroundColor: "transparent",
    outline: "none",
    cursor: "pointer",
    transition: `color ${e.motionDurationSlow}`,
    "-webkit-text-decoration-skip": "objects",
    "&:hover": {
      color: e.colorLinkHover
    },
    "&:active": {
      color: e.colorLinkActive
    },
    "&:active,\n  &:hover": {
      textDecoration: e.linkHoverDecoration,
      outline: 0
    },
    // https://github.com/ant-design/ant-design/issues/22503
    "&:focus": {
      textDecoration: e.linkFocusDecoration,
      outline: 0
    },
    "&[disabled]": {
      color: e.colorTextDisabled,
      cursor: "not-allowed"
    }
  }
}), N5 = (e, t) => {
  const {
    fontFamily: n,
    fontSize: o
  } = e, r = `[class^="${t}"], [class*=" ${t}"]`;
  return {
    [r]: {
      fontFamily: n,
      fontSize: o,
      boxSizing: "border-box",
      "&::before, &::after": {
        boxSizing: "border-box"
      },
      [r]: {
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        }
      }
    }
  };
}, Gr = (e) => ({
  outline: `${e.lineWidthBold}px solid ${e.colorPrimaryBorder}`,
  outlineOffset: 1,
  transition: "outline-offset 0s, outline 0s"
}), Xr = (e) => ({
  "&:focus-visible": m({}, Gr(e))
});
function Xe(e, t, n) {
  return (o) => {
    const r = P(() => o == null ? void 0 : o.value), [l, a, i] = qr(), {
      getPrefixCls: s,
      iconPrefixCls: c
    } = oc(), u = P(() => s()), d = P(() => ({
      theme: l.value,
      token: a.value,
      hashId: i.value,
      path: ["Shared", u.value]
    }));
    Ig(d, () => [{
      // Link
      "&": D5(a.value)
    }]);
    const p = P(() => ({
      theme: l.value,
      token: a.value,
      hashId: i.value,
      path: [e, r.value, c.value]
    }));
    return [Ig(p, () => {
      const {
        token: v,
        flush: h
      } = k5(a.value), g = typeof n == "function" ? n(v) : n, b = m(m({}, g), a.value[e]), y = `.${r.value}`, S = He(v, {
        componentCls: y,
        prefixCls: r.value,
        iconCls: `.${c.value}`,
        antCls: `.${u.value}`
      }, b), C = t(S, {
        hashId: i.value,
        prefixCls: r.value,
        rootPrefixCls: u.value,
        iconPrefixCls: c.value,
        overrideComponentToken: a.value[e]
      });
      return h(e, b), [N5(a.value, r.value), C];
    }), i];
  };
}
const _2 = process.env.NODE_ENV !== "production" || typeof CSSINJS_STATISTIC < "u";
let _g = !0;
function He() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  if (!_2)
    return m({}, ...t);
  _g = !1;
  const o = {};
  return t.forEach((r) => {
    Object.keys(r).forEach((a) => {
      Object.defineProperty(o, a, {
        configurable: !0,
        enumerable: !0,
        get: () => r[a]
      });
    });
  }), _g = !0, o;
}
function R5() {
}
function k5(e) {
  let t, n = e, o = R5;
  return _2 && (t = /* @__PURE__ */ new Set(), n = new Proxy(e, {
    get(r, l) {
      return _g && t.add(l), r[l];
    }
  }), o = (r, l) => {
    Array.from(t);
  }), {
    token: n,
    keys: t,
    flush: o
  };
}
const B5 = g2(M5), A2 = {
  token: $f,
  hashed: !0
}, D2 = Symbol("DesignTokenContext"), Ag = Q(), F5 = (e) => {
  Je(D2, e), ie(e, () => {
    Ag.value = hn(e), Rx(Ag);
  }, {
    immediate: !0,
    deep: !0
  });
}, L5 = Z({
  props: {
    value: Re()
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return F5(P(() => e.value)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
});
function qr() {
  const e = tt(D2, P(() => Ag.value || A2)), t = P(() => `${n5}-${e.value.hashed || ""}`), n = P(() => e.value.theme || B5), o = T8(n, P(() => [$f, e.value.token]), P(() => ({
    salt: t.value,
    override: m({
      override: e.value.token
    }, e.value.components),
    formatToken: A5
  })));
  return [n, P(() => o.value[0]), P(() => e.value.hashed ? o.value[1] : "")];
}
const fh = Z({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, e] = qr(), t = P(() => new Ct(e.value.colorBgBase).toHsl().l < 0.5 ? {
      opacity: 0.65
    } : {});
    return () => f("svg", {
      style: t.value,
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg"
    }, [f("g", {
      fill: "none",
      "fill-rule": "evenodd"
    }, [f("g", {
      transform: "translate(24 31.67)"
    }, [f("ellipse", {
      "fill-opacity": ".8",
      fill: "#F5F5F7",
      cx: "67.797",
      cy: "106.89",
      rx: "67.797",
      ry: "12.668"
    }, null), f("path", {
      d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
      fill: "#AEB8C2"
    }, null), f("path", {
      d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
      fill: "url(#linearGradient-1)",
      transform: "translate(13.56)"
    }, null), f("path", {
      d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
      fill: "#F5F5F7"
    }, null), f("path", {
      d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
      fill: "#DCE0E6"
    }, null)]), f("path", {
      d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
      fill: "#DCE0E6"
    }, null), f("g", {
      transform: "translate(149.65 15.383)",
      fill: "#FFF"
    }, [f("ellipse", {
      cx: "20.654",
      cy: "3.167",
      rx: "2.849",
      ry: "2.815"
    }, null), f("path", {
      d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }, null)])])]);
  }
});
fh.PRESENTED_IMAGE_DEFAULT = !0;
const N2 = Z({
  compatConfig: {
    MODE: 3
  },
  setup() {
    const [, e] = qr(), t = P(() => {
      const {
        colorFill: n,
        colorFillTertiary: o,
        colorFillQuaternary: r,
        colorBgContainer: l
      } = e.value;
      return {
        borderColor: new Ct(n).onBackground(l).toHexString(),
        shadowColor: new Ct(o).onBackground(l).toHexString(),
        contentColor: new Ct(r).onBackground(l).toHexString()
      };
    });
    return () => f("svg", {
      width: "64",
      height: "41",
      viewBox: "0 0 64 41",
      xmlns: "http://www.w3.org/2000/svg"
    }, [f("g", {
      transform: "translate(0 1)",
      fill: "none",
      "fill-rule": "evenodd"
    }, [f("ellipse", {
      fill: t.value.shadowColor,
      cx: "32",
      cy: "33",
      rx: "32",
      ry: "7"
    }, null), f("g", {
      "fill-rule": "nonzero",
      stroke: t.value.borderColor
    }, [f("path", {
      d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }, null), f("path", {
      d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      fill: t.value.contentColor
    }, null)])])]);
  }
});
N2.PRESENTED_IMAGE_SIMPLE = !0;
const z5 = (e) => {
  const {
    componentCls: t,
    margin: n,
    marginXS: o,
    marginXL: r,
    fontSize: l,
    lineHeight: a
  } = e;
  return {
    [t]: {
      marginInline: o,
      fontSize: l,
      lineHeight: a,
      textAlign: "center",
      // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${t}-image`]: {
        height: e.emptyImgHeight,
        marginBottom: o,
        opacity: e.opacityImage,
        img: {
          height: "100%"
        },
        svg: {
          height: "100%",
          margin: "auto"
        }
      },
      // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
      [`${t}-footer`]: {
        marginTop: n
      },
      "&-normal": {
        marginBlock: r,
        color: e.colorTextDisabled,
        [`${t}-image`]: {
          height: e.emptyImgHeightMD
        }
      },
      "&-small": {
        marginBlock: o,
        color: e.colorTextDisabled,
        [`${t}-image`]: {
          height: e.emptyImgHeightSM
        }
      }
    }
  };
}, H5 = Xe("Empty", (e) => {
  const {
    componentCls: t,
    controlHeightLG: n
  } = e, o = He(e, {
    emptyImgCls: `${t}-img`,
    emptyImgHeight: n * 2.5,
    emptyImgHeightMD: n,
    emptyImgHeightSM: n * 0.875
  });
  return [z5(o)];
});
var j5 = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const V5 = () => ({
  prefixCls: String,
  imageStyle: Re(),
  image: _t(),
  description: _t()
}), ph = Z({
  name: "AEmpty",
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: V5(),
  setup(e, t) {
    let {
      slots: n = {},
      attrs: o
    } = t;
    const {
      direction: r,
      prefixCls: l
    } = Ie("empty", e), [a, i] = H5(l);
    return () => {
      var s, c;
      const u = l.value, d = m(m({}, e), o), {
        image: p = ((s = n.image) === null || s === void 0 ? void 0 : s.call(n)) || vr(fh),
        description: v = ((c = n.description) === null || c === void 0 ? void 0 : c.call(n)) || void 0,
        imageStyle: h,
        class: g = ""
      } = d, b = j5(d, ["image", "description", "imageStyle", "class"]), y = typeof p == "function" ? p() : p, S = typeof y == "object" && "type" in y && y.type.PRESENTED_IMAGE_SIMPLE;
      return a(f(ma, {
        componentName: "Empty",
        children: (C) => {
          const w = typeof v < "u" ? v : C.description, $ = typeof w == "string" ? w : "empty";
          let O = null;
          return typeof y == "string" ? O = f("img", {
            alt: $,
            src: y
          }, null) : O = y, f("div", D({
            class: ee(u, g, i.value, {
              [`${u}-normal`]: S,
              [`${u}-rtl`]: r.value === "rtl"
            })
          }, b), [f("div", {
            class: `${u}-image`,
            style: h
          }, [O]), w && f("p", {
            class: `${u}-description`
          }, [w]), n.default && f("div", {
            class: `${u}-footer`
          }, [Lt(n.default())])]);
        }
      }, null));
    };
  }
});
ph.PRESENTED_IMAGE_DEFAULT = () => vr(fh);
ph.PRESENTED_IMAGE_SIMPLE = () => vr(N2);
const cl = kt(ph), vh = (e) => {
  const {
    prefixCls: t
  } = Ie("empty", e);
  return ((o) => {
    switch (o) {
      case "Table":
      case "List":
        return f(cl, {
          image: cl.PRESENTED_IMAGE_SIMPLE
        }, null);
      case "Select":
      case "TreeSelect":
      case "Cascader":
      case "Transfer":
      case "Mentions":
        return f(cl, {
          image: cl.PRESENTED_IMAGE_SIMPLE,
          class: `${t.value}-small`
        }, null);
      default:
        return f(cl, null, null);
    }
  })(e.componentName);
};
function W5(e) {
  return f(vh, {
    componentName: e
  }, null);
}
const R2 = Symbol("SizeContextKey"), k2 = () => tt(R2, Y(void 0)), B2 = (e) => {
  const t = k2();
  return Je(R2, P(() => e.value || t.value)), e;
}, Ie = (e, t) => {
  const n = k2(), o = so(), r = tt(ih, m(m({}, Jx), {
    renderEmpty: (x) => vr(vh, {
      componentName: x
    })
  })), l = P(() => r.getPrefixCls(e, t.prefixCls)), a = P(() => {
    var x, I;
    return (x = t.direction) !== null && x !== void 0 ? x : (I = r.direction) === null || I === void 0 ? void 0 : I.value;
  }), i = P(() => {
    var x;
    return (x = t.iconPrefixCls) !== null && x !== void 0 ? x : r.iconPrefixCls.value;
  }), s = P(() => r.getPrefixCls()), c = P(() => {
    var x;
    return (x = r.autoInsertSpaceInButton) === null || x === void 0 ? void 0 : x.value;
  }), u = r.renderEmpty, d = r.space, p = r.pageHeader, v = r.form, h = P(() => {
    var x, I;
    return (x = t.getTargetContainer) !== null && x !== void 0 ? x : (I = r.getTargetContainer) === null || I === void 0 ? void 0 : I.value;
  }), g = P(() => {
    var x, I, E;
    return (I = (x = t.getContainer) !== null && x !== void 0 ? x : t.getPopupContainer) !== null && I !== void 0 ? I : (E = r.getPopupContainer) === null || E === void 0 ? void 0 : E.value;
  }), b = P(() => {
    var x, I;
    return (x = t.dropdownMatchSelectWidth) !== null && x !== void 0 ? x : (I = r.dropdownMatchSelectWidth) === null || I === void 0 ? void 0 : I.value;
  }), y = P(() => {
    var x;
    return (t.virtual === void 0 ? ((x = r.virtual) === null || x === void 0 ? void 0 : x.value) !== !1 : t.virtual !== !1) && b.value !== !1;
  }), S = P(() => t.size || n.value), C = P(() => {
    var x, I, E;
    return (x = t.autocomplete) !== null && x !== void 0 ? x : (E = (I = r.input) === null || I === void 0 ? void 0 : I.value) === null || E === void 0 ? void 0 : E.autocomplete;
  }), w = P(() => {
    var x;
    return (x = t.disabled) !== null && x !== void 0 ? x : o.value;
  }), $ = P(() => {
    var x;
    return (x = t.csp) !== null && x !== void 0 ? x : r.csp;
  }), O = P(() => {
    var x, I;
    return (x = t.wave) !== null && x !== void 0 ? x : (I = r.wave) === null || I === void 0 ? void 0 : I.value;
  });
  return {
    configProvider: r,
    prefixCls: l,
    direction: a,
    size: S,
    getTargetContainer: h,
    getPopupContainer: g,
    space: d,
    pageHeader: p,
    form: v,
    autoInsertSpaceInButton: c,
    renderEmpty: u,
    virtual: y,
    dropdownMatchSelectWidth: b,
    rootPrefixCls: s,
    getPrefixCls: r.getPrefixCls,
    autocomplete: C,
    csp: $,
    iconPrefixCls: i,
    disabled: w,
    select: r.select,
    wave: O
  };
};
function ot(e, t) {
  const n = m({}, e);
  for (let o = 0; o < t.length; o += 1) {
    const r = t[o];
    delete n[r];
  }
  return n;
}
const K5 = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      position: "fixed",
      zIndex: e.zIndexPopup
    }
  };
}, G5 = Xe("Affix", (e) => {
  const t = He(e, {
    zIndexPopup: e.zIndexBase + 10
  });
  return [K5(t)];
});
function X5() {
  return typeof window < "u" ? window : null;
}
var Ua;
(function(e) {
  e[e.None = 0] = "None", e[e.Prepare = 1] = "Prepare";
})(Ua || (Ua = {}));
const U5 = () => ({
  /**
   * 距离窗口顶部达到指定偏移量后触发
   */
  offsetTop: Number,
  /** 距离窗口底部达到指定偏移量后触发 */
  offsetBottom: Number,
  /** 设置 Affix 需要监听其滚动事件的元素，值为一个返回对应 DOM 元素的函数 */
  target: {
    type: Function,
    default: X5
  },
  prefixCls: String,
  /** 固定状态改变时触发的回调函数 */
  onChange: Function,
  onTestUpdatePosition: Function
}), Y5 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AAffix",
  inheritAttrs: !1,
  props: U5(),
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      expose: r,
      attrs: l
    } = t;
    const a = Q(), i = Q(), s = xt({
      affixStyle: void 0,
      placeholderStyle: void 0,
      status: Ua.None,
      lastAffix: !1,
      prevTarget: null,
      timeout: null
    }), c = Wn(), u = P(() => e.offsetBottom === void 0 && e.offsetTop === void 0 ? 0 : e.offsetTop), d = P(() => e.offsetBottom), p = () => {
      const {
        status: C,
        lastAffix: w
      } = s, {
        target: $
      } = e;
      if (C !== Ua.Prepare || !i.value || !a.value || !$)
        return;
      const O = $();
      if (!O)
        return;
      const x = {
        status: Ua.None
      }, I = Tc(a.value);
      if (I.top === 0 && I.left === 0 && I.width === 0 && I.height === 0)
        return;
      const E = Tc(O), _ = Ly(I, E, u.value), M = zy(I, E, d.value);
      if (!(I.top === 0 && I.left === 0 && I.width === 0 && I.height === 0)) {
        if (_ !== void 0) {
          const R = `${I.width}px`, A = `${I.height}px`;
          x.affixStyle = {
            position: "fixed",
            top: _,
            width: R,
            height: A
          }, x.placeholderStyle = {
            width: R,
            height: A
          };
        } else if (M !== void 0) {
          const R = `${I.width}px`, A = `${I.height}px`;
          x.affixStyle = {
            position: "fixed",
            bottom: M,
            width: R,
            height: A
          }, x.placeholderStyle = {
            width: R,
            height: A
          };
        }
        x.lastAffix = !!x.affixStyle, w !== x.lastAffix && o("change", x.lastAffix), m(s, x);
      }
    }, v = () => {
      m(s, {
        status: Ua.Prepare,
        affixStyle: void 0,
        placeholderStyle: void 0
      }), process.env.NODE_ENV === "test" && o("testUpdatePosition");
    }, h = hg(() => {
      v();
    }), g = hg(() => {
      const {
        target: C
      } = e, {
        affixStyle: w
      } = s;
      if (C && w) {
        const $ = C();
        if ($ && a.value) {
          const O = Tc($), x = Tc(a.value), I = Ly(x, O, u.value), E = zy(x, O, d.value);
          if (I !== void 0 && w.top === I || E !== void 0 && w.bottom === E)
            return;
        }
      }
      v();
    });
    r({
      updatePosition: h,
      lazyUpdatePosition: g
    }), ie(() => e.target, (C) => {
      const w = (C == null ? void 0 : C()) || null;
      s.prevTarget !== w && (jy(c), w && (Hy(w, c), h()), s.prevTarget = w);
    }), ie(() => [e.offsetTop, e.offsetBottom], h), Ke(() => {
      const {
        target: C
      } = e;
      C && (s.timeout = setTimeout(() => {
        Hy(C(), c), h();
      }));
    }), co(() => {
      p();
    }), uo(() => {
      clearTimeout(s.timeout), jy(c), h.cancel(), g.cancel();
    });
    const {
      prefixCls: b
    } = Ie("affix", e), [y, S] = G5(b);
    return () => {
      var C;
      const {
        affixStyle: w,
        placeholderStyle: $,
        status: O
      } = s, x = ee({
        [b.value]: w,
        [S.value]: !0
      }), I = ot(e, ["prefixCls", "offsetTop", "offsetBottom", "target", "onChange", "onTestUpdatePosition"]);
      return y(f(Fo, {
        onResize: h
      }, {
        default: () => [f("div", D(D(D({}, I), l), {}, {
          ref: a,
          "data-measure-status": O
        }), [w && f("div", {
          style: $,
          "aria-hidden": "true"
        }, null), f("div", {
          class: x,
          ref: i,
          style: w
        }, [(C = n.default) === null || C === void 0 ? void 0 : C.call(n)])])]
      }));
    };
  }
}), F2 = kt(Y5);
function a1(e) {
  return typeof e == "object" && e != null && e.nodeType === 1;
}
function i1(e, t) {
  return (!t || e !== "hidden") && e !== "visible" && e !== "clip";
}
function Up(e, t) {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    var n = getComputedStyle(e, null);
    return i1(n.overflowY, t) || i1(n.overflowX, t) || function(o) {
      var r = function(l) {
        if (!l.ownerDocument || !l.ownerDocument.defaultView)
          return null;
        try {
          return l.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      }(o);
      return !!r && (r.clientHeight < o.scrollHeight || r.clientWidth < o.scrollWidth);
    }(e);
  }
  return !1;
}
function kc(e, t, n, o, r, l, a, i) {
  return l < e && a > t || l > e && a < t ? 0 : l <= e && i <= n || a >= t && i >= n ? l - e - o : a > t && i < n || l < e && i > n ? a - t + r : 0;
}
var s1 = function(e, t) {
  var n = window, o = t.scrollMode, r = t.block, l = t.inline, a = t.boundary, i = t.skipOverflowHiddenElements, s = typeof a == "function" ? a : function(me) {
    return me !== a;
  };
  if (!a1(e))
    throw new TypeError("Invalid target");
  for (var c, u, d = document.scrollingElement || document.documentElement, p = [], v = e; a1(v) && s(v); ) {
    if ((v = (u = (c = v).parentElement) == null ? c.getRootNode().host || null : u) === d) {
      p.push(v);
      break;
    }
    v != null && v === document.body && Up(v) && !Up(document.documentElement) || v != null && Up(v, i) && p.push(v);
  }
  for (var h = n.visualViewport ? n.visualViewport.width : innerWidth, g = n.visualViewport ? n.visualViewport.height : innerHeight, b = window.scrollX || pageXOffset, y = window.scrollY || pageYOffset, S = e.getBoundingClientRect(), C = S.height, w = S.width, $ = S.top, O = S.right, x = S.bottom, I = S.left, E = r === "start" || r === "nearest" ? $ : r === "end" ? x : $ + C / 2, _ = l === "center" ? I + w / 2 : l === "end" ? O : I, M = [], R = 0; R < p.length; R++) {
    var A = p[R], z = A.getBoundingClientRect(), T = z.height, N = z.width, k = z.top, B = z.right, F = z.bottom, L = z.left;
    if (o === "if-needed" && $ >= 0 && I >= 0 && x <= g && O <= h && $ >= k && x <= F && I >= L && O <= B)
      return M;
    var j = getComputedStyle(A), H = parseInt(j.borderLeftWidth, 10), K = parseInt(j.borderTopWidth, 10), X = parseInt(j.borderRightWidth, 10), W = parseInt(j.borderBottomWidth, 10), q = 0, J = 0, ne = "offsetWidth" in A ? A.offsetWidth - A.clientWidth - H - X : 0, te = "offsetHeight" in A ? A.offsetHeight - A.clientHeight - K - W : 0, G = "offsetWidth" in A ? A.offsetWidth === 0 ? 0 : N / A.offsetWidth : 0, U = "offsetHeight" in A ? A.offsetHeight === 0 ? 0 : T / A.offsetHeight : 0;
    if (d === A)
      q = r === "start" ? E : r === "end" ? E - g : r === "nearest" ? kc(y, y + g, g, K, W, y + E, y + E + C, C) : E - g / 2, J = l === "start" ? _ : l === "center" ? _ - h / 2 : l === "end" ? _ - h : kc(b, b + h, h, H, X, b + _, b + _ + w, w), q = Math.max(0, q + y), J = Math.max(0, J + b);
    else {
      q = r === "start" ? E - k - K : r === "end" ? E - F + W + te : r === "nearest" ? kc(k, F, T, K, W + te, E, E + C, C) : E - (k + T / 2) + te / 2, J = l === "start" ? _ - L - H : l === "center" ? _ - (L + N / 2) + ne / 2 : l === "end" ? _ - B + X + ne : kc(L, B, N, H, X + ne, _, _ + w, w);
      var re = A.scrollLeft, se = A.scrollTop;
      E += se - (q = Math.max(0, Math.min(se + q / U, A.scrollHeight - T / U + te))), _ += re - (J = Math.max(0, Math.min(re + J / G, A.scrollWidth - N / G + ne)));
    }
    M.push({ el: A, top: q, left: J });
  }
  return M;
};
function L2(e) {
  return e === Object(e) && Object.keys(e).length !== 0;
}
function q5(e, t) {
  t === void 0 && (t = "auto");
  var n = "scrollBehavior" in document.body.style;
  e.forEach(function(o) {
    var r = o.el, l = o.top, a = o.left;
    r.scroll && n ? r.scroll({
      top: l,
      left: a,
      behavior: t
    }) : (r.scrollTop = l, r.scrollLeft = a);
  });
}
function Z5(e) {
  return e === !1 ? {
    block: "end",
    inline: "nearest"
  } : L2(e) ? e : {
    block: "start",
    inline: "nearest"
  };
}
function z2(e, t) {
  var n = e.isConnected || e.ownerDocument.documentElement.contains(e);
  if (L2(t) && typeof t.behavior == "function")
    return t.behavior(n ? s1(e, t) : []);
  if (n) {
    var o = Z5(t);
    return q5(s1(e, o), o.behavior);
  }
}
function Q5(e, t, n, o) {
  const r = n - t;
  return e /= o / 2, e < 1 ? r / 2 * e * e * e + t : r / 2 * ((e -= 2) * e * e + 2) + t;
}
function Dg(e) {
  return e != null && e === e.window;
}
function gh(e, t) {
  var n, o;
  if (typeof window > "u")
    return 0;
  const r = "scrollTop";
  let l = 0;
  return Dg(e) ? l = e.scrollY : e instanceof Document ? l = e.documentElement[r] : (e instanceof HTMLElement || e) && (l = e[r]), e && !Dg(e) && typeof l != "number" && (l = (o = ((n = e.ownerDocument) !== null && n !== void 0 ? n : e).documentElement) === null || o === void 0 ? void 0 : o[r]), l;
}
function mh(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    getContainer: n = () => window,
    callback: o,
    duration: r = 450
  } = t, l = n(), a = gh(l), i = Date.now(), s = () => {
    const u = Date.now() - i, d = Q5(u > r ? r : u, a, e, r);
    Dg(l) ? l.scrollTo(window.scrollX, d) : l instanceof Document ? l.documentElement.scrollTop = d : l.scrollTop = d, u < r ? Ze(s) : typeof o == "function" && o();
  };
  Ze(s);
}
function Bc() {
}
const H2 = Symbol("anchorContextKey"), J5 = (e) => {
  Je(H2, e);
}, eM = () => tt(H2, {
  registerLink: Bc,
  unregisterLink: Bc,
  scrollTo: Bc,
  activeLink: P(() => ""),
  handleClick: Bc,
  direction: P(() => "vertical")
}), tM = (e) => {
  const {
    componentCls: t,
    holderOffsetBlock: n,
    motionDurationSlow: o,
    lineWidthBold: r,
    colorPrimary: l,
    lineType: a,
    colorSplit: i
  } = e;
  return {
    [`${t}-wrapper`]: {
      marginBlockStart: -n,
      paddingBlockStart: n,
      // delete overflow: auto
      // overflow: 'auto',
      backgroundColor: "transparent",
      [t]: m(m({}, qe(e)), {
        position: "relative",
        paddingInlineStart: r,
        [`${t}-link`]: {
          paddingBlock: e.anchorPaddingBlock,
          paddingInline: `${e.anchorPaddingInline}px 0`,
          "&-title": m(m({}, tn), {
            position: "relative",
            display: "block",
            marginBlockEnd: e.anchorTitleBlock,
            color: e.colorText,
            transition: `all ${e.motionDurationSlow}`,
            "&:only-child": {
              marginBlockEnd: 0
            }
          }),
          [`&-active > ${t}-link-title`]: {
            color: e.colorPrimary
          },
          // link link
          [`${t}-link`]: {
            paddingBlock: e.anchorPaddingBlockSecondary
          }
        }
      }),
      [`&:not(${t}-wrapper-horizontal)`]: {
        [t]: {
          "&::before": {
            position: "absolute",
            left: {
              _skip_check_: !0,
              value: 0
            },
            top: 0,
            height: "100%",
            borderInlineStart: `${r}px ${a} ${i}`,
            content: '" "'
          },
          [`${t}-ink`]: {
            position: "absolute",
            left: {
              _skip_check_: !0,
              value: 0
            },
            display: "none",
            transform: "translateY(-50%)",
            transition: `top ${o} ease-in-out`,
            width: r,
            backgroundColor: l,
            [`&${t}-ink-visible`]: {
              display: "inline-block"
            }
          }
        }
      },
      [`${t}-fixed ${t}-ink ${t}-ink`]: {
        display: "none"
      }
    }
  };
}, nM = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    lineWidthBold: o,
    colorPrimary: r
  } = e;
  return {
    [`${t}-wrapper-horizontal`]: {
      position: "relative",
      "&::before": {
        position: "absolute",
        left: {
          _skip_check_: !0,
          value: 0
        },
        right: {
          _skip_check_: !0,
          value: 0
        },
        bottom: 0,
        borderBottom: `1px ${e.lineType} ${e.colorSplit}`,
        content: '" "'
      },
      [t]: {
        overflowX: "scroll",
        position: "relative",
        display: "flex",
        scrollbarWidth: "none",
        "&::-webkit-scrollbar": {
          display: "none"
          /* Safari and Chrome */
        },
        [`${t}-link:first-of-type`]: {
          paddingInline: 0
        },
        [`${t}-ink`]: {
          position: "absolute",
          bottom: 0,
          transition: `left ${n} ease-in-out, width ${n} ease-in-out`,
          height: o,
          backgroundColor: r
        }
      }
    }
  };
}, oM = Xe("Anchor", (e) => {
  const {
    fontSize: t,
    fontSizeLG: n,
    padding: o,
    paddingXXS: r
  } = e, l = He(e, {
    holderOffsetBlock: r,
    anchorPaddingBlock: r,
    anchorPaddingBlockSecondary: r / 2,
    anchorPaddingInline: o,
    anchorTitleBlock: t / 14 * 3,
    anchorBallSize: n / 2
  });
  return [tM(l), nM(l)];
}), rM = () => ({
  prefixCls: String,
  href: String,
  title: _t(),
  target: String,
  /* private use  */
  customTitleProps: Re()
}), hh = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AAnchorLink",
  inheritAttrs: !1,
  props: Qe(rM(), {
    href: "#"
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t, r = null;
    const {
      handleClick: l,
      scrollTo: a,
      unregisterLink: i,
      registerLink: s,
      activeLink: c
    } = eM(), {
      prefixCls: u
    } = Ie("anchor", e), d = (p) => {
      const {
        href: v
      } = e;
      l(p, {
        title: r,
        href: v
      }), a(v);
    };
    return ie(() => e.href, (p, v) => {
      rt(() => {
        i(v), s(p);
      });
    }), Ke(() => {
      s(e.href);
    }), et(() => {
      i(e.href);
    }), () => {
      var p;
      const {
        href: v,
        target: h,
        title: g = n.title,
        customTitleProps: b = {}
      } = e, y = u.value;
      r = typeof g == "function" ? g(b) : g;
      const S = c.value === v, C = ee(`${y}-link`, {
        [`${y}-link-active`]: S
      }, o.class), w = ee(`${y}-link-title`, {
        [`${y}-link-title-active`]: S
      });
      return f("div", D(D({}, o), {}, {
        class: C
      }), [f("a", {
        class: w,
        href: v,
        title: typeof r == "string" ? r : "",
        target: h,
        onClick: d
      }, [n.customTitle ? n.customTitle(b) : r]), (p = n.default) === null || p === void 0 ? void 0 : p.call(n)]);
    };
  }
});
function lM(e, t) {
  for (var n = 0; n < t.length; n++) {
    var o = t[n];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
  }
}
function j2(e, t, n) {
  return n && lM(e, n), e;
}
function mu() {
  return (mu = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }).apply(this, arguments);
}
function V2(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
function W2(e, t) {
  if (e == null)
    return {};
  var n, o, r = {}, l = Object.keys(e);
  for (o = 0; o < l.length; o++)
    t.indexOf(n = l[o]) >= 0 || (r[n] = e[n]);
  return r;
}
function c1(e) {
  return ((t = e) != null && typeof t == "object" && Array.isArray(t) === !1) == 1 && Object.prototype.toString.call(e) === "[object Object]";
  var t;
}
var K2 = Object.prototype, G2 = K2.toString, aM = K2.hasOwnProperty, X2 = /^\s*function (\w+)/;
function u1(e) {
  var t, n = (t = e == null ? void 0 : e.type) !== null && t !== void 0 ? t : e;
  if (n) {
    var o = n.toString().match(X2);
    return o ? o[1] : "";
  }
  return "";
}
var ca = function(e) {
  var t, n;
  return c1(e) !== !1 && typeof (t = e.constructor) == "function" && c1(n = t.prototype) !== !1 && n.hasOwnProperty("isPrototypeOf") !== !1;
}, U2 = function(e) {
  return e;
}, kn = U2;
if (process.env.NODE_ENV !== "production") {
  var iM = typeof console < "u";
  kn = iM ? function(e) {
    console.warn("[VueTypes warn]: " + e);
  } : U2;
}
var Ls = function(e, t) {
  return aM.call(e, t);
}, sM = Number.isInteger || function(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}, mi = Array.isArray || function(e) {
  return G2.call(e) === "[object Array]";
}, hi = function(e) {
  return G2.call(e) === "[object Function]";
}, fd = function(e) {
  return ca(e) && Ls(e, "_vueTypes_name");
}, Y2 = function(e) {
  return ca(e) && (Ls(e, "type") || ["_vueTypes_name", "validator", "default", "required"].some(function(t) {
    return Ls(e, t);
  }));
};
function bh(e, t) {
  return Object.defineProperty(e.bind(t), "__original", { value: e });
}
function ba(e, t, n) {
  var o;
  n === void 0 && (n = !1);
  var r = !0, l = "";
  o = ca(e) ? e : { type: e };
  var a = fd(o) ? o._vueTypes_name + " - " : "";
  if (Y2(o) && o.type !== null) {
    if (o.type === void 0 || o.type === !0 || !o.required && t === void 0)
      return r;
    mi(o.type) ? (r = o.type.some(function(d) {
      return ba(d, t, !0) === !0;
    }), l = o.type.map(function(d) {
      return u1(d);
    }).join(" or ")) : r = (l = u1(o)) === "Array" ? mi(t) : l === "Object" ? ca(t) : l === "String" || l === "Number" || l === "Boolean" || l === "Function" ? function(d) {
      if (d == null)
        return "";
      var p = d.constructor.toString().match(X2);
      return p ? p[1] : "";
    }(t) === l : t instanceof o.type;
  }
  if (!r) {
    var i = a + 'value "' + t + '" should be of type "' + l + '"';
    return n === !1 ? (kn(i), !1) : i;
  }
  if (Ls(o, "validator") && hi(o.validator)) {
    var s = kn, c = [];
    if (kn = function(d) {
      c.push(d);
    }, r = o.validator(t), kn = s, !r) {
      var u = (c.length > 1 ? "* " : "") + c.join(`
* `);
      return c.length = 0, n === !1 ? (kn(u), r) : u;
    }
  }
  return r;
}
function xo(e, t) {
  var n = Object.defineProperties(t, { _vueTypes_name: { value: e, writable: !0 }, isRequired: { get: function() {
    return this.required = !0, this;
  } }, def: { value: function(r) {
    return r !== void 0 || this.default ? hi(r) || ba(this, r, !0) === !0 ? (this.default = mi(r) ? function() {
      return [].concat(r);
    } : ca(r) ? function() {
      return Object.assign({}, r);
    } : r, this) : (kn(this._vueTypes_name + ' - invalid default value: "' + r + '"'), this) : this;
  } } }), o = n.validator;
  return hi(o) && (n.validator = bh(o, n)), n;
}
function Cr(e, t) {
  var n = xo(e, t);
  return Object.defineProperty(n, "validate", { value: function(o) {
    return hi(this.validator) && kn(this._vueTypes_name + ` - calling .validate() will overwrite the current custom validator function. Validator info:
` + JSON.stringify(this)), this.validator = bh(o, this), this;
  } });
}
function d1(e, t, n) {
  var o, r, l = (o = t, r = {}, Object.getOwnPropertyNames(o).forEach(function(d) {
    r[d] = Object.getOwnPropertyDescriptor(o, d);
  }), Object.defineProperties({}, r));
  if (l._vueTypes_name = e, !ca(n))
    return l;
  var a, i, s = n.validator, c = W2(n, ["validator"]);
  if (hi(s)) {
    var u = l.validator;
    u && (u = (i = (a = u).__original) !== null && i !== void 0 ? i : a), l.validator = bh(u ? function(d) {
      return u.call(this, d) && s.call(this, d);
    } : s, l);
  }
  return Object.assign(l, c);
}
function xf(e) {
  return e.replace(/^(?!\s*$)/gm, "  ");
}
var cM = function() {
  return Cr("any", {});
}, uM = function() {
  return Cr("function", { type: Function });
}, dM = function() {
  return Cr("boolean", { type: Boolean });
}, fM = function() {
  return Cr("string", { type: String });
}, pM = function() {
  return Cr("number", { type: Number });
}, vM = function() {
  return Cr("array", { type: Array });
}, gM = function() {
  return Cr("object", { type: Object });
}, mM = function() {
  return xo("integer", { type: Number, validator: function(e) {
    return sM(e);
  } });
}, hM = function() {
  return xo("symbol", { validator: function(e) {
    return typeof e == "symbol";
  } });
};
function bM(e, t) {
  if (t === void 0 && (t = "custom validation failed"), typeof e != "function")
    throw new TypeError("[VueTypes error]: You must provide a function as argument");
  return xo(e.name || "<<anonymous function>>", { validator: function(n) {
    var o = e(n);
    return o || kn(this._vueTypes_name + " - " + t), o;
  } });
}
function yM(e) {
  if (!mi(e))
    throw new TypeError("[VueTypes error]: You must provide an array as argument.");
  var t = 'oneOf - value should be one of "' + e.join('", "') + '".', n = e.reduce(function(o, r) {
    if (r != null) {
      var l = r.constructor;
      o.indexOf(l) === -1 && o.push(l);
    }
    return o;
  }, []);
  return xo("oneOf", { type: n.length > 0 ? n : void 0, validator: function(o) {
    var r = e.indexOf(o) !== -1;
    return r || kn(t), r;
  } });
}
function SM(e) {
  if (!mi(e))
    throw new TypeError("[VueTypes error]: You must provide an array as argument");
  for (var t = !1, n = [], o = 0; o < e.length; o += 1) {
    var r = e[o];
    if (Y2(r)) {
      if (fd(r) && r._vueTypes_name === "oneOf") {
        n = n.concat(r.type);
        continue;
      }
      if (hi(r.validator) && (t = !0), r.type !== !0 && r.type) {
        n = n.concat(r.type);
        continue;
      }
    }
    n.push(r);
  }
  return n = n.filter(function(l, a) {
    return n.indexOf(l) === a;
  }), xo("oneOfType", t ? { type: n, validator: function(l) {
    var a = [], i = e.some(function(s) {
      var c = ba(fd(s) && s._vueTypes_name === "oneOf" ? s.type || null : s, l, !0);
      return typeof c == "string" && a.push(c), c === !0;
    });
    return i || kn("oneOfType - provided value does not match any of the " + a.length + ` passed-in validators:
` + xf(a.join(`
`))), i;
  } } : { type: n });
}
function CM(e) {
  return xo("arrayOf", { type: Array, validator: function(t) {
    var n, o = t.every(function(r) {
      return (n = ba(e, r, !0)) === !0;
    });
    return o || kn(`arrayOf - value validation error:
` + xf(n)), o;
  } });
}
function $M(e) {
  return xo("instanceOf", { type: e });
}
function wM(e) {
  return xo("objectOf", { type: Object, validator: function(t) {
    var n, o = Object.keys(t).every(function(r) {
      return (n = ba(e, t[r], !0)) === !0;
    });
    return o || kn(`objectOf - value validation error:
` + xf(n)), o;
  } });
}
function xM(e) {
  var t = Object.keys(e), n = t.filter(function(r) {
    var l;
    return !!(!((l = e[r]) === null || l === void 0) && l.required);
  }), o = xo("shape", { type: Object, validator: function(r) {
    var l = this;
    if (!ca(r))
      return !1;
    var a = Object.keys(r);
    if (n.length > 0 && n.some(function(s) {
      return a.indexOf(s) === -1;
    })) {
      var i = n.filter(function(s) {
        return a.indexOf(s) === -1;
      });
      return kn(i.length === 1 ? 'shape - required property "' + i[0] + '" is not defined.' : 'shape - required properties "' + i.join('", "') + '" are not defined.'), !1;
    }
    return a.every(function(s) {
      if (t.indexOf(s) === -1)
        return l._vueTypes_isLoose === !0 || (kn('shape - shape definition does not include a "' + s + '" property. Allowed keys: "' + t.join('", "') + '".'), !1);
      var c = ba(e[s], r[s], !0);
      return typeof c == "string" && kn('shape - "' + s + `" property validation error:
 ` + xf(c)), c === !0;
    });
  } });
  return Object.defineProperty(o, "_vueTypes_isLoose", { writable: !0, value: !1 }), Object.defineProperty(o, "loose", { get: function() {
    return this._vueTypes_isLoose = !0, this;
  } }), o;
}
var ur = function() {
  function e() {
  }
  return e.extend = function(t) {
    var n = this;
    if (mi(t))
      return t.forEach(function(d) {
        return n.extend(d);
      }), this;
    var o = t.name, r = t.validate, l = r !== void 0 && r, a = t.getter, i = a !== void 0 && a, s = W2(t, ["name", "validate", "getter"]);
    if (Ls(this, o))
      throw new TypeError('[VueTypes error]: Type "' + o + '" already defined');
    var c, u = s.type;
    return fd(u) ? (delete s.type, Object.defineProperty(this, o, i ? { get: function() {
      return d1(o, u, s);
    } } : { value: function() {
      var d, p = d1(o, u, s);
      return p.validator && (p.validator = (d = p.validator).bind.apply(d, [p].concat([].slice.call(arguments)))), p;
    } })) : (c = i ? { get: function() {
      var d = Object.assign({}, s);
      return l ? Cr(o, d) : xo(o, d);
    }, enumerable: !0 } : { value: function() {
      var d, p, v = Object.assign({}, s);
      return d = l ? Cr(o, v) : xo(o, v), v.validator && (d.validator = (p = v.validator).bind.apply(p, [d].concat([].slice.call(arguments)))), d;
    }, enumerable: !0 }, Object.defineProperty(this, o, c));
  }, j2(e, null, [{ key: "any", get: function() {
    return cM();
  } }, { key: "func", get: function() {
    return uM().def(this.defaults.func);
  } }, { key: "bool", get: function() {
    return dM().def(this.defaults.bool);
  } }, { key: "string", get: function() {
    return fM().def(this.defaults.string);
  } }, { key: "number", get: function() {
    return pM().def(this.defaults.number);
  } }, { key: "array", get: function() {
    return vM().def(this.defaults.array);
  } }, { key: "object", get: function() {
    return gM().def(this.defaults.object);
  } }, { key: "integer", get: function() {
    return mM().def(this.defaults.integer);
  } }, { key: "symbol", get: function() {
    return hM();
  } }]), e;
}();
function q2(e) {
  var t;
  return e === void 0 && (e = { func: function() {
  }, bool: !0, string: "", number: 0, array: function() {
    return [];
  }, object: function() {
    return {};
  }, integer: 0 }), (t = function(n) {
    function o() {
      return n.apply(this, arguments) || this;
    }
    return V2(o, n), j2(o, null, [{ key: "sensibleDefaults", get: function() {
      return mu({}, this.defaults);
    }, set: function(r) {
      this.defaults = r !== !1 ? mu({}, r !== !0 ? r : e) : {};
    } }]), o;
  }(ur)).defaults = mu({}, e), t;
}
ur.defaults = {}, ur.custom = bM, ur.oneOf = yM, ur.instanceOf = $M, ur.oneOfType = SM, ur.arrayOf = CM, ur.objectOf = wM, ur.shape = xM, ur.utils = { validate: function(e, t) {
  return ba(t, e, !0) === !0;
}, toType: function(e, t, n) {
  return n === void 0 && (n = !1), n ? Cr(e, t) : xo(e, t);
} };
(function(e) {
  function t() {
    return e.apply(this, arguments) || this;
  }
  return V2(t, e), t;
})(q2());
const V = q2({
  func: void 0,
  bool: void 0,
  string: void 0,
  number: void 0,
  array: void 0,
  object: void 0,
  integer: void 0
});
V.extend([{
  name: "looseBool",
  getter: !0,
  type: Boolean,
  default: void 0
}, {
  name: "style",
  getter: !0,
  type: [String, Object],
  default: void 0
}, {
  name: "VueNode",
  getter: !0,
  type: null
}]);
function Z2(e) {
  return e.default = void 0, e;
}
const nt = (e, t, n) => {
  lo(e, `[ant-design-vue: ${t}] ${n}`);
};
function OM() {
  return window;
}
function f1(e, t) {
  if (!e.getClientRects().length)
    return 0;
  const n = e.getBoundingClientRect();
  return n.width || n.height ? t === window ? (t = e.ownerDocument.documentElement, n.top - t.clientTop) : n.top - t.getBoundingClientRect().top : n.top;
}
const p1 = /#([\S ]+)$/, PM = () => ({
  prefixCls: String,
  offsetTop: Number,
  bounds: Number,
  affix: {
    type: Boolean,
    default: !0
  },
  showInkInFixed: {
    type: Boolean,
    default: !1
  },
  getContainer: Function,
  wrapperClass: String,
  wrapperStyle: {
    type: Object,
    default: void 0
  },
  getCurrentAnchor: Function,
  targetOffset: Number,
  items: vt(),
  direction: V.oneOf(["vertical", "horizontal"]).def("vertical"),
  onChange: Function,
  onClick: Function
}), Wl = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AAnchor",
  inheritAttrs: !1,
  props: PM(),
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      slots: r,
      expose: l
    } = t;
    var a;
    const {
      prefixCls: i,
      getTargetContainer: s,
      direction: c
    } = Ie("anchor", e), u = P(() => {
      var I;
      return (I = e.direction) !== null && I !== void 0 ? I : "vertical";
    });
    process.env.NODE_ENV !== "production" && nt(e.items && typeof r.default != "function", "Anchor", "`Anchor children` is deprecated. Please use `items` instead."), process.env.NODE_ENV !== "production" && nt(!(u.value === "horizontal" && (!((a = e.items) === null || a === void 0) && a.some((I) => "children" in I))), "Anchor", "`Anchor items#children` is not supported when `Anchor` direction is horizontal.");
    const d = Y(null), p = Y(), v = xt({
      links: [],
      scrollContainer: null,
      scrollEvent: null,
      animating: !1
    }), h = Y(null), g = P(() => {
      const {
        getContainer: I
      } = e;
      return I || (s == null ? void 0 : s.value) || OM;
    }), b = function() {
      let I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0, E = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
      const _ = [], M = g.value();
      return v.links.forEach((R) => {
        const A = p1.exec(R.toString());
        if (!A)
          return;
        const z = document.getElementById(A[1]);
        if (z) {
          const T = f1(z, M);
          T < I + E && _.push({
            link: R,
            top: T
          });
        }
      }), _.length ? _.reduce((A, z) => z.top > A.top ? z : A).link : "";
    }, y = (I) => {
      const {
        getCurrentAnchor: E
      } = e;
      h.value !== I && (h.value = typeof E == "function" ? E(I) : I, n("change", I));
    }, S = (I) => {
      const {
        offsetTop: E,
        targetOffset: _
      } = e;
      y(I);
      const M = p1.exec(I);
      if (!M)
        return;
      const R = document.getElementById(M[1]);
      if (!R)
        return;
      const A = g.value(), z = gh(A), T = f1(R, A);
      let N = z + T;
      N -= _ !== void 0 ? _ : E || 0, v.animating = !0, mh(N, {
        callback: () => {
          v.animating = !1;
        },
        getContainer: g.value
      });
    };
    l({
      scrollTo: S
    });
    const C = () => {
      if (v.animating)
        return;
      const {
        offsetTop: I,
        bounds: E,
        targetOffset: _
      } = e, M = b(_ !== void 0 ? _ : I || 0, E);
      y(M);
    }, w = () => {
      const I = p.value.querySelector(`.${i.value}-link-title-active`);
      if (I && d.value) {
        const E = u.value === "horizontal";
        d.value.style.top = E ? "" : `${I.offsetTop + I.clientHeight / 2}px`, d.value.style.height = E ? "" : `${I.clientHeight}px`, d.value.style.left = E ? `${I.offsetLeft}px` : "", d.value.style.width = E ? `${I.clientWidth}px` : "", E && z2(I, {
          scrollMode: "if-needed",
          block: "nearest"
        });
      }
    };
    J5({
      registerLink: (I) => {
        v.links.includes(I) || v.links.push(I);
      },
      unregisterLink: (I) => {
        const E = v.links.indexOf(I);
        E !== -1 && v.links.splice(E, 1);
      },
      activeLink: h,
      scrollTo: S,
      handleClick: (I, E) => {
        n("click", I, E);
      },
      direction: u
    }), Ke(() => {
      rt(() => {
        const I = g.value();
        v.scrollContainer = I, v.scrollEvent = Bt(v.scrollContainer, "scroll", C), C();
      });
    }), et(() => {
      v.scrollEvent && v.scrollEvent.remove();
    }), co(() => {
      if (v.scrollEvent) {
        const I = g.value();
        v.scrollContainer !== I && (v.scrollContainer = I, v.scrollEvent.remove(), v.scrollEvent = Bt(v.scrollContainer, "scroll", C), C());
      }
      w();
    });
    const $ = (I) => Array.isArray(I) ? I.map((E) => {
      const {
        children: _,
        key: M,
        href: R,
        target: A,
        class: z,
        style: T,
        title: N
      } = E;
      return f(hh, {
        key: M,
        href: R,
        target: A,
        class: z,
        style: T,
        title: N,
        customTitleProps: E
      }, {
        default: () => [u.value === "vertical" ? $(_) : null],
        customTitle: r.customTitle
      });
    }) : null, [O, x] = oM(i);
    return () => {
      var I;
      const {
        offsetTop: E,
        affix: _,
        showInkInFixed: M
      } = e, R = i.value, A = ee(`${R}-ink`, {
        [`${R}-ink-visible`]: h.value
      }), z = ee(x.value, e.wrapperClass, `${R}-wrapper`, {
        [`${R}-wrapper-horizontal`]: u.value === "horizontal",
        [`${R}-rtl`]: c.value === "rtl"
      }), T = ee(R, {
        [`${R}-fixed`]: !_ && !M
      }), N = m({
        maxHeight: E ? `calc(100vh - ${E}px)` : "100vh"
      }, e.wrapperStyle), k = f("div", {
        class: z,
        style: N,
        ref: p
      }, [f("div", {
        class: T
      }, [f("span", {
        class: A,
        ref: d
      }, null), Array.isArray(e.items) ? $(e.items) : (I = r.default) === null || I === void 0 ? void 0 : I.call(r)])]);
      return O(_ ? f(F2, D(D({}, o), {}, {
        offsetTop: E,
        target: g.value
      }), {
        default: () => [k]
      }) : k);
    };
  }
});
Wl.Link = hh;
Wl.install = function(e) {
  return e.component(Wl.name, Wl), e.component(Wl.Link.name, Wl.Link), e;
};
function v1(e, t) {
  const {
    key: n
  } = e;
  let o;
  return "value" in e && ({
    value: o
  } = e), n ?? (o !== void 0 ? o : `rc-index-key-${t}`);
}
function Q2(e, t) {
  const {
    label: n,
    value: o,
    options: r
  } = e || {};
  return {
    label: n || (t ? "children" : "label"),
    value: o || "value",
    options: r || "options"
  };
}
function IM(e) {
  let {
    fieldNames: t,
    childrenAsData: n
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const o = [], {
    label: r,
    value: l,
    options: a
  } = Q2(t, !1);
  function i(s, c) {
    s.forEach((u) => {
      const d = u[r];
      if (c || !(a in u)) {
        const p = u[l];
        o.push({
          key: v1(u, o.length),
          groupOption: c,
          data: u,
          label: d,
          value: p
        });
      } else {
        let p = d;
        p === void 0 && n && (p = u.label), o.push({
          key: v1(u, o.length),
          group: !0,
          data: u,
          label: p
        }), i(u[a], !0);
      }
    });
  }
  return i(e, !1), o;
}
function Ng(e) {
  const t = m({}, e);
  return "props" in t || Object.defineProperty(t, "props", {
    get() {
      return ct(!1, "Return type is option instead of Option instance. Please read value directly instead of reading from `props`."), t;
    }
  }), t;
}
function EM(e, t) {
  if (!t || !t.length)
    return null;
  let n = !1;
  function o(l, a) {
    let [i, ...s] = a;
    if (!i)
      return [l];
    const c = l.split(i);
    return n = n || c.length > 1, c.reduce((u, d) => [...u, ...o(d, s)], []).filter((u) => u);
  }
  const r = o(e, t);
  return n ? r : null;
}
function TM() {
  return "";
}
function MM(e) {
  return e ? e.ownerDocument : window.document;
}
function J2() {
}
const e4 = () => ({
  action: V.oneOfType([V.string, V.arrayOf(V.string)]).def([]),
  showAction: V.any.def([]),
  hideAction: V.any.def([]),
  getPopupClassNameFromAlign: V.any.def(TM),
  onPopupVisibleChange: Function,
  afterPopupVisibleChange: V.func.def(J2),
  popup: V.any,
  arrow: V.bool.def(!0),
  popupStyle: {
    type: Object,
    default: void 0
  },
  prefixCls: V.string.def("rc-trigger-popup"),
  popupClassName: V.string.def(""),
  popupPlacement: String,
  builtinPlacements: V.object,
  popupTransitionName: String,
  popupAnimation: V.any,
  mouseEnterDelay: V.number.def(0),
  mouseLeaveDelay: V.number.def(0.1),
  zIndex: Number,
  focusDelay: V.number.def(0),
  blurDelay: V.number.def(0.15),
  getPopupContainer: Function,
  getDocument: V.func.def(MM),
  forceRender: {
    type: Boolean,
    default: void 0
  },
  destroyPopupOnHide: {
    type: Boolean,
    default: !1
  },
  mask: {
    type: Boolean,
    default: !1
  },
  maskClosable: {
    type: Boolean,
    default: !0
  },
  // onPopupAlign: PropTypes.func.def(noop),
  popupAlign: V.object.def(() => ({})),
  popupVisible: {
    type: Boolean,
    default: void 0
  },
  defaultPopupVisible: {
    type: Boolean,
    default: !1
  },
  maskTransitionName: String,
  maskAnimation: String,
  stretch: String,
  alignPoint: {
    type: Boolean,
    default: void 0
  },
  autoDestroy: {
    type: Boolean,
    default: !1
  },
  mobile: Object,
  getTriggerDOMNode: Function
}), yh = {
  visible: Boolean,
  prefixCls: String,
  zIndex: Number,
  destroyPopupOnHide: Boolean,
  forceRender: Boolean,
  arrow: {
    type: Boolean,
    default: !0
  },
  // Legacy Motion
  animation: [String, Object],
  transitionName: String,
  // Measure
  stretch: {
    type: String
  },
  // Align
  align: {
    type: Object
  },
  point: {
    type: Object
  },
  getRootDomNode: {
    type: Function
  },
  getClassNameFromAlign: {
    type: Function
  },
  onAlign: {
    type: Function
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onTouchstart: {
    type: Function
  }
}, _M = m(m({}, yh), {
  mobile: {
    type: Object
  }
}), AM = m(m({}, yh), {
  mask: Boolean,
  mobile: {
    type: Object
  },
  maskAnimation: String,
  maskTransitionName: String
});
function Sh(e) {
  let {
    prefixCls: t,
    animation: n,
    transitionName: o
  } = e;
  return n ? {
    name: `${t}-${n}`
  } : o ? {
    name: o
  } : {};
}
function t4(e) {
  const {
    prefixCls: t,
    visible: n,
    zIndex: o,
    mask: r,
    maskAnimation: l,
    maskTransitionName: a
  } = e;
  if (!r)
    return null;
  let i = {};
  return (a || l) && (i = Sh({
    prefixCls: t,
    transitionName: a,
    animation: l
  })), f(yn, D({
    appear: !0
  }, i), {
    default: () => [Tn(f("div", {
      style: {
        zIndex: o
      },
      class: `${t}-mask`
    }, null), [[oT("if"), n]])]
  });
}
t4.displayName = "Mask";
const DM = Z({
  compatConfig: {
    MODE: 3
  },
  name: "MobilePopupInner",
  inheritAttrs: !1,
  props: _M,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(e, t) {
    let {
      expose: n,
      slots: o
    } = t;
    const r = Y();
    return n({
      forceAlign: () => {
      },
      getElement: () => r.value
    }), () => {
      var l;
      const {
        zIndex: a,
        visible: i,
        prefixCls: s,
        mobile: {
          popupClassName: c,
          popupStyle: u,
          popupMotion: d = {},
          popupRender: p
        } = {}
      } = e, v = m({
        zIndex: a
      }, u);
      let h = It((l = o.default) === null || l === void 0 ? void 0 : l.call(o));
      h.length > 1 && (h = f("div", {
        class: `${s}-content`
      }, [h])), p && (h = p(h));
      const g = ee(s, c);
      return f(yn, D({
        ref: r
      }, d), {
        default: () => [i ? f("div", {
          class: g,
          style: v
        }, [h]) : null]
      });
    };
  }
});
var NM = function(e, t, n, o) {
  function r(l) {
    return l instanceof n ? l : new n(function(a) {
      a(l);
    });
  }
  return new (n || (n = Promise))(function(l, a) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (d) {
        a(d);
      }
    }
    function s(u) {
      try {
        c(o.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? l(u.value) : r(u.value).then(i, s);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
const g1 = ["measure", "align", null, "motion"], RM = (e, t) => {
  const n = Q(null), o = Q(), r = Q(!1);
  function l(s) {
    r.value || (n.value = s);
  }
  function a() {
    Ze.cancel(o.value);
  }
  function i(s) {
    a(), o.value = Ze(() => {
      let c = n.value;
      switch (n.value) {
        case "align":
          c = "motion";
          break;
        case "motion":
          c = "stable";
          break;
      }
      l(c), s == null || s();
    });
  }
  return ie(e, () => {
    l("measure");
  }, {
    immediate: !0,
    flush: "post"
  }), Ke(() => {
    ie(n, () => {
      switch (n.value) {
        case "measure":
          t();
          break;
      }
      n.value && (o.value = Ze(() => NM(void 0, void 0, void 0, function* () {
        const s = g1.indexOf(n.value), c = g1[s + 1];
        c && s !== -1 && l(c);
      })));
    }, {
      immediate: !0,
      flush: "post"
    });
  }), et(() => {
    r.value = !0, a();
  }), [n, i];
}, kM = (e) => {
  const t = Q({
    width: 0,
    height: 0
  });
  function n(r) {
    t.value = {
      width: r.offsetWidth,
      height: r.offsetHeight
    };
  }
  return [P(() => {
    const r = {};
    if (e.value) {
      const {
        width: l,
        height: a
      } = t.value;
      e.value.indexOf("height") !== -1 && a ? r.height = `${a}px` : e.value.indexOf("minHeight") !== -1 && a && (r.minHeight = `${a}px`), e.value.indexOf("width") !== -1 && l ? r.width = `${l}px` : e.value.indexOf("minWidth") !== -1 && l && (r.minWidth = `${l}px`);
    }
    return r;
  }), n];
};
function m1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function h1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? m1(Object(n), !0).forEach(function(o) {
      BM(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : m1(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function Rg(e) {
  "@babel/helpers - typeof";
  return Rg = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Rg(e);
}
function BM(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var Xi, FM = {
  Webkit: "-webkit-",
  Moz: "-moz-",
  // IE did it wrong again ...
  ms: "-ms-",
  O: "-o-"
};
function pd() {
  if (Xi !== void 0)
    return Xi;
  Xi = "";
  var e = document.createElement("p").style, t = "Transform";
  for (var n in FM)
    n + t in e && (Xi = n);
  return Xi;
}
function n4() {
  return pd() ? "".concat(pd(), "TransitionProperty") : "transitionProperty";
}
function Of() {
  return pd() ? "".concat(pd(), "Transform") : "transform";
}
function b1(e, t) {
  var n = n4();
  n && (e.style[n] = t, n !== "transitionProperty" && (e.style.transitionProperty = t));
}
function Yp(e, t) {
  var n = Of();
  n && (e.style[n] = t, n !== "transform" && (e.style.transform = t));
}
function LM(e) {
  return e.style.transitionProperty || e.style[n4()];
}
function zM(e) {
  var t = window.getComputedStyle(e, null), n = t.getPropertyValue("transform") || t.getPropertyValue(Of());
  if (n && n !== "none") {
    var o = n.replace(/[^0-9\-.,]/g, "").split(",");
    return {
      x: parseFloat(o[12] || o[4], 0),
      y: parseFloat(o[13] || o[5], 0)
    };
  }
  return {
    x: 0,
    y: 0
  };
}
var HM = /matrix\((.*)\)/, jM = /matrix3d\((.*)\)/;
function VM(e, t) {
  var n = window.getComputedStyle(e, null), o = n.getPropertyValue("transform") || n.getPropertyValue(Of());
  if (o && o !== "none") {
    var r, l = o.match(HM);
    if (l)
      l = l[1], r = l.split(",").map(function(i) {
        return parseFloat(i, 10);
      }), r[4] = t.x, r[5] = t.y, Yp(e, "matrix(".concat(r.join(","), ")"));
    else {
      var a = o.match(jM)[1];
      r = a.split(",").map(function(i) {
        return parseFloat(i, 10);
      }), r[12] = t.x, r[13] = t.y, Yp(e, "matrix3d(".concat(r.join(","), ")"));
    }
  } else
    Yp(e, "translateX(".concat(t.x, "px) translateY(").concat(t.y, "px) translateZ(0)"));
}
var WM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source, rc;
function y1(e) {
  var t = e.style.display;
  e.style.display = "none", e.offsetHeight, e.style.display = t;
}
function ti(e, t, n) {
  var o = n;
  if (Rg(t) === "object") {
    for (var r in t)
      t.hasOwnProperty(r) && ti(e, r, t[r]);
    return;
  }
  if (typeof o < "u") {
    typeof o == "number" && (o = "".concat(o, "px")), e.style[t] = o;
    return;
  }
  return rc(e, t);
}
function KM(e) {
  var t, n, o, r = e.ownerDocument, l = r.body, a = r && r.documentElement;
  return t = e.getBoundingClientRect(), n = Math.floor(t.left), o = Math.floor(t.top), n -= a.clientLeft || l.clientLeft || 0, o -= a.clientTop || l.clientTop || 0, {
    left: n,
    top: o
  };
}
function o4(e, t) {
  var n = e["page".concat(t ? "Y" : "X", "Offset")], o = "scroll".concat(t ? "Top" : "Left");
  if (typeof n != "number") {
    var r = e.document;
    n = r.documentElement[o], typeof n != "number" && (n = r.body[o]);
  }
  return n;
}
function r4(e) {
  return o4(e);
}
function l4(e) {
  return o4(e, !0);
}
function zs(e) {
  var t = KM(e), n = e.ownerDocument, o = n.defaultView || n.parentWindow;
  return t.left += r4(o), t.top += l4(o), t;
}
function Ch(e) {
  return e != null && e == e.window;
}
function a4(e) {
  return Ch(e) ? e.document : e.nodeType === 9 ? e : e.ownerDocument;
}
function GM(e, t, n) {
  var o = n, r = "", l = a4(e);
  return o = o || l.defaultView.getComputedStyle(e, null), o && (r = o.getPropertyValue(t) || o[t]), r;
}
var XM = new RegExp("^(".concat(WM, ")(?!px)[a-z%]+$"), "i"), UM = /^(top|right|bottom|left)$/, qp = "currentStyle", Zp = "runtimeStyle", _l = "left", YM = "px";
function qM(e, t) {
  var n = e[qp] && e[qp][t];
  if (XM.test(n) && !UM.test(t)) {
    var o = e.style, r = o[_l], l = e[Zp][_l];
    e[Zp][_l] = e[qp][_l], o[_l] = t === "fontSize" ? "1em" : n || 0, n = o.pixelLeft + YM, o[_l] = r, e[Zp][_l] = l;
  }
  return n === "" ? "auto" : n;
}
typeof window < "u" && (rc = window.getComputedStyle ? GM : qM);
function Fc(e, t) {
  return e === "left" ? t.useCssRight ? "right" : e : t.useCssBottom ? "bottom" : e;
}
function S1(e) {
  if (e === "left")
    return "right";
  if (e === "right")
    return "left";
  if (e === "top")
    return "bottom";
  if (e === "bottom")
    return "top";
}
function C1(e, t, n) {
  ti(e, "position") === "static" && (e.style.position = "relative");
  var o = -999, r = -999, l = Fc("left", n), a = Fc("top", n), i = S1(l), s = S1(a);
  l !== "left" && (o = 999), a !== "top" && (r = 999);
  var c = "", u = zs(e);
  ("left" in t || "top" in t) && (c = LM(e) || "", b1(e, "none")), "left" in t && (e.style[i] = "", e.style[l] = "".concat(o, "px")), "top" in t && (e.style[s] = "", e.style[a] = "".concat(r, "px")), y1(e);
  var d = zs(e), p = {};
  for (var v in t)
    if (t.hasOwnProperty(v)) {
      var h = Fc(v, n), g = v === "left" ? o : r, b = u[v] - d[v];
      h === v ? p[h] = g + b : p[h] = g - b;
    }
  ti(e, p), y1(e), ("left" in t || "top" in t) && b1(e, c);
  var y = {};
  for (var S in t)
    if (t.hasOwnProperty(S)) {
      var C = Fc(S, n), w = t[S] - u[S];
      S === C ? y[C] = p[C] + w : y[C] = p[C] - w;
    }
  ti(e, y);
}
function ZM(e, t) {
  var n = zs(e), o = zM(e), r = {
    x: o.x,
    y: o.y
  };
  "left" in t && (r.x = o.x + t.left - n.left), "top" in t && (r.y = o.y + t.top - n.top), VM(e, r);
}
function QM(e, t, n) {
  if (n.ignoreShake) {
    var o = zs(e), r = o.left.toFixed(0), l = o.top.toFixed(0), a = t.left.toFixed(0), i = t.top.toFixed(0);
    if (r === a && l === i)
      return;
  }
  n.useCssRight || n.useCssBottom ? C1(e, t, n) : n.useCssTransform && Of() in document.body.style ? ZM(e, t) : C1(e, t, n);
}
function $h(e, t) {
  for (var n = 0; n < e.length; n++)
    t(e[n]);
}
function i4(e) {
  return rc(e, "boxSizing") === "border-box";
}
var JM = ["margin", "border", "padding"], kg = -1, e7 = 2, Bg = 1, t7 = 0;
function n7(e, t, n) {
  var o = {}, r = e.style, l;
  for (l in t)
    t.hasOwnProperty(l) && (o[l] = r[l], r[l] = t[l]);
  n.call(e);
  for (l in t)
    t.hasOwnProperty(l) && (r[l] = o[l]);
}
function ts(e, t, n) {
  var o = 0, r, l, a;
  for (l = 0; l < t.length; l++)
    if (r = t[l], r)
      for (a = 0; a < n.length; a++) {
        var i = void 0;
        r === "border" ? i = "".concat(r).concat(n[a], "Width") : i = r + n[a], o += parseFloat(rc(e, i)) || 0;
      }
  return o;
}
var gr = {
  getParent: function(t) {
    var n = t;
    do
      n.nodeType === 11 && n.host ? n = n.host : n = n.parentNode;
    while (n && n.nodeType !== 1 && n.nodeType !== 9);
    return n;
  }
};
$h(["Width", "Height"], function(e) {
  gr["doc".concat(e)] = function(t) {
    var n = t.document;
    return Math.max(
      // firefox chrome documentElement.scrollHeight< body.scrollHeight
      // ie standard mode : documentElement.scrollHeight> body.scrollHeight
      n.documentElement["scroll".concat(e)],
      // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
      n.body["scroll".concat(e)],
      gr["viewport".concat(e)](n)
    );
  }, gr["viewport".concat(e)] = function(t) {
    var n = "client".concat(e), o = t.document, r = o.body, l = o.documentElement, a = l[n];
    return o.compatMode === "CSS1Compat" && a || r && r[n] || a;
  };
});
function $1(e, t, n) {
  var o = n;
  if (Ch(e))
    return t === "width" ? gr.viewportWidth(e) : gr.viewportHeight(e);
  if (e.nodeType === 9)
    return t === "width" ? gr.docWidth(e) : gr.docHeight(e);
  var r = t === "width" ? ["Left", "Right"] : ["Top", "Bottom"], l = Math.floor(t === "width" ? e.getBoundingClientRect().width : e.getBoundingClientRect().height), a = i4(e), i = 0;
  (l == null || l <= 0) && (l = void 0, i = rc(e, t), (i == null || Number(i) < 0) && (i = e.style[t] || 0), i = Math.floor(parseFloat(i)) || 0), o === void 0 && (o = a ? Bg : kg);
  var s = l !== void 0 || a, c = l || i;
  return o === kg ? s ? c - ts(e, ["border", "padding"], r) : i : s ? o === Bg ? c : c + (o === e7 ? -ts(e, ["border"], r) : ts(e, ["margin"], r)) : i + ts(e, JM.slice(o), r);
}
var o7 = {
  position: "absolute",
  visibility: "hidden",
  display: "block"
};
function w1() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  var o, r = t[0];
  return r.offsetWidth !== 0 ? o = $1.apply(void 0, t) : n7(r, o7, function() {
    o = $1.apply(void 0, t);
  }), o;
}
$h(["width", "height"], function(e) {
  var t = e.charAt(0).toUpperCase() + e.slice(1);
  gr["outer".concat(t)] = function(o, r) {
    return o && w1(o, e, r ? t7 : Bg);
  };
  var n = e === "width" ? ["Left", "Right"] : ["Top", "Bottom"];
  gr[e] = function(o, r) {
    var l = r;
    if (l !== void 0) {
      if (o) {
        var a = i4(o);
        return a && (l += ts(o, ["padding", "border"], n)), ti(o, e, l);
      }
      return;
    }
    return o && w1(o, e, kg);
  };
});
function s4(e, t) {
  for (var n in t)
    t.hasOwnProperty(n) && (e[n] = t[n]);
  return e;
}
var bt = {
  getWindow: function(t) {
    if (t && t.document && t.setTimeout)
      return t;
    var n = t.ownerDocument || t;
    return n.defaultView || n.parentWindow;
  },
  getDocument: a4,
  offset: function(t, n, o) {
    if (typeof n < "u")
      QM(t, n, o || {});
    else
      return zs(t);
  },
  isWindow: Ch,
  each: $h,
  css: ti,
  clone: function(t) {
    var n, o = {};
    for (n in t)
      t.hasOwnProperty(n) && (o[n] = t[n]);
    var r = t.overflow;
    if (r)
      for (n in t)
        t.hasOwnProperty(n) && (o.overflow[n] = t.overflow[n]);
    return o;
  },
  mix: s4,
  getWindowScrollLeft: function(t) {
    return r4(t);
  },
  getWindowScrollTop: function(t) {
    return l4(t);
  },
  merge: function() {
    for (var t = {}, n = 0; n < arguments.length; n++)
      bt.mix(t, n < 0 || arguments.length <= n ? void 0 : arguments[n]);
    return t;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
s4(bt, gr);
var Qp = bt.getParent;
function Fg(e) {
  if (bt.isWindow(e) || e.nodeType === 9)
    return null;
  var t = bt.getDocument(e), n = t.body, o, r = bt.css(e, "position"), l = r === "fixed" || r === "absolute";
  if (!l)
    return e.nodeName.toLowerCase() === "html" ? null : Qp(e);
  for (o = Qp(e); o && o !== n && o.nodeType !== 9; o = Qp(o))
    if (r = bt.css(o, "position"), r !== "static")
      return o;
  return null;
}
var x1 = bt.getParent;
function r7(e) {
  if (bt.isWindow(e) || e.nodeType === 9)
    return !1;
  var t = bt.getDocument(e), n = t.body, o = null;
  for (
    o = x1(e);
    // 修复元素位于 document.documentElement 下导致崩溃问题
    o && o !== n && o !== t;
    o = x1(o)
  ) {
    var r = bt.css(o, "position");
    if (r === "fixed")
      return !0;
  }
  return !1;
}
function wh(e, t) {
  for (var n = {
    left: 0,
    right: 1 / 0,
    top: 0,
    bottom: 1 / 0
  }, o = Fg(e), r = bt.getDocument(e), l = r.defaultView || r.parentWindow, a = r.body, i = r.documentElement; o; ) {
    if ((navigator.userAgent.indexOf("MSIE") === -1 || o.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    o !== a && o !== i && bt.css(o, "overflow") !== "visible") {
      var s = bt.offset(o);
      s.left += o.clientLeft, s.top += o.clientTop, n.top = Math.max(n.top, s.top), n.right = Math.min(
        n.right,
        // consider area without scrollBar
        s.left + o.clientWidth
      ), n.bottom = Math.min(n.bottom, s.top + o.clientHeight), n.left = Math.max(n.left, s.left);
    } else if (o === a || o === i)
      break;
    o = Fg(o);
  }
  var c = null;
  if (!bt.isWindow(e) && e.nodeType !== 9) {
    c = e.style.position;
    var u = bt.css(e, "position");
    u === "absolute" && (e.style.position = "fixed");
  }
  var d = bt.getWindowScrollLeft(l), p = bt.getWindowScrollTop(l), v = bt.viewportWidth(l), h = bt.viewportHeight(l), g = i.scrollWidth, b = i.scrollHeight, y = window.getComputedStyle(a);
  if (y.overflowX === "hidden" && (g = l.innerWidth), y.overflowY === "hidden" && (b = l.innerHeight), e.style && (e.style.position = c), t || r7(e))
    n.left = Math.max(n.left, d), n.top = Math.max(n.top, p), n.right = Math.min(n.right, d + v), n.bottom = Math.min(n.bottom, p + h);
  else {
    var S = Math.max(g, d + v);
    n.right = Math.min(n.right, S);
    var C = Math.max(b, p + h);
    n.bottom = Math.min(n.bottom, C);
  }
  return n.top >= 0 && n.left >= 0 && n.bottom > n.top && n.right > n.left ? n : null;
}
function l7(e, t, n, o) {
  var r = bt.clone(e), l = {
    width: t.width,
    height: t.height
  };
  return o.adjustX && r.left < n.left && (r.left = n.left), o.resizeWidth && r.left >= n.left && r.left + l.width > n.right && (l.width -= r.left + l.width - n.right), o.adjustX && r.left + l.width > n.right && (r.left = Math.max(n.right - l.width, n.left)), o.adjustY && r.top < n.top && (r.top = n.top), o.resizeHeight && r.top >= n.top && r.top + l.height > n.bottom && (l.height -= r.top + l.height - n.bottom), o.adjustY && r.top + l.height > n.bottom && (r.top = Math.max(n.bottom - l.height, n.top)), bt.mix(r, l);
}
function xh(e) {
  var t, n, o;
  if (!bt.isWindow(e) && e.nodeType !== 9)
    t = bt.offset(e), n = bt.outerWidth(e), o = bt.outerHeight(e);
  else {
    var r = bt.getWindow(e);
    t = {
      left: bt.getWindowScrollLeft(r),
      top: bt.getWindowScrollTop(r)
    }, n = bt.viewportWidth(r), o = bt.viewportHeight(r);
  }
  return t.width = n, t.height = o, t;
}
function O1(e, t) {
  var n = t.charAt(0), o = t.charAt(1), r = e.width, l = e.height, a = e.left, i = e.top;
  return n === "c" ? i += l / 2 : n === "b" && (i += l), o === "c" ? a += r / 2 : o === "r" && (a += r), {
    left: a,
    top: i
  };
}
function Lc(e, t, n, o, r) {
  var l = O1(t, n[1]), a = O1(e, n[0]), i = [a.left - l.left, a.top - l.top];
  return {
    left: Math.round(e.left - i[0] + o[0] - r[0]),
    top: Math.round(e.top - i[1] + o[1] - r[1])
  };
}
function P1(e, t, n) {
  return e.left < n.left || e.left + t.width > n.right;
}
function I1(e, t, n) {
  return e.top < n.top || e.top + t.height > n.bottom;
}
function a7(e, t, n) {
  return e.left > n.right || e.left + t.width < n.left;
}
function i7(e, t, n) {
  return e.top > n.bottom || e.top + t.height < n.top;
}
function zc(e, t, n) {
  var o = [];
  return bt.each(e, function(r) {
    o.push(r.replace(t, function(l) {
      return n[l];
    }));
  }), o;
}
function Hc(e, t) {
  return e[t] = -e[t], e;
}
function E1(e, t) {
  var n;
  return /%$/.test(e) ? n = parseInt(e.substring(0, e.length - 1), 10) / 100 * t : n = parseInt(e, 10), n || 0;
}
function T1(e, t) {
  e[0] = E1(e[0], t.width), e[1] = E1(e[1], t.height);
}
function c4(e, t, n, o) {
  var r = n.points, l = n.offset || [0, 0], a = n.targetOffset || [0, 0], i = n.overflow, s = n.source || e;
  l = [].concat(l), a = [].concat(a), i = i || {};
  var c = {}, u = 0, d = !!(i && i.alwaysByViewport), p = wh(s, d), v = xh(s);
  T1(l, v), T1(a, t);
  var h = Lc(v, t, r, l, a), g = bt.merge(v, h);
  if (p && (i.adjustX || i.adjustY) && o) {
    if (i.adjustX && P1(h, v, p)) {
      var b = zc(r, /[lr]/gi, {
        l: "r",
        r: "l"
      }), y = Hc(l, 0), S = Hc(a, 0), C = Lc(v, t, b, y, S);
      a7(C, v, p) || (u = 1, r = b, l = y, a = S);
    }
    if (i.adjustY && I1(h, v, p)) {
      var w = zc(r, /[tb]/gi, {
        t: "b",
        b: "t"
      }), $ = Hc(l, 1), O = Hc(a, 1), x = Lc(v, t, w, $, O);
      i7(x, v, p) || (u = 1, r = w, l = $, a = O);
    }
    u && (h = Lc(v, t, r, l, a), bt.mix(g, h));
    var I = P1(h, v, p), E = I1(h, v, p);
    if (I || E) {
      var _ = r;
      I && (_ = zc(r, /[lr]/gi, {
        l: "r",
        r: "l"
      })), E && (_ = zc(r, /[tb]/gi, {
        t: "b",
        b: "t"
      })), r = _, l = n.offset || [0, 0], a = n.targetOffset || [0, 0];
    }
    c.adjustX = i.adjustX && I, c.adjustY = i.adjustY && E, (c.adjustX || c.adjustY) && (g = l7(h, v, p, c));
  }
  return g.width !== v.width && bt.css(s, "width", bt.width(s) + g.width - v.width), g.height !== v.height && bt.css(s, "height", bt.height(s) + g.height - v.height), bt.offset(s, {
    left: g.left,
    top: g.top
  }, {
    useCssRight: n.useCssRight,
    useCssBottom: n.useCssBottom,
    useCssTransform: n.useCssTransform,
    ignoreShake: n.ignoreShake
  }), {
    points: r,
    offset: l,
    targetOffset: a,
    overflow: c
  };
}
function s7(e, t) {
  var n = wh(e, t), o = xh(e);
  return !n || o.left + o.width <= n.left || o.top + o.height <= n.top || o.left >= n.right || o.top >= n.bottom;
}
function Oh(e, t, n) {
  var o = n.target || t, r = xh(o), l = !s7(o, n.overflow && n.overflow.alwaysByViewport);
  return c4(e, r, n, l);
}
Oh.__getOffsetParent = Fg;
Oh.__getVisibleRectForElement = wh;
function c7(e, t, n) {
  var o, r, l = bt.getDocument(e), a = l.defaultView || l.parentWindow, i = bt.getWindowScrollLeft(a), s = bt.getWindowScrollTop(a), c = bt.viewportWidth(a), u = bt.viewportHeight(a);
  "pageX" in t ? o = t.pageX : o = i + t.clientX, "pageY" in t ? r = t.pageY : r = s + t.clientY;
  var d = {
    left: o,
    top: r,
    width: 0,
    height: 0
  }, p = o >= 0 && o <= i + c && r >= 0 && r <= s + u, v = [n.points[0], "cc"];
  return c4(e, d, h1(h1({}, n), {}, {
    points: v
  }), p);
}
function yt(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1, r = e;
  if (Array.isArray(e) && (r = Lt(e)[0]), !r)
    return null;
  const l = tr(r, t, o);
  return l.props = n ? m(m({}, l.props), t) : l.props, Mt(typeof l.props.class != "object", "class must be string"), l;
}
function u7(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
  return e.map((o) => yt(o, t, n));
}
function ps(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (Array.isArray(e))
    return e.map((r) => ps(r, t, n, o));
  {
    if (!In(e))
      return e;
    const r = yt(e, t, n, o);
    return Array.isArray(r.children) && (r.children = ps(r.children)), r;
  }
}
function d7(e, t, n) {
  yl(tr(e, m({}, t)), n);
}
const u4 = (e) => (e || []).some((t) => In(t) ? !(t.type === Nx || t.type === Fe && !u4(t.children)) : !0) ? e : null;
function Pf(e, t, n, o) {
  var r;
  const l = (r = e[t]) === null || r === void 0 ? void 0 : r.call(e, n);
  return u4(l) ? l : o == null ? void 0 : o();
}
const If = (e) => {
  if (!e)
    return !1;
  if (e.offsetParent)
    return !0;
  if (e.getBBox) {
    const t = e.getBBox();
    if (t.width || t.height)
      return !0;
  }
  if (e.getBoundingClientRect) {
    const t = e.getBoundingClientRect();
    if (t.width || t.height)
      return !0;
  }
  return !1;
};
function f7(e, t) {
  return e === t ? !0 : !e || !t ? !1 : "pageX" in t && "pageY" in t ? e.pageX === t.pageX && e.pageY === t.pageY : "clientX" in t && "clientY" in t ? e.clientX === t.clientX && e.clientY === t.clientY : !1;
}
function p7(e, t) {
  e !== document.activeElement && sl(t, e) && typeof e.focus == "function" && e.focus();
}
function M1(e, t) {
  let n = null, o = null;
  function r(a) {
    let [{
      target: i
    }] = a;
    if (!document.documentElement.contains(i))
      return;
    const {
      width: s,
      height: c
    } = i.getBoundingClientRect(), u = Math.floor(s), d = Math.floor(c);
    (n !== u || o !== d) && Promise.resolve().then(() => {
      t({
        width: u,
        height: d
      });
    }), n = u, o = d;
  }
  const l = new oh(r);
  return e && l.observe(e), () => {
    l.disconnect();
  };
}
const v7 = (e, t) => {
  let n = !1, o = null;
  function r() {
    clearTimeout(o);
  }
  function l(a) {
    if (!n || a === !0) {
      if (e() === !1)
        return;
      n = !0, r(), o = setTimeout(() => {
        n = !1;
      }, t.value);
    } else
      r(), o = setTimeout(() => {
        n = !1, l();
      }, t.value);
  }
  return [l, () => {
    n = !1, r();
  }];
};
function g7() {
  this.__data__ = [], this.size = 0;
}
function Ph(e, t) {
  return e === t || e !== e && t !== t;
}
function Ef(e, t) {
  for (var n = e.length; n--; )
    if (Ph(e[n][0], t))
      return n;
  return -1;
}
var m7 = Array.prototype, h7 = m7.splice;
function b7(e) {
  var t = this.__data__, n = Ef(t, e);
  if (n < 0)
    return !1;
  var o = t.length - 1;
  return n == o ? t.pop() : h7.call(t, n, 1), --this.size, !0;
}
function y7(e) {
  var t = this.__data__, n = Ef(t, e);
  return n < 0 ? void 0 : t[n][1];
}
function S7(e) {
  return Ef(this.__data__, e) > -1;
}
function C7(e, t) {
  var n = this.__data__, o = Ef(n, e);
  return o < 0 ? (++this.size, n.push([e, t])) : n[o][1] = t, this;
}
function Zr(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Zr.prototype.clear = g7;
Zr.prototype.delete = b7;
Zr.prototype.get = y7;
Zr.prototype.has = S7;
Zr.prototype.set = C7;
function $7() {
  this.__data__ = new Zr(), this.size = 0;
}
function w7(e) {
  var t = this.__data__, n = t.delete(e);
  return this.size = t.size, n;
}
function x7(e) {
  return this.__data__.get(e);
}
function O7(e) {
  return this.__data__.has(e);
}
var d4 = typeof global == "object" && global && global.Object === Object && global, P7 = typeof self == "object" && self && self.Object === Object && self, lr = d4 || P7 || Function("return this")(), zo = lr.Symbol, f4 = Object.prototype, I7 = f4.hasOwnProperty, E7 = f4.toString, Ui = zo ? zo.toStringTag : void 0;
function T7(e) {
  var t = I7.call(e, Ui), n = e[Ui];
  try {
    e[Ui] = void 0;
    var o = !0;
  } catch {
  }
  var r = E7.call(e);
  return o && (t ? e[Ui] = n : delete e[Ui]), r;
}
var M7 = Object.prototype, _7 = M7.toString;
function A7(e) {
  return _7.call(e);
}
var D7 = "[object Null]", N7 = "[object Undefined]", _1 = zo ? zo.toStringTag : void 0;
function $l(e) {
  return e == null ? e === void 0 ? N7 : D7 : _1 && _1 in Object(e) ? T7(e) : A7(e);
}
function or(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var R7 = "[object AsyncFunction]", k7 = "[object Function]", B7 = "[object GeneratorFunction]", F7 = "[object Proxy]";
function p4(e) {
  if (!or(e))
    return !1;
  var t = $l(e);
  return t == k7 || t == B7 || t == R7 || t == F7;
}
var Jp = lr["__core-js_shared__"], A1 = function() {
  var e = /[^.]+$/.exec(Jp && Jp.keys && Jp.keys.IE_PROTO || "");
  return e ? "Symbol(src)_1." + e : "";
}();
function L7(e) {
  return !!A1 && A1 in e;
}
var z7 = Function.prototype, H7 = z7.toString;
function ya(e) {
  if (e != null) {
    try {
      return H7.call(e);
    } catch {
    }
    try {
      return e + "";
    } catch {
    }
  }
  return "";
}
var j7 = /[\\^$.*+?()[\]{}|]/g, V7 = /^\[object .+?Constructor\]$/, W7 = Function.prototype, K7 = Object.prototype, G7 = W7.toString, X7 = K7.hasOwnProperty, U7 = RegExp(
  "^" + G7.call(X7).replace(j7, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function Y7(e) {
  if (!or(e) || L7(e))
    return !1;
  var t = p4(e) ? U7 : V7;
  return t.test(ya(e));
}
function q7(e, t) {
  return e == null ? void 0 : e[t];
}
function Sa(e, t) {
  var n = q7(e, t);
  return Y7(n) ? n : void 0;
}
var Hs = Sa(lr, "Map"), js = Sa(Object, "create");
function Z7() {
  this.__data__ = js ? js(null) : {}, this.size = 0;
}
function Q7(e) {
  var t = this.has(e) && delete this.__data__[e];
  return this.size -= t ? 1 : 0, t;
}
var J7 = "__lodash_hash_undefined__", e_ = Object.prototype, t_ = e_.hasOwnProperty;
function n_(e) {
  var t = this.__data__;
  if (js) {
    var n = t[e];
    return n === J7 ? void 0 : n;
  }
  return t_.call(t, e) ? t[e] : void 0;
}
var o_ = Object.prototype, r_ = o_.hasOwnProperty;
function l_(e) {
  var t = this.__data__;
  return js ? t[e] !== void 0 : r_.call(t, e);
}
var a_ = "__lodash_hash_undefined__";
function i_(e, t) {
  var n = this.__data__;
  return this.size += this.has(e) ? 0 : 1, n[e] = js && t === void 0 ? a_ : t, this;
}
function ua(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
ua.prototype.clear = Z7;
ua.prototype.delete = Q7;
ua.prototype.get = n_;
ua.prototype.has = l_;
ua.prototype.set = i_;
function s_() {
  this.size = 0, this.__data__ = {
    hash: new ua(),
    map: new (Hs || Zr)(),
    string: new ua()
  };
}
function c_(e) {
  var t = typeof e;
  return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? e !== "__proto__" : e === null;
}
function Tf(e, t) {
  var n = e.__data__;
  return c_(t) ? n[typeof t == "string" ? "string" : "hash"] : n.map;
}
function u_(e) {
  var t = Tf(this, e).delete(e);
  return this.size -= t ? 1 : 0, t;
}
function d_(e) {
  return Tf(this, e).get(e);
}
function f_(e) {
  return Tf(this, e).has(e);
}
function p_(e, t) {
  var n = Tf(this, e), o = n.size;
  return n.set(e, t), this.size += n.size == o ? 0 : 1, this;
}
function Qr(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.clear(); ++t < n; ) {
    var o = e[t];
    this.set(o[0], o[1]);
  }
}
Qr.prototype.clear = s_;
Qr.prototype.delete = u_;
Qr.prototype.get = d_;
Qr.prototype.has = f_;
Qr.prototype.set = p_;
var v_ = 200;
function g_(e, t) {
  var n = this.__data__;
  if (n instanceof Zr) {
    var o = n.__data__;
    if (!Hs || o.length < v_ - 1)
      return o.push([e, t]), this.size = ++n.size, this;
    n = this.__data__ = new Qr(o);
  }
  return n.set(e, t), this.size = n.size, this;
}
function mr(e) {
  var t = this.__data__ = new Zr(e);
  this.size = t.size;
}
mr.prototype.clear = $7;
mr.prototype.delete = w7;
mr.prototype.get = x7;
mr.prototype.has = O7;
mr.prototype.set = g_;
var m_ = "__lodash_hash_undefined__";
function h_(e) {
  return this.__data__.set(e, m_), this;
}
function b_(e) {
  return this.__data__.has(e);
}
function bi(e) {
  var t = -1, n = e == null ? 0 : e.length;
  for (this.__data__ = new Qr(); ++t < n; )
    this.add(e[t]);
}
bi.prototype.add = bi.prototype.push = h_;
bi.prototype.has = b_;
function y_(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o; )
    if (t(e[n], n, e))
      return !0;
  return !1;
}
function vd(e, t) {
  return e.has(t);
}
var S_ = 1, C_ = 2;
function v4(e, t, n, o, r, l) {
  var a = n & S_, i = e.length, s = t.length;
  if (i != s && !(a && s > i))
    return !1;
  var c = l.get(e), u = l.get(t);
  if (c && u)
    return c == t && u == e;
  var d = -1, p = !0, v = n & C_ ? new bi() : void 0;
  for (l.set(e, t), l.set(t, e); ++d < i; ) {
    var h = e[d], g = t[d];
    if (o)
      var b = a ? o(g, h, d, t, e, l) : o(h, g, d, e, t, l);
    if (b !== void 0) {
      if (b)
        continue;
      p = !1;
      break;
    }
    if (v) {
      if (!y_(t, function(y, S) {
        if (!vd(v, S) && (h === y || r(h, y, n, o, l)))
          return v.push(S);
      })) {
        p = !1;
        break;
      }
    } else if (!(h === g || r(h, g, n, o, l))) {
      p = !1;
      break;
    }
  }
  return l.delete(e), l.delete(t), p;
}
var gd = lr.Uint8Array;
function $_(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o, r) {
    n[++t] = [r, o];
  }), n;
}
function Ih(e) {
  var t = -1, n = Array(e.size);
  return e.forEach(function(o) {
    n[++t] = o;
  }), n;
}
var w_ = 1, x_ = 2, O_ = "[object Boolean]", P_ = "[object Date]", I_ = "[object Error]", E_ = "[object Map]", T_ = "[object Number]", M_ = "[object RegExp]", __ = "[object Set]", A_ = "[object String]", D_ = "[object Symbol]", N_ = "[object ArrayBuffer]", R_ = "[object DataView]", D1 = zo ? zo.prototype : void 0, ev = D1 ? D1.valueOf : void 0;
function k_(e, t, n, o, r, l, a) {
  switch (n) {
    case R_:
      if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
        return !1;
      e = e.buffer, t = t.buffer;
    case N_:
      return !(e.byteLength != t.byteLength || !l(new gd(e), new gd(t)));
    case O_:
    case P_:
    case T_:
      return Ph(+e, +t);
    case I_:
      return e.name == t.name && e.message == t.message;
    case M_:
    case A_:
      return e == t + "";
    case E_:
      var i = $_;
    case __:
      var s = o & w_;
      if (i || (i = Ih), e.size != t.size && !s)
        return !1;
      var c = a.get(e);
      if (c)
        return c == t;
      o |= x_, a.set(e, t);
      var u = v4(i(e), i(t), o, r, l, a);
      return a.delete(e), u;
    case D_:
      if (ev)
        return ev.call(e) == ev.call(t);
  }
  return !1;
}
function Eh(e, t) {
  for (var n = -1, o = t.length, r = e.length; ++n < o; )
    e[r + n] = t[n];
  return e;
}
var Oo = Array.isArray;
function g4(e, t, n) {
  var o = t(e);
  return Oo(e) ? o : Eh(o, n(e));
}
function B_(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, r = 0, l = []; ++n < o; ) {
    var a = e[n];
    t(a, n, e) && (l[r++] = a);
  }
  return l;
}
function m4() {
  return [];
}
var F_ = Object.prototype, L_ = F_.propertyIsEnumerable, N1 = Object.getOwnPropertySymbols, Th = N1 ? function(e) {
  return e == null ? [] : (e = Object(e), B_(N1(e), function(t) {
    return L_.call(e, t);
  }));
} : m4;
function z_(e, t) {
  for (var n = -1, o = Array(e); ++n < e; )
    o[n] = t(n);
  return o;
}
function rr(e) {
  return e != null && typeof e == "object";
}
var H_ = "[object Arguments]";
function R1(e) {
  return rr(e) && $l(e) == H_;
}
var h4 = Object.prototype, j_ = h4.hasOwnProperty, V_ = h4.propertyIsEnumerable, Mf = R1(/* @__PURE__ */ function() {
  return arguments;
}()) ? R1 : function(e) {
  return rr(e) && j_.call(e, "callee") && !V_.call(e, "callee");
};
function W_() {
  return !1;
}
var b4 = typeof exports == "object" && exports && !exports.nodeType && exports, k1 = b4 && typeof module == "object" && module && !module.nodeType && module, K_ = k1 && k1.exports === b4, B1 = K_ ? lr.Buffer : void 0, G_ = B1 ? B1.isBuffer : void 0, Vs = G_ || W_, X_ = 9007199254740991, U_ = /^(?:0|[1-9]\d*)$/;
function Mh(e, t) {
  var n = typeof e;
  return t = t ?? X_, !!t && (n == "number" || n != "symbol" && U_.test(e)) && e > -1 && e % 1 == 0 && e < t;
}
var Y_ = 9007199254740991;
function _h(e) {
  return typeof e == "number" && e > -1 && e % 1 == 0 && e <= Y_;
}
var q_ = "[object Arguments]", Z_ = "[object Array]", Q_ = "[object Boolean]", J_ = "[object Date]", eA = "[object Error]", tA = "[object Function]", nA = "[object Map]", oA = "[object Number]", rA = "[object Object]", lA = "[object RegExp]", aA = "[object Set]", iA = "[object String]", sA = "[object WeakMap]", cA = "[object ArrayBuffer]", uA = "[object DataView]", dA = "[object Float32Array]", fA = "[object Float64Array]", pA = "[object Int8Array]", vA = "[object Int16Array]", gA = "[object Int32Array]", mA = "[object Uint8Array]", hA = "[object Uint8ClampedArray]", bA = "[object Uint16Array]", yA = "[object Uint32Array]", jt = {};
jt[dA] = jt[fA] = jt[pA] = jt[vA] = jt[gA] = jt[mA] = jt[hA] = jt[bA] = jt[yA] = !0;
jt[q_] = jt[Z_] = jt[cA] = jt[Q_] = jt[uA] = jt[J_] = jt[eA] = jt[tA] = jt[nA] = jt[oA] = jt[rA] = jt[lA] = jt[aA] = jt[iA] = jt[sA] = !1;
function SA(e) {
  return rr(e) && _h(e.length) && !!jt[$l(e)];
}
function _f(e) {
  return function(t) {
    return e(t);
  };
}
var y4 = typeof exports == "object" && exports && !exports.nodeType && exports, vs = y4 && typeof module == "object" && module && !module.nodeType && module, CA = vs && vs.exports === y4, tv = CA && d4.process, yi = function() {
  try {
    var e = vs && vs.require && vs.require("util").types;
    return e || tv && tv.binding && tv.binding("util");
  } catch {
  }
}(), F1 = yi && yi.isTypedArray, Ah = F1 ? _f(F1) : SA, $A = Object.prototype, wA = $A.hasOwnProperty;
function S4(e, t) {
  var n = Oo(e), o = !n && Mf(e), r = !n && !o && Vs(e), l = !n && !o && !r && Ah(e), a = n || o || r || l, i = a ? z_(e.length, String) : [], s = i.length;
  for (var c in e)
    (t || wA.call(e, c)) && !(a && // Safari 9 has enumerable `arguments.length` in strict mode.
    (c == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    r && (c == "offset" || c == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    l && (c == "buffer" || c == "byteLength" || c == "byteOffset") || // Skip index properties.
    Mh(c, s))) && i.push(c);
  return i;
}
var xA = Object.prototype;
function Af(e) {
  var t = e && e.constructor, n = typeof t == "function" && t.prototype || xA;
  return e === n;
}
function C4(e, t) {
  return function(n) {
    return e(t(n));
  };
}
var OA = C4(Object.keys, Object), PA = Object.prototype, IA = PA.hasOwnProperty;
function $4(e) {
  if (!Af(e))
    return OA(e);
  var t = [];
  for (var n in Object(e))
    IA.call(e, n) && n != "constructor" && t.push(n);
  return t;
}
function Ii(e) {
  return e != null && _h(e.length) && !p4(e);
}
function Ei(e) {
  return Ii(e) ? S4(e) : $4(e);
}
function Lg(e) {
  return g4(e, Ei, Th);
}
var EA = 1, TA = Object.prototype, MA = TA.hasOwnProperty;
function _A(e, t, n, o, r, l) {
  var a = n & EA, i = Lg(e), s = i.length, c = Lg(t), u = c.length;
  if (s != u && !a)
    return !1;
  for (var d = s; d--; ) {
    var p = i[d];
    if (!(a ? p in t : MA.call(t, p)))
      return !1;
  }
  var v = l.get(e), h = l.get(t);
  if (v && h)
    return v == t && h == e;
  var g = !0;
  l.set(e, t), l.set(t, e);
  for (var b = a; ++d < s; ) {
    p = i[d];
    var y = e[p], S = t[p];
    if (o)
      var C = a ? o(S, y, p, t, e, l) : o(y, S, p, e, t, l);
    if (!(C === void 0 ? y === S || r(y, S, n, o, l) : C)) {
      g = !1;
      break;
    }
    b || (b = p == "constructor");
  }
  if (g && !b) {
    var w = e.constructor, $ = t.constructor;
    w != $ && "constructor" in e && "constructor" in t && !(typeof w == "function" && w instanceof w && typeof $ == "function" && $ instanceof $) && (g = !1);
  }
  return l.delete(e), l.delete(t), g;
}
var zg = Sa(lr, "DataView"), Hg = Sa(lr, "Promise"), ni = Sa(lr, "Set"), jg = Sa(lr, "WeakMap"), L1 = "[object Map]", AA = "[object Object]", z1 = "[object Promise]", H1 = "[object Set]", j1 = "[object WeakMap]", V1 = "[object DataView]", DA = ya(zg), NA = ya(Hs), RA = ya(Hg), kA = ya(ni), BA = ya(jg), Ro = $l;
(zg && Ro(new zg(new ArrayBuffer(1))) != V1 || Hs && Ro(new Hs()) != L1 || Hg && Ro(Hg.resolve()) != z1 || ni && Ro(new ni()) != H1 || jg && Ro(new jg()) != j1) && (Ro = function(e) {
  var t = $l(e), n = t == AA ? e.constructor : void 0, o = n ? ya(n) : "";
  if (o)
    switch (o) {
      case DA:
        return V1;
      case NA:
        return L1;
      case RA:
        return z1;
      case kA:
        return H1;
      case BA:
        return j1;
    }
  return t;
});
var FA = 1, W1 = "[object Arguments]", K1 = "[object Array]", jc = "[object Object]", LA = Object.prototype, G1 = LA.hasOwnProperty;
function zA(e, t, n, o, r, l) {
  var a = Oo(e), i = Oo(t), s = a ? K1 : Ro(e), c = i ? K1 : Ro(t);
  s = s == W1 ? jc : s, c = c == W1 ? jc : c;
  var u = s == jc, d = c == jc, p = s == c;
  if (p && Vs(e)) {
    if (!Vs(t))
      return !1;
    a = !0, u = !1;
  }
  if (p && !u)
    return l || (l = new mr()), a || Ah(e) ? v4(e, t, n, o, r, l) : k_(e, t, s, n, o, r, l);
  if (!(n & FA)) {
    var v = u && G1.call(e, "__wrapped__"), h = d && G1.call(t, "__wrapped__");
    if (v || h) {
      var g = v ? e.value() : e, b = h ? t.value() : t;
      return l || (l = new mr()), r(g, b, n, o, l);
    }
  }
  return p ? (l || (l = new mr()), _A(e, t, n, o, r, l)) : !1;
}
function Df(e, t, n, o, r) {
  return e === t ? !0 : e == null || t == null || !rr(e) && !rr(t) ? e !== e && t !== t : zA(e, t, n, o, Df, r);
}
function Dh(e, t) {
  return Df(e, t);
}
const HA = {
  align: Object,
  target: [Object, Function],
  onAlign: Function,
  monitorBufferTime: Number,
  monitorWindowResize: Boolean,
  disabled: Boolean
};
function X1(e) {
  return typeof e != "function" ? null : e();
}
function U1(e) {
  return typeof e != "object" || !e ? null : e;
}
const jA = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Align",
  props: HA,
  emits: ["align"],
  setup(e, t) {
    let {
      expose: n,
      slots: o
    } = t;
    const r = Y({}), l = Y(), [a, i] = v7(() => {
      const {
        disabled: p,
        target: v,
        align: h,
        onAlign: g
      } = e;
      if (!p && v && l.value) {
        const b = l.value;
        let y;
        const S = X1(v), C = U1(v);
        r.value.element = S, r.value.point = C, r.value.align = h;
        const {
          activeElement: w
        } = document;
        return S && If(S) ? y = Oh(b, S, h) : C && (y = c7(b, C, h)), p7(w, b), g && y && g(b, y), !0;
      }
      return !1;
    }, P(() => e.monitorBufferTime)), s = Y({
      cancel: () => {
      }
    }), c = Y({
      cancel: () => {
      }
    }), u = () => {
      const p = e.target, v = X1(p), h = U1(p);
      l.value !== c.value.element && (c.value.cancel(), c.value.element = l.value, c.value.cancel = M1(l.value, a)), (r.value.element !== v || !f7(r.value.point, h) || !Dh(r.value.align, e.align)) && (a(), s.value.element !== v && (s.value.cancel(), s.value.element = v, s.value.cancel = M1(v, a)));
    };
    Ke(() => {
      rt(() => {
        u();
      });
    }), co(() => {
      rt(() => {
        u();
      });
    }), ie(() => e.disabled, (p) => {
      p ? i() : a();
    }, {
      immediate: !0,
      flush: "post"
    });
    const d = Y(null);
    return ie(() => e.monitorWindowResize, (p) => {
      p ? d.value || (d.value = Bt(window, "resize", a)) : d.value && (d.value.remove(), d.value = null);
    }, {
      flush: "post"
    }), uo(() => {
      s.value.cancel(), c.value.cancel(), d.value && d.value.remove(), i();
    }), n({
      forceAlign: () => a(!0)
    }), () => {
      const p = o == null ? void 0 : o.default();
      return p ? yt(p[0], {
        ref: l
      }, !0, !0) : null;
    };
  }
});
Mn("bottomLeft", "bottomRight", "topLeft", "topRight");
const Nh = (e) => e !== void 0 && (e === "topLeft" || e === "topRight") ? "slide-down" : "slide-up", Ho = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return m(e ? {
    name: e,
    appear: !0,
    // type: 'animation',
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    // appearActiveClass: `antdv-base-transtion`,
    // appearToClass: `${transitionName}-appear ${transitionName}-appear-active`,
    enterFromClass: `${e}-enter ${e}-enter-prepare ${e}-enter-start`,
    enterActiveClass: `${e}-enter ${e}-enter-prepare`,
    enterToClass: `${e}-enter ${e}-enter-active`,
    leaveFromClass: ` ${e}-leave`,
    leaveActiveClass: `${e}-leave ${e}-leave-active`,
    leaveToClass: `${e}-leave ${e}-leave-active`
  } : {
    css: !1
  }, t);
}, Nf = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return m(e ? {
    name: e,
    appear: !0,
    // appearFromClass: `${transitionName}-appear ${transitionName}-appear-prepare`,
    appearActiveClass: `${e}`,
    appearToClass: `${e}-appear ${e}-appear-active`,
    enterFromClass: `${e}-appear ${e}-enter ${e}-appear-prepare ${e}-enter-prepare`,
    enterActiveClass: `${e}`,
    enterToClass: `${e}-enter ${e}-appear ${e}-appear-active ${e}-enter-active`,
    leaveActiveClass: `${e} ${e}-leave`,
    leaveToClass: `${e}-leave-active`
  } : {
    css: !1
  }, t);
}, Vn = (e, t, n) => n !== void 0 ? n : `${e}-${t}`, VA = Z({
  compatConfig: {
    MODE: 3
  },
  name: "PopupInner",
  inheritAttrs: !1,
  props: yh,
  emits: ["mouseenter", "mouseleave", "mousedown", "touchstart", "align"],
  setup(e, t) {
    let {
      expose: n,
      attrs: o,
      slots: r
    } = t;
    const l = Q(), a = Q(), i = Q(), [s, c] = kM(Te(e, "stretch")), u = () => {
      e.stretch && c(e.getRootDomNode());
    }, d = Q(!1);
    let p;
    ie(() => e.visible, (O) => {
      clearTimeout(p), O ? p = setTimeout(() => {
        d.value = e.visible;
      }) : d.value = !1;
    }, {
      immediate: !0
    });
    const [v, h] = RM(d, u), g = Q(), b = () => e.point ? e.point : e.getRootDomNode, y = () => {
      var O;
      (O = l.value) === null || O === void 0 || O.forceAlign();
    }, S = (O, x) => {
      var I;
      const E = e.getClassNameFromAlign(x), _ = i.value;
      i.value !== E && (i.value = E), v.value === "align" && (_ !== E ? Promise.resolve().then(() => {
        y();
      }) : h(() => {
        var M;
        (M = g.value) === null || M === void 0 || M.call(g);
      }), (I = e.onAlign) === null || I === void 0 || I.call(e, O, x));
    }, C = P(() => {
      const O = typeof e.animation == "object" ? e.animation : Sh(e);
      return ["onAfterEnter", "onAfterLeave"].forEach((x) => {
        const I = O[x];
        O[x] = (E) => {
          h(), v.value = "stable", I == null || I(E);
        };
      }), O;
    }), w = () => new Promise((O) => {
      g.value = O;
    });
    ie([C, v], () => {
      !C.value && v.value === "motion" && h();
    }, {
      immediate: !0
    }), n({
      forceAlign: y,
      getElement: () => a.value.$el || a.value
    });
    const $ = P(() => {
      var O;
      return !(!((O = e.align) === null || O === void 0) && O.points && (v.value === "align" || v.value === "stable"));
    });
    return () => {
      var O;
      const {
        zIndex: x,
        align: I,
        prefixCls: E,
        destroyPopupOnHide: _,
        onMouseenter: M,
        onMouseleave: R,
        onTouchstart: A = () => {
        },
        onMousedown: z
      } = e, T = v.value, N = [m(m({}, s.value), {
        zIndex: x,
        opacity: T === "motion" || T === "stable" || !d.value ? null : 0,
        // pointerEvents: statusValue === 'stable' ? null : 'none',
        pointerEvents: !d.value && T !== "stable" ? "none" : null
      }), o.style];
      let k = It((O = r.default) === null || O === void 0 ? void 0 : O.call(r, {
        visible: e.visible
      }));
      k.length > 1 && (k = f("div", {
        class: `${E}-content`
      }, [k]));
      const B = ee(E, o.class, i.value, !e.arrow && `${E}-arrow-hidden`), L = d.value || !e.visible ? Ho(C.value.name, C.value) : {};
      return f(yn, D(D({
        ref: a
      }, L), {}, {
        onBeforeEnter: w
      }), {
        default: () => !_ || e.visible ? Tn(f(jA, {
          target: b(),
          key: "popup",
          ref: l,
          monitorWindowResize: !0,
          disabled: $.value,
          align: I,
          onAlign: S
        }, {
          default: () => f("div", {
            class: B,
            onMouseenter: M,
            onMouseleave: R,
            onMousedown: Ay(z, ["capture"]),
            [on ? "onTouchstartPassive" : "onTouchstart"]: Ay(A, ["capture"]),
            style: N
          }, [k])
        }), [[Hn, d.value]]) : null
      });
    };
  }
}), WA = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Popup",
  inheritAttrs: !1,
  props: AM,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r
    } = t;
    const l = Q(!1), a = Q(!1), i = Q(), s = Q();
    return ie([() => e.visible, () => e.mobile], () => {
      l.value = e.visible, e.visible && e.mobile && (a.value = !0);
    }, {
      immediate: !0,
      flush: "post"
    }), r({
      forceAlign: () => {
        var c;
        (c = i.value) === null || c === void 0 || c.forceAlign();
      },
      getElement: () => {
        var c;
        return (c = i.value) === null || c === void 0 ? void 0 : c.getElement();
      }
    }), () => {
      const c = m(m(m({}, e), n), {
        visible: l.value
      }), u = a.value ? f(DM, D(D({}, c), {}, {
        mobile: e.mobile,
        ref: i
      }), {
        default: o.default
      }) : f(VA, D(D({}, c), {}, {
        ref: i
      }), {
        default: o.default
      });
      return f("div", {
        ref: s
      }, [f(t4, c, null), u]);
    };
  }
});
function KA(e, t, n) {
  return n ? e[0] === t[0] : e[0] === t[0] && e[1] === t[1];
}
function Y1(e, t, n) {
  const o = e[t] || {};
  return m(m({}, o), n);
}
function GA(e, t, n, o) {
  const {
    points: r
  } = n, l = Object.keys(e);
  for (let a = 0; a < l.length; a += 1) {
    const i = l[a];
    if (KA(e[i].points, r, o))
      return `${t}-placement-${i}`;
  }
  return "";
}
const Ca = {
  methods: {
    setState() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0, n = typeof e == "function" ? e(this.$data, this.$props) : e;
      if (this.getDerivedStateFromProps) {
        const o = this.getDerivedStateFromProps(Kx(this), m(m({}, this.$data), n));
        if (o === null)
          return;
        n = m(m({}, n), o || {});
      }
      m(this.$data, n), this._.isMounted && this.$forceUpdate(), rt(() => {
        t && t();
      });
    },
    __emit() {
      const e = [].slice.call(arguments, 0);
      let t = e[0];
      t = `on${t[0].toUpperCase()}${t.substring(1)}`;
      const n = this.$props[t] || this.$attrs[t];
      if (e.length && n)
        if (Array.isArray(n))
          for (let o = 0, r = n.length; o < r; o++)
            n[o](...e.slice(1));
        else
          n(...e.slice(1));
    }
  }
}, w4 = Symbol("PortalContextKey"), Rh = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    inTriggerContext: !0
  };
  Je(w4, {
    inTriggerContext: t.inTriggerContext,
    shouldRender: P(() => {
      const {
        sPopupVisible: n,
        popupRef: o,
        forceRender: r,
        autoDestroy: l
      } = e || {};
      let a = !1;
      return (n || o || r) && (a = !0), !n && l && (a = !1), a;
    })
  });
}, XA = () => {
  Rh({}, {
    inTriggerContext: !1
  });
  const e = tt(w4, {
    shouldRender: P(() => !1),
    inTriggerContext: !1
  });
  return {
    shouldRender: P(() => e.shouldRender.value || e.inTriggerContext === !1)
  };
}, x4 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Portal",
  inheritAttrs: !1,
  props: {
    getContainer: V.func.isRequired,
    didUpdate: Function
  },
  setup(e, t) {
    let {
      slots: n
    } = t, o = !0, r;
    const {
      shouldRender: l
    } = XA();
    function a() {
      l.value && (r = e.getContainer());
    }
    vf(() => {
      o = !1, a();
    }), Ke(() => {
      r || a();
    });
    const i = ie(l, () => {
      l.value && !r && (r = e.getContainer()), r && i();
    });
    return co(() => {
      rt(() => {
        var s;
        l.value && ((s = e.didUpdate) === null || s === void 0 || s.call(e, e));
      });
    }), () => {
      var s;
      return l.value ? o ? (s = n.default) === null || s === void 0 ? void 0 : s.call(n) : r ? f(Jm, {
        to: r
      }, n) : null : null;
    };
  }
});
let nv;
function md(e) {
  if (typeof document > "u")
    return 0;
  if (nv === void 0) {
    const t = document.createElement("div");
    t.style.width = "100%", t.style.height = "200px";
    const n = document.createElement("div"), o = n.style;
    o.position = "absolute", o.top = "0", o.left = "0", o.pointerEvents = "none", o.visibility = "hidden", o.width = "200px", o.height = "150px", o.overflow = "hidden", n.appendChild(t), document.body.appendChild(n);
    const r = t.offsetWidth;
    n.style.overflow = "scroll";
    let l = t.offsetWidth;
    r === l && (l = n.clientWidth), document.body.removeChild(n), nv = r - l;
  }
  return nv;
}
function q1(e) {
  const t = e.match(/^(.*)px$/), n = Number(t == null ? void 0 : t[1]);
  return Number.isNaN(n) ? md() : n;
}
function UA(e) {
  if (typeof document > "u" || !e || !(e instanceof Element))
    return {
      width: 0,
      height: 0
    };
  const {
    width: t,
    height: n
  } = getComputedStyle(e, "::-webkit-scrollbar");
  return {
    width: q1(t),
    height: q1(n)
  };
}
const YA = `vc-util-locker-${Date.now()}`;
let Z1 = 0;
function qA() {
  return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
}
function ZA(e) {
  const t = P(() => !!e && !!e.value);
  Z1 += 1;
  const n = `${YA}_${Z1}`;
  Le((o) => {
    if (jn()) {
      if (t.value) {
        const r = md(), l = qA();
        Rs(`
html body {
  overflow-y: hidden;
  ${l ? `width: calc(100% - ${r}px);` : ""}
}`, n);
      } else
        cd(n);
      o(() => {
        cd(n);
      });
    }
  }, {
    flush: "post"
  });
}
let Al = 0;
const hu = jn(), Q1 = (e) => {
  if (!hu)
    return null;
  if (e) {
    if (typeof e == "string")
      return document.querySelectorAll(e)[0];
    if (typeof e == "function")
      return e();
    if (typeof e == "object" && e instanceof window.HTMLElement)
      return e;
  }
  return document.body;
}, lc = Z({
  compatConfig: {
    MODE: 3
  },
  name: "PortalWrapper",
  inheritAttrs: !1,
  props: {
    wrapperClassName: String,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getContainer: V.any,
    visible: {
      type: Boolean,
      default: void 0
    },
    autoLock: ve(),
    didUpdate: Function
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Q(), r = Q(), l = Q(), a = Q(1), i = jn() && document.createElement("div"), s = () => {
      var v, h;
      o.value === i && ((h = (v = o.value) === null || v === void 0 ? void 0 : v.parentNode) === null || h === void 0 || h.removeChild(o.value)), o.value = null;
    };
    let c = null;
    const u = function() {
      return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1) || o.value && !o.value.parentNode ? (c = Q1(e.getContainer), c ? (c.appendChild(o.value), !0) : !1) : !0;
    }, d = () => hu ? (o.value || (o.value = i, u(!0)), p(), o.value) : null, p = () => {
      const {
        wrapperClassName: v
      } = e;
      o.value && v && v !== o.value.className && (o.value.className = v);
    };
    return co(() => {
      p(), u();
    }), ZA(P(() => e.autoLock && e.visible && jn() && (o.value === document.body || o.value === i))), Ke(() => {
      let v = !1;
      ie([() => e.visible, () => e.getContainer], (h, g) => {
        let [b, y] = h, [S, C] = g;
        hu && (c = Q1(e.getContainer), c === document.body && (b && !S ? Al += 1 : v && (Al -= 1))), v && (typeof y == "function" && typeof C == "function" ? y.toString() !== C.toString() : y !== C) && s(), v = !0;
      }, {
        immediate: !0,
        flush: "post"
      }), rt(() => {
        u() || (l.value = Ze(() => {
          a.value += 1;
        }));
      });
    }), et(() => {
      const {
        visible: v
      } = e;
      hu && c === document.body && (Al = v && Al ? Al - 1 : Al), s(), Ze.cancel(l.value);
    }), () => {
      const {
        forceRender: v,
        visible: h
      } = e;
      let g = null;
      const b = {
        getOpenCount: () => Al,
        getContainer: d
      };
      return a.value && (v || h || r.value) && (g = f(x4, {
        getContainer: d,
        ref: r,
        didUpdate: e.didUpdate
      }, {
        default: () => {
          var y;
          return (y = n.default) === null || y === void 0 ? void 0 : y.call(n, b);
        }
      })), g;
    };
  }
}), QA = ["onClick", "onMousedown", "onTouchstart", "onMouseenter", "onMouseleave", "onFocus", "onBlur", "onContextmenu"], $a = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Trigger",
  mixins: [Ca],
  inheritAttrs: !1,
  props: e4(),
  setup(e) {
    const t = P(() => {
      const {
        popupPlacement: r,
        popupAlign: l,
        builtinPlacements: a
      } = e;
      return r && a ? Y1(a, r, l) : l;
    }), n = Q(null), o = (r) => {
      n.value = r;
    };
    return {
      vcTriggerContext: tt("vcTriggerContext", {}),
      popupRef: n,
      setPopupRef: o,
      triggerRef: Q(null),
      align: t,
      focusTime: null,
      clickOutsideHandler: null,
      contextmenuOutsideHandler1: null,
      contextmenuOutsideHandler2: null,
      touchOutsideHandler: null,
      attachId: null,
      delayTimer: null,
      hasPopupMouseDown: !1,
      preClickTime: null,
      preTouchTime: null,
      mouseDownTimeout: null,
      childOriginEvents: {}
    };
  },
  data() {
    const e = this.$props;
    let t;
    return this.popupVisible !== void 0 ? t = !!e.popupVisible : t = !!e.defaultPopupVisible, QA.forEach((n) => {
      this[`fire${n}`] = (o) => {
        this.fireEvents(n, o);
      };
    }), {
      prevPopupVisible: t,
      sPopupVisible: t,
      point: null
    };
  },
  watch: {
    popupVisible(e) {
      e !== void 0 && (this.prevPopupVisible = this.sPopupVisible, this.sPopupVisible = e);
    }
  },
  created() {
    Je("vcTriggerContext", {
      onPopupMouseDown: this.onPopupMouseDown,
      onPopupMouseenter: this.onPopupMouseenter,
      onPopupMouseleave: this.onPopupMouseleave
    }), Rh(this);
  },
  deactivated() {
    this.setPopupVisible(!1);
  },
  mounted() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  updated() {
    this.$nextTick(() => {
      this.updatedCal();
    });
  },
  beforeUnmount() {
    this.clearDelayTimer(), this.clearOutsideHandler(), clearTimeout(this.mouseDownTimeout), Ze.cancel(this.attachId);
  },
  methods: {
    updatedCal() {
      const e = this.$props;
      if (this.$data.sPopupVisible) {
        let n;
        !this.clickOutsideHandler && (this.isClickToHide() || this.isContextmenuToShow()) && (n = e.getDocument(this.getRootDomNode()), this.clickOutsideHandler = Bt(n, "mousedown", this.onDocumentClick)), this.touchOutsideHandler || (n = n || e.getDocument(this.getRootDomNode()), this.touchOutsideHandler = Bt(n, "touchstart", this.onDocumentClick, on ? {
          passive: !1
        } : !1)), !this.contextmenuOutsideHandler1 && this.isContextmenuToShow() && (n = n || e.getDocument(this.getRootDomNode()), this.contextmenuOutsideHandler1 = Bt(n, "scroll", this.onContextmenuClose)), !this.contextmenuOutsideHandler2 && this.isContextmenuToShow() && (this.contextmenuOutsideHandler2 = Bt(window, "blur", this.onContextmenuClose));
      } else
        this.clearOutsideHandler();
    },
    onMouseenter(e) {
      const {
        mouseEnterDelay: t
      } = this.$props;
      this.fireEvents("onMouseenter", e), this.delaySetPopupVisible(!0, t, t ? null : e);
    },
    onMouseMove(e) {
      this.fireEvents("onMousemove", e), this.setPoint(e);
    },
    onMouseleave(e) {
      this.fireEvents("onMouseleave", e), this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
    },
    onPopupMouseenter() {
      const {
        vcTriggerContext: e = {}
      } = this;
      e.onPopupMouseenter && e.onPopupMouseenter(), this.clearDelayTimer();
    },
    onPopupMouseleave(e) {
      var t;
      if (e && e.relatedTarget && !e.relatedTarget.setTimeout && sl((t = this.popupRef) === null || t === void 0 ? void 0 : t.getElement(), e.relatedTarget))
        return;
      this.isMouseLeaveToHide() && this.delaySetPopupVisible(!1, this.$props.mouseLeaveDelay);
      const {
        vcTriggerContext: n = {}
      } = this;
      n.onPopupMouseleave && n.onPopupMouseleave(e);
    },
    onFocus(e) {
      this.fireEvents("onFocus", e), this.clearDelayTimer(), this.isFocusToShow() && (this.focusTime = Date.now(), this.delaySetPopupVisible(!0, this.$props.focusDelay));
    },
    onMousedown(e) {
      this.fireEvents("onMousedown", e), this.preClickTime = Date.now();
    },
    onTouchstart(e) {
      this.fireEvents("onTouchstart", e), this.preTouchTime = Date.now();
    },
    onBlur(e) {
      sl(e.target, e.relatedTarget || document.activeElement) || (this.fireEvents("onBlur", e), this.clearDelayTimer(), this.isBlurToHide() && this.delaySetPopupVisible(!1, this.$props.blurDelay));
    },
    onContextmenu(e) {
      e.preventDefault(), this.fireEvents("onContextmenu", e), this.setPopupVisible(!0, e);
    },
    onContextmenuClose() {
      this.isContextmenuToShow() && this.close();
    },
    onClick(e) {
      if (this.fireEvents("onClick", e), this.focusTime) {
        let n;
        if (this.preClickTime && this.preTouchTime ? n = Math.min(this.preClickTime, this.preTouchTime) : this.preClickTime ? n = this.preClickTime : this.preTouchTime && (n = this.preTouchTime), Math.abs(n - this.focusTime) < 20)
          return;
        this.focusTime = 0;
      }
      this.preClickTime = 0, this.preTouchTime = 0, this.isClickToShow() && (this.isClickToHide() || this.isBlurToHide()) && e && e.preventDefault && e.preventDefault(), e && e.domEvent && e.domEvent.preventDefault();
      const t = !this.$data.sPopupVisible;
      (this.isClickToHide() && !t || t && this.isClickToShow()) && this.setPopupVisible(!this.$data.sPopupVisible, e);
    },
    onPopupMouseDown() {
      const {
        vcTriggerContext: e = {}
      } = this;
      this.hasPopupMouseDown = !0, clearTimeout(this.mouseDownTimeout), this.mouseDownTimeout = setTimeout(() => {
        this.hasPopupMouseDown = !1;
      }, 0), e.onPopupMouseDown && e.onPopupMouseDown(...arguments);
    },
    onDocumentClick(e) {
      if (this.$props.mask && !this.$props.maskClosable)
        return;
      const t = e.target, n = this.getRootDomNode(), o = this.getPopupDomNode();
      // mousedown on the target should also close popup when action is contextMenu.
      // https://github.com/ant-design/ant-design/issues/29853
      (!sl(n, t) || this.isContextMenuOnly()) && !sl(o, t) && !this.hasPopupMouseDown && this.delaySetPopupVisible(!1, 0.1);
    },
    getPopupDomNode() {
      var e;
      return ((e = this.popupRef) === null || e === void 0 ? void 0 : e.getElement()) || null;
    },
    getRootDomNode() {
      var e, t, n, o;
      const {
        getTriggerDOMNode: r
      } = this.$props;
      if (r) {
        const l = ((t = (e = this.triggerRef) === null || e === void 0 ? void 0 : e.$el) === null || t === void 0 ? void 0 : t.nodeName) === "#comment" ? null : qn(this.triggerRef);
        return qn(r(l));
      }
      try {
        const l = ((o = (n = this.triggerRef) === null || n === void 0 ? void 0 : n.$el) === null || o === void 0 ? void 0 : o.nodeName) === "#comment" ? null : qn(this.triggerRef);
        if (l)
          return l;
      } catch {
      }
      return qn(this);
    },
    handleGetPopupClassFromAlign(e) {
      const t = [], n = this.$props, {
        popupPlacement: o,
        builtinPlacements: r,
        prefixCls: l,
        alignPoint: a,
        getPopupClassNameFromAlign: i
      } = n;
      return o && r && t.push(GA(r, l, e, a)), i && t.push(i(e)), t.join(" ");
    },
    getPopupAlign() {
      const e = this.$props, {
        popupPlacement: t,
        popupAlign: n,
        builtinPlacements: o
      } = e;
      return t && o ? Y1(o, t, n) : n;
    },
    getComponent() {
      const e = {};
      this.isMouseEnterToShow() && (e.onMouseenter = this.onPopupMouseenter), this.isMouseLeaveToHide() && (e.onMouseleave = this.onPopupMouseleave), e.onMousedown = this.onPopupMouseDown, e[on ? "onTouchstartPassive" : "onTouchstart"] = this.onPopupMouseDown;
      const {
        handleGetPopupClassFromAlign: t,
        getRootDomNode: n,
        $attrs: o
      } = this, {
        prefixCls: r,
        destroyPopupOnHide: l,
        popupClassName: a,
        popupAnimation: i,
        popupTransitionName: s,
        popupStyle: c,
        mask: u,
        maskAnimation: d,
        maskTransitionName: p,
        zIndex: v,
        stretch: h,
        alignPoint: g,
        mobile: b,
        arrow: y,
        forceRender: S
      } = this.$props, {
        sPopupVisible: C,
        point: w
      } = this.$data, $ = m(m({
        prefixCls: r,
        arrow: y,
        destroyPopupOnHide: l,
        visible: C,
        point: g ? w : null,
        align: this.align,
        animation: i,
        getClassNameFromAlign: t,
        stretch: h,
        getRootDomNode: n,
        mask: u,
        zIndex: v,
        transitionName: s,
        maskAnimation: d,
        maskTransitionName: p,
        class: a,
        style: c,
        onAlign: o.onPopupAlign || J2
      }, e), {
        ref: this.setPopupRef,
        mobile: b,
        forceRender: S
      });
      return f(WA, $, {
        default: this.$slots.popup || (() => Gx(this, "popup"))
      });
    },
    attachParent(e) {
      Ze.cancel(this.attachId);
      const {
        getPopupContainer: t,
        getDocument: n
      } = this.$props, o = this.getRootDomNode();
      let r;
      t ? (o || t.length === 0) && (r = t(o)) : r = n(this.getRootDomNode()).body, r ? r.appendChild(e) : this.attachId = Ze(() => {
        this.attachParent(e);
      });
    },
    getContainer() {
      const {
        $props: e
      } = this, {
        getDocument: t
      } = e, n = t(this.getRootDomNode()).createElement("div");
      return n.style.position = "absolute", n.style.top = "0", n.style.left = "0", n.style.width = "100%", this.attachParent(n), n;
    },
    setPopupVisible(e, t) {
      const {
        alignPoint: n,
        sPopupVisible: o,
        onPopupVisibleChange: r
      } = this;
      this.clearDelayTimer(), o !== e && (Rr(this, "popupVisible") || this.setState({
        sPopupVisible: e,
        prevPopupVisible: o
      }), r && r(e)), n && t && e && this.setPoint(t);
    },
    setPoint(e) {
      const {
        alignPoint: t
      } = this.$props;
      !t || !e || this.setState({
        point: {
          pageX: e.pageX,
          pageY: e.pageY
        }
      });
    },
    handlePortalUpdate() {
      this.prevPopupVisible !== this.sPopupVisible && this.afterPopupVisibleChange(this.sPopupVisible);
    },
    delaySetPopupVisible(e, t, n) {
      const o = t * 1e3;
      if (this.clearDelayTimer(), o) {
        const r = n ? {
          pageX: n.pageX,
          pageY: n.pageY
        } : null;
        this.delayTimer = setTimeout(() => {
          this.setPopupVisible(e, r), this.clearDelayTimer();
        }, o);
      } else
        this.setPopupVisible(e, n);
    },
    clearDelayTimer() {
      this.delayTimer && (clearTimeout(this.delayTimer), this.delayTimer = null);
    },
    clearOutsideHandler() {
      this.clickOutsideHandler && (this.clickOutsideHandler.remove(), this.clickOutsideHandler = null), this.contextmenuOutsideHandler1 && (this.contextmenuOutsideHandler1.remove(), this.contextmenuOutsideHandler1 = null), this.contextmenuOutsideHandler2 && (this.contextmenuOutsideHandler2.remove(), this.contextmenuOutsideHandler2 = null), this.touchOutsideHandler && (this.touchOutsideHandler.remove(), this.touchOutsideHandler = null);
    },
    createTwoChains(e) {
      let t = () => {
      };
      const n = By(this);
      return this.childOriginEvents[e] && n[e] ? this[`fire${e}`] : (t = this.childOriginEvents[e] || n[e] || t, t);
    },
    isClickToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("click") !== -1 || t.indexOf("click") !== -1;
    },
    isContextMenuOnly() {
      const {
        action: e
      } = this.$props;
      return e === "contextmenu" || e.length === 1 && e[0] === "contextmenu";
    },
    isContextmenuToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("contextmenu") !== -1 || t.indexOf("contextmenu") !== -1;
    },
    isClickToHide() {
      const {
        action: e,
        hideAction: t
      } = this.$props;
      return e.indexOf("click") !== -1 || t.indexOf("click") !== -1;
    },
    isMouseEnterToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("hover") !== -1 || t.indexOf("mouseenter") !== -1;
    },
    isMouseLeaveToHide() {
      const {
        action: e,
        hideAction: t
      } = this.$props;
      return e.indexOf("hover") !== -1 || t.indexOf("mouseleave") !== -1;
    },
    isFocusToShow() {
      const {
        action: e,
        showAction: t
      } = this.$props;
      return e.indexOf("focus") !== -1 || t.indexOf("focus") !== -1;
    },
    isBlurToHide() {
      const {
        action: e,
        hideAction: t
      } = this.$props;
      return e.indexOf("focus") !== -1 || t.indexOf("blur") !== -1;
    },
    forcePopupAlign() {
      var e;
      this.$data.sPopupVisible && ((e = this.popupRef) === null || e === void 0 || e.forceAlign());
    },
    fireEvents(e, t) {
      this.childOriginEvents[e] && this.childOriginEvents[e](t);
      const n = this.$props[e] || this.$attrs[e];
      n && n(t);
    },
    close() {
      this.setPopupVisible(!1);
    }
  },
  render() {
    const {
      $attrs: e
    } = this, t = Lt(hf(this)), {
      alignPoint: n,
      getPopupContainer: o
    } = this.$props, r = t[0];
    this.childOriginEvents = By(r);
    const l = {
      key: "trigger"
    };
    this.isContextmenuToShow() ? l.onContextmenu = this.onContextmenu : l.onContextmenu = this.createTwoChains("onContextmenu"), this.isClickToHide() || this.isClickToShow() ? (l.onClick = this.onClick, l.onMousedown = this.onMousedown, l[on ? "onTouchstartPassive" : "onTouchstart"] = this.onTouchstart) : (l.onClick = this.createTwoChains("onClick"), l.onMousedown = this.createTwoChains("onMousedown"), l[on ? "onTouchstartPassive" : "onTouchstart"] = this.createTwoChains("onTouchstart")), this.isMouseEnterToShow() ? (l.onMouseenter = this.onMouseenter, n && (l.onMousemove = this.onMouseMove)) : l.onMouseenter = this.createTwoChains("onMouseenter"), this.isMouseLeaveToHide() ? l.onMouseleave = this.onMouseleave : l.onMouseleave = this.createTwoChains("onMouseleave"), this.isFocusToShow() || this.isBlurToHide() ? (l.onFocus = this.onFocus, l.onBlur = this.onBlur) : (l.onFocus = this.createTwoChains("onFocus"), l.onBlur = (c) => {
      c && (!c.relatedTarget || !sl(c.target, c.relatedTarget)) && this.createTwoChains("onBlur")(c);
    });
    const a = ee(r && r.props && r.props.class, e.class);
    a && (l.class = a);
    const i = yt(r, m(m({}, l), {
      ref: "triggerRef"
    }), !0, !0), s = f(lc, {
      key: "portal",
      getContainer: o && (() => o(this.getRootDomNode())),
      didUpdate: this.handlePortalUpdate,
      visible: this.$data.sPopupVisible
    }, {
      default: this.getComponent
    });
    return f(Fe, null, [i, s]);
  }
});
var JA = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const eD = (e) => {
  const t = e === !0 ? 0 : 1;
  return {
    bottomLeft: {
      points: ["tl", "bl"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ["tr", "br"],
      offset: [0, 4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    topLeft: {
      points: ["bl", "tl"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    },
    topRight: {
      points: ["br", "tr"],
      offset: [0, -4],
      overflow: {
        adjustX: t,
        adjustY: 1
      }
    }
  };
}, tD = Z({
  name: "SelectTrigger",
  inheritAttrs: !1,
  props: {
    dropdownAlign: Object,
    visible: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownStyle: V.object,
    placement: String,
    empty: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    popupClassName: String,
    animation: String,
    transitionName: String,
    getPopupContainer: Function,
    dropdownRender: Function,
    containerWidth: Number,
    dropdownMatchSelectWidth: V.oneOfType([Number, Boolean]).def(!0),
    popupElement: V.any,
    direction: String,
    getTriggerDOMNode: Function,
    onPopupVisibleChange: Function,
    onPopupMouseEnter: Function,
    onPopupFocusin: Function,
    onPopupFocusout: Function
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const l = P(() => {
      const {
        dropdownMatchSelectWidth: i
      } = e;
      return eD(i);
    }), a = Y();
    return r({
      getPopupElement: () => a.value
    }), () => {
      const i = m(m({}, e), o), {
        empty: s = !1
      } = i, c = JA(i, ["empty"]), {
        visible: u,
        dropdownAlign: d,
        prefixCls: p,
        popupElement: v,
        dropdownClassName: h,
        dropdownStyle: g,
        direction: b = "ltr",
        placement: y,
        dropdownMatchSelectWidth: S,
        containerWidth: C,
        dropdownRender: w,
        animation: $,
        transitionName: O,
        getPopupContainer: x,
        getTriggerDOMNode: I,
        onPopupVisibleChange: E,
        onPopupMouseEnter: _,
        onPopupFocusin: M,
        onPopupFocusout: R
      } = c, A = `${p}-dropdown`;
      let z = v;
      w && (z = w({
        menuNode: v,
        props: e
      }));
      const T = $ ? `${A}-${$}` : O, N = m({
        minWidth: `${C}px`
      }, g);
      return typeof S == "number" ? N.width = `${S}px` : S && (N.width = `${C}px`), f($a, D(D({}, e), {}, {
        showAction: E ? ["click"] : [],
        hideAction: E ? ["click"] : [],
        popupPlacement: y || (b === "rtl" ? "bottomRight" : "bottomLeft"),
        builtinPlacements: l.value,
        prefixCls: A,
        popupTransitionName: T,
        popupAlign: d,
        popupVisible: u,
        getPopupContainer: x,
        popupClassName: ee(h, {
          [`${A}-empty`]: s
        }),
        popupStyle: N,
        getTriggerDOMNode: I,
        onPopupVisibleChange: E
      }), {
        default: n.default,
        popup: () => f("div", {
          ref: a,
          onMouseenter: _,
          onFocusin: M,
          onFocusout: R
        }, [z])
      });
    };
  }
}), ce = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  /**
   * END
   */
  END: 35,
  /**
   * HOME
   */
  HOME: 36,
  /**
   * LEFT
   */
  LEFT: 37,
  /**
   * UP
   */
  UP: 38,
  /**
   * RIGHT
   */
  RIGHT: 39,
  /**
   * DOWN
   */
  DOWN: 40,
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  /**
   * DELETE
   */
  DELETE: 46,
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  /**
   * DASH
   */
  DASH: 189,
  /**
   * EQUALS
   */
  EQUALS: 187,
  /**
   * COMMA
   */
  COMMA: 188,
  /**
   * PERIOD
   */
  PERIOD: 190,
  /**
   * SLASH
   */
  SLASH: 191,
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================
  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function(t) {
    const {
      keyCode: n
    } = t;
    if (t.altKey && !t.ctrlKey || t.metaKey || // Function keys don't generate text
    n >= ce.F1 && n <= ce.F12)
      return !1;
    switch (n) {
      case ce.ALT:
      case ce.CAPS_LOCK:
      case ce.CONTEXT_MENU:
      case ce.CTRL:
      case ce.DOWN:
      case ce.END:
      case ce.ESC:
      case ce.HOME:
      case ce.INSERT:
      case ce.LEFT:
      case ce.MAC_FF_META:
      case ce.META:
      case ce.NUMLOCK:
      case ce.NUM_CENTER:
      case ce.PAGE_DOWN:
      case ce.PAGE_UP:
      case ce.PAUSE:
      case ce.PRINT_SCREEN:
      case ce.RIGHT:
      case ce.SHIFT:
      case ce.UP:
      case ce.WIN_KEY:
      case ce.WIN_KEY_RIGHT:
        return !1;
      default:
        return !0;
    }
  },
  /**
   * whether character is entered.
   */
  isCharacterKey: function(t) {
    if (t >= ce.ZERO && t <= ce.NINE || t >= ce.NUM_ZERO && t <= ce.NUM_MULTIPLY || t >= ce.A && t <= ce.Z || window.navigator.userAgent.indexOf("WebKit") !== -1 && t === 0)
      return !0;
    switch (t) {
      case ce.SPACE:
      case ce.QUESTION_MARK:
      case ce.NUM_PLUS:
      case ce.NUM_MINUS:
      case ce.NUM_PERIOD:
      case ce.NUM_DIVISION:
      case ce.SEMICOLON:
      case ce.DASH:
      case ce.EQUALS:
      case ce.COMMA:
      case ce.PERIOD:
      case ce.SLASH:
      case ce.APOSTROPHE:
      case ce.SINGLE_QUOTE:
      case ce.OPEN_SQUARE_BRACKET:
      case ce.BACKSLASH:
      case ce.CLOSE_SQUARE_BRACKET:
        return !0;
      default:
        return !1;
    }
  }
}, da = (e, t) => {
  let {
    slots: n
  } = t;
  var o;
  const {
    class: r,
    customizeIcon: l,
    customizeIconProps: a,
    onMousedown: i,
    onClick: s
  } = e;
  let c;
  return typeof l == "function" ? c = l(a) : c = In(l) ? tr(l) : l, f("span", {
    class: r,
    onMousedown: (u) => {
      u.preventDefault(), i && i(u);
    },
    style: {
      userSelect: "none",
      WebkitUserSelect: "none"
    },
    unselectable: "on",
    onClick: s,
    "aria-hidden": !0
  }, [c !== void 0 ? c : f("span", {
    class: r.split(/\s+/).map((u) => `${u}-icon`)
  }, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)])]);
};
da.inheritAttrs = !1;
da.displayName = "TransBtn";
da.props = {
  class: String,
  customizeIcon: V.any,
  customizeIconProps: V.any,
  onMousedown: Function,
  onClick: Function
};
var nD = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const oD = Z({
  compatConfig: {
    MODE: 3
  },
  // inheritAttrs: false,
  props: {
    disabled: V.looseBool,
    type: V.string,
    value: V.any,
    tag: {
      type: String,
      default: "input"
    },
    size: V.string,
    onChange: Function,
    onInput: Function,
    onBlur: Function,
    onFocus: Function,
    onKeydown: Function,
    onCompositionstart: Function,
    onCompositionend: Function,
    onKeyup: Function,
    onPaste: Function,
    onMousedown: Function
  },
  emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown"],
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = Q(null);
    return n({
      focus: () => {
        o.value && o.value.focus();
      },
      blur: () => {
        o.value && o.value.blur();
      },
      input: o,
      setSelectionRange: (s, c, u) => {
        var d;
        (d = o.value) === null || d === void 0 || d.setSelectionRange(s, c, u);
      },
      select: () => {
        var s;
        (s = o.value) === null || s === void 0 || s.select();
      },
      getSelectionStart: () => {
        var s;
        return (s = o.value) === null || s === void 0 ? void 0 : s.selectionStart;
      },
      getSelectionEnd: () => {
        var s;
        return (s = o.value) === null || s === void 0 ? void 0 : s.selectionEnd;
      },
      getScrollTop: () => {
        var s;
        return (s = o.value) === null || s === void 0 ? void 0 : s.scrollTop;
      }
    }), () => {
      const {
        tag: s,
        value: c
      } = e, u = nD(e, ["tag", "value"]);
      return f(s, D(D({}, u), {}, {
        ref: o,
        value: c
      }), null);
    };
  }
});
function rD() {
  const e = document.documentElement.clientWidth, t = window.innerHeight || document.documentElement.clientHeight;
  return {
    width: e,
    height: t
  };
}
function hd(e) {
  const t = e.getBoundingClientRect(), n = document.documentElement;
  return {
    left: t.left + (window.scrollX || n.scrollLeft) - (n.clientLeft || document.body.clientLeft || 0),
    top: t.top + (window.scrollY || n.scrollTop) - (n.clientTop || document.body.clientTop || 0)
  };
}
function lD(e) {
  return Array.prototype.slice.apply(e).map((n) => `${n}: ${e.getPropertyValue(n)};`).join("");
}
function aD(e) {
  return Object.keys(e).reduce((t, n) => {
    const o = e[n];
    return typeof o > "u" || o === null || (t += `${n}: ${e[n]};`), t;
  }, "");
}
var iD = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Ti = Z({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: {
    disabled: V.looseBool,
    type: V.string,
    value: V.any,
    lazy: V.bool.def(!0),
    tag: {
      type: String,
      default: "input"
    },
    size: V.string,
    style: V.oneOfType([String, Object]),
    class: V.string
  },
  emits: ["change", "input", "blur", "keydown", "focus", "compositionstart", "compositionend", "keyup", "paste", "mousedown"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      expose: r
    } = t;
    const l = Q(null), a = Y(), i = Y(!1);
    ie([() => e.value, i], () => {
      i.value || (a.value = e.value);
    }, {
      immediate: !0
    });
    const s = (x) => {
      n("change", x);
    }, c = (x) => {
      i.value = !0, x.target.composing = !0, n("compositionstart", x);
    }, u = (x) => {
      i.value = !1, x.target.composing = !1, n("compositionend", x);
      const I = document.createEvent("HTMLEvents");
      I.initEvent("input", !0, !0), x.target.dispatchEvent(I), s(x);
    }, d = (x) => {
      if (i.value && e.lazy) {
        a.value = x.target.value;
        return;
      }
      n("input", x);
    }, p = (x) => {
      n("blur", x);
    }, v = (x) => {
      n("focus", x);
    }, h = () => {
      l.value && l.value.focus();
    }, g = () => {
      l.value && l.value.blur();
    }, b = (x) => {
      n("keydown", x);
    }, y = (x) => {
      n("keyup", x);
    }, S = (x, I, E) => {
      var _;
      (_ = l.value) === null || _ === void 0 || _.setSelectionRange(x, I, E);
    }, C = () => {
      var x;
      (x = l.value) === null || x === void 0 || x.select();
    };
    r({
      focus: h,
      blur: g,
      input: P(() => {
        var x;
        return (x = l.value) === null || x === void 0 ? void 0 : x.input;
      }),
      setSelectionRange: S,
      select: C,
      getSelectionStart: () => {
        var x;
        return (x = l.value) === null || x === void 0 ? void 0 : x.getSelectionStart();
      },
      getSelectionEnd: () => {
        var x;
        return (x = l.value) === null || x === void 0 ? void 0 : x.getSelectionEnd();
      },
      getScrollTop: () => {
        var x;
        return (x = l.value) === null || x === void 0 ? void 0 : x.getScrollTop();
      }
    });
    const w = (x) => {
      n("mousedown", x);
    }, $ = (x) => {
      n("paste", x);
    }, O = P(() => e.style && typeof e.style != "string" ? aD(e.style) : e.style);
    return () => {
      const x = iD(e, ["style", "lazy"]);
      return f(oD, D(D(D({}, x), o), {}, {
        style: O.value,
        onInput: d,
        onChange: s,
        onBlur: p,
        onFocus: v,
        ref: l,
        value: a.value,
        onCompositionstart: c,
        onCompositionend: u,
        onKeyup: y,
        onKeydown: b,
        onPaste: $,
        onMousedown: w
      }), null);
    };
  }
}), sD = {
  inputRef: V.any,
  prefixCls: String,
  id: String,
  inputElement: V.VueNode,
  disabled: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  editable: {
    type: Boolean,
    default: void 0
  },
  activeDescendantId: String,
  value: String,
  open: {
    type: Boolean,
    default: void 0
  },
  tabindex: V.oneOfType([V.number, V.string]),
  /** Pass accessibility props to input */
  attrs: V.object,
  onKeydown: {
    type: Function
  },
  onMousedown: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPaste: {
    type: Function
  },
  onCompositionstart: {
    type: Function
  },
  onCompositionend: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  }
}, O4 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "SelectInput",
  inheritAttrs: !1,
  props: sD,
  setup(e) {
    let t = null;
    const n = tt("VCSelectContainerEvent");
    return () => {
      var o;
      const {
        prefixCls: r,
        id: l,
        inputElement: a,
        disabled: i,
        tabindex: s,
        autofocus: c,
        autocomplete: u,
        editable: d,
        activeDescendantId: p,
        value: v,
        onKeydown: h,
        onMousedown: g,
        onChange: b,
        onPaste: y,
        onCompositionstart: S,
        onCompositionend: C,
        onFocus: w,
        onBlur: $,
        open: O,
        inputRef: x,
        attrs: I
      } = e;
      let E = a || f(Ti, null, null);
      const _ = E.props || {}, {
        onKeydown: M,
        onInput: R,
        onFocus: A,
        onBlur: z,
        onMousedown: T,
        onCompositionstart: N,
        onCompositionend: k,
        style: B
      } = _;
      return E = yt(E, m(m(m(m(m({
        type: "search"
      }, _), {
        id: l,
        ref: x,
        disabled: i,
        tabindex: s,
        lazy: !1,
        autocomplete: u || "off",
        autofocus: c,
        class: ee(`${r}-selection-search-input`, (o = E == null ? void 0 : E.props) === null || o === void 0 ? void 0 : o.class),
        role: "combobox",
        "aria-expanded": O,
        "aria-haspopup": "listbox",
        "aria-owns": `${l}_list`,
        "aria-autocomplete": "list",
        "aria-controls": `${l}_list`,
        "aria-activedescendant": p
      }), I), {
        value: d ? v : "",
        readonly: !d,
        unselectable: d ? null : "on",
        style: m(m({}, B), {
          opacity: d ? null : 0
        }),
        onKeydown: (F) => {
          h(F), M && M(F);
        },
        onMousedown: (F) => {
          g(F), T && T(F);
        },
        onInput: (F) => {
          b(F), R && R(F);
        },
        onCompositionstart(F) {
          S(F), N && N(F);
        },
        onCompositionend(F) {
          C(F), k && k(F);
        },
        onPaste: y,
        onFocus: function() {
          clearTimeout(t), A && A(arguments.length <= 0 ? void 0 : arguments[0]), w && w(arguments.length <= 0 ? void 0 : arguments[0]), n == null || n.focus(arguments.length <= 0 ? void 0 : arguments[0]);
        },
        onBlur: function() {
          for (var F = arguments.length, L = new Array(F), j = 0; j < F; j++)
            L[j] = arguments[j];
          t = setTimeout(() => {
            z && z(L[0]), $ && $(L[0]), n == null || n.blur(L[0]);
          }, 100);
        }
      }), E.type === "textarea" ? {} : {
        type: "search"
      }), !0, !0), E;
    };
  }
}), cD = `accept acceptcharset accesskey action allowfullscreen allowtransparency
alt async autocomplete autofocus autoplay capture cellpadding cellspacing challenge
charset checked classid classname colspan cols content contenteditable contextmenu
controls coords crossorigin data datetime default defer dir disabled download draggable
enctype form formaction formenctype formmethod formnovalidate formtarget frameborder
headers height hidden high href hreflang htmlfor for httpequiv icon id inputmode integrity
is keyparams keytype kind label lang list loop low manifest marginheight marginwidth max maxlength media
mediagroup method min minlength multiple muted name novalidate nonce open
optimum pattern placeholder poster preload radiogroup readonly rel required
reversed role rowspan rows sandbox scope scoped scrolling seamless selected
shape size sizes span spellcheck src srcdoc srclang srcset start step style
summary tabindex target title type usemap value width wmode wrap`, uD = `onCopy onCut onPaste onCompositionend onCompositionstart onCompositionupdate onKeydown
    onKeypress onKeyup onFocus onBlur onChange onInput onSubmit onClick onContextmenu onDoubleclick onDblclick
    onDrag onDragend onDragenter onDragexit onDragleave onDragover onDragstart onDrop onMousedown
    onMouseenter onMouseleave onMousemove onMouseout onMouseover onMouseup onSelect onTouchcancel
    onTouchend onTouchmove onTouchstart onTouchstartPassive onTouchmovePassive onScroll onWheel onAbort onCanplay onCanplaythrough
    onDurationchange onEmptied onEncrypted onEnded onError onLoadeddata onLoadedmetadata
    onLoadstart onPause onPlay onPlaying onProgress onRatechange onSeeked onSeeking onStalled onSuspend onTimeupdate onVolumechange onWaiting onLoad onError`, J1 = `${cD} ${uD}`.split(/[\s\n]+/), dD = "aria-", fD = "data-";
function eS(e, t) {
  return e.indexOf(t) === 0;
}
function wl(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n;
  t === !1 ? n = {
    aria: !0,
    data: !0,
    attr: !0
  } : t === !0 ? n = {
    aria: !0
  } : n = m({}, t);
  const o = {};
  return Object.keys(e).forEach((r) => {
    // Aria
    (n.aria && (r === "role" || eS(r, dD)) || // Data
    n.data && eS(r, fD) || // Attr
    n.attr && (J1.includes(r) || J1.includes(r.toLowerCase()))) && (o[r] = e[r]);
  }), o;
}
const P4 = Symbol("OverflowContextProviderKey"), Vg = Z({
  compatConfig: {
    MODE: 3
  },
  name: "OverflowContextProvider",
  inheritAttrs: !1,
  props: {
    value: {
      type: Object
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Je(P4, P(() => e.value)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), pD = () => tt(P4, P(() => null));
var vD = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Ta = void 0, bu = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Item",
  props: {
    prefixCls: String,
    item: V.any,
    renderItem: Function,
    responsive: Boolean,
    itemKey: {
      type: [String, Number]
    },
    registerSize: Function,
    display: Boolean,
    order: Number,
    component: V.any,
    invalidate: Boolean
  },
  setup(e, t) {
    let {
      slots: n,
      expose: o
    } = t;
    const r = P(() => e.responsive && !e.display), l = Y();
    o({
      itemNodeRef: l
    });
    function a(i) {
      e.registerSize(e.itemKey, i);
    }
    return uo(() => {
      a(null);
    }), () => {
      var i;
      const {
        prefixCls: s,
        invalidate: c,
        item: u,
        renderItem: d,
        responsive: p,
        registerSize: v,
        itemKey: h,
        display: g,
        order: b,
        component: y = "div"
      } = e, S = vD(e, ["prefixCls", "invalidate", "item", "renderItem", "responsive", "registerSize", "itemKey", "display", "order", "component"]), C = (i = n.default) === null || i === void 0 ? void 0 : i.call(n), w = d && u !== Ta ? d(u) : C;
      let $;
      c || ($ = {
        opacity: r.value ? 0 : 1,
        height: r.value ? 0 : Ta,
        overflowY: r.value ? "hidden" : Ta,
        order: p ? b : Ta,
        pointerEvents: r.value ? "none" : Ta,
        position: r.value ? "absolute" : Ta
      });
      const O = {};
      return r.value && (O["aria-hidden"] = !0), f(Fo, {
        disabled: !p,
        onResize: (x) => {
          let {
            offsetWidth: I
          } = x;
          a(I);
        }
      }, {
        default: () => f(y, D(D(D({
          class: ee(!c && s),
          style: $
        }, O), S), {}, {
          ref: l
        }), {
          default: () => [w]
        })
      });
    };
  }
});
var ov = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const gD = Z({
  compatConfig: {
    MODE: 3
  },
  name: "RawItem",
  inheritAttrs: !1,
  props: {
    component: V.any,
    title: V.any,
    id: String,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onClick: {
      type: Function
    },
    onKeydown: {
      type: Function
    },
    onFocus: {
      type: Function
    },
    role: String,
    tabindex: Number
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = pD();
    return () => {
      var l;
      if (!r.value) {
        const {
          component: d = "div"
        } = e, p = ov(e, ["component"]);
        return f(d, D(D({}, p), o), {
          default: () => [(l = n.default) === null || l === void 0 ? void 0 : l.call(n)]
        });
      }
      const a = r.value, {
        className: i
      } = a, s = ov(a, ["className"]), {
        class: c
      } = o, u = ov(o, ["class"]);
      return f(Vg, {
        value: null
      }, {
        default: () => [f(bu, D(D(D({
          class: ee(i, c)
        }, s), u), e), n)]
      });
    };
  }
});
var mD = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const I4 = "responsive", E4 = "invalidate";
function hD(e) {
  return `+ ${e.length} ...`;
}
const bD = () => ({
  id: String,
  prefixCls: String,
  data: Array,
  itemKey: [String, Number, Function],
  /** Used for `responsive`. It will limit render node to avoid perf issue */
  itemWidth: {
    type: Number,
    default: 10
  },
  renderItem: Function,
  /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
  renderRawItem: Function,
  maxCount: [Number, String],
  renderRest: Function,
  /** @private Do not use in your production. Render raw node that need wrap Item by developer self */
  renderRawRest: Function,
  suffix: V.any,
  component: String,
  itemComponent: V.any,
  /** @private This API may be refactor since not well design */
  onVisibleChange: Function,
  /** When set to `full`, ssr will render full items by default and remove at client side */
  ssr: String,
  onMousedown: Function,
  role: String
}), Vr = Z({
  name: "Overflow",
  inheritAttrs: !1,
  props: bD(),
  emits: ["visibleChange"],
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      slots: r
    } = t;
    const l = P(() => e.ssr === "full"), a = Q(null), i = P(() => a.value || 0), s = Q(/* @__PURE__ */ new Map()), c = Q(0), u = Q(0), d = Q(0), p = Q(null), v = Q(null), h = P(() => v.value === null && l.value ? Number.MAX_SAFE_INTEGER : v.value || 0), g = Q(!1), b = P(() => `${e.prefixCls}-item`), y = P(() => Math.max(c.value, u.value)), S = P(() => !!(e.data.length && e.maxCount === I4)), C = P(() => e.maxCount === E4), w = P(() => S.value || typeof e.maxCount == "number" && e.data.length > e.maxCount), $ = P(() => {
      let T = e.data;
      return S.value ? a.value === null && l.value ? T = e.data : T = e.data.slice(0, Math.min(e.data.length, i.value / e.itemWidth)) : typeof e.maxCount == "number" && (T = e.data.slice(0, e.maxCount)), T;
    }), O = P(() => S.value ? e.data.slice(h.value + 1) : e.data.slice($.value.length)), x = (T, N) => {
      var k;
      return typeof e.itemKey == "function" ? e.itemKey(T) : (k = e.itemKey && (T == null ? void 0 : T[e.itemKey])) !== null && k !== void 0 ? k : N;
    }, I = P(() => e.renderItem || ((T) => T)), E = (T, N) => {
      v.value = T, N || (g.value = T < e.data.length - 1, o("visibleChange", T));
    }, _ = (T, N) => {
      a.value = N.clientWidth;
    }, M = (T, N) => {
      const k = new Map(s.value);
      N === null ? k.delete(T) : k.set(T, N), s.value = k;
    }, R = (T, N) => {
      c.value = u.value, u.value = N;
    }, A = (T, N) => {
      d.value = N;
    }, z = (T) => s.value.get(x($.value[T], T));
    return ie([i, s, u, d, () => e.itemKey, $], () => {
      if (i.value && y.value && $.value) {
        let T = d.value;
        const N = $.value.length, k = N - 1;
        if (!N) {
          E(0), p.value = null;
          return;
        }
        for (let B = 0; B < N; B += 1) {
          const F = z(B);
          if (F === void 0) {
            E(B - 1, !0);
            break;
          }
          if (T += F, // Only one means `totalWidth` is the final width
          k === 0 && T <= i.value || // Last two width will be the final width
          B === k - 1 && T + z(k) <= i.value) {
            E(k), p.value = null;
            break;
          } else if (T + y.value > i.value) {
            E(B - 1), p.value = T - F - d.value + u.value;
            break;
          }
        }
        e.suffix && z(0) + d.value > i.value && (p.value = null);
      }
    }), () => {
      const T = g.value && !!O.value.length, {
        itemComponent: N,
        renderRawItem: k,
        renderRawRest: B,
        renderRest: F,
        prefixCls: L = "rc-overflow",
        suffix: j,
        component: H = "div",
        id: K,
        onMousedown: X
      } = e, {
        class: W,
        style: q
      } = n, J = mD(n, ["class", "style"]);
      let ne = {};
      p.value !== null && S.value && (ne = {
        position: "absolute",
        left: `${p.value}px`,
        top: 0
      });
      const te = {
        prefixCls: b.value,
        responsive: S.value,
        component: N,
        invalidate: C.value
      }, G = k ? (me, Ce) => {
        const fe = x(me, Ce);
        return f(Vg, {
          key: fe,
          value: m(m({}, te), {
            order: Ce,
            item: me,
            itemKey: fe,
            registerSize: M,
            display: Ce <= h.value
          })
        }, {
          default: () => [k(me, Ce)]
        });
      } : (me, Ce) => {
        const fe = x(me, Ce);
        return f(bu, D(D({}, te), {}, {
          order: Ce,
          key: fe,
          item: me,
          renderItem: I.value,
          itemKey: fe,
          registerSize: M,
          display: Ce <= h.value
        }), null);
      };
      let U = () => null;
      const re = {
        order: T ? h.value : Number.MAX_SAFE_INTEGER,
        className: `${b.value} ${b.value}-rest`,
        registerSize: R,
        display: T
      };
      if (B)
        B && (U = () => f(Vg, {
          value: m(m({}, te), re)
        }, {
          default: () => [B(O.value)]
        }));
      else {
        const me = F || hD;
        U = () => f(bu, D(D({}, te), re), {
          default: () => typeof me == "function" ? me(O.value) : me
        });
      }
      const se = () => {
        var me;
        return f(H, D({
          id: K,
          class: ee(!C.value && L, W),
          style: q,
          onMousedown: X,
          role: e.role
        }, J), {
          default: () => [$.value.map(G), w.value ? U() : null, j && f(bu, D(D({}, te), {}, {
            order: h.value,
            class: `${b.value}-suffix`,
            registerSize: A,
            display: !0,
            style: ne
          }), {
            default: () => j
          }), (me = r.default) === null || me === void 0 ? void 0 : me.call(r)]
        });
      };
      return f(Fo, {
        disabled: !S.value,
        onResize: _
      }, {
        default: se
      });
    };
  }
});
Vr.Item = gD;
Vr.RESPONSIVE = I4;
Vr.INVALIDATE = E4;
const T4 = Symbol("TreeSelectLegacyContextPropsKey");
function yD(e) {
  return Je(T4, e);
}
function Rf() {
  return tt(T4, {});
}
const SD = {
  id: String,
  prefixCls: String,
  values: V.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: V.any,
  placeholder: V.any,
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: V.oneOfType([V.number, V.string]),
  compositionStatus: Boolean,
  removeIcon: V.any,
  choiceTransitionName: String,
  maxTagCount: V.oneOfType([V.number, V.string]),
  maxTagTextLength: Number,
  maxTagPlaceholder: V.any.def(() => (e) => `+ ${e.length} ...`),
  tagRender: Function,
  onToggleOpen: {
    type: Function
  },
  onRemove: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, tS = (e) => {
  e.preventDefault(), e.stopPropagation();
}, CD = Z({
  name: "MultipleSelectSelector",
  inheritAttrs: !1,
  props: SD,
  setup(e) {
    const t = Q(), n = Q(0), o = Q(!1), r = Rf(), l = P(() => `${e.prefixCls}-selection`), a = P(() => e.open || e.mode === "tags" ? e.searchValue : ""), i = P(() => e.mode === "tags" || e.showSearch && (e.open || o.value)), s = Y("");
    Le(() => {
      s.value = a.value;
    }), Ke(() => {
      ie(s, () => {
        n.value = t.value.scrollWidth;
      }, {
        flush: "post",
        immediate: !0
      });
    });
    function c(h, g, b, y, S) {
      return f("span", {
        class: ee(`${l.value}-item`, {
          [`${l.value}-item-disabled`]: b
        }),
        title: typeof h == "string" || typeof h == "number" ? h.toString() : void 0
      }, [f("span", {
        class: `${l.value}-item-content`
      }, [g]), y && f(da, {
        class: `${l.value}-item-remove`,
        onMousedown: tS,
        onClick: S,
        customizeIcon: e.removeIcon
      }, {
        default: () => [Ot("×")]
      })]);
    }
    function u(h, g, b, y, S, C) {
      var w;
      const $ = (x) => {
        tS(x), e.onToggleOpen(!open);
      };
      let O = C;
      return r.keyEntities && (O = ((w = r.keyEntities[h]) === null || w === void 0 ? void 0 : w.node) || {}), f("span", {
        key: h,
        onMousedown: $
      }, [e.tagRender({
        label: g,
        value: h,
        disabled: b,
        closable: y,
        onClose: S,
        option: O
      })]);
    }
    function d(h) {
      const {
        disabled: g,
        label: b,
        value: y,
        option: S
      } = h, C = !e.disabled && !g;
      let w = b;
      if (typeof e.maxTagTextLength == "number" && (typeof b == "string" || typeof b == "number")) {
        const O = String(w);
        O.length > e.maxTagTextLength && (w = `${O.slice(0, e.maxTagTextLength)}...`);
      }
      const $ = (O) => {
        var x;
        O && O.stopPropagation(), (x = e.onRemove) === null || x === void 0 || x.call(e, h);
      };
      return typeof e.tagRender == "function" ? u(y, w, g, C, $, S) : c(b, w, g, C, $);
    }
    function p(h) {
      const {
        maxTagPlaceholder: g = (y) => `+ ${y.length} ...`
      } = e, b = typeof g == "function" ? g(h) : g;
      return c(b, b, !1);
    }
    const v = (h) => {
      const g = h.target.composing;
      s.value = h.target.value, g || e.onInputChange(h);
    };
    return () => {
      const {
        id: h,
        prefixCls: g,
        values: b,
        open: y,
        inputRef: S,
        placeholder: C,
        disabled: w,
        autofocus: $,
        autocomplete: O,
        activeDescendantId: x,
        tabindex: I,
        compositionStatus: E,
        onInputPaste: _,
        onInputKeyDown: M,
        onInputMouseDown: R,
        onInputCompositionStart: A,
        onInputCompositionEnd: z
      } = e, T = f("div", {
        class: `${l.value}-search`,
        style: {
          width: n.value + "px"
        },
        key: "input"
      }, [f(O4, {
        inputRef: S,
        open: y,
        prefixCls: g,
        id: h,
        inputElement: null,
        disabled: w,
        autofocus: $,
        autocomplete: O,
        editable: i.value,
        activeDescendantId: x,
        value: s.value,
        onKeydown: M,
        onMousedown: R,
        onChange: v,
        onPaste: _,
        onCompositionstart: A,
        onCompositionend: z,
        tabindex: I,
        attrs: wl(e, !0),
        onFocus: () => o.value = !0,
        onBlur: () => o.value = !1
      }, null), f("span", {
        ref: t,
        class: `${l.value}-search-mirror`,
        "aria-hidden": !0
      }, [s.value, Ot(" ")])]), N = f(Vr, {
        prefixCls: `${l.value}-overflow`,
        data: b,
        renderItem: d,
        renderRest: p,
        suffix: T,
        itemKey: "key",
        maxCount: e.maxTagCount,
        key: "overflow"
      }, null);
      return f(Fe, null, [N, !b.length && !a.value && !E && f("span", {
        class: `${l.value}-placeholder`
      }, [C])]);
    };
  }
}), $D = {
  inputElement: V.any,
  id: String,
  prefixCls: String,
  values: V.array,
  open: {
    type: Boolean,
    default: void 0
  },
  searchValue: String,
  inputRef: V.any,
  placeholder: V.any,
  compositionStatus: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  mode: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  autocomplete: String,
  activeDescendantId: String,
  tabindex: V.oneOfType([V.number, V.string]),
  activeValue: String,
  backfill: {
    type: Boolean,
    default: void 0
  },
  optionLabelRender: Function,
  onInputChange: Function,
  onInputPaste: Function,
  onInputKeyDown: Function,
  onInputMouseDown: Function,
  onInputCompositionStart: Function,
  onInputCompositionEnd: Function
}, kh = Z({
  name: "SingleSelector",
  setup(e) {
    const t = Q(!1), n = P(() => e.mode === "combobox"), o = P(() => n.value || e.showSearch), r = P(() => {
      let u = e.searchValue || "";
      return n.value && e.activeValue && !t.value && (u = e.activeValue), u;
    }), l = Rf();
    ie([n, () => e.activeValue], () => {
      n.value && (t.value = !1);
    }, {
      immediate: !0
    });
    const a = P(() => e.mode !== "combobox" && !e.open && !e.showSearch ? !1 : !!r.value || e.compositionStatus), i = P(() => {
      const u = e.values[0];
      return u && (typeof u.label == "string" || typeof u.label == "number") ? u.label.toString() : void 0;
    }), s = () => {
      if (e.values[0])
        return null;
      const u = a.value ? {
        visibility: "hidden"
      } : void 0;
      return f("span", {
        class: `${e.prefixCls}-selection-placeholder`,
        style: u
      }, [e.placeholder]);
    }, c = (u) => {
      u.target.composing || (t.value = !0, e.onInputChange(u));
    };
    return () => {
      var u, d, p, v;
      const {
        inputElement: h,
        prefixCls: g,
        id: b,
        values: y,
        inputRef: S,
        disabled: C,
        autofocus: w,
        autocomplete: $,
        activeDescendantId: O,
        open: x,
        tabindex: I,
        optionLabelRender: E,
        onInputKeyDown: _,
        onInputMouseDown: M,
        onInputPaste: R,
        onInputCompositionStart: A,
        onInputCompositionEnd: z
      } = e, T = y[0];
      let N = null;
      if (T && l.customSlots) {
        const k = (u = T.key) !== null && u !== void 0 ? u : T.value, B = ((d = l.keyEntities[k]) === null || d === void 0 ? void 0 : d.node) || {};
        N = l.customSlots[(p = B.slots) === null || p === void 0 ? void 0 : p.title] || l.customSlots.title || T.label, typeof N == "function" && (N = N(B));
      } else
        N = E && T ? E(T.option) : T == null ? void 0 : T.label;
      return f(Fe, null, [f("span", {
        class: `${g}-selection-search`
      }, [f(O4, {
        inputRef: S,
        prefixCls: g,
        id: b,
        open: x,
        inputElement: h,
        disabled: C,
        autofocus: w,
        autocomplete: $,
        editable: o.value,
        activeDescendantId: O,
        value: r.value,
        onKeydown: _,
        onMousedown: M,
        onChange: c,
        onPaste: R,
        onCompositionstart: A,
        onCompositionend: z,
        tabindex: I,
        attrs: wl(e, !0)
      }, null)]), !n.value && T && !a.value && f("span", {
        class: `${g}-selection-item`,
        title: i.value
      }, [f(Fe, {
        key: (v = T.key) !== null && v !== void 0 ? v : T.value
      }, [N])]), s()]);
    };
  }
});
kh.props = $D;
kh.inheritAttrs = !1;
function wD(e) {
  return ![
    // System function button
    ce.ESC,
    ce.SHIFT,
    ce.BACKSPACE,
    ce.TAB,
    ce.WIN_KEY,
    ce.ALT,
    ce.META,
    ce.WIN_KEY_RIGHT,
    ce.CTRL,
    ce.SEMICOLON,
    ce.EQUALS,
    ce.CAPS_LOCK,
    ce.CONTEXT_MENU,
    // F1-F12
    ce.F1,
    ce.F2,
    ce.F3,
    ce.F4,
    ce.F5,
    ce.F6,
    ce.F7,
    ce.F8,
    ce.F9,
    ce.F10,
    ce.F11,
    ce.F12
  ].includes(e);
}
function M4() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 250, t = null, n;
  et(() => {
    clearTimeout(n);
  });
  function o(r) {
    (r || t === null) && (t = r), clearTimeout(n), n = setTimeout(() => {
      t = null;
    }, e);
  }
  return [() => t, o];
}
function Ws() {
  const e = (t) => {
    e.current = t;
  };
  return e;
}
const xD = Z({
  name: "Selector",
  inheritAttrs: !1,
  props: {
    id: String,
    prefixCls: String,
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    /** Display in the Selector value, it's not same as `value` prop */
    values: V.array,
    multiple: {
      type: Boolean,
      default: void 0
    },
    mode: String,
    searchValue: String,
    activeValue: String,
    inputElement: V.any,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    activeDescendantId: String,
    tabindex: V.oneOfType([V.number, V.string]),
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: V.any,
    removeIcon: V.any,
    // Tags
    maxTagCount: V.oneOfType([V.number, V.string]),
    maxTagTextLength: Number,
    maxTagPlaceholder: V.any,
    tagRender: Function,
    optionLabelRender: Function,
    /** Check if `tokenSeparators` contains `\n` or `\r\n` */
    tokenWithEnter: {
      type: Boolean,
      default: void 0
    },
    // Motion
    choiceTransitionName: String,
    onToggleOpen: {
      type: Function
    },
    /** `onSearch` returns go next step boolean to check if need do toggle open */
    onSearch: Function,
    onSearchSubmit: Function,
    onRemove: Function,
    onInputKeyDown: {
      type: Function
    },
    /**
     * @private get real dom for trigger align.
     * This may be removed after React provides replacement of `findDOMNode`
     */
    domRef: Function
  },
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = Ws(), r = Y(!1), [l, a] = M4(0), i = (y) => {
      const {
        which: S
      } = y;
      (S === ce.UP || S === ce.DOWN) && y.preventDefault(), e.onInputKeyDown && e.onInputKeyDown(y), S === ce.ENTER && e.mode === "tags" && !r.value && !e.open && e.onSearchSubmit(y.target.value), wD(S) && e.onToggleOpen(!0);
    }, s = () => {
      a(!0);
    };
    let c = null;
    const u = (y) => {
      e.onSearch(y, !0, r.value) !== !1 && e.onToggleOpen(!0);
    }, d = () => {
      r.value = !0;
    }, p = (y) => {
      r.value = !1, e.mode !== "combobox" && u(y.target.value);
    }, v = (y) => {
      let {
        target: {
          value: S
        }
      } = y;
      if (e.tokenWithEnter && c && /[\r\n]/.test(c)) {
        const C = c.replace(/[\r\n]+$/, "").replace(/\r\n/g, " ").replace(/[\r\n]/g, " ");
        S = S.replace(C, c);
      }
      c = null, u(S);
    }, h = (y) => {
      const {
        clipboardData: S
      } = y;
      c = S.getData("text");
    }, g = (y) => {
      let {
        target: S
      } = y;
      S !== o.current && (document.body.style.msTouchAction !== void 0 ? setTimeout(() => {
        o.current.focus();
      }) : o.current.focus());
    }, b = (y) => {
      const S = l();
      y.target !== o.current && !S && y.preventDefault(), (e.mode !== "combobox" && (!e.showSearch || !S) || !e.open) && (e.open && e.onSearch("", !0, !1), e.onToggleOpen());
    };
    return n({
      focus: () => {
        o.current.focus();
      },
      blur: () => {
        o.current.blur();
      }
    }), () => {
      const {
        prefixCls: y,
        domRef: S,
        mode: C
      } = e, w = {
        inputRef: o,
        onInputKeyDown: i,
        onInputMouseDown: s,
        onInputChange: v,
        onInputPaste: h,
        compositionStatus: r.value,
        onInputCompositionStart: d,
        onInputCompositionEnd: p
      }, $ = C === "multiple" || C === "tags" ? f(CD, D(D({}, e), w), null) : f(kh, D(D({}, e), w), null);
      return f("div", {
        ref: S,
        class: `${y}-selector`,
        onClick: g,
        onMousedown: b
      }, [$]);
    };
  }
});
function OD(e, t, n) {
  function o(r) {
    var l, a, i;
    let s = r.target;
    s.shadowRoot && r.composed && (s = r.composedPath()[0] || s);
    const c = [(l = e[0]) === null || l === void 0 ? void 0 : l.value, (i = (a = e[1]) === null || a === void 0 ? void 0 : a.value) === null || i === void 0 ? void 0 : i.getPopupElement()];
    t.value && c.every((u) => u && !u.contains(s) && u !== s) && n(!1);
  }
  Ke(() => {
    window.addEventListener("mousedown", o);
  }), et(() => {
    window.removeEventListener("mousedown", o);
  });
}
function PD() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 10;
  const t = Q(!1);
  let n;
  const o = () => {
    clearTimeout(n);
  };
  return Ke(() => {
    o();
  }), [t, (l, a) => {
    o(), n = setTimeout(() => {
      t.value = l, a && a();
    }, e);
  }, o];
}
const _4 = Symbol("BaseSelectContextKey");
function ID(e) {
  return Je(_4, e);
}
function ac() {
  return tt(_4, {});
}
const Bh = () => {
  if (typeof navigator > "u" || typeof window > "u")
    return !1;
  const e = navigator.userAgent || navigator.vendor || window.opera;
  return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e == null ? void 0 : e.substring(0, 4));
};
function bd(e) {
  if (!kx(e))
    return xt(e);
  const t = new Proxy({}, {
    get(n, o, r) {
      return Reflect.get(e.value, o, r);
    },
    set(n, o, r) {
      return e.value[o] = r, !0;
    },
    deleteProperty(n, o) {
      return Reflect.deleteProperty(e.value, o);
    },
    has(n, o) {
      return Reflect.has(e.value, o);
    },
    ownKeys() {
      return Object.keys(e.value);
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    }
  });
  return xt(t);
}
var ED = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const TD = ["value", "onChange", "removeIcon", "placeholder", "autofocus", "maxTagCount", "maxTagTextLength", "maxTagPlaceholder", "choiceTransitionName", "onInputKeyDown", "onPopupScroll", "tabindex", "OptionList", "notFoundContent"], MD = () => ({
  prefixCls: String,
  id: String,
  omitDomProps: Array,
  // >>> Value
  displayValues: Array,
  onDisplayValuesChange: Function,
  // >>> Active
  /** Current dropdown list active item string value */
  activeValue: String,
  /** Link search input with target element */
  activeDescendantId: String,
  onActiveValueChange: Function,
  // >>> Search
  searchValue: String,
  /** Trigger onSearch, return false to prevent trigger open event */
  onSearch: Function,
  /** Trigger when search text match the `tokenSeparators`. Will provide split content */
  onSearchSplit: Function,
  maxLength: Number,
  OptionList: V.any,
  /** Tell if provided `options` is empty */
  emptyOptions: Boolean
}), kf = () => ({
  showSearch: {
    type: Boolean,
    default: void 0
  },
  tagRender: {
    type: Function
  },
  optionLabelRender: {
    type: Function
  },
  direction: {
    type: String
  },
  // MISC
  tabindex: Number,
  autofocus: Boolean,
  notFoundContent: V.any,
  placeholder: V.any,
  onClear: Function,
  choiceTransitionName: String,
  // >>> Mode
  mode: String,
  // >>> Status
  disabled: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  // >>> Open
  open: {
    type: Boolean,
    default: void 0
  },
  defaultOpen: {
    type: Boolean,
    default: void 0
  },
  onDropdownVisibleChange: {
    type: Function
  },
  // >>> Customize Input
  /** @private Internal usage. Do not use in your production. */
  getInputElement: {
    type: Function
  },
  /** @private Internal usage. Do not use in your production. */
  getRawInputElement: {
    type: Function
  },
  // >>> Selector
  maxTagTextLength: Number,
  maxTagCount: {
    type: [String, Number]
  },
  maxTagPlaceholder: V.any,
  // >>> Search
  tokenSeparators: {
    type: Array
  },
  // >>> Icons
  allowClear: {
    type: Boolean,
    default: void 0
  },
  showArrow: {
    type: Boolean,
    default: void 0
  },
  inputIcon: V.any,
  /** Clear all icon */
  clearIcon: V.any,
  /** Selector remove icon */
  removeIcon: V.any,
  // >>> Dropdown
  animation: String,
  transitionName: String,
  dropdownStyle: {
    type: Object
  },
  dropdownClassName: String,
  dropdownMatchSelectWidth: {
    type: [Boolean, Number],
    default: void 0
  },
  dropdownRender: {
    type: Function
  },
  dropdownAlign: Object,
  placement: {
    type: String
  },
  getPopupContainer: {
    type: Function
  },
  // >>> Focus
  showAction: {
    type: Array
  },
  onBlur: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  // >>> Rest Events
  onKeyup: Function,
  onKeydown: Function,
  onMousedown: Function,
  onPopupScroll: Function,
  onInputKeyDown: Function,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function
}), _D = () => m(m({}, MD()), kf());
function Fh(e) {
  return e === "tags" || e === "multiple";
}
const Lh = Z({
  compatConfig: {
    MODE: 3
  },
  name: "BaseSelect",
  inheritAttrs: !1,
  props: Qe(_D(), {
    showAction: [],
    notFoundContent: "Not Found"
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: r
    } = t;
    const l = P(() => Fh(e.mode)), a = P(() => e.showSearch !== void 0 ? e.showSearch : l.value || e.mode === "combobox"), i = Q(!1);
    Ke(() => {
      i.value = Bh();
    });
    const s = Rf(), c = Q(null), u = Ws(), d = Q(null), p = Q(null), v = Q(null), h = Y(!1), [g, b, y] = PD();
    o({
      focus: () => {
        var G;
        (G = p.value) === null || G === void 0 || G.focus();
      },
      blur: () => {
        var G;
        (G = p.value) === null || G === void 0 || G.blur();
      },
      scrollTo: (G) => {
        var U;
        return (U = v.value) === null || U === void 0 ? void 0 : U.scrollTo(G);
      }
    });
    const w = P(() => {
      var G;
      if (e.mode !== "combobox")
        return e.searchValue;
      const U = (G = e.displayValues[0]) === null || G === void 0 ? void 0 : G.value;
      return typeof U == "string" || typeof U == "number" ? String(U) : "";
    }), $ = e.open !== void 0 ? e.open : e.defaultOpen, O = Q($), x = Q($), I = (G) => {
      O.value = e.open !== void 0 ? e.open : G, x.value = O.value;
    };
    ie(() => e.open, () => {
      I(e.open);
    });
    const E = P(() => !e.notFoundContent && e.emptyOptions);
    Le(() => {
      x.value = O.value, (e.disabled || E.value && x.value && e.mode === "combobox") && (x.value = !1);
    });
    const _ = P(() => E.value ? !1 : x.value), M = (G) => {
      const U = G !== void 0 ? G : !x.value;
      x.value !== U && !e.disabled && (I(U), e.onDropdownVisibleChange && e.onDropdownVisibleChange(U), !U && H.value && (H.value = !1, b(!1, () => {
        L.value = !1, h.value = !1;
      })));
    }, R = P(() => (e.tokenSeparators || []).some((G) => [`
`, `\r
`].includes(G))), A = (G, U, re) => {
      var se, me;
      let Ce = !0, fe = G;
      (se = e.onActiveValueChange) === null || se === void 0 || se.call(e, null);
      const be = re ? null : EM(G, e.tokenSeparators);
      return e.mode !== "combobox" && be && (fe = "", (me = e.onSearchSplit) === null || me === void 0 || me.call(e, be), M(!1), Ce = !1), e.onSearch && w.value !== fe && e.onSearch(fe, {
        source: U ? "typing" : "effect"
      }), Ce;
    }, z = (G) => {
      var U;
      !G || !G.trim() || (U = e.onSearch) === null || U === void 0 || U.call(e, G, {
        source: "submit"
      });
    };
    ie(x, () => {
      !x.value && !l.value && e.mode !== "combobox" && A("", !1, !1);
    }, {
      immediate: !0,
      flush: "post"
    }), ie(() => e.disabled, () => {
      O.value && e.disabled && I(!1), e.disabled && !h.value && b(!1);
    }, {
      immediate: !0
    });
    const [T, N] = M4(), k = function(G) {
      var U;
      const re = T(), {
        which: se
      } = G;
      if (se === ce.ENTER && (e.mode !== "combobox" && G.preventDefault(), x.value || M(!0)), N(!!w.value), se === ce.BACKSPACE && !re && l.value && !w.value && e.displayValues.length) {
        const be = [...e.displayValues];
        let ue = null;
        for (let de = be.length - 1; de >= 0; de -= 1) {
          const Se = be[de];
          if (!Se.disabled) {
            be.splice(de, 1), ue = Se;
            break;
          }
        }
        ue && e.onDisplayValuesChange(be, {
          type: "remove",
          values: [ue]
        });
      }
      for (var me = arguments.length, Ce = new Array(me > 1 ? me - 1 : 0), fe = 1; fe < me; fe++)
        Ce[fe - 1] = arguments[fe];
      x.value && v.value && v.value.onKeydown(G, ...Ce), (U = e.onKeydown) === null || U === void 0 || U.call(e, G, ...Ce);
    }, B = function(G) {
      for (var U = arguments.length, re = new Array(U > 1 ? U - 1 : 0), se = 1; se < U; se++)
        re[se - 1] = arguments[se];
      x.value && v.value && v.value.onKeyup(G, ...re), e.onKeyup && e.onKeyup(G, ...re);
    }, F = (G) => {
      const U = e.displayValues.filter((re) => re !== G);
      e.onDisplayValuesChange(U, {
        type: "remove",
        values: [G]
      });
    }, L = Q(!1), j = function() {
      b(!0), e.disabled || (e.onFocus && !L.value && e.onFocus(...arguments), e.showAction && e.showAction.includes("focus") && M(!0)), L.value = !0;
    }, H = Y(!1), K = function() {
      if (H.value || (h.value = !0, b(!1, () => {
        L.value = !1, h.value = !1, M(!1);
      }), e.disabled))
        return;
      const G = w.value;
      G && (e.mode === "tags" ? e.onSearch(G, {
        source: "submit"
      }) : e.mode === "multiple" && e.onSearch("", {
        source: "blur"
      })), e.onBlur && e.onBlur(...arguments);
    }, X = () => {
      H.value = !0;
    }, W = () => {
      H.value = !1;
    };
    Je("VCSelectContainerEvent", {
      focus: j,
      blur: K
    });
    const q = [];
    Ke(() => {
      q.forEach((G) => clearTimeout(G)), q.splice(0, q.length);
    }), et(() => {
      q.forEach((G) => clearTimeout(G)), q.splice(0, q.length);
    });
    const J = function(G) {
      var U, re;
      const {
        target: se
      } = G, me = (U = d.value) === null || U === void 0 ? void 0 : U.getPopupElement();
      if (me && me.contains(se)) {
        const ue = setTimeout(() => {
          var de;
          const Se = q.indexOf(ue);
          Se !== -1 && q.splice(Se, 1), y(), !i.value && !me.contains(document.activeElement) && ((de = p.value) === null || de === void 0 || de.focus());
        });
        q.push(ue);
      }
      for (var Ce = arguments.length, fe = new Array(Ce > 1 ? Ce - 1 : 0), be = 1; be < Ce; be++)
        fe[be - 1] = arguments[be];
      (re = e.onMousedown) === null || re === void 0 || re.call(e, G, ...fe);
    }, ne = Q(null), te = () => {
    };
    return Ke(() => {
      ie(_, () => {
        var G;
        if (_.value) {
          const U = Math.ceil((G = c.value) === null || G === void 0 ? void 0 : G.offsetWidth);
          ne.value !== U && !Number.isNaN(U) && (ne.value = U);
        }
      }, {
        immediate: !0,
        flush: "post"
      });
    }), OD([c, d], _, M), ID(bd(m(m({}, Qo(e)), {
      open: x,
      triggerOpen: _,
      showSearch: a,
      multiple: l,
      toggleOpen: M
    }))), () => {
      const G = m(m({}, e), n), {
        prefixCls: U,
        id: re,
        open: se,
        defaultOpen: me,
        mode: Ce,
        // Search related
        showSearch: fe,
        searchValue: be,
        onSearch: ue,
        // Icons
        allowClear: de,
        clearIcon: Se,
        showArrow: xe,
        inputIcon: he,
        // Others
        disabled: we,
        loading: Me,
        getInputElement: ae,
        getPopupContainer: oe,
        placement: pe,
        // Dropdown
        animation: Pe,
        transitionName: Ee,
        dropdownStyle: ze,
        dropdownClassName: ge,
        dropdownMatchSelectWidth: ye,
        dropdownRender: $e,
        dropdownAlign: Ae,
        showAction: Ve,
        direction: De,
        // Tags
        tokenSeparators: We,
        tagRender: at,
        optionLabelRender: gt,
        // Events
        onPopupScroll: ut,
        onDropdownVisibleChange: St,
        onFocus: wt,
        onBlur: Xt,
        onKeyup: qt,
        onKeydown: gn,
        onMousedown: Zt,
        onClear: An,
        omitDomProps: Jn,
        getRawInputElement: Io,
        displayValues: Vo,
        onDisplayValuesChange: eo,
        emptyOptions: Ml,
        activeDescendantId: Oe,
        activeValue: Ue,
        OptionList: Ye
      } = G, Dt = ED(G, ["prefixCls", "id", "open", "defaultOpen", "mode", "showSearch", "searchValue", "onSearch", "allowClear", "clearIcon", "showArrow", "inputIcon", "disabled", "loading", "getInputElement", "getPopupContainer", "placement", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "showAction", "direction", "tokenSeparators", "tagRender", "optionLabelRender", "onPopupScroll", "onDropdownVisibleChange", "onFocus", "onBlur", "onKeyup", "onKeydown", "onMousedown", "onClear", "omitDomProps", "getRawInputElement", "displayValues", "onDisplayValuesChange", "emptyOptions", "activeDescendantId", "activeValue", "OptionList"]), cn = Ce === "combobox" && ae && ae() || null, Qt = typeof Io == "function" && Io(), to = m({}, Dt);
      let $n;
      Qt && ($n = (Ko) => {
        M(Ko);
      }), TD.forEach((Ko) => {
        delete to[Ko];
      }), Jn == null || Jn.forEach((Ko) => {
        delete to[Ko];
      });
      const cr = xe !== void 0 ? xe : Me || !l.value && Ce !== "combobox";
      let fo;
      cr && (fo = f(da, {
        class: ee(`${U}-arrow`, {
          [`${U}-arrow-loading`]: Me
        }),
        customizeIcon: he,
        customizeIconProps: {
          loading: Me,
          searchValue: w.value,
          open: x.value,
          focused: g.value,
          showSearch: a.value
        }
      }, null));
      let Eo;
      const zt = () => {
        An == null || An(), eo([], {
          type: "clear",
          values: Vo
        }), A("", !1, !1);
      };
      !we && de && (Vo.length || w.value) && (Eo = f(da, {
        class: `${U}-clear`,
        onMousedown: zt,
        customizeIcon: Se
      }, {
        default: () => [Ot("×")]
      }));
      const Wo = f(Ye, {
        ref: v
      }, m(m({}, s.customSlots), {
        option: r.option
      })), To = ee(U, n.class, {
        [`${U}-focused`]: g.value,
        [`${U}-multiple`]: l.value,
        [`${U}-single`]: !l.value,
        [`${U}-allow-clear`]: de,
        [`${U}-show-arrow`]: cr,
        [`${U}-disabled`]: we,
        [`${U}-loading`]: Me,
        [`${U}-open`]: x.value,
        [`${U}-customize-input`]: cn,
        [`${U}-show-search`]: a.value
      }), tl = f(tD, {
        ref: d,
        disabled: we,
        prefixCls: U,
        visible: _.value,
        popupElement: Wo,
        containerWidth: ne.value,
        animation: Pe,
        transitionName: Ee,
        dropdownStyle: ze,
        dropdownClassName: ge,
        direction: De,
        dropdownMatchSelectWidth: ye,
        dropdownRender: $e,
        dropdownAlign: Ae,
        placement: pe,
        getPopupContainer: oe,
        empty: Ml,
        getTriggerDOMNode: () => u.current,
        onPopupVisibleChange: $n,
        onPopupMouseEnter: te,
        onPopupFocusin: X,
        onPopupFocusout: W
      }, {
        default: () => Qt ? Gt(Qt) && yt(Qt, {
          ref: u
        }, !1, !0) : f(xD, D(D({}, e), {}, {
          domRef: u,
          prefixCls: U,
          inputElement: cn,
          ref: p,
          id: re,
          showSearch: a.value,
          mode: Ce,
          activeDescendantId: Oe,
          tagRender: at,
          optionLabelRender: gt,
          values: Vo,
          open: x.value,
          onToggleOpen: M,
          activeValue: Ue,
          searchValue: w.value,
          onSearch: A,
          onSearchSubmit: z,
          onRemove: F,
          tokenWithEnter: R.value
        }), null)
      });
      let nl;
      return Qt ? nl = tl : nl = f("div", D(D({}, to), {}, {
        class: To,
        ref: c,
        onMousedown: J,
        onKeydown: k,
        onKeyup: B
      }), [g.value && !x.value && f("span", {
        style: {
          width: 0,
          height: 0,
          position: "absolute",
          overflow: "hidden",
          opacity: 0
        },
        "aria-live": "polite"
      }, [`${Vo.map((Ko) => {
        let {
          label: Ea,
          value: Go
        } = Ko;
        return ["number", "string"].includes(typeof Ea) ? Ea : Go;
      }).join(", ")}`]), tl, fo, Eo]), nl;
    };
  }
}), Bf = (e, t) => {
  let {
    height: n,
    offset: o,
    prefixCls: r,
    onInnerResize: l
  } = e, {
    slots: a
  } = t;
  var i;
  let s = {}, c = {
    display: "flex",
    flexDirection: "column"
  };
  return o !== void 0 && (s = {
    height: `${n}px`,
    position: "relative",
    overflow: "hidden"
  }, c = m(m({}, c), {
    transform: `translateY(${o}px)`,
    position: "absolute",
    left: 0,
    right: 0,
    top: 0
  })), f("div", {
    style: s
  }, [f(Fo, {
    onResize: (u) => {
      let {
        offsetHeight: d
      } = u;
      d && l && l();
    }
  }, {
    default: () => [f("div", {
      style: c,
      class: ee({
        [`${r}-holder-inner`]: r
      })
    }, [(i = a.default) === null || i === void 0 ? void 0 : i.call(a)])]
  })]);
};
Bf.displayName = "Filter";
Bf.inheritAttrs = !1;
Bf.props = {
  prefixCls: String,
  /** Virtual filler height. Should be `count * itemMinHeight` */
  height: Number,
  /** Set offset of visible items. Should be the top of start item position */
  offset: Number,
  onInnerResize: Function
};
const A4 = (e, t) => {
  let {
    setRef: n
  } = e, {
    slots: o
  } = t;
  var r;
  const l = It((r = o.default) === null || r === void 0 ? void 0 : r.call(o));
  return l && l.length ? tr(l[0], {
    ref: n
  }) : l;
};
A4.props = {
  setRef: {
    type: Function,
    default: () => {
    }
  }
};
const AD = 20;
function nS(e) {
  return "touches" in e ? e.touches[0].pageY : e.pageY;
}
const DD = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollBar",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    scrollTop: Number,
    scrollHeight: Number,
    height: Number,
    count: Number,
    onScroll: {
      type: Function
    },
    onStartMove: {
      type: Function
    },
    onStopMove: {
      type: Function
    }
  },
  setup() {
    return {
      moveRaf: null,
      scrollbarRef: Ws(),
      thumbRef: Ws(),
      visibleTimeout: null,
      state: xt({
        dragging: !1,
        pageY: null,
        startTop: null,
        visible: !1
      })
    };
  },
  watch: {
    scrollTop: {
      handler() {
        this.delayHidden();
      },
      flush: "post"
    }
  },
  mounted() {
    var e, t;
    (e = this.scrollbarRef.current) === null || e === void 0 || e.addEventListener("touchstart", this.onScrollbarTouchStart, on ? {
      passive: !1
    } : !1), (t = this.thumbRef.current) === null || t === void 0 || t.addEventListener("touchstart", this.onMouseDown, on ? {
      passive: !1
    } : !1);
  },
  beforeUnmount() {
    this.removeEvents(), clearTimeout(this.visibleTimeout);
  },
  methods: {
    delayHidden() {
      clearTimeout(this.visibleTimeout), this.state.visible = !0, this.visibleTimeout = setTimeout(() => {
        this.state.visible = !1;
      }, 2e3);
    },
    onScrollbarTouchStart(e) {
      e.preventDefault();
    },
    onContainerMouseDown(e) {
      e.stopPropagation(), e.preventDefault();
    },
    // ======================= Clean =======================
    patchEvents() {
      window.addEventListener("mousemove", this.onMouseMove), window.addEventListener("mouseup", this.onMouseUp), this.thumbRef.current.addEventListener("touchmove", this.onMouseMove, on ? {
        passive: !1
      } : !1), this.thumbRef.current.addEventListener("touchend", this.onMouseUp);
    },
    removeEvents() {
      window.removeEventListener("mousemove", this.onMouseMove), window.removeEventListener("mouseup", this.onMouseUp), this.scrollbarRef.current.removeEventListener("touchstart", this.onScrollbarTouchStart, on ? {
        passive: !1
      } : !1), this.thumbRef.current && (this.thumbRef.current.removeEventListener("touchstart", this.onMouseDown, on ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchmove", this.onMouseMove, on ? {
        passive: !1
      } : !1), this.thumbRef.current.removeEventListener("touchend", this.onMouseUp)), Ze.cancel(this.moveRaf);
    },
    // ======================= Thumb =======================
    onMouseDown(e) {
      const {
        onStartMove: t
      } = this.$props;
      m(this.state, {
        dragging: !0,
        pageY: nS(e),
        startTop: this.getTop()
      }), t(), this.patchEvents(), e.stopPropagation(), e.preventDefault();
    },
    onMouseMove(e) {
      const {
        dragging: t,
        pageY: n,
        startTop: o
      } = this.state, {
        onScroll: r
      } = this.$props;
      if (Ze.cancel(this.moveRaf), t) {
        const l = nS(e) - n, a = o + l, i = this.getEnableScrollRange(), s = this.getEnableHeightRange(), c = s ? a / s : 0, u = Math.ceil(c * i);
        this.moveRaf = Ze(() => {
          r(u);
        });
      }
    },
    onMouseUp() {
      const {
        onStopMove: e
      } = this.$props;
      this.state.dragging = !1, e(), this.removeEvents();
    },
    // ===================== Calculate =====================
    getSpinHeight() {
      const {
        height: e,
        scrollHeight: t
      } = this.$props;
      let n = e / t * 100;
      return n = Math.max(n, AD), n = Math.min(n, e / 2), Math.floor(n);
    },
    getEnableScrollRange() {
      const {
        scrollHeight: e,
        height: t
      } = this.$props;
      return e - t || 0;
    },
    getEnableHeightRange() {
      const {
        height: e
      } = this.$props, t = this.getSpinHeight();
      return e - t || 0;
    },
    getTop() {
      const {
        scrollTop: e
      } = this.$props, t = this.getEnableScrollRange(), n = this.getEnableHeightRange();
      return e === 0 || t === 0 ? 0 : e / t * n;
    },
    // Not show scrollbar when height is large than scrollHeight
    showScroll() {
      const {
        height: e,
        scrollHeight: t
      } = this.$props;
      return t > e;
    }
  },
  render() {
    const {
      dragging: e,
      visible: t
    } = this.state, {
      prefixCls: n
    } = this.$props, o = this.getSpinHeight() + "px", r = this.getTop() + "px", l = this.showScroll(), a = l && t;
    return f("div", {
      ref: this.scrollbarRef,
      class: ee(`${n}-scrollbar`, {
        [`${n}-scrollbar-show`]: l
      }),
      style: {
        width: "8px",
        top: 0,
        bottom: 0,
        right: 0,
        position: "absolute",
        display: a ? void 0 : "none"
      },
      onMousedown: this.onContainerMouseDown,
      onMousemove: this.delayHidden
    }, [f("div", {
      ref: this.thumbRef,
      class: ee(`${n}-scrollbar-thumb`, {
        [`${n}-scrollbar-thumb-moving`]: e
      }),
      style: {
        width: "100%",
        height: o,
        top: r,
        left: 0,
        position: "absolute",
        background: "rgba(0, 0, 0, 0.5)",
        borderRadius: "99px",
        cursor: "pointer",
        userSelect: "none"
      },
      onMousedown: this.onMouseDown
    }, null)]);
  }
});
function ND(e, t, n, o) {
  const r = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), a = Y(Symbol("update"));
  ie(e, () => {
    a.value = Symbol("update");
  });
  let i;
  function s() {
    Ze.cancel(i);
  }
  function c() {
    s(), i = Ze(() => {
      r.forEach((d, p) => {
        if (d && d.offsetParent) {
          const {
            offsetHeight: v
          } = d;
          l.get(p) !== v && (a.value = Symbol("update"), l.set(p, d.offsetHeight));
        }
      });
    });
  }
  function u(d, p) {
    const v = t(d);
    r.get(v), p ? (r.set(v, p.$el || p), c()) : r.delete(v);
  }
  return uo(() => {
    s();
  }), [u, c, l, a];
}
function RD(e, t, n, o, r, l, a, i) {
  let s;
  return (c) => {
    if (c == null) {
      i();
      return;
    }
    Ze.cancel(s);
    const u = t.value, d = o.itemHeight;
    if (typeof c == "number")
      a(c);
    else if (c && typeof c == "object") {
      let p;
      const {
        align: v
      } = c;
      "index" in c ? {
        index: p
      } = c : p = u.findIndex((b) => r(b) === c.key);
      const {
        offset: h = 0
      } = c, g = (b, y) => {
        if (b < 0 || !e.value)
          return;
        const S = e.value.clientHeight;
        let C = !1, w = y;
        if (S) {
          const $ = y || v;
          let O = 0, x = 0, I = 0;
          const E = Math.min(u.length, p);
          for (let R = 0; R <= E; R += 1) {
            const A = r(u[R]);
            x = O;
            const z = n.get(A);
            I = x + (z === void 0 ? d : z), O = I, R === p && z === void 0 && (C = !0);
          }
          const _ = e.value.scrollTop;
          let M = null;
          switch ($) {
            case "top":
              M = x - h;
              break;
            case "bottom":
              M = I - S + h;
              break;
            default: {
              const R = _ + S;
              x < _ ? w = "top" : I > R && (w = "bottom");
            }
          }
          M !== null && M !== _ && a(M);
        }
        s = Ze(() => {
          C && l(), g(b - 1, w);
        }, 2);
      };
      g(5);
    }
  };
}
const kD = typeof navigator == "object" && /Firefox/i.test(navigator.userAgent), D4 = (e, t) => {
  let n = !1, o = null;
  function r() {
    clearTimeout(o), n = !0, o = setTimeout(() => {
      n = !1;
    }, 50);
  }
  return function(l) {
    let a = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const i = (
      // Pass origin wheel when on the top
      l < 0 && e.value || // Pass origin wheel when on the bottom
      l > 0 && t.value
    );
    return a && i ? (clearTimeout(o), n = !1) : (!i || n) && r(), !n && i;
  };
};
function BD(e, t, n, o) {
  let r = 0, l = null, a = null, i = !1;
  const s = D4(t, n);
  function c(d) {
    if (!e.value)
      return;
    Ze.cancel(l);
    const {
      deltaY: p
    } = d;
    r += p, a = p, !s(p) && (kD || d.preventDefault(), l = Ze(() => {
      o(r * (i ? 10 : 1)), r = 0;
    }));
  }
  function u(d) {
    e.value && (i = d.detail === a);
  }
  return [c, u];
}
const FD = 14 / 15;
function LD(e, t, n) {
  let o = !1, r = 0, l = null, a = null;
  const i = () => {
    l && (l.removeEventListener("touchmove", s), l.removeEventListener("touchend", c));
  }, s = (p) => {
    if (o) {
      const v = Math.ceil(p.touches[0].pageY);
      let h = r - v;
      r = v, n(h) && p.preventDefault(), clearInterval(a), a = setInterval(() => {
        h *= FD, (!n(h, !0) || Math.abs(h) <= 0.1) && clearInterval(a);
      }, 16);
    }
  }, c = () => {
    o = !1, i();
  }, u = (p) => {
    i(), p.touches.length === 1 && !o && (o = !0, r = Math.ceil(p.touches[0].pageY), l = p.target, l.addEventListener("touchmove", s, {
      passive: !1
    }), l.addEventListener("touchend", c));
  }, d = () => {
  };
  Ke(() => {
    document.addEventListener("touchmove", d, {
      passive: !1
    }), ie(e, (p) => {
      t.value.removeEventListener("touchstart", u), i(), clearInterval(a), p && t.value.addEventListener("touchstart", u, {
        passive: !1
      });
    }, {
      immediate: !0
    });
  }), et(() => {
    document.removeEventListener("touchmove", d);
  });
}
var zD = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const HD = [], jD = {
  overflowY: "auto",
  overflowAnchor: "none"
};
function VD(e, t, n, o, r, l) {
  let {
    getKey: a
  } = l;
  return e.slice(t, n + 1).map((i, s) => {
    const c = t + s, u = r(i, c, {
      // style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
    }), d = a(i);
    return f(A4, {
      key: d,
      setRef: (p) => o(i, p)
    }, {
      default: () => [u]
    });
  });
}
const N4 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "List",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    data: V.array,
    height: Number,
    itemHeight: Number,
    /** If not match virtual scroll condition, Set List still use height of container. */
    fullHeight: {
      type: Boolean,
      default: void 0
    },
    itemKey: {
      type: [String, Number, Function],
      required: !0
    },
    component: {
      type: [String, Object]
    },
    /** Set `false` will always use real scroll instead of virtual one */
    virtual: {
      type: Boolean,
      default: void 0
    },
    children: Function,
    onScroll: Function,
    onMousedown: Function,
    onMouseenter: Function,
    onVisibleChange: Function
  },
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = P(() => {
      const {
        height: F,
        itemHeight: L,
        virtual: j
      } = e;
      return !!(j !== !1 && F && L);
    }), r = P(() => {
      const {
        height: F,
        itemHeight: L,
        data: j
      } = e;
      return o.value && j && L * j.length > F;
    }), l = xt({
      scrollTop: 0,
      scrollMoving: !1
    }), a = P(() => e.data || HD), i = Q([]);
    ie(a, () => {
      i.value = Yt(a.value).slice();
    }, {
      immediate: !0
    });
    const s = Q((F) => {
    });
    ie(() => e.itemKey, (F) => {
      typeof F == "function" ? s.value = F : s.value = (L) => L == null ? void 0 : L[F];
    }, {
      immediate: !0
    });
    const c = Q(), u = Q(), d = Q(), p = (F) => s.value(F), v = {
      getKey: p
    };
    function h(F) {
      let L;
      typeof F == "function" ? L = F(l.scrollTop) : L = F;
      const j = O(L);
      c.value && (c.value.scrollTop = j), l.scrollTop = j;
    }
    const [g, b, y, S] = ND(i, p), C = xt({
      scrollHeight: void 0,
      start: 0,
      end: 0,
      offset: void 0
    }), w = Q(0);
    Ke(() => {
      rt(() => {
        var F;
        w.value = ((F = u.value) === null || F === void 0 ? void 0 : F.offsetHeight) || 0;
      });
    }), co(() => {
      rt(() => {
        var F;
        w.value = ((F = u.value) === null || F === void 0 ? void 0 : F.offsetHeight) || 0;
      });
    }), ie([o, i], () => {
      o.value || m(C, {
        scrollHeight: void 0,
        start: 0,
        end: i.value.length - 1,
        offset: void 0
      });
    }, {
      immediate: !0
    }), ie([o, i, w, r], () => {
      o.value && !r.value && m(C, {
        scrollHeight: w.value,
        start: 0,
        end: i.value.length - 1,
        offset: void 0
      }), c.value && (l.scrollTop = c.value.scrollTop);
    }, {
      immediate: !0
    }), ie([r, o, () => l.scrollTop, i, S, () => e.height, w], () => {
      if (!o.value || !r.value)
        return;
      let F = 0, L, j, H;
      const K = i.value.length, X = i.value, W = l.scrollTop, {
        itemHeight: q,
        height: J
      } = e, ne = W + J;
      for (let te = 0; te < K; te += 1) {
        const G = X[te], U = p(G);
        let re = y.get(U);
        re === void 0 && (re = q);
        const se = F + re;
        L === void 0 && se >= W && (L = te, j = F), H === void 0 && se > ne && (H = te), F = se;
      }
      L === void 0 && (L = 0, j = 0, H = Math.ceil(J / q)), H === void 0 && (H = K - 1), H = Math.min(H + 1, K), m(C, {
        scrollHeight: F,
        start: L,
        end: H,
        offset: j
      });
    }, {
      immediate: !0
    });
    const $ = P(() => C.scrollHeight - e.height);
    function O(F) {
      let L = F;
      return Number.isNaN($.value) || (L = Math.min(L, $.value)), L = Math.max(L, 0), L;
    }
    const x = P(() => l.scrollTop <= 0), I = P(() => l.scrollTop >= $.value), E = D4(x, I);
    function _(F) {
      h(F);
    }
    function M(F) {
      var L;
      const {
        scrollTop: j
      } = F.currentTarget;
      j !== l.scrollTop && h(j), (L = e.onScroll) === null || L === void 0 || L.call(e, F);
    }
    const [R, A] = BD(o, x, I, (F) => {
      h((L) => L + F);
    });
    LD(o, c, (F, L) => E(F, L) ? !1 : (R({
      preventDefault() {
      },
      deltaY: F
    }), !0));
    function z(F) {
      o.value && F.preventDefault();
    }
    const T = () => {
      c.value && (c.value.removeEventListener("wheel", R, on ? {
        passive: !1
      } : !1), c.value.removeEventListener("DOMMouseScroll", A), c.value.removeEventListener("MozMousePixelScroll", z));
    };
    Le(() => {
      rt(() => {
        c.value && (T(), c.value.addEventListener("wheel", R, on ? {
          passive: !1
        } : !1), c.value.addEventListener("DOMMouseScroll", A), c.value.addEventListener("MozMousePixelScroll", z));
      });
    }), et(() => {
      T();
    });
    const N = RD(c, i, y, e, p, b, h, () => {
      var F;
      (F = d.value) === null || F === void 0 || F.delayHidden();
    });
    n({
      scrollTo: N
    });
    const k = P(() => {
      let F = null;
      return e.height && (F = m({
        [e.fullHeight ? "height" : "maxHeight"]: e.height + "px"
      }, jD), o.value && (F.overflowY = "hidden", l.scrollMoving && (F.pointerEvents = "none"))), F;
    });
    return ie([() => C.start, () => C.end, i], () => {
      if (e.onVisibleChange) {
        const F = i.value.slice(C.start, C.end + 1);
        e.onVisibleChange(F, i.value);
      }
    }, {
      flush: "post"
    }), {
      state: l,
      mergedData: i,
      componentStyle: k,
      onFallbackScroll: M,
      onScrollBar: _,
      componentRef: c,
      useVirtual: o,
      calRes: C,
      collectHeight: b,
      setInstance: g,
      sharedConfig: v,
      scrollBarRef: d,
      fillerInnerRef: u,
      delayHideScrollBar: () => {
        var F;
        (F = d.value) === null || F === void 0 || F.delayHidden();
      }
    };
  },
  render() {
    const e = m(m({}, this.$props), this.$attrs), {
      prefixCls: t = "rc-virtual-list",
      height: n,
      itemHeight: o,
      // eslint-disable-next-line no-unused-vars
      fullHeight: r,
      data: l,
      itemKey: a,
      virtual: i,
      component: s = "div",
      onScroll: c,
      children: u = this.$slots.default,
      style: d,
      class: p
    } = e, v = zD(e, ["prefixCls", "height", "itemHeight", "fullHeight", "data", "itemKey", "virtual", "component", "onScroll", "children", "style", "class"]), h = ee(t, p), {
      scrollTop: g
    } = this.state, {
      scrollHeight: b,
      offset: y,
      start: S,
      end: C
    } = this.calRes, {
      componentStyle: w,
      onFallbackScroll: $,
      onScrollBar: O,
      useVirtual: x,
      collectHeight: I,
      sharedConfig: E,
      setInstance: _,
      mergedData: M,
      delayHideScrollBar: R
    } = this;
    return f("div", D({
      style: m(m({}, d), {
        position: "relative"
      }),
      class: h
    }, v), [f(s, {
      class: `${t}-holder`,
      style: w,
      ref: "componentRef",
      onScroll: $,
      onMouseenter: R
    }, {
      default: () => [f(Bf, {
        prefixCls: t,
        height: b,
        offset: y,
        onInnerResize: I,
        ref: "fillerInnerRef"
      }, {
        default: () => VD(M, S, C, _, u, E)
      })]
    }), x && f(DD, {
      ref: "scrollBarRef",
      prefixCls: t,
      scrollTop: g,
      height: n,
      scrollHeight: b,
      count: M.length,
      onScroll: O,
      onStartMove: () => {
        this.state.scrollMoving = !0;
      },
      onStopMove: () => {
        this.state.scrollMoving = !1;
      }
    }, null)]);
  }
});
function zh(e, t, n) {
  const o = Y(e());
  return ie(t, (r, l) => {
    n ? n(r, l) && (o.value = e()) : o.value = e();
  }), o;
}
function WD() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
const R4 = Symbol("SelectContextKey");
function KD(e) {
  return Je(R4, e);
}
function GD() {
  return tt(R4, {});
}
var XD = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function oS(e) {
  return typeof e == "string" || typeof e == "number";
}
const UD = Z({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  setup(e, t) {
    let {
      expose: n,
      slots: o
    } = t;
    const r = ac(), l = GD(), a = P(() => `${r.prefixCls}-item`), i = zh(() => l.flattenOptions, [() => r.open, () => l.flattenOptions], ($) => $[0]), s = Ws(), c = ($) => {
      $.preventDefault();
    }, u = ($) => {
      s.current && s.current.scrollTo(typeof $ == "number" ? {
        index: $
      } : $);
    }, d = function($) {
      let O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const x = i.value.length;
      for (let I = 0; I < x; I += 1) {
        const E = ($ + I * O + x) % x, {
          group: _,
          data: M
        } = i.value[E];
        if (!_ && !M.disabled)
          return E;
      }
      return -1;
    }, p = xt({
      activeIndex: d(0)
    }), v = function($) {
      let O = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      p.activeIndex = $;
      const x = {
        source: O ? "keyboard" : "mouse"
      }, I = i.value[$];
      if (!I) {
        l.onActiveValue(null, -1, x);
        return;
      }
      l.onActiveValue(I.value, $, x);
    };
    ie([() => i.value.length, () => r.searchValue], () => {
      v(l.defaultActiveFirstOption !== !1 ? d(0) : -1);
    }, {
      immediate: !0
    });
    const h = ($) => l.rawValues.has($) && r.mode !== "combobox";
    ie([() => r.open, () => r.searchValue], () => {
      if (!r.multiple && r.open && l.rawValues.size === 1) {
        const $ = Array.from(l.rawValues)[0], O = Yt(i.value).findIndex((x) => {
          let {
            data: I
          } = x;
          return I[l.fieldNames.value] === $;
        });
        O !== -1 && (v(O), rt(() => {
          u(O);
        }));
      }
      r.open && rt(() => {
        var $;
        ($ = s.current) === null || $ === void 0 || $.scrollTo(void 0);
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const g = ($) => {
      $ !== void 0 && l.onSelect($, {
        selected: !l.rawValues.has($)
      }), r.multiple || r.toggleOpen(!1);
    }, b = ($) => typeof $.label == "function" ? $.label() : $.label;
    function y($) {
      const O = i.value[$];
      if (!O)
        return null;
      const x = O.data || {}, {
        value: I
      } = x, {
        group: E
      } = O, _ = wl(x, !0), M = b(O);
      return O ? f("div", D(D({
        "aria-label": typeof M == "string" && !E ? M : null
      }, _), {}, {
        key: $,
        role: E ? "presentation" : "option",
        id: `${r.id}_list_${$}`,
        "aria-selected": h(I)
      }), [I]) : null;
    }
    return n({
      onKeydown: ($) => {
        const {
          which: O,
          ctrlKey: x
        } = $;
        switch (O) {
          case ce.N:
          case ce.P:
          case ce.UP:
          case ce.DOWN: {
            let I = 0;
            if (O === ce.UP ? I = -1 : O === ce.DOWN ? I = 1 : WD() && x && (O === ce.N ? I = 1 : O === ce.P && (I = -1)), I !== 0) {
              const E = d(p.activeIndex + I, I);
              u(E), v(E, !0);
            }
            break;
          }
          case ce.ENTER: {
            const I = i.value[p.activeIndex];
            I && !I.data.disabled ? g(I.value) : g(void 0), r.open && $.preventDefault();
            break;
          }
          case ce.ESC:
            r.toggleOpen(!1), r.open && $.stopPropagation();
        }
      },
      onKeyup: () => {
      },
      scrollTo: ($) => {
        u($);
      }
    }), () => {
      const {
        id: $,
        notFoundContent: O,
        onPopupScroll: x
      } = r, {
        menuItemSelectedIcon: I,
        fieldNames: E,
        virtual: _,
        listHeight: M,
        listItemHeight: R
      } = l, A = o.option, {
        activeIndex: z
      } = p, T = Object.keys(E).map((N) => E[N]);
      return i.value.length === 0 ? f("div", {
        role: "listbox",
        id: `${$}_list`,
        class: `${a.value}-empty`,
        onMousedown: c
      }, [O]) : f(Fe, null, [f("div", {
        role: "listbox",
        id: `${$}_list`,
        style: {
          height: 0,
          width: 0,
          overflow: "hidden"
        }
      }, [y(z - 1), y(z), y(z + 1)]), f(N4, {
        itemKey: "key",
        ref: s,
        data: i.value,
        height: M,
        itemHeight: R,
        fullHeight: !1,
        onMousedown: c,
        onScroll: x,
        virtual: _
      }, {
        default: (N, k) => {
          var B;
          const {
            group: F,
            groupOption: L,
            data: j,
            value: H
          } = N, {
            key: K
          } = j, X = typeof N.label == "function" ? N.label() : N.label;
          if (F) {
            const Se = (B = j.title) !== null && B !== void 0 ? B : oS(X) && X;
            return f("div", {
              class: ee(a.value, `${a.value}-group`),
              title: Se
            }, [A ? A(j) : X !== void 0 ? X : K]);
          }
          const {
            disabled: W,
            title: q,
            children: J,
            style: ne,
            class: te,
            className: G
          } = j, U = XD(j, ["disabled", "title", "children", "style", "class", "className"]), re = ot(U, T), se = h(H), me = `${a.value}-option`, Ce = ee(a.value, me, te, G, {
            [`${me}-grouped`]: L,
            [`${me}-active`]: z === k && !W,
            [`${me}-disabled`]: W,
            [`${me}-selected`]: se
          }), fe = b(N), be = !I || typeof I == "function" || se, ue = typeof fe == "number" ? fe : fe || H;
          let de = oS(ue) ? ue.toString() : void 0;
          return q !== void 0 && (de = q), f("div", D(D({}, re), {}, {
            "aria-selected": se,
            class: Ce,
            title: de,
            onMousemove: (Se) => {
              U.onMousemove && U.onMousemove(Se), !(z === k || W) && v(k);
            },
            onClick: (Se) => {
              W || g(H), U.onClick && U.onClick(Se);
            },
            style: ne
          }), [f("div", {
            class: `${me}-content`
          }, [A ? A(j) : ue]), Gt(I) || se, be && f(da, {
            class: `${a.value}-option-state`,
            customizeIcon: I,
            customizeIconProps: {
              isSelected: se
            }
          }, {
            default: () => [se ? "✓" : null]
          })]);
        }
      })]);
    };
  }
});
var YD = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function qD(e) {
  const t = e, {
    key: n,
    children: o
  } = t, r = t.props, {
    value: l,
    disabled: a
  } = r, i = YD(r, ["value", "disabled"]), s = o == null ? void 0 : o.default;
  return m({
    key: n,
    value: l !== void 0 ? l : n,
    children: s,
    disabled: a || a === ""
  }, i);
}
function Hh(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  return It(e).map((o, r) => {
    var l;
    if (!Gt(o) || !o.type)
      return null;
    const {
      type: {
        isSelectOptGroup: a
      },
      key: i,
      children: s,
      props: c
    } = o;
    if (t || !a)
      return qD(o);
    const u = s && s.default ? s.default() : void 0, d = (c == null ? void 0 : c.label) || ((l = s.label) === null || l === void 0 ? void 0 : l.call(s)) || i;
    return m(m({
      key: `__RC_SELECT_GRP__${i === null ? r : String(i)}__`
    }, c), {
      label: d,
      options: Hh(u || [])
    });
  }).filter((o) => o);
}
function ZD(e, t, n) {
  const o = Q(), r = Q(), l = Q(), a = Q([]);
  return ie([e, t], () => {
    e.value ? a.value = Yt(e.value).slice() : a.value = Hh(t.value);
  }, {
    immediate: !0,
    deep: !0
  }), Le(() => {
    const i = a.value, s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), u = n.value;
    function d(p) {
      let v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      for (let h = 0; h < p.length; h += 1) {
        const g = p[h];
        !g[u.options] || v ? (s.set(g[u.value], g), c.set(g[u.label], g)) : d(g[u.options], !0);
      }
    }
    d(i), o.value = i, r.value = s, l.value = c;
  }), {
    options: o,
    valueOptions: r,
    labelOptions: l
  };
}
let rS = 0;
const QD = process.env.NODE_ENV !== "test" && jn();
function JD() {
  let e;
  return QD ? (e = rS, rS += 1) : e = "TEST_OR_SSR", e;
}
function jh() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Y("");
  const t = `rc_select_${JD()}`;
  return e.value || t;
}
function Vh(e) {
  return Array.isArray(e) ? e : e !== void 0 ? [e] : [];
}
const eN = typeof window < "u" && window.document && window.document.documentElement;
process.env.NODE_ENV;
function tN(e) {
  const {
    mode: t,
    options: n,
    children: o,
    backfill: r,
    allowClear: l,
    placeholder: a,
    getInputElement: i,
    showSearch: s,
    onSearch: c,
    defaultOpen: u,
    autofocus: d,
    labelInValue: p,
    value: v,
    inputValue: h,
    optionLabelProp: g
  } = e, b = Fh(t), y = s !== void 0 ? s : b || t === "combobox", S = n || Hh(o);
  if (lo(t !== "tags" || S.every((C) => !C.disabled), "Please avoid setting option to disabled in tags mode since user can always type text as tag."), lo(t !== "combobox" || !g, "`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly."), lo(t === "combobox" || !r, "`backfill` only works with `combobox` mode."), lo(t === "combobox" || !i, "`getInputElement` only work with `combobox` mode."), Cg(t !== "combobox" || !i || !l || !a, "Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`."), c && !y && t !== "combobox" && t !== "tags" && lo(!1, "`onSearch` should work with `showSearch` instead of use alone."), Cg(!u || d, "`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autofocus` if needed."), v != null) {
    const C = Vh(v);
    lo(!p || C.every((w) => typeof w == "object" && ("key" in w || "value" in w)), "`value` should in shape of `{ value: string | number, label?: any }` when you set `labelInValue` to `true`"), lo(!b || Array.isArray(v), "`value` should be array when `mode` is `multiple` or `tags`");
  }
  if (o) {
    let C = null;
    o.some((w) => {
      var $;
      if (!Gt(w) || !w.type)
        return !1;
      const {
        type: O
      } = w;
      return O.isSelectOption ? !1 : O.isSelectOptGroup ? !((($ = w.children) === null || $ === void 0 ? void 0 : $.default()) || []).every((E) => !Gt(E) || !w.type || E.type.isSelectOption ? !0 : (C = E.type, !1)) : (C = O, !0);
    }), C && lo(!1, `\`children\` should be \`Select.Option\` or \`Select.OptGroup\` instead of \`${C.displayName || C.name || C}\`.`), lo(h === void 0, "`inputValue` is deprecated, please use `searchValue` instead.");
  }
}
function rv(e, t) {
  return Vh(e).join("").toUpperCase().includes(t);
}
const nN = (e, t, n, o, r) => P(() => {
  const l = n.value, a = r == null ? void 0 : r.value, i = o == null ? void 0 : o.value;
  if (!l || i === !1)
    return e.value;
  const {
    options: s,
    label: c,
    value: u
  } = t.value, d = [], p = typeof i == "function", v = l.toUpperCase(), h = p ? i : (b, y) => a ? rv(y[a], v) : y[s] ? rv(y[c !== "children" ? c : "label"], v) : rv(y[u], v), g = p ? (b) => Ng(b) : (b) => b;
  return e.value.forEach((b) => {
    if (b[s]) {
      if (h(l, g(b)))
        d.push(b);
      else {
        const S = b[s].filter((C) => h(l, g(C)));
        S.length && d.push(m(m({}, b), {
          [s]: S
        }));
      }
      return;
    }
    h(l, g(b)) && d.push(b);
  }), d;
}), oN = (e, t) => {
  const n = Q({
    values: /* @__PURE__ */ new Map(),
    options: /* @__PURE__ */ new Map()
  });
  return [P(() => {
    const {
      values: l,
      options: a
    } = n.value, i = e.value.map((u) => {
      var d;
      return u.label === void 0 ? m(m({}, u), {
        label: (d = l.get(u.value)) === null || d === void 0 ? void 0 : d.label
      }) : u;
    }), s = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map();
    return i.forEach((u) => {
      s.set(u.value, u), c.set(u.value, t.value.get(u.value) || a.get(u.value));
    }), n.value.values = s, n.value.options = c, i;
  }), (l) => t.value.get(l) || n.value.options.get(l)];
};
function Rt(e, t) {
  const {
    defaultValue: n,
    value: o = Y()
  } = t || {};
  let r = typeof e == "function" ? e() : e;
  o.value !== void 0 && (r = hn(o)), n !== void 0 && (r = typeof n == "function" ? n() : n);
  const l = Y(r), a = Y(r);
  Le(() => {
    let s = o.value !== void 0 ? o.value : l.value;
    t.postState && (s = t.postState(s)), a.value = s;
  });
  function i(s) {
    const c = a.value;
    l.value = s, Yt(a.value) !== s && t.onChange && t.onChange(s, c);
  }
  return ie(o, () => {
    l.value = o.value;
  }), [a, i];
}
function Pt(e) {
  const t = typeof e == "function" ? e() : e, n = Y(t);
  function o(r) {
    n.value = r;
  }
  return [n, o];
}
const rN = ["inputValue"];
function k4() {
  return m(m({}, kf()), {
    prefixCls: String,
    id: String,
    backfill: {
      type: Boolean,
      default: void 0
    },
    // >>> Field Names
    fieldNames: Object,
    // >>> Search
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    searchValue: String,
    onSearch: Function,
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    // >>> Options
    /**
     * In Select, `false` means do nothing.
     * In TreeSelect, `false` will highlight match item.
     * It's by design.
     */
    filterOption: {
      type: [Boolean, Function],
      default: void 0
    },
    filterSort: Function,
    optionFilterProp: String,
    optionLabelProp: String,
    options: Array,
    defaultActiveFirstOption: {
      type: Boolean,
      default: void 0
    },
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    // >>> Icon
    menuItemSelectedIcon: V.any,
    mode: String,
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    value: V.any,
    defaultValue: V.any,
    onChange: Function,
    children: Array
  });
}
function lN(e) {
  return !e || typeof e != "object";
}
const aN = Z({
  compatConfig: {
    MODE: 3
  },
  name: "VcSelect",
  inheritAttrs: !1,
  props: Qe(k4(), {
    prefixCls: "vc-select",
    autoClearSearchValue: !0,
    listHeight: 200,
    listItemHeight: 20,
    dropdownMatchSelectWidth: !0
  }),
  setup(e, t) {
    let {
      expose: n,
      attrs: o,
      slots: r
    } = t;
    const l = jh(Te(e, "id")), a = P(() => Fh(e.mode)), i = P(() => !!(!e.options && e.children)), s = P(() => e.filterOption === void 0 && e.mode === "combobox" ? !1 : e.filterOption), c = P(() => Q2(e.fieldNames, i.value)), [u, d] = Rt("", {
      value: P(() => e.searchValue !== void 0 ? e.searchValue : e.inputValue),
      postState: (te) => te || ""
    }), p = ZD(Te(e, "options"), Te(e, "children"), c), {
      valueOptions: v,
      labelOptions: h,
      options: g
    } = p, b = (te) => Vh(te).map((U) => {
      var re, se;
      let me, Ce, fe, be;
      lN(U) ? me = U : (fe = U.key, Ce = U.label, me = (re = U.value) !== null && re !== void 0 ? re : fe);
      const ue = v.value.get(me);
      return ue && (Ce === void 0 && (Ce = ue == null ? void 0 : ue[e.optionLabelProp || c.value.label]), fe === void 0 && (fe = (se = ue == null ? void 0 : ue.key) !== null && se !== void 0 ? se : me), be = ue == null ? void 0 : ue.disabled), {
        label: Ce,
        value: me,
        key: fe,
        disabled: be,
        option: ue
      };
    }), [y, S] = Rt(e.defaultValue, {
      value: Te(e, "value")
    }), C = P(() => {
      var te;
      const G = b(y.value);
      return e.mode === "combobox" && !(!((te = G[0]) === null || te === void 0) && te.value) ? [] : G;
    }), [w, $] = oN(C, v), O = P(() => {
      if (!e.mode && w.value.length === 1) {
        const te = w.value[0];
        if (te.value === null && (te.label === null || te.label === void 0))
          return [];
      }
      return w.value.map((te) => {
        var G;
        return m(m({}, te), {
          label: (G = typeof te.label == "function" ? te.label() : te.label) !== null && G !== void 0 ? G : te.value
        });
      });
    }), x = P(() => new Set(w.value.map((te) => te.value)));
    Le(() => {
      var te;
      if (e.mode === "combobox") {
        const G = (te = w.value[0]) === null || te === void 0 ? void 0 : te.value;
        G != null && d(String(G));
      }
    }, {
      flush: "post"
    });
    const I = (te, G) => {
      const U = G ?? te;
      return {
        [c.value.value]: te,
        [c.value.label]: U
      };
    }, E = Q();
    Le(() => {
      if (e.mode !== "tags") {
        E.value = g.value;
        return;
      }
      const te = g.value.slice(), G = (U) => v.value.has(U);
      [...w.value].sort((U, re) => U.value < re.value ? -1 : 1).forEach((U) => {
        const re = U.value;
        G(re) || te.push(I(re, U.label));
      }), E.value = te;
    });
    const _ = nN(E, c, u, s, Te(e, "optionFilterProp")), M = P(() => e.mode !== "tags" || !u.value || _.value.some((te) => te[e.optionFilterProp || "value"] === u.value) ? _.value : [I(u.value), ..._.value]), R = P(() => e.filterSort ? [...M.value].sort((te, G) => e.filterSort(te, G)) : M.value), A = P(() => IM(R.value, {
      fieldNames: c.value,
      childrenAsData: i.value
    })), z = (te) => {
      const G = b(te);
      if (S(G), e.onChange && // Trigger event only when value changed
      (G.length !== w.value.length || G.some((U, re) => {
        var se;
        return ((se = w.value[re]) === null || se === void 0 ? void 0 : se.value) !== (U == null ? void 0 : U.value);
      }))) {
        const U = e.labelInValue ? G.map((se) => m(m({}, se), {
          originLabel: se.label,
          label: typeof se.label == "function" ? se.label() : se.label
        })) : G.map((se) => se.value), re = G.map((se) => Ng($(se.value)));
        e.onChange(
          // Value
          a.value ? U : U[0],
          // Option
          a.value ? re : re[0]
        );
      }
    }, [T, N] = Pt(null), [k, B] = Pt(0), F = P(() => e.defaultActiveFirstOption !== void 0 ? e.defaultActiveFirstOption : e.mode !== "combobox"), L = function(te, G) {
      let {
        source: U = "keyboard"
      } = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      B(G), e.backfill && e.mode === "combobox" && te !== null && U === "keyboard" && N(String(te));
    }, j = (te, G) => {
      const U = () => {
        var re;
        const se = $(te), me = se == null ? void 0 : se[c.value.label];
        return [e.labelInValue ? {
          label: typeof me == "function" ? me() : me,
          originLabel: me,
          value: te,
          key: (re = se == null ? void 0 : se.key) !== null && re !== void 0 ? re : te
        } : te, Ng(se)];
      };
      if (G && e.onSelect) {
        const [re, se] = U();
        e.onSelect(re, se);
      } else if (!G && e.onDeselect) {
        const [re, se] = U();
        e.onDeselect(re, se);
      }
    }, H = (te, G) => {
      let U;
      const re = a.value ? G.selected : !0;
      re ? U = a.value ? [...w.value, te] : [te] : U = w.value.filter((se) => se.value !== te), z(U), j(te, re), e.mode === "combobox" ? N("") : (!a.value || e.autoClearSearchValue) && (d(""), N(""));
    }, K = (te, G) => {
      z(te), (G.type === "remove" || G.type === "clear") && G.values.forEach((U) => {
        j(U.value, !1);
      });
    }, X = (te, G) => {
      var U;
      if (d(te), N(null), G.source === "submit") {
        const re = (te || "").trim();
        if (re) {
          const se = Array.from(/* @__PURE__ */ new Set([...x.value, re]));
          z(se), j(re, !0), d("");
        }
        return;
      }
      G.source !== "blur" && (e.mode === "combobox" && z(te), (U = e.onSearch) === null || U === void 0 || U.call(e, te));
    }, W = (te) => {
      let G = te;
      e.mode !== "tags" && (G = te.map((re) => {
        const se = h.value.get(re);
        return se == null ? void 0 : se.value;
      }).filter((re) => re !== void 0));
      const U = Array.from(/* @__PURE__ */ new Set([...x.value, ...G]));
      z(U), U.forEach((re) => {
        j(re, !0);
      });
    }, q = P(() => e.virtual !== !1 && e.dropdownMatchSelectWidth !== !1);
    KD(bd(m(m({}, p), {
      flattenOptions: A,
      onActiveValue: L,
      defaultActiveFirstOption: F,
      onSelect: H,
      menuItemSelectedIcon: Te(e, "menuItemSelectedIcon"),
      rawValues: x,
      fieldNames: c,
      virtual: q,
      listHeight: Te(e, "listHeight"),
      listItemHeight: Te(e, "listItemHeight"),
      childrenAsData: i
    }))), process.env.NODE_ENV !== "production" && Le(() => {
      tN(e);
    }, {
      flush: "post"
    });
    const J = Y();
    n({
      focus() {
        var te;
        (te = J.value) === null || te === void 0 || te.focus();
      },
      blur() {
        var te;
        (te = J.value) === null || te === void 0 || te.blur();
      },
      scrollTo(te) {
        var G;
        (G = J.value) === null || G === void 0 || G.scrollTo(te);
      }
    });
    const ne = P(() => ot(e, [
      "id",
      "mode",
      "prefixCls",
      "backfill",
      "fieldNames",
      // Search
      "inputValue",
      "searchValue",
      "onSearch",
      "autoClearSearchValue",
      // Select
      "onSelect",
      "onDeselect",
      "dropdownMatchSelectWidth",
      // Options
      "filterOption",
      "filterSort",
      "optionFilterProp",
      "optionLabelProp",
      "options",
      "children",
      "defaultActiveFirstOption",
      "menuItemSelectedIcon",
      "virtual",
      "listHeight",
      "listItemHeight",
      // Value
      "value",
      "defaultValue",
      "labelInValue",
      "onChange"
    ]));
    return () => f(Lh, D(D(D({}, ne.value), o), {}, {
      id: l,
      prefixCls: e.prefixCls,
      ref: J,
      omitDomProps: rN,
      mode: e.mode,
      displayValues: O.value,
      onDisplayValuesChange: K,
      searchValue: u.value,
      onSearch: X,
      onSearchSplit: W,
      dropdownMatchSelectWidth: e.dropdownMatchSelectWidth,
      OptionList: UD,
      emptyOptions: !A.value.length,
      activeValue: T.value,
      activeDescendantId: `${l}_list_${k.value}`
    }), r);
  }
}), Wh = () => null;
Wh.isSelectOption = !0;
Wh.displayName = "ASelectOption";
const Kh = () => null;
Kh.isSelectOptGroup = !0;
Kh.displayName = "ASelectOptGroup";
var iN = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M884 256h-75c-5.1 0-9.9 2.5-12.9 6.6L512 654.2 227.9 262.6c-3-4.1-7.8-6.6-12.9-6.6h-75c-6.5 0-10.3 7.4-6.5 12.7l352.6 486.1c12.8 17.6 39 17.6 51.7 0l352.6-486.1c3.9-5.3.1-12.7-6.4-12.7z" } }] }, name: "down", theme: "outlined" }, sN = Symbol("iconContext"), B4 = function() {
  return tt(sN, {
    prefixCls: Y("anticon"),
    rootClassName: Y(""),
    csp: Y()
  });
};
function Gh() {
  return !!(typeof window < "u" && window.document && window.document.createElement);
}
function cN(e, t) {
  return e && e.contains ? e.contains(t) : !1;
}
var lS = "data-vc-order", uN = "vc-icon-key", Wg = /* @__PURE__ */ new Map();
function F4() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = e.mark;
  return t ? t.startsWith("data-") ? t : "data-".concat(t) : uN;
}
function Xh(e) {
  if (e.attachTo)
    return e.attachTo;
  var t = document.querySelector("head");
  return t || document.body;
}
function dN(e) {
  return e === "queue" ? "prependQueue" : e ? "prepend" : "append";
}
function L4(e) {
  return Array.from((Wg.get(e) || e).children).filter(function(t) {
    return t.tagName === "STYLE";
  });
}
function z4(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (!Gh())
    return null;
  var n = t.csp, o = t.prepend, r = document.createElement("style");
  r.setAttribute(lS, dN(o)), n && n.nonce && (r.nonce = n.nonce), r.innerHTML = e;
  var l = Xh(t), a = l.firstChild;
  if (o) {
    if (o === "queue") {
      var i = L4(l).filter(function(s) {
        return ["prepend", "prependQueue"].includes(s.getAttribute(lS));
      });
      if (i.length)
        return l.insertBefore(r, i[i.length - 1].nextSibling), r;
    }
    l.insertBefore(r, a);
  } else
    l.appendChild(r);
  return r;
}
function fN(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n = Xh(t);
  return L4(n).find(function(o) {
    return o.getAttribute(F4(t)) === e;
  });
}
function pN(e, t) {
  var n = Wg.get(e);
  if (!n || !cN(document, n)) {
    var o = z4("", t), r = o.parentNode;
    Wg.set(e, r), e.removeChild(o);
  }
}
function vN(e, t) {
  var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Xh(n);
  pN(o, n);
  var r = fN(t, n);
  if (r)
    return n.csp && n.csp.nonce && r.nonce !== n.csp.nonce && (r.nonce = n.csp.nonce), r.innerHTML !== e && (r.innerHTML = e), r;
  var l = z4(e, n);
  return l.setAttribute(F4(n), t), l;
}
function aS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      gN(e, r, n[r]);
    });
  }
  return e;
}
function gN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function mN(e, t) {
  process.env.NODE_ENV !== "production" && !e && console !== void 0 && console.error("Warning: ".concat(t));
}
function hN(e, t) {
  mN(e, "[@ant-design/icons-vue] ".concat(t));
}
function iS(e) {
  return typeof e == "object" && typeof e.name == "string" && typeof e.theme == "string" && (typeof e.icon == "object" || typeof e.icon == "function");
}
function Kg(e, t, n) {
  return n ? vr(e.tag, aS({
    key: t
  }, n, e.attrs), (e.children || []).map(function(o, r) {
    return Kg(o, "".concat(t, "-").concat(e.tag, "-").concat(r));
  })) : vr(e.tag, aS({
    key: t
  }, e.attrs), (e.children || []).map(function(o, r) {
    return Kg(o, "".concat(t, "-").concat(e.tag, "-").concat(r));
  }));
}
function H4(e) {
  return sa(e)[0];
}
function j4(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
var bN = `
.anticon {
  display: inline-block;
  color: inherit;
  font-style: normal;
  line-height: 0;
  text-align: center;
  text-transform: none;
  vertical-align: -0.125em;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.anticon > * {
  line-height: 1;
}

.anticon svg {
  display: inline-block;
}

.anticon::before {
  display: none;
}

.anticon .anticon-icon {
  display: block;
}

.anticon[tabindex] {
  cursor: pointer;
}

.anticon-spin::before,
.anticon-spin {
  display: inline-block;
  -webkit-animation: loadingCircle 1s infinite linear;
  animation: loadingCircle 1s infinite linear;
}

@-webkit-keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}

@keyframes loadingCircle {
  100% {
    -webkit-transform: rotate(360deg);
    transform: rotate(360deg);
  }
}
`;
function V4(e) {
  return e && e.getRootNode && e.getRootNode();
}
function yN(e) {
  return Gh() ? V4(e) instanceof ShadowRoot : !1;
}
function SN(e) {
  return yN(e) ? V4(e) : null;
}
var CN = function() {
  var t = B4(), n = t.prefixCls, o = t.csp, r = Wn(), l = bN;
  n && (l = l.replace(/anticon/g, n.value)), rt(function() {
    if (Gh()) {
      var a = r.vnode.el, i = SN(a);
      vN(l, "@ant-design-vue-icons", {
        prepend: !0,
        csp: o.value,
        attachTo: i
      });
    }
  });
}, $N = ["icon", "primaryColor", "secondaryColor"];
function wN(e, t) {
  if (e == null)
    return {};
  var n = xN(e, t), o, r;
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (r = 0; r < l.length; r++)
      o = l[r], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
function xN(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), r, l;
  for (l = 0; l < o.length; l++)
    r = o[l], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function yu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      ON(e, r, n[r]);
    });
  }
  return e;
}
function ON(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var gs = xt({
  primaryColor: "#333",
  secondaryColor: "#E6E6E6",
  calculated: !1
});
function PN(e) {
  var t = e.primaryColor, n = e.secondaryColor;
  gs.primaryColor = t, gs.secondaryColor = n || H4(t), gs.calculated = !!n;
}
function IN() {
  return yu({}, gs);
}
var xl = function(t, n) {
  var o = yu({}, t, n.attrs), r = o.icon, l = o.primaryColor, a = o.secondaryColor, i = wN(o, $N), s = gs;
  if (l && (s = {
    primaryColor: l,
    secondaryColor: a || H4(l)
  }), hN(iS(r), "icon should be icon definiton, but got ".concat(r)), !iS(r))
    return null;
  var c = r;
  return c && typeof c.icon == "function" && (c = yu({}, c, {
    icon: c.icon(s.primaryColor, s.secondaryColor)
  })), Kg(c.icon, "svg-".concat(c.name), yu({}, i, {
    "data-icon": c.name,
    width: "1em",
    height: "1em",
    fill: "currentColor",
    "aria-hidden": "true"
  }));
};
xl.props = {
  icon: Object,
  primaryColor: String,
  secondaryColor: String,
  focusable: String
};
xl.inheritAttrs = !1;
xl.displayName = "IconBase";
xl.getTwoToneColors = IN;
xl.setTwoToneColors = PN;
function EN(e, t) {
  return AN(e) || _N(e, t) || MN(e, t) || TN();
}
function TN() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function MN(e, t) {
  if (e) {
    if (typeof e == "string")
      return sS(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return sS(e, t);
  }
}
function sS(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, o = new Array(t); n < t; n++)
    o[n] = e[n];
  return o;
}
function _N(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var o = [], r = !0, l = !1, a, i;
    try {
      for (n = n.call(e); !(r = (a = n.next()).done) && (o.push(a.value), !(t && o.length === t)); r = !0)
        ;
    } catch (s) {
      l = !0, i = s;
    } finally {
      try {
        !r && n.return != null && n.return();
      } finally {
        if (l)
          throw i;
      }
    }
    return o;
  }
}
function AN(e) {
  if (Array.isArray(e))
    return e;
}
function W4(e) {
  var t = j4(e), n = EN(t, 2), o = n[0], r = n[1];
  return xl.setTwoToneColors({
    primaryColor: o,
    secondaryColor: r
  });
}
function DN() {
  var e = xl.getTwoToneColors();
  return e.calculated ? [e.primaryColor, e.secondaryColor] : e.primaryColor;
}
var NN = Z({
  name: "InsertStyles",
  setup: function() {
    return CN(), function() {
      return null;
    };
  }
}), RN = ["class", "icon", "spin", "rotate", "tabindex", "twoToneColor", "onClick"];
function kN(e, t) {
  return zN(e) || LN(e, t) || FN(e, t) || BN();
}
function BN() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function FN(e, t) {
  if (e) {
    if (typeof e == "string")
      return cS(e, t);
    var n = Object.prototype.toString.call(e).slice(8, -1);
    if (n === "Object" && e.constructor && (n = e.constructor.name), n === "Map" || n === "Set")
      return Array.from(e);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return cS(e, t);
  }
}
function cS(e, t) {
  (t == null || t > e.length) && (t = e.length);
  for (var n = 0, o = new Array(t); n < t; n++)
    o[n] = e[n];
  return o;
}
function LN(e, t) {
  var n = e == null ? null : typeof Symbol < "u" && e[Symbol.iterator] || e["@@iterator"];
  if (n != null) {
    var o = [], r = !0, l = !1, a, i;
    try {
      for (n = n.call(e); !(r = (a = n.next()).done) && (o.push(a.value), !(t && o.length === t)); r = !0)
        ;
    } catch (s) {
      l = !0, i = s;
    } finally {
      try {
        !r && n.return != null && n.return();
      } finally {
        if (l)
          throw i;
      }
    }
    return o;
  }
}
function zN(e) {
  if (Array.isArray(e))
    return e;
}
function uS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      ns(e, r, n[r]);
    });
  }
  return e;
}
function ns(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function HN(e, t) {
  if (e == null)
    return {};
  var n = jN(e, t), o, r;
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (r = 0; r < l.length; r++)
      o = l[r], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
function jN(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), r, l;
  for (l = 0; l < o.length; l++)
    r = o[l], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
W4(S5.primary);
var Ge = function(t, n) {
  var o, r = uS({}, t, n.attrs), l = r.class, a = r.icon, i = r.spin, s = r.rotate, c = r.tabindex, u = r.twoToneColor, d = r.onClick, p = HN(r, RN), v = B4(), h = v.prefixCls, g = v.rootClassName, b = (o = {}, ns(o, g.value, !!g.value), ns(o, h.value, !0), ns(o, "".concat(h.value, "-").concat(a.name), !!a.name), ns(o, "".concat(h.value, "-spin"), !!i || a.name === "loading"), o), y = c;
  y === void 0 && d && (y = -1);
  var S = s ? {
    msTransform: "rotate(".concat(s, "deg)"),
    transform: "rotate(".concat(s, "deg)")
  } : void 0, C = j4(u), w = kN(C, 2), $ = w[0], O = w[1];
  return f("span", uS({
    role: "img",
    "aria-label": a.name
  }, p, {
    onClick: d,
    class: [b, l],
    tabindex: y
  }), [f(xl, {
    icon: a,
    primaryColor: $,
    secondaryColor: O,
    style: S
  }, null), f(NN, null, null)]);
};
Ge.props = {
  spin: Boolean,
  rotate: Number,
  icon: Object,
  twoToneColor: [String, Array]
};
Ge.displayName = "AntdIcon";
Ge.inheritAttrs = !1;
Ge.getTwoToneColor = DN;
Ge.setTwoToneColor = W4;
function dS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      VN(e, r, n[r]);
    });
  }
  return e;
}
function VN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Or = function(t, n) {
  var o = dS({}, t, n.attrs);
  return f(Ge, dS({}, o, {
    icon: iN
  }), null);
};
Or.displayName = "DownOutlined";
Or.inheritAttrs = !1;
var WN = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, name: "loading", theme: "outlined" };
function fS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      KN(e, r, n[r]);
    });
  }
  return e;
}
function KN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Qn = function(t, n) {
  var o = fS({}, t, n.attrs);
  return f(Ge, fS({}, o, {
    icon: WN
  }), null);
};
Qn.displayName = "LoadingOutlined";
Qn.inheritAttrs = !1;
var GN = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 190h-69.9c-9.8 0-19.1 4.5-25.1 12.2L404.7 724.5 207 474a32 32 0 00-25.1-12.2H112c-6.7 0-10.4 7.7-6.3 12.9l273.9 347c12.8 16.2 37.4 16.2 50.3 0l488.4-618.9c4.1-5.1.4-12.8-6.3-12.8z" } }] }, name: "check", theme: "outlined" };
function pS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      XN(e, r, n[r]);
    });
  }
  return e;
}
function XN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Mi = function(t, n) {
  var o = pS({}, t, n.attrs);
  return f(Ge, pS({}, o, {
    icon: GN
  }), null);
};
Mi.displayName = "CheckOutlined";
Mi.inheritAttrs = !1;
var UN = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, name: "close", theme: "outlined" };
function vS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      YN(e, r, n[r]);
    });
  }
  return e;
}
function YN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Kn = function(t, n) {
  var o = vS({}, t, n.attrs);
  return f(Ge, vS({}, o, {
    icon: UN
  }), null);
};
Kn.displayName = "CloseOutlined";
Kn.inheritAttrs = !1;
var qN = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, name: "close-circle", theme: "filled" };
function gS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      ZN(e, r, n[r]);
    });
  }
  return e;
}
function ZN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Gn = function(t, n) {
  var o = gS({}, t, n.attrs);
  return f(Ge, gS({}, o, {
    icon: qN
  }), null);
};
Gn.displayName = "CloseCircleFilled";
Gn.inheritAttrs = !1;
var QN = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, name: "search", theme: "outlined" };
function mS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      JN(e, r, n[r]);
    });
  }
  return e;
}
function JN(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var _i = function(t, n) {
  var o = mS({}, t, n.attrs);
  return f(Ge, mS({}, o, {
    icon: QN
  }), null);
};
_i.displayName = "SearchOutlined";
_i.inheritAttrs = !1;
function Uh(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    loading: n,
    multiple: o,
    prefixCls: r,
    hasFeedback: l,
    feedbackIcon: a,
    showArrow: i
  } = e, s = e.suffixIcon || t.suffixIcon && t.suffixIcon(), c = e.clearIcon || t.clearIcon && t.clearIcon(), u = e.menuItemSelectedIcon || t.menuItemSelectedIcon && t.menuItemSelectedIcon(), d = e.removeIcon || t.removeIcon && t.removeIcon(), p = c ?? f(Gn, null, null), v = (y) => f(Fe, null, [i !== !1 && y, l && a]);
  let h = null;
  if (s !== void 0)
    h = v(s);
  else if (n)
    h = v(f(Qn, {
      spin: !0
    }, null));
  else {
    const y = `${r}-suffix`;
    h = (S) => {
      let {
        open: C,
        showSearch: w
      } = S;
      return v(C && w ? f(_i, {
        class: y
      }, null) : f(Or, {
        class: y
      }, null));
    };
  }
  let g = null;
  u !== void 0 ? g = u : o ? g = f(Mi, null, null) : g = null;
  let b = null;
  return d !== void 0 ? b = d : b = f(Kn, null, null), {
    clearIcon: p,
    suffixIcon: h,
    itemIcon: g,
    removeIcon: b
  };
}
function Yh(e) {
  const t = Symbol("contextKey");
  return {
    useProvide: (r, l) => {
      const a = xt({});
      return Je(t, a), Le(() => {
        m(a, r, l || {});
      }), a;
    },
    useInject: () => tt(t, e) || {}
  };
}
const yd = Symbol("ContextProps"), Sd = Symbol("InternalContextProps"), eR = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : P(() => !0);
  const n = Y(/* @__PURE__ */ new Map()), o = (a, i) => {
    n.value.set(a, i), n.value = new Map(n.value);
  }, r = (a) => {
    n.value.delete(a), n.value = new Map(n.value);
  }, l = Wn();
  ie([t, n], () => {
    if (process.env.NODE_ENV !== "production" && t.value && n.value.size > 1) {
      nt(!1, "Form.Item", `FormItem can only collect one field item, you haved set ${[...n.value.values()].map((i) => `\`${i.name}\``).join(", ")} ${n.value.size} field items.
        You can set not need to be collected fields into \`a-form-item-rest\``);
      let a = l;
      for (; a.parent; )
        console.warn("at", a.type), a = a.parent;
    }
  }), Je(yd, e), Je(Sd, {
    addFormItemField: o,
    removeFormItemField: r
  });
}, Gg = {
  id: P(() => {
  }),
  onFieldBlur: () => {
  },
  onFieldChange: () => {
  },
  clearValidate: () => {
  }
}, Xg = {
  addFormItemField: () => {
  },
  removeFormItemField: () => {
  }
}, sn = () => {
  const e = tt(Sd, Xg), t = Symbol("FormItemFieldKey"), n = Wn();
  return e.addFormItemField(t, n.type), et(() => {
    e.removeFormItemField(t);
  }), Je(Sd, Xg), Je(yd, Gg), tt(yd, Gg);
}, Si = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItemRest",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Je(Sd, Xg), Je(yd, Gg), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), Sn = Yh({}), Cd = Z({
  name: "NoFormStatus",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Sn.useProvide({}), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
});
function Fn(e, t, n) {
  return ee({
    [`${e}-status-success`]: t === "success",
    [`${e}-status-warning`]: t === "warning",
    [`${e}-status-error`]: t === "error",
    [`${e}-status-validating`]: t === "validating",
    [`${e}-has-feedback`]: n
  });
}
const ar = (e, t) => t || e, tR = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "inline-flex",
      "&-block": {
        display: "flex",
        width: "100%"
      },
      "&-vertical": {
        flexDirection: "column"
      }
    }
  };
}, nR = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "inline-flex",
      "&-rtl": {
        direction: "rtl"
      },
      "&-vertical": {
        flexDirection: "column"
      },
      "&-align": {
        flexDirection: "column",
        "&-center": {
          alignItems: "center"
        },
        "&-start": {
          alignItems: "flex-start"
        },
        "&-end": {
          alignItems: "flex-end"
        },
        "&-baseline": {
          alignItems: "baseline"
        }
      },
      [`${t}-item`]: {
        "&:empty": {
          display: "none"
        }
      }
    }
  };
}, K4 = Xe("Space", (e) => [nR(e), tR(e)]);
var oR = "[object Symbol]";
function Ff(e) {
  return typeof e == "symbol" || rr(e) && $l(e) == oR;
}
function Lf(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length, r = Array(o); ++n < o; )
    r[n] = t(e[n], n, e);
  return r;
}
var rR = 1 / 0, hS = zo ? zo.prototype : void 0, bS = hS ? hS.toString : void 0;
function G4(e) {
  if (typeof e == "string")
    return e;
  if (Oo(e))
    return Lf(e, G4) + "";
  if (Ff(e))
    return bS ? bS.call(e) : "";
  var t = e + "";
  return t == "0" && 1 / e == -rR ? "-0" : t;
}
var lR = /\s/;
function aR(e) {
  for (var t = e.length; t-- && lR.test(e.charAt(t)); )
    ;
  return t;
}
var iR = /^\s+/;
function sR(e) {
  return e && e.slice(0, aR(e) + 1).replace(iR, "");
}
var yS = NaN, cR = /^[-+]0x[0-9a-f]+$/i, uR = /^0b[01]+$/i, dR = /^0o[0-7]+$/i, fR = parseInt;
function Ug(e) {
  if (typeof e == "number")
    return e;
  if (Ff(e))
    return yS;
  if (or(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = or(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = sR(e);
  var n = uR.test(e);
  return n || dR.test(e) ? fR(e.slice(2), n ? 2 : 8) : cR.test(e) ? yS : +e;
}
var SS = 1 / 0, pR = 17976931348623157e292;
function vR(e) {
  if (!e)
    return e === 0 ? e : 0;
  if (e = Ug(e), e === SS || e === -SS) {
    var t = e < 0 ? -1 : 1;
    return t * pR;
  }
  return e === e ? e : 0;
}
function gR(e) {
  var t = vR(e), n = t % 1;
  return t === t ? n ? t - n : t : 0;
}
function qh(e) {
  return e;
}
var CS = Object.create, mR = /* @__PURE__ */ function() {
  function e() {
  }
  return function(t) {
    if (!or(t))
      return {};
    if (CS)
      return CS(t);
    e.prototype = t;
    var n = new e();
    return e.prototype = void 0, n;
  };
}();
function hR(e, t, n) {
  switch (n.length) {
    case 0:
      return e.call(t);
    case 1:
      return e.call(t, n[0]);
    case 2:
      return e.call(t, n[0], n[1]);
    case 3:
      return e.call(t, n[0], n[1], n[2]);
  }
  return e.apply(t, n);
}
function bR() {
}
function yR(e, t) {
  var n = -1, o = e.length;
  for (t || (t = Array(o)); ++n < o; )
    t[n] = e[n];
  return t;
}
var SR = 800, CR = 16, $R = Date.now;
function wR(e) {
  var t = 0, n = 0;
  return function() {
    var o = $R(), r = CR - (o - n);
    if (n = o, r > 0) {
      if (++t >= SR)
        return arguments[0];
    } else
      t = 0;
    return e.apply(void 0, arguments);
  };
}
function xR(e) {
  return function() {
    return e;
  };
}
var $d = function() {
  try {
    var e = Sa(Object, "defineProperty");
    return e({}, "", {}), e;
  } catch {
  }
}(), OR = $d ? function(e, t) {
  return $d(e, "toString", {
    configurable: !0,
    enumerable: !1,
    value: xR(t),
    writable: !0
  });
} : qh, X4 = wR(OR);
function PR(e, t) {
  for (var n = -1, o = e == null ? 0 : e.length; ++n < o && t(e[n], n, e) !== !1; )
    ;
  return e;
}
function U4(e, t, n, o) {
  for (var r = e.length, l = n + -1; ++l < r; )
    if (t(e[l], l, e))
      return l;
  return -1;
}
function IR(e) {
  return e !== e;
}
function ER(e, t, n) {
  for (var o = n - 1, r = e.length; ++o < r; )
    if (e[o] === t)
      return o;
  return -1;
}
function TR(e, t, n) {
  return t === t ? ER(e, t, n) : U4(e, IR, n);
}
function Y4(e, t) {
  var n = e == null ? 0 : e.length;
  return !!n && TR(e, t, 0) > -1;
}
function q4(e, t, n) {
  t == "__proto__" && $d ? $d(e, t, {
    configurable: !0,
    enumerable: !0,
    value: n,
    writable: !0
  }) : e[t] = n;
}
var MR = Object.prototype, _R = MR.hasOwnProperty;
function Zh(e, t, n) {
  var o = e[t];
  (!(_R.call(e, t) && Ph(o, n)) || n === void 0 && !(t in e)) && q4(e, t, n);
}
function ic(e, t, n, o) {
  var r = !n;
  n || (n = {});
  for (var l = -1, a = t.length; ++l < a; ) {
    var i = t[l], s = void 0;
    s === void 0 && (s = e[i]), r ? q4(n, i, s) : Zh(n, i, s);
  }
  return n;
}
var $S = Math.max;
function Z4(e, t, n) {
  return t = $S(t === void 0 ? e.length - 1 : t, 0), function() {
    for (var o = arguments, r = -1, l = $S(o.length - t, 0), a = Array(l); ++r < l; )
      a[r] = o[t + r];
    r = -1;
    for (var i = Array(t + 1); ++r < t; )
      i[r] = o[r];
    return i[t] = n(a), hR(e, this, i);
  };
}
function AR(e, t) {
  return X4(Z4(e, t, qh), e + "");
}
function DR(e) {
  var t = [];
  if (e != null)
    for (var n in Object(e))
      t.push(n);
  return t;
}
var NR = Object.prototype, RR = NR.hasOwnProperty;
function kR(e) {
  if (!or(e))
    return DR(e);
  var t = Af(e), n = [];
  for (var o in e)
    o == "constructor" && (t || !RR.call(e, o)) || n.push(o);
  return n;
}
function Qh(e) {
  return Ii(e) ? S4(e, !0) : kR(e);
}
var BR = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, FR = /^\w*$/;
function Jh(e, t) {
  if (Oo(e))
    return !1;
  var n = typeof e;
  return n == "number" || n == "symbol" || n == "boolean" || e == null || Ff(e) ? !0 : FR.test(e) || !BR.test(e) || t != null && e in Object(t);
}
var LR = "Expected a function";
function e0(e, t) {
  if (typeof e != "function" || t != null && typeof t != "function")
    throw new TypeError(LR);
  var n = function() {
    var o = arguments, r = t ? t.apply(this, o) : o[0], l = n.cache;
    if (l.has(r))
      return l.get(r);
    var a = e.apply(this, o);
    return n.cache = l.set(r, a) || l, a;
  };
  return n.cache = new (e0.Cache || Qr)(), n;
}
e0.Cache = Qr;
var zR = 500;
function HR(e) {
  var t = e0(e, function(o) {
    return n.size === zR && n.clear(), o;
  }), n = t.cache;
  return t;
}
var jR = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, VR = /\\(\\)?/g, WR = HR(function(e) {
  var t = [];
  return e.charCodeAt(0) === 46 && t.push(""), e.replace(jR, function(n, o, r, l) {
    t.push(r ? l.replace(VR, "$1") : o || n);
  }), t;
});
function Q4(e) {
  return e == null ? "" : G4(e);
}
function Ai(e, t) {
  return Oo(e) ? e : Jh(e, t) ? [e] : WR(Q4(e));
}
var KR = 1 / 0;
function Di(e) {
  if (typeof e == "string" || Ff(e))
    return e;
  var t = e + "";
  return t == "0" && 1 / e == -KR ? "-0" : t;
}
function zf(e, t) {
  t = Ai(t, e);
  for (var n = 0, o = t.length; e != null && n < o; )
    e = e[Di(t[n++])];
  return n && n == o ? e : void 0;
}
function GR(e, t, n) {
  var o = e == null ? void 0 : zf(e, t);
  return o === void 0 ? n : o;
}
var wS = zo ? zo.isConcatSpreadable : void 0;
function XR(e) {
  return Oo(e) || Mf(e) || !!(wS && e && e[wS]);
}
function UR(e, t, n, o, r) {
  var l = -1, a = e.length;
  for (n || (n = XR), r || (r = []); ++l < a; ) {
    var i = e[l];
    n(i) ? Eh(r, i) : r[r.length] = i;
  }
  return r;
}
function YR(e) {
  var t = e == null ? 0 : e.length;
  return t ? UR(e) : [];
}
function J4(e) {
  return X4(Z4(e, void 0, YR), e + "");
}
var t0 = C4(Object.getPrototypeOf, Object), qR = "[object Object]", ZR = Function.prototype, QR = Object.prototype, eO = ZR.toString, JR = QR.hasOwnProperty, e9 = eO.call(Object);
function n0(e) {
  if (!rr(e) || $l(e) != qR)
    return !1;
  var t = t0(e);
  if (t === null)
    return !0;
  var n = JR.call(t, "constructor") && t.constructor;
  return typeof n == "function" && n instanceof n && eO.call(n) == e9;
}
function tO(e, t, n) {
  var o = -1, r = e.length;
  t < 0 && (t = -t > r ? 0 : r + t), n = n > r ? r : n, n < 0 && (n += r), r = t > n ? 0 : n - t >>> 0, t >>>= 0;
  for (var l = Array(r); ++o < r; )
    l[o] = e[o + t];
  return l;
}
function t9(e, t, n) {
  var o = e.length;
  return n = n === void 0 ? o : n, !t && n >= o ? e : tO(e, t, n);
}
var n9 = "\\ud800-\\udfff", o9 = "\\u0300-\\u036f", r9 = "\\ufe20-\\ufe2f", l9 = "\\u20d0-\\u20ff", a9 = o9 + r9 + l9, i9 = "\\ufe0e\\ufe0f", s9 = "\\u200d", c9 = RegExp("[" + s9 + n9 + a9 + i9 + "]");
function nO(e) {
  return c9.test(e);
}
function u9(e) {
  return e.split("");
}
var oO = "\\ud800-\\udfff", d9 = "\\u0300-\\u036f", f9 = "\\ufe20-\\ufe2f", p9 = "\\u20d0-\\u20ff", v9 = d9 + f9 + p9, g9 = "\\ufe0e\\ufe0f", m9 = "[" + oO + "]", Yg = "[" + v9 + "]", qg = "\\ud83c[\\udffb-\\udfff]", h9 = "(?:" + Yg + "|" + qg + ")", rO = "[^" + oO + "]", lO = "(?:\\ud83c[\\udde6-\\uddff]){2}", aO = "[\\ud800-\\udbff][\\udc00-\\udfff]", b9 = "\\u200d", iO = h9 + "?", sO = "[" + g9 + "]?", y9 = "(?:" + b9 + "(?:" + [rO, lO, aO].join("|") + ")" + sO + iO + ")*", S9 = sO + iO + y9, C9 = "(?:" + [rO + Yg + "?", Yg, lO, aO, m9].join("|") + ")", $9 = RegExp(qg + "(?=" + qg + ")|" + C9 + S9, "g");
function w9(e) {
  return e.match($9) || [];
}
function x9(e) {
  return nO(e) ? w9(e) : u9(e);
}
function O9(e) {
  return function(t) {
    t = Q4(t);
    var n = nO(t) ? x9(t) : void 0, o = n ? n[0] : t.charAt(0), r = n ? t9(n, 1).join("") : t.slice(1);
    return o[e]() + r;
  };
}
function P9(e, t) {
  return e && ic(t, Ei(t), e);
}
function I9(e, t) {
  return e && ic(t, Qh(t), e);
}
var cO = typeof exports == "object" && exports && !exports.nodeType && exports, xS = cO && typeof module == "object" && module && !module.nodeType && module, E9 = xS && xS.exports === cO, OS = E9 ? lr.Buffer : void 0, PS = OS ? OS.allocUnsafe : void 0;
function T9(e, t) {
  if (t)
    return e.slice();
  var n = e.length, o = PS ? PS(n) : new e.constructor(n);
  return e.copy(o), o;
}
function M9(e, t) {
  return ic(e, Th(e), t);
}
var _9 = Object.getOwnPropertySymbols, uO = _9 ? function(e) {
  for (var t = []; e; )
    Eh(t, Th(e)), e = t0(e);
  return t;
} : m4;
function A9(e, t) {
  return ic(e, uO(e), t);
}
function dO(e) {
  return g4(e, Qh, uO);
}
var D9 = Object.prototype, N9 = D9.hasOwnProperty;
function R9(e) {
  var t = e.length, n = new e.constructor(t);
  return t && typeof e[0] == "string" && N9.call(e, "index") && (n.index = e.index, n.input = e.input), n;
}
function o0(e) {
  var t = new e.constructor(e.byteLength);
  return new gd(t).set(new gd(e)), t;
}
function k9(e, t) {
  var n = t ? o0(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.byteLength);
}
var B9 = /\w*$/;
function F9(e) {
  var t = new e.constructor(e.source, B9.exec(e));
  return t.lastIndex = e.lastIndex, t;
}
var IS = zo ? zo.prototype : void 0, ES = IS ? IS.valueOf : void 0;
function L9(e) {
  return ES ? Object(ES.call(e)) : {};
}
function z9(e, t) {
  var n = t ? o0(e.buffer) : e.buffer;
  return new e.constructor(n, e.byteOffset, e.length);
}
var H9 = "[object Boolean]", j9 = "[object Date]", V9 = "[object Map]", W9 = "[object Number]", K9 = "[object RegExp]", G9 = "[object Set]", X9 = "[object String]", U9 = "[object Symbol]", Y9 = "[object ArrayBuffer]", q9 = "[object DataView]", Z9 = "[object Float32Array]", Q9 = "[object Float64Array]", J9 = "[object Int8Array]", ek = "[object Int16Array]", tk = "[object Int32Array]", nk = "[object Uint8Array]", ok = "[object Uint8ClampedArray]", rk = "[object Uint16Array]", lk = "[object Uint32Array]";
function ak(e, t, n) {
  var o = e.constructor;
  switch (t) {
    case Y9:
      return o0(e);
    case H9:
    case j9:
      return new o(+e);
    case q9:
      return k9(e, n);
    case Z9:
    case Q9:
    case J9:
    case ek:
    case tk:
    case nk:
    case ok:
    case rk:
    case lk:
      return z9(e, n);
    case V9:
      return new o();
    case W9:
    case X9:
      return new o(e);
    case K9:
      return F9(e);
    case G9:
      return new o();
    case U9:
      return L9(e);
  }
}
function ik(e) {
  return typeof e.constructor == "function" && !Af(e) ? mR(t0(e)) : {};
}
var sk = "[object Map]";
function ck(e) {
  return rr(e) && Ro(e) == sk;
}
var TS = yi && yi.isMap, uk = TS ? _f(TS) : ck, dk = "[object Set]";
function fk(e) {
  return rr(e) && Ro(e) == dk;
}
var MS = yi && yi.isSet, pk = MS ? _f(MS) : fk, vk = 1, gk = 2, mk = 4, fO = "[object Arguments]", hk = "[object Array]", bk = "[object Boolean]", yk = "[object Date]", Sk = "[object Error]", pO = "[object Function]", Ck = "[object GeneratorFunction]", $k = "[object Map]", wk = "[object Number]", vO = "[object Object]", xk = "[object RegExp]", Ok = "[object Set]", Pk = "[object String]", Ik = "[object Symbol]", Ek = "[object WeakMap]", Tk = "[object ArrayBuffer]", Mk = "[object DataView]", _k = "[object Float32Array]", Ak = "[object Float64Array]", Dk = "[object Int8Array]", Nk = "[object Int16Array]", Rk = "[object Int32Array]", kk = "[object Uint8Array]", Bk = "[object Uint8ClampedArray]", Fk = "[object Uint16Array]", Lk = "[object Uint32Array]", Ht = {};
Ht[fO] = Ht[hk] = Ht[Tk] = Ht[Mk] = Ht[bk] = Ht[yk] = Ht[_k] = Ht[Ak] = Ht[Dk] = Ht[Nk] = Ht[Rk] = Ht[$k] = Ht[wk] = Ht[vO] = Ht[xk] = Ht[Ok] = Ht[Pk] = Ht[Ik] = Ht[kk] = Ht[Bk] = Ht[Fk] = Ht[Lk] = !0;
Ht[Sk] = Ht[pO] = Ht[Ek] = !1;
function ms(e, t, n, o, r, l) {
  var a, i = t & vk, s = t & gk, c = t & mk;
  if (n && (a = r ? n(e, o, r, l) : n(e)), a !== void 0)
    return a;
  if (!or(e))
    return e;
  var u = Oo(e);
  if (u) {
    if (a = R9(e), !i)
      return yR(e, a);
  } else {
    var d = Ro(e), p = d == pO || d == Ck;
    if (Vs(e))
      return T9(e, i);
    if (d == vO || d == fO || p && !r) {
      if (a = s || p ? {} : ik(e), !i)
        return s ? A9(e, I9(a, e)) : M9(e, P9(a, e));
    } else {
      if (!Ht[d])
        return r ? e : {};
      a = ak(e, d, i);
    }
  }
  l || (l = new mr());
  var v = l.get(e);
  if (v)
    return v;
  l.set(e, a), pk(e) ? e.forEach(function(b) {
    a.add(ms(b, t, n, b, e, l));
  }) : uk(e) && e.forEach(function(b, y) {
    a.set(y, ms(b, t, n, y, e, l));
  });
  var h = c ? s ? dO : Lg : s ? Qh : Ei, g = u ? void 0 : h(e);
  return PR(g || e, function(b, y) {
    g && (y = b, b = e[y]), Zh(a, y, ms(b, t, n, y, e, l));
  }), a;
}
var zk = 1, Hk = 4;
function _e(e) {
  return ms(e, zk | Hk);
}
var jk = 1, Vk = 2;
function Wk(e, t, n, o) {
  var r = n.length, l = r;
  if (e == null)
    return !l;
  for (e = Object(e); r--; ) {
    var a = n[r];
    if (a[2] ? a[1] !== e[a[0]] : !(a[0] in e))
      return !1;
  }
  for (; ++r < l; ) {
    a = n[r];
    var i = a[0], s = e[i], c = a[1];
    if (a[2]) {
      if (s === void 0 && !(i in e))
        return !1;
    } else {
      var u = new mr(), d;
      if (!(d === void 0 ? Df(c, s, jk | Vk, o, u) : d))
        return !1;
    }
  }
  return !0;
}
function gO(e) {
  return e === e && !or(e);
}
function Kk(e) {
  for (var t = Ei(e), n = t.length; n--; ) {
    var o = t[n], r = e[o];
    t[n] = [o, r, gO(r)];
  }
  return t;
}
function mO(e, t) {
  return function(n) {
    return n == null ? !1 : n[e] === t && (t !== void 0 || e in Object(n));
  };
}
function Gk(e) {
  var t = Kk(e);
  return t.length == 1 && t[0][2] ? mO(t[0][0], t[0][1]) : function(n) {
    return n === e || Wk(n, e, t);
  };
}
function Xk(e, t) {
  return e != null && t in Object(e);
}
function Uk(e, t, n) {
  t = Ai(t, e);
  for (var o = -1, r = t.length, l = !1; ++o < r; ) {
    var a = Di(t[o]);
    if (!(l = e != null && n(e, a)))
      break;
    e = e[a];
  }
  return l || ++o != r ? l : (r = e == null ? 0 : e.length, !!r && _h(r) && Mh(a, r) && (Oo(e) || Mf(e)));
}
function hO(e, t) {
  return e != null && Uk(e, t, Xk);
}
var Yk = 1, qk = 2;
function Zk(e, t) {
  return Jh(e) && gO(t) ? mO(Di(e), t) : function(n) {
    var o = GR(n, e);
    return o === void 0 && o === t ? hO(n, e) : Df(t, o, Yk | qk);
  };
}
function Qk(e) {
  return function(t) {
    return t == null ? void 0 : t[e];
  };
}
function Jk(e) {
  return function(t) {
    return zf(t, e);
  };
}
function eB(e) {
  return Jh(e) ? Qk(Di(e)) : Jk(e);
}
function r0(e) {
  return typeof e == "function" ? e : e == null ? qh : typeof e == "object" ? Oo(e) ? Zk(e[0], e[1]) : Gk(e) : eB(e);
}
function tB(e, t, n, o) {
  for (var r = -1, l = e == null ? 0 : e.length; ++r < l; ) {
    var a = e[r];
    t(o, a, n(a), e);
  }
  return o;
}
function nB(e) {
  return function(t, n, o) {
    for (var r = -1, l = Object(t), a = o(t), i = a.length; i--; ) {
      var s = a[++r];
      if (n(l[s], s, l) === !1)
        break;
    }
    return t;
  };
}
var oB = nB();
function rB(e, t) {
  return e && oB(e, t, Ei);
}
function lB(e, t) {
  return function(n, o) {
    if (n == null)
      return n;
    if (!Ii(n))
      return e(n, o);
    for (var r = n.length, l = -1, a = Object(n); ++l < r && o(a[l], l, a) !== !1; )
      ;
    return n;
  };
}
var aB = lB(rB);
function iB(e, t, n, o) {
  return aB(e, function(r, l, a) {
    t(o, r, n(r), a);
  }), o;
}
function sB(e, t) {
  return function(n, o) {
    var r = Oo(n) ? tB : iB, l = t ? t() : {};
    return r(n, e, r0(o), l);
  };
}
var lv = function() {
  return lr.Date.now();
}, cB = "Expected a function", uB = Math.max, dB = Math.min;
function Hf(e, t, n) {
  var o, r, l, a, i, s, c = 0, u = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(cB);
  t = Ug(t) || 0, or(n) && (u = !!n.leading, d = "maxWait" in n, l = d ? uB(Ug(n.maxWait) || 0, t) : l, p = "trailing" in n ? !!n.trailing : p);
  function v(O) {
    var x = o, I = r;
    return o = r = void 0, c = O, a = e.apply(I, x), a;
  }
  function h(O) {
    return c = O, i = setTimeout(y, t), u ? v(O) : a;
  }
  function g(O) {
    var x = O - s, I = O - c, E = t - x;
    return d ? dB(E, l - I) : E;
  }
  function b(O) {
    var x = O - s, I = O - c;
    return s === void 0 || x >= t || x < 0 || d && I >= l;
  }
  function y() {
    var O = lv();
    if (b(O))
      return S(O);
    i = setTimeout(y, g(O));
  }
  function S(O) {
    return i = void 0, p && o ? v(O) : (o = r = void 0, a);
  }
  function C() {
    i !== void 0 && clearTimeout(i), c = 0, o = s = r = i = void 0;
  }
  function w() {
    return i === void 0 ? a : S(lv());
  }
  function $() {
    var O = lv(), x = b(O);
    if (o = arguments, r = this, s = O, x) {
      if (i === void 0)
        return h(s);
      if (d)
        return clearTimeout(i), i = setTimeout(y, t), v(s);
    }
    return i === void 0 && (i = setTimeout(y, t)), a;
  }
  return $.cancel = C, $.flush = w, $;
}
function fB(e) {
  return rr(e) && Ii(e);
}
function pB(e) {
  var t = e == null ? 0 : e.length;
  return t ? e[t - 1] : void 0;
}
function vB(e) {
  return function(t, n, o) {
    var r = Object(t);
    if (!Ii(t)) {
      var l = r0(n);
      t = Ei(t), n = function(i) {
        return l(r[i], i, r);
      };
    }
    var a = e(t, n, o);
    return a > -1 ? r[l ? t[a] : a] : void 0;
  };
}
var gB = Math.max;
function mB(e, t, n) {
  var o = e == null ? 0 : e.length;
  if (!o)
    return -1;
  var r = n == null ? 0 : gR(n);
  return r < 0 && (r = gB(o + r, 0)), U4(e, r0(t), r);
}
var hB = vB(mB);
function bB(e) {
  for (var t = -1, n = e == null ? 0 : e.length, o = {}; ++t < n; ) {
    var r = e[t];
    o[r[0]] = r[1];
  }
  return o;
}
var yB = Math.min;
function SB(e, t, n) {
  for (var o = Y4, r = e[0].length, l = e.length, a = l, i = Array(l), s = 1 / 0, c = []; a--; ) {
    var u = e[a];
    a && t && (u = Lf(u, _f(t))), s = yB(u.length, s), i[a] = r >= 120 && u.length >= 120 ? new bi(a && u) : void 0;
  }
  u = e[0];
  var d = -1, p = i[0];
  e:
    for (; ++d < r && c.length < s; ) {
      var v = u[d], h = v;
      if (v = v !== 0 ? v : 0, !(p ? vd(p, h) : o(c, h))) {
        for (a = l; --a; ) {
          var g = i[a];
          if (!(g ? vd(g, h) : o(e[a], h)))
            continue e;
        }
        p && p.push(h), c.push(v);
      }
    }
  return c;
}
function CB(e) {
  return fB(e) ? e : [];
}
var $B = AR(function(e) {
  var t = Lf(e, CB);
  return t.length && t[0] === e[0] ? SB(t) : [];
});
function wB(e, t) {
  return t.length < 2 ? e : zf(e, tO(t, 0, -1));
}
var xB = "[object Map]", OB = "[object Set]", PB = Object.prototype, IB = PB.hasOwnProperty;
function bO(e) {
  if (e == null)
    return !0;
  if (Ii(e) && (Oo(e) || typeof e == "string" || typeof e.splice == "function" || Vs(e) || Ah(e) || Mf(e)))
    return !e.length;
  var t = Ro(e);
  if (t == xB || t == OB)
    return !e.size;
  if (Af(e))
    return !$4(e).length;
  for (var n in e)
    if (IB.call(e, n))
      return !1;
  return !0;
}
var EB = "[object Number]";
function TB(e) {
  return typeof e == "number" || rr(e) && $l(e) == EB;
}
var yO = O9("toLowerCase");
function MB(e, t) {
  return t = Ai(t, e), e = wB(e, t), e == null || delete e[Di(pB(t))];
}
function _B(e) {
  return n0(e) ? void 0 : e;
}
var AB = 1, DB = 2, NB = 4, RB = J4(function(e, t) {
  var n = {};
  if (e == null)
    return n;
  var o = !1;
  t = Lf(t, function(l) {
    return l = Ai(l, e), o || (o = l.length > 1), l;
  }), ic(e, dO(e), n), o && (n = ms(n, AB | DB | NB, _B));
  for (var r = t.length; r--; )
    MB(n, t[r]);
  return n;
});
function kB(e, t, n, o) {
  if (!or(e))
    return e;
  t = Ai(t, e);
  for (var r = -1, l = t.length, a = l - 1, i = e; i != null && ++r < l; ) {
    var s = Di(t[r]), c = n;
    if (s === "__proto__" || s === "constructor" || s === "prototype")
      return e;
    if (r != a) {
      var u = i[s];
      c = void 0, c === void 0 && (c = or(u) ? u : Mh(t[r + 1]) ? [] : {});
    }
    Zh(i, s, c), i = i[s];
  }
  return e;
}
function BB(e, t, n) {
  for (var o = -1, r = t.length, l = {}; ++o < r; ) {
    var a = t[o], i = zf(e, a);
    n(i, a) && kB(l, Ai(a, e), i);
  }
  return l;
}
var FB = sB(function(e, t, n) {
  e[n ? 0 : 1].push(t);
}, function() {
  return [[], []];
});
function LB(e, t) {
  return BB(e, t, function(n, o) {
    return hO(e, o);
  });
}
var SO = J4(function(e, t) {
  return e == null ? {} : LB(e, t);
}), zB = 1 / 0, HB = ni && 1 / Ih(new ni([, -0]))[1] == zB ? function(e) {
  return new ni(e);
} : bR, jB = 200;
function VB(e, t, n) {
  var o = -1, r = Y4, l = e.length, a = !0, i = [], s = i;
  if (l >= jB) {
    var c = HB(e);
    if (c)
      return Ih(c);
    a = !1, r = vd, s = new bi();
  } else
    s = i;
  e:
    for (; ++o < l; ) {
      var u = e[o], d = u;
      if (u = u !== 0 ? u : 0, a && d === d) {
        for (var p = s.length; p--; )
          if (s[p] === d)
            continue e;
        i.push(u);
      } else
        r(s, d, n) || (s !== i && s.push(d), i.push(u));
    }
  return i;
}
function av(e) {
  return e && e.length ? VB(e) : [];
}
const WB = () => ({
  compactSize: String,
  compactDirection: V.oneOf(Mn("horizontal", "vertical")).def("horizontal"),
  isFirstItem: ve(),
  isLastItem: ve()
}), jf = Yh(null), Ol = (e, t) => {
  const n = jf.useInject(), o = P(() => {
    if (!n || bO(n))
      return "";
    const {
      compactDirection: r,
      isFirstItem: l,
      isLastItem: a
    } = n, i = r === "vertical" ? "-vertical-" : "-";
    return ee({
      [`${e.value}-compact${i}item`]: !0,
      [`${e.value}-compact${i}first-item`]: l,
      [`${e.value}-compact${i}last-item`]: a,
      [`${e.value}-compact${i}item-rtl`]: t.value === "rtl"
    });
  });
  return {
    compactSize: P(() => n == null ? void 0 : n.compactSize),
    compactDirection: P(() => n == null ? void 0 : n.compactDirection),
    compactItemClassnames: o
  };
}, Ks = Z({
  name: "NoCompactStyle",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return jf.useProvide(null), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), KB = () => ({
  prefixCls: String,
  size: {
    type: String
  },
  direction: V.oneOf(Mn("horizontal", "vertical")).def("horizontal"),
  align: V.oneOf(Mn("start", "end", "center", "baseline")),
  block: {
    type: Boolean,
    default: void 0
  }
}), GB = Z({
  name: "CompactItem",
  props: WB(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return jf.useProvide(e), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), wd = Z({
  name: "ASpaceCompact",
  inheritAttrs: !1,
  props: KB(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("space-compact", e), a = jf.useInject(), [i, s] = K4(r), c = P(() => ee(r.value, s.value, {
      [`${r.value}-rtl`]: l.value === "rtl",
      [`${r.value}-block`]: e.block,
      [`${r.value}-vertical`]: e.direction === "vertical"
    }));
    return () => {
      var u;
      const d = It(((u = o.default) === null || u === void 0 ? void 0 : u.call(o)) || []);
      return d.length === 0 ? null : i(f("div", D(D({}, n), {}, {
        class: [c.value, n.class]
      }), [d.map((p, v) => {
        var h;
        const g = p && p.key || `${r.value}-item-${v}`, b = !a || bO(a);
        return f(GB, {
          key: g,
          compactSize: (h = e.size) !== null && h !== void 0 ? h : "middle",
          compactDirection: e.direction,
          isFirstItem: v === 0 && (b || (a == null ? void 0 : a.isFirstItem)),
          isLastItem: v === d.length - 1 && (b || (a == null ? void 0 : a.isLastItem))
        }, {
          default: () => [p]
        });
      })]));
    };
  }
}), XB = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), UB = (e) => ({
  animationDuration: e,
  animationFillMode: "both"
}), sc = function(e, t, n, o) {
  const l = (arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !1) ? "&" : "";
  return {
    [`
      ${l}${e}-enter,
      ${l}${e}-appear
    `]: m(m({}, XB(o)), {
      animationPlayState: "paused"
    }),
    [`${l}${e}-leave`]: m(m({}, UB(o)), {
      animationPlayState: "paused"
    }),
    [`
      ${l}${e}-enter${e}-enter-active,
      ${l}${e}-appear${e}-appear-active
    `]: {
      animationName: t,
      animationPlayState: "running"
    },
    [`${l}${e}-leave${e}-leave-active`]: {
      animationName: n,
      animationPlayState: "running",
      pointerEvents: "none"
    }
  };
}, YB = new lt("antFadeIn", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), qB = new lt("antFadeOut", {
  "0%": {
    opacity: 1
  },
  "100%": {
    opacity: 0
  }
}), l0 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const {
    antCls: n
  } = e, o = `${n}-fade`, r = t ? "&" : "";
  return [sc(o, YB, qB, e.motionDurationMid, t), {
    [`
        ${r}${o}-enter,
        ${r}${o}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: "linear"
    },
    [`${r}${o}-leave`]: {
      animationTimingFunction: "linear"
    }
  }];
}, ZB = new lt("antMoveDownIn", {
  "0%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), QB = new lt("antMoveDownOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, 100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), JB = new lt("antMoveLeftIn", {
  "0%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), eF = new lt("antMoveLeftOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(-100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), tF = new lt("antMoveRightIn", {
  "0%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), nF = new lt("antMoveRightOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(100%, 0, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), oF = new lt("antMoveUpIn", {
  "0%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  },
  "100%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  }
}), rF = new lt("antMoveUpOut", {
  "0%": {
    transform: "translate3d(0, 0, 0)",
    transformOrigin: "0 0",
    opacity: 1
  },
  "100%": {
    transform: "translate3d(0, -100%, 0)",
    transformOrigin: "0 0",
    opacity: 0
  }
}), lF = {
  "move-up": {
    inKeyframes: oF,
    outKeyframes: rF
  },
  "move-down": {
    inKeyframes: ZB,
    outKeyframes: QB
  },
  "move-left": {
    inKeyframes: JB,
    outKeyframes: eF
  },
  "move-right": {
    inKeyframes: tF,
    outKeyframes: nF
  }
}, Ci = (e, t) => {
  const {
    antCls: n
  } = e, o = `${n}-${t}`, {
    inKeyframes: r,
    outKeyframes: l
  } = lF[t];
  return [sc(o, r, l, e.motionDurationMid), {
    [`
        ${o}-enter,
        ${o}-appear
      `]: {
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc
    },
    [`${o}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
}, Vf = new lt("antSlideUpIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), Wf = new lt("antSlideUpOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), Kf = new lt("antSlideDownIn", {
  "0%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  }
}), Gf = new lt("antSlideDownOut", {
  "0%": {
    transform: "scaleY(1)",
    transformOrigin: "100% 100%",
    opacity: 1
  },
  "100%": {
    transform: "scaleY(0.8)",
    transformOrigin: "100% 100%",
    opacity: 0
  }
}), aF = new lt("antSlideLeftIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  }
}), iF = new lt("antSlideLeftOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "0% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "0% 0%",
    opacity: 0
  }
}), sF = new lt("antSlideRightIn", {
  "0%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  }
}), cF = new lt("antSlideRightOut", {
  "0%": {
    transform: "scaleX(1)",
    transformOrigin: "100% 0%",
    opacity: 1
  },
  "100%": {
    transform: "scaleX(0.8)",
    transformOrigin: "100% 0%",
    opacity: 0
  }
}), uF = {
  "slide-up": {
    inKeyframes: Vf,
    outKeyframes: Wf
  },
  "slide-down": {
    inKeyframes: Kf,
    outKeyframes: Gf
  },
  "slide-left": {
    inKeyframes: aF,
    outKeyframes: iF
  },
  "slide-right": {
    inKeyframes: sF,
    outKeyframes: cF
  }
}, $r = (e, t) => {
  const {
    antCls: n
  } = e, o = `${n}-${t}`, {
    inKeyframes: r,
    outKeyframes: l
  } = uF[t];
  return [sc(o, r, l, e.motionDurationMid), {
    [`
      ${o}-enter,
      ${o}-appear
    `]: {
      transform: "scale(0)",
      transformOrigin: "0% 0%",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutQuint
    },
    [`${o}-leave`]: {
      animationTimingFunction: e.motionEaseInQuint
    }
  }];
}, a0 = new lt("antZoomIn", {
  "0%": {
    transform: "scale(0.2)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), dF = new lt("antZoomOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.2)",
    opacity: 0
  }
}), _S = new lt("antZoomBigIn", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    opacity: 1
  }
}), AS = new lt("antZoomBigOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0.8)",
    opacity: 0
  }
}), fF = new lt("antZoomUpIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  }
}), pF = new lt("antZoomUpOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 0%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 0%",
    opacity: 0
  }
}), vF = new lt("antZoomLeftIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  }
}), gF = new lt("antZoomLeftOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "0% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "0% 50%",
    opacity: 0
  }
}), mF = new lt("antZoomRightIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  }
}), hF = new lt("antZoomRightOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "100% 50%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "100% 50%",
    opacity: 0
  }
}), bF = new lt("antZoomDownIn", {
  "0%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  }
}), yF = new lt("antZoomDownOut", {
  "0%": {
    transform: "scale(1)",
    transformOrigin: "50% 100%"
  },
  "100%": {
    transform: "scale(0.8)",
    transformOrigin: "50% 100%",
    opacity: 0
  }
}), SF = {
  zoom: {
    inKeyframes: a0,
    outKeyframes: dF
  },
  "zoom-big": {
    inKeyframes: _S,
    outKeyframes: AS
  },
  "zoom-big-fast": {
    inKeyframes: _S,
    outKeyframes: AS
  },
  "zoom-left": {
    inKeyframes: vF,
    outKeyframes: gF
  },
  "zoom-right": {
    inKeyframes: mF,
    outKeyframes: hF
  },
  "zoom-up": {
    inKeyframes: fF,
    outKeyframes: pF
  },
  "zoom-down": {
    inKeyframes: bF,
    outKeyframes: yF
  }
}, Ni = (e, t) => {
  const {
    antCls: n
  } = e, o = `${n}-${t}`, {
    inKeyframes: r,
    outKeyframes: l
  } = SF[t];
  return [sc(o, r, l, t === "zoom-big-fast" ? e.motionDurationFast : e.motionDurationMid), {
    [`
        ${o}-enter,
        ${o}-appear
      `]: {
      transform: "scale(0)",
      opacity: 0,
      animationTimingFunction: e.motionEaseOutCirc,
      "&-prepare": {
        transform: "none"
      }
    },
    [`${o}-leave`]: {
      animationTimingFunction: e.motionEaseInOutCirc
    }
  }];
}, cc = (e) => ({
  [e.componentCls]: {
    // For common/openAnimation
    [`${e.antCls}-motion-collapse-legacy`]: {
      overflow: "hidden",
      "&-active": {
        transition: `height ${e.motionDurationMid} ${e.motionEaseInOut},
        opacity ${e.motionDurationMid} ${e.motionEaseInOut} !important`
      }
    },
    [`${e.antCls}-motion-collapse`]: {
      overflow: "hidden",
      transition: `height ${e.motionDurationMid} ${e.motionEaseInOut},
        opacity ${e.motionDurationMid} ${e.motionEaseInOut} !important`
    }
  }
}), DS = (e) => {
  const {
    controlPaddingHorizontal: t
  } = e;
  return {
    position: "relative",
    display: "block",
    minHeight: e.controlHeight,
    padding: `${(e.controlHeight - e.fontSize * e.lineHeight) / 2}px ${t}px`,
    color: e.colorText,
    fontWeight: "normal",
    fontSize: e.fontSize,
    lineHeight: e.lineHeight,
    boxSizing: "border-box"
  };
}, CF = (e) => {
  const {
    antCls: t,
    componentCls: n
  } = e, o = `${n}-item`;
  return [
    {
      [`${n}-dropdown`]: m(m({}, qe(e)), {
        position: "absolute",
        top: -9999,
        zIndex: e.zIndexPopup,
        boxSizing: "border-box",
        padding: e.paddingXXS,
        overflow: "hidden",
        fontSize: e.fontSize,
        // Fix select render lag of long text in chrome
        // https://github.com/ant-design/ant-design/issues/11456
        // https://github.com/ant-design/ant-design/issues/11843
        fontVariant: "initial",
        backgroundColor: e.colorBgElevated,
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        [`
            &${t}-slide-up-enter${t}-slide-up-enter-active${n}-dropdown-placement-bottomLeft,
            &${t}-slide-up-appear${t}-slide-up-appear-active${n}-dropdown-placement-bottomLeft
          `]: {
          animationName: Vf
        },
        [`
            &${t}-slide-up-enter${t}-slide-up-enter-active${n}-dropdown-placement-topLeft,
            &${t}-slide-up-appear${t}-slide-up-appear-active${n}-dropdown-placement-topLeft
          `]: {
          animationName: Kf
        },
        [`&${t}-slide-up-leave${t}-slide-up-leave-active${n}-dropdown-placement-bottomLeft`]: {
          animationName: Wf
        },
        [`&${t}-slide-up-leave${t}-slide-up-leave-active${n}-dropdown-placement-topLeft`]: {
          animationName: Gf
        },
        "&-hidden": {
          display: "none"
        },
        "&-empty": {
          color: e.colorTextDisabled
        },
        // ========================= Options =========================
        [`${o}-empty`]: m(m({}, DS(e)), {
          color: e.colorTextDisabled
        }),
        [`${o}`]: m(m({}, DS(e)), {
          cursor: "pointer",
          transition: `background ${e.motionDurationSlow} ease`,
          borderRadius: e.borderRadiusSM,
          // =========== Group ============
          "&-group": {
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            cursor: "default"
          },
          // =========== Option ===========
          "&-option": {
            display: "flex",
            "&-content": m({
              flex: "auto"
            }, tn),
            "&-state": {
              flex: "none"
            },
            [`&-active:not(${o}-option-disabled)`]: {
              backgroundColor: e.controlItemBgHover
            },
            [`&-selected:not(${o}-option-disabled)`]: {
              color: e.colorText,
              fontWeight: e.fontWeightStrong,
              backgroundColor: e.controlItemBgActive,
              [`${o}-option-state`]: {
                color: e.colorPrimary
              }
            },
            "&-disabled": {
              [`&${o}-option-selected`]: {
                backgroundColor: e.colorBgContainerDisabled
              },
              color: e.colorTextDisabled,
              cursor: "not-allowed"
            },
            "&-grouped": {
              paddingInlineStart: e.controlPaddingHorizontal * 2
            }
          }
        }),
        // =========================== RTL ===========================
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Follow code may reuse in other components
    $r(e, "slide-up"),
    $r(e, "slide-down"),
    Ci(e, "move-up"),
    Ci(e, "move-down")
  ];
}, Ma = 2;
function CO(e) {
  let {
    controlHeightSM: t,
    controlHeight: n,
    lineWidth: o
  } = e;
  const r = (n - t) / 2 - o, l = Math.ceil(r / 2);
  return [r, l];
}
function iv(e, t) {
  const {
    componentCls: n,
    iconCls: o
  } = e, r = `${n}-selection-overflow`, l = e.controlHeightSM, [a] = CO(e), i = t ? `${n}-${t}` : "";
  return {
    [`${n}-multiple${i}`]: {
      fontSize: e.fontSize,
      /**
       * Do not merge `height` & `line-height` under style with `selection` & `search`, since chrome
       * may update to redesign with its align logic.
       */
      // =========================== Overflow ===========================
      [r]: {
        position: "relative",
        display: "flex",
        flex: "auto",
        flexWrap: "wrap",
        maxWidth: "100%",
        "&-item": {
          flex: "none",
          alignSelf: "center",
          maxWidth: "100%",
          display: "inline-flex"
        }
      },
      // ========================= Selector =========================
      [`${n}-selector`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        // Multiple is little different that horizontal is follow the vertical
        padding: `${a - Ma}px ${Ma * 2}px`,
        borderRadius: e.borderRadius,
        [`${n}-show-search&`]: {
          cursor: "text"
        },
        [`${n}-disabled&`]: {
          background: e.colorBgContainerDisabled,
          cursor: "not-allowed"
        },
        "&:after": {
          display: "inline-block",
          width: 0,
          margin: `${Ma}px 0`,
          lineHeight: `${l}px`,
          content: '"\\a0"'
        }
      },
      [`
        &${n}-show-arrow ${n}-selector,
        &${n}-allow-clear ${n}-selector
      `]: {
        paddingInlineEnd: e.fontSizeIcon + e.controlPaddingHorizontal
      },
      // ======================== Selections ========================
      [`${n}-selection-item`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        boxSizing: "border-box",
        maxWidth: "100%",
        height: l,
        marginTop: Ma,
        marginBottom: Ma,
        lineHeight: `${l - e.lineWidth * 2}px`,
        background: e.colorFillSecondary,
        border: `${e.lineWidth}px solid ${e.colorSplit}`,
        borderRadius: e.borderRadiusSM,
        cursor: "default",
        transition: `font-size ${e.motionDurationSlow}, line-height ${e.motionDurationSlow}, height ${e.motionDurationSlow}`,
        userSelect: "none",
        marginInlineEnd: Ma * 2,
        paddingInlineStart: e.paddingXS,
        paddingInlineEnd: e.paddingXS / 2,
        [`${n}-disabled&`]: {
          color: e.colorTextDisabled,
          borderColor: e.colorBorder,
          cursor: "not-allowed"
        },
        // It's ok not to do this, but 24px makes bottom narrow in view should adjust
        "&-content": {
          display: "inline-block",
          marginInlineEnd: e.paddingXS / 2,
          overflow: "hidden",
          whiteSpace: "pre",
          textOverflow: "ellipsis"
        },
        "&-remove": m(m({}, ha()), {
          display: "inline-block",
          color: e.colorIcon,
          fontWeight: "bold",
          fontSize: 10,
          lineHeight: "inherit",
          cursor: "pointer",
          [`> ${o}`]: {
            verticalAlign: "-0.2em"
          },
          "&:hover": {
            color: e.colorIconHover
          }
        })
      },
      // ========================== Input ==========================
      [`${r}-item + ${r}-item`]: {
        [`${n}-selection-search`]: {
          marginInlineStart: 0
        }
      },
      [`${n}-selection-search`]: {
        display: "inline-flex",
        position: "relative",
        maxWidth: "100%",
        marginInlineStart: e.inputPaddingHorizontalBase - a,
        "\n          &-input,\n          &-mirror\n        ": {
          height: l,
          fontFamily: e.fontFamily,
          lineHeight: `${l}px`,
          transition: `all ${e.motionDurationSlow}`
        },
        "&-input": {
          width: "100%",
          minWidth: 4.1
          // fix search cursor missing
        },
        "&-mirror": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          insetInlineEnd: "auto",
          zIndex: 999,
          whiteSpace: "pre",
          visibility: "hidden"
        }
      },
      // ======================= Placeholder =======================
      [`${n}-selection-placeholder `]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: e.inputPaddingHorizontalBase,
        insetInlineEnd: e.inputPaddingHorizontalBase,
        transform: "translateY(-50%)",
        transition: `all ${e.motionDurationSlow}`
      }
    }
  };
}
function $F(e) {
  const {
    componentCls: t
  } = e, n = He(e, {
    controlHeight: e.controlHeightSM,
    controlHeightSM: e.controlHeightXS,
    borderRadius: e.borderRadiusSM,
    borderRadiusSM: e.borderRadiusXS
  }), [, o] = CO(e);
  return [
    iv(e),
    // ======================== Small ========================
    // Shared
    iv(n, "sm"),
    // Padding
    {
      [`${t}-multiple${t}-sm`]: {
        [`${t}-selection-placeholder`]: {
          insetInlineStart: e.controlPaddingHorizontalSM - e.lineWidth,
          insetInlineEnd: "auto"
        },
        // https://github.com/ant-design/ant-design/issues/29559
        [`${t}-selection-search`]: {
          marginInlineStart: o
        }
      }
    },
    // ======================== Large ========================
    // Shared
    iv(He(e, {
      fontSize: e.fontSizeLG,
      controlHeight: e.controlHeightLG,
      controlHeightSM: e.controlHeight,
      borderRadius: e.borderRadiusLG,
      borderRadiusSM: e.borderRadius
    }), "lg")
  ];
}
function sv(e, t) {
  const {
    componentCls: n,
    inputPaddingHorizontalBase: o,
    borderRadius: r
  } = e, l = e.controlHeight - e.lineWidth * 2, a = Math.ceil(e.fontSize * 1.25), i = t ? `${n}-${t}` : "";
  return {
    [`${n}-single${i}`]: {
      fontSize: e.fontSize,
      // ========================= Selector =========================
      [`${n}-selector`]: m(m({}, qe(e)), {
        display: "flex",
        borderRadius: r,
        [`${n}-selection-search`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: o,
          insetInlineEnd: o,
          bottom: 0,
          "&-input": {
            width: "100%"
          }
        },
        [`
          ${n}-selection-item,
          ${n}-selection-placeholder
        `]: {
          padding: 0,
          lineHeight: `${l}px`,
          transition: `all ${e.motionDurationSlow}`,
          // Firefox inline-block position calculation is not same as Chrome & Safari. Patch this:
          "@supports (-moz-appearance: meterbar)": {
            lineHeight: `${l}px`
          }
        },
        [`${n}-selection-item`]: {
          position: "relative",
          userSelect: "none"
        },
        [`${n}-selection-placeholder`]: {
          transition: "none",
          pointerEvents: "none"
        },
        // For common baseline align
        [[
          "&:after",
          /* For '' value baseline align */
          `${n}-selection-item:after`,
          /* For undefined value baseline align */
          `${n}-selection-placeholder:after`
        ].join(",")]: {
          display: "inline-block",
          width: 0,
          visibility: "hidden",
          content: '"\\a0"'
        }
      }),
      [`
        &${n}-show-arrow ${n}-selection-item,
        &${n}-show-arrow ${n}-selection-placeholder
      `]: {
        paddingInlineEnd: a
      },
      // Opacity selection if open
      [`&${n}-open ${n}-selection-item`]: {
        color: e.colorTextPlaceholder
      },
      // ========================== Input ==========================
      // We only change the style of non-customize input which is only support by `combobox` mode.
      // Not customize
      [`&:not(${n}-customize-input)`]: {
        [`${n}-selector`]: {
          width: "100%",
          height: e.controlHeight,
          padding: `0 ${o}px`,
          [`${n}-selection-search-input`]: {
            height: l
          },
          "&:after": {
            lineHeight: `${l}px`
          }
        }
      },
      [`&${n}-customize-input`]: {
        [`${n}-selector`]: {
          "&:after": {
            display: "none"
          },
          [`${n}-selection-search`]: {
            position: "static",
            width: "100%"
          },
          [`${n}-selection-placeholder`]: {
            position: "absolute",
            insetInlineStart: 0,
            insetInlineEnd: 0,
            padding: `0 ${o}px`,
            "&:after": {
              display: "none"
            }
          }
        }
      }
    }
  };
}
function wF(e) {
  const {
    componentCls: t
  } = e, n = e.controlPaddingHorizontalSM - e.lineWidth;
  return [
    sv(e),
    // ======================== Small ========================
    // Shared
    sv(He(e, {
      controlHeight: e.controlHeightSM,
      borderRadius: e.borderRadiusSM
    }), "sm"),
    // padding
    {
      [`${t}-single${t}-sm`]: {
        [`&:not(${t}-customize-input)`]: {
          [`${t}-selection-search`]: {
            insetInlineStart: n,
            insetInlineEnd: n
          },
          [`${t}-selector`]: {
            padding: `0 ${n}px`
          },
          // With arrow should provides `padding-right` to show the arrow
          [`&${t}-show-arrow ${t}-selection-search`]: {
            insetInlineEnd: n + e.fontSize * 1.5
          },
          [`
            &${t}-show-arrow ${t}-selection-item,
            &${t}-show-arrow ${t}-selection-placeholder
          `]: {
            paddingInlineEnd: e.fontSize * 1.5
          }
        }
      }
    },
    // ======================== Large ========================
    // Shared
    sv(He(e, {
      controlHeight: e.controlHeightLG,
      fontSize: e.fontSizeLG,
      borderRadius: e.borderRadiusLG
    }), "lg")
  ];
}
function xF(e, t, n) {
  const {
    focusElCls: o,
    focus: r,
    borderElCls: l
  } = n, a = l ? "> *" : "", i = ["hover", r ? "focus" : null, "active"].filter(Boolean).map((s) => `&:${s} ${a}`).join(",");
  return {
    [`&-item:not(${t}-last-item)`]: {
      marginInlineEnd: -e.lineWidth
    },
    "&-item": m(m({
      [i]: {
        zIndex: 2
      }
    }, o ? {
      [`&${o}`]: {
        zIndex: 2
      }
    } : {}), {
      [`&[disabled] ${a}`]: {
        zIndex: 0
      }
    })
  };
}
function OF(e, t, n) {
  const {
    borderElCls: o
  } = n, r = o ? `> ${o}` : "";
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item) ${r}`]: {
      borderRadius: 0
    },
    [`&-item:not(${t}-last-item)${t}-first-item`]: {
      [`& ${r}, &${e}-sm ${r}, &${e}-lg ${r}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`&-item:not(${t}-first-item)${t}-last-item`]: {
      [`& ${r}, &${e}-sm ${r}, &${e}-lg ${r}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    }
  };
}
function Ri(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    focus: !0
  };
  const {
    componentCls: n
  } = e, o = `${n}-compact`;
  return {
    [o]: m(m({}, xF(e, o, t)), OF(n, o, t))
  };
}
const PF = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    position: "relative",
    backgroundColor: e.colorBgContainer,
    border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
    transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
    input: {
      cursor: "pointer"
    },
    [`${t}-show-search&`]: {
      cursor: "text",
      input: {
        cursor: "auto",
        color: "inherit"
      }
    },
    [`${t}-disabled&`]: {
      color: e.colorTextDisabled,
      background: e.colorBgContainerDisabled,
      cursor: "not-allowed",
      [`${t}-multiple&`]: {
        background: e.colorBgContainerDisabled
      },
      input: {
        cursor: "not-allowed"
      }
    }
  };
}, cv = function(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const {
    componentCls: o,
    borderHoverColor: r,
    outlineColor: l,
    antCls: a
  } = t, i = n ? {
    [`${o}-selector`]: {
      borderColor: r
    }
  } : {};
  return {
    [e]: {
      [`&:not(${o}-disabled):not(${o}-customize-input):not(${a}-pagination-size-changer)`]: m(m({}, i), {
        [`${o}-focused& ${o}-selector`]: {
          borderColor: r,
          boxShadow: `0 0 0 ${t.controlOutlineWidth}px ${l}`,
          borderInlineEndWidth: `${t.controlLineWidth}px !important`,
          outline: 0
        },
        [`&:hover ${o}-selector`]: {
          borderColor: r,
          borderInlineEndWidth: `${t.controlLineWidth}px !important`
        }
      })
    }
  };
}, IF = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-selection-search-input`]: {
      margin: 0,
      padding: 0,
      background: "transparent",
      border: "none",
      outline: "none",
      appearance: "none",
      "&::-webkit-search-cancel-button": {
        display: "none",
        "-webkit-appearance": "none"
      }
    }
  };
}, EF = (e) => {
  const {
    componentCls: t,
    inputPaddingHorizontalBase: n,
    iconCls: o
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      position: "relative",
      display: "inline-block",
      cursor: "pointer",
      [`&:not(${t}-customize-input) ${t}-selector`]: m(m({}, PF(e)), IF(e)),
      // [`&:not(&-disabled):hover ${selectCls}-selector`]: {
      //   ...genHoverStyle(token),
      // },
      // ======================== Selection ========================
      [`${t}-selection-item`]: m({
        flex: 1,
        fontWeight: "normal"
      }, tn),
      // ======================= Placeholder =======================
      [`${t}-selection-placeholder`]: m(m({}, tn), {
        flex: 1,
        color: e.colorTextPlaceholder,
        pointerEvents: "none"
      }),
      // ========================== Arrow ==========================
      [`${t}-arrow`]: m(m({}, ha()), {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        height: e.fontSizeIcon,
        marginTop: -e.fontSizeIcon / 2,
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        lineHeight: 1,
        textAlign: "center",
        pointerEvents: "none",
        display: "flex",
        alignItems: "center",
        [o]: {
          verticalAlign: "top",
          transition: `transform ${e.motionDurationSlow}`,
          "> svg": {
            verticalAlign: "top"
          },
          [`&:not(${t}-suffix)`]: {
            pointerEvents: "auto"
          }
        },
        [`${t}-disabled &`]: {
          cursor: "not-allowed"
        },
        "> *:not(:last-child)": {
          marginInlineEnd: 8
          // FIXME: magic
        }
      }),
      // ========================== Clear ==========================
      [`${t}-clear`]: {
        position: "absolute",
        top: "50%",
        insetInlineStart: "auto",
        insetInlineEnd: n,
        zIndex: 1,
        display: "inline-block",
        width: e.fontSizeIcon,
        height: e.fontSizeIcon,
        marginTop: -e.fontSizeIcon / 2,
        color: e.colorTextQuaternary,
        fontSize: e.fontSizeIcon,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        background: e.colorBgContainer,
        cursor: "pointer",
        opacity: 0,
        transition: `color ${e.motionDurationMid} ease, opacity ${e.motionDurationSlow} ease`,
        textRendering: "auto",
        "&:before": {
          display: "block"
        },
        "&:hover": {
          color: e.colorTextTertiary
        }
      },
      "&:hover": {
        [`${t}-clear`]: {
          opacity: 1
        }
      }
    }),
    // ========================= Feedback ==========================
    [`${t}-has-feedback`]: {
      [`${t}-clear`]: {
        insetInlineEnd: n + e.fontSize + e.paddingXXS
      }
    }
  };
}, TF = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    {
      [t]: {
        // ==================== BorderLess ====================
        [`&-borderless ${t}-selector`]: {
          backgroundColor: "transparent !important",
          borderColor: "transparent !important",
          boxShadow: "none !important"
        },
        // ==================== In Form ====================
        [`&${t}-in-form-item`]: {
          width: "100%"
        }
      }
    },
    // =====================================================
    // ==                       LTR                       ==
    // =====================================================
    // Base
    EF(e),
    // Single
    wF(e),
    // Multiple
    $F(e),
    // Dropdown
    CF(e),
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${t}-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==                     Status                      ==
    // =====================================================
    cv(t, He(e, {
      borderHoverColor: e.colorPrimaryHover,
      outlineColor: e.controlOutline
    })),
    cv(`${t}-status-error`, He(e, {
      borderHoverColor: e.colorErrorHover,
      outlineColor: e.colorErrorOutline
    }), !0),
    cv(`${t}-status-warning`, He(e, {
      borderHoverColor: e.colorWarningHover,
      outlineColor: e.colorWarningOutline
    }), !0),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Ri(e, {
      borderElCls: `${t}-selector`,
      focusElCls: `${t}-focused`
    })
  ];
}, i0 = Xe("Select", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const o = He(e, {
    rootPrefixCls: n,
    inputPaddingHorizontalBase: e.paddingSM - 1
  });
  return [TF(o)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50
})), Xf = () => m(m({}, ot(k4(), ["inputIcon", "mode", "getInputElement", "getRawInputElement", "backfill"])), {
  value: je([Array, Object, String, Number]),
  defaultValue: je([Array, Object, String, Number]),
  notFoundContent: V.any,
  suffixIcon: V.any,
  itemIcon: V.any,
  size: ke(),
  mode: ke(),
  bordered: ve(!0),
  transitionName: String,
  choiceTransitionName: ke(""),
  popupClassName: String,
  /** @deprecated Please use `popupClassName` instead */
  dropdownClassName: String,
  placement: ke(),
  status: ke(),
  "onUpdate:value": le()
}), NS = "SECRET_COMBOBOX_MODE_DO_NOT_USE", bn = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASelect",
  Option: Wh,
  OptGroup: Kh,
  inheritAttrs: !1,
  props: Qe(Xf(), {
    listHeight: 256,
    listItemHeight: 24
  }),
  SECRET_COMBOBOX_MODE_DO_NOT_USE: NS,
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      slots: r,
      expose: l
    } = t;
    const a = Y(), i = sn(), s = Sn.useInject(), c = P(() => ar(s.status, e.status)), u = () => {
      var H;
      (H = a.value) === null || H === void 0 || H.focus();
    }, d = () => {
      var H;
      (H = a.value) === null || H === void 0 || H.blur();
    }, p = (H) => {
      var K;
      (K = a.value) === null || K === void 0 || K.scrollTo(H);
    }, v = P(() => {
      const {
        mode: H
      } = e;
      if (H !== "combobox")
        return H === NS ? "combobox" : H;
    });
    process.env.NODE_ENV !== "production" && nt(!e.dropdownClassName, "Select", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const {
      prefixCls: h,
      direction: g,
      configProvider: b,
      renderEmpty: y,
      size: S,
      getPrefixCls: C,
      getPopupContainer: w,
      disabled: $,
      select: O
    } = Ie("select", e), {
      compactSize: x,
      compactItemClassnames: I
    } = Ol(h, g), E = P(() => x.value || S.value), _ = so(), M = P(() => {
      var H;
      return (H = $.value) !== null && H !== void 0 ? H : _.value;
    }), [R, A] = i0(h), z = P(() => C()), T = P(() => e.placement !== void 0 ? e.placement : g.value === "rtl" ? "bottomRight" : "bottomLeft"), N = P(() => Vn(z.value, Nh(T.value), e.transitionName)), k = P(() => ee({
      [`${h.value}-lg`]: E.value === "large",
      [`${h.value}-sm`]: E.value === "small",
      [`${h.value}-rtl`]: g.value === "rtl",
      [`${h.value}-borderless`]: !e.bordered,
      [`${h.value}-in-form-item`]: s.isFormItemInput
    }, Fn(h.value, c.value, s.hasFeedback), I.value, A.value)), B = function() {
      for (var H = arguments.length, K = new Array(H), X = 0; X < H; X++)
        K[X] = arguments[X];
      o("update:value", K[0]), o("change", ...K), i.onFieldChange();
    }, F = (H) => {
      o("blur", H), i.onFieldBlur();
    };
    l({
      blur: d,
      focus: u,
      scrollTo: p
    });
    const L = P(() => v.value === "multiple" || v.value === "tags"), j = P(() => e.showArrow !== void 0 ? e.showArrow : e.loading || !(L.value || v.value === "combobox"));
    return () => {
      var H, K, X, W;
      const {
        notFoundContent: q,
        listHeight: J = 256,
        listItemHeight: ne = 24,
        popupClassName: te,
        dropdownClassName: G,
        virtual: U,
        dropdownMatchSelectWidth: re,
        id: se = i.id.value,
        placeholder: me = (H = r.placeholder) === null || H === void 0 ? void 0 : H.call(r),
        showArrow: Ce
      } = e, {
        hasFeedback: fe,
        feedbackIcon: be
      } = s;
      let ue;
      q !== void 0 ? ue = q : r.notFoundContent ? ue = r.notFoundContent() : v.value === "combobox" ? ue = null : ue = (y == null ? void 0 : y("Select")) || f(vh, {
        componentName: "Select"
      }, null);
      const {
        suffixIcon: de,
        itemIcon: Se,
        removeIcon: xe,
        clearIcon: he
      } = Uh(m(m({}, e), {
        multiple: L.value,
        prefixCls: h.value,
        hasFeedback: fe,
        feedbackIcon: be,
        showArrow: j.value
      }), r), we = ot(e, ["prefixCls", "suffixIcon", "itemIcon", "removeIcon", "clearIcon", "size", "bordered", "status"]), Me = ee(te || G, {
        [`${h.value}-dropdown-${g.value}`]: g.value === "rtl"
      }, A.value);
      return R(f(aN, D(D(D({
        ref: a,
        virtual: U,
        dropdownMatchSelectWidth: re
      }, we), n), {}, {
        showSearch: (K = e.showSearch) !== null && K !== void 0 ? K : (X = O == null ? void 0 : O.value) === null || X === void 0 ? void 0 : X.showSearch,
        placeholder: me,
        listHeight: J,
        listItemHeight: ne,
        mode: v.value,
        prefixCls: h.value,
        direction: g.value,
        inputIcon: de,
        menuItemSelectedIcon: Se,
        removeIcon: xe,
        clearIcon: he,
        notFoundContent: ue,
        class: [k.value, n.class],
        getPopupContainer: w == null ? void 0 : w.value,
        dropdownClassName: Me,
        onChange: B,
        onBlur: F,
        id: se,
        dropdownRender: we.dropdownRender || r.dropdownRender,
        transitionName: N.value,
        children: (W = r.default) === null || W === void 0 ? void 0 : W.call(r),
        tagRender: e.tagRender || r.tagRender,
        optionLabelRender: r.optionLabel,
        maxTagPlaceholder: e.maxTagPlaceholder || r.maxTagPlaceholder,
        showArrow: fe || Ce,
        disabled: M.value
      }), {
        option: r.option
      }));
    };
  }
});
bn.install = function(e) {
  return e.component(bn.name, bn), e.component(bn.Option.displayName, bn.Option), e.component(bn.OptGroup.displayName, bn.OptGroup), e;
};
const MF = bn.Option, _F = bn.OptGroup, gl = () => null;
gl.isSelectOption = !0;
gl.displayName = "AAutoCompleteOption";
const oi = () => null;
oi.isSelectOptGroup = !0;
oi.displayName = "AAutoCompleteOptGroup";
function AF(e) {
  var t, n;
  return ((t = e == null ? void 0 : e.type) === null || t === void 0 ? void 0 : t.isSelectOption) || ((n = e == null ? void 0 : e.type) === null || n === void 0 ? void 0 : n.isSelectOptGroup);
}
const DF = () => m(m({}, ot(Xf(), ["loading", "mode", "optionLabelProp", "labelInValue"])), {
  dataSource: Array,
  dropdownMenuStyle: {
    type: Object,
    default: void 0
  },
  // optionLabelProp: String,
  dropdownMatchSelectWidth: {
    type: [Number, Boolean],
    default: !0
  },
  prefixCls: String,
  showSearch: {
    type: Boolean,
    default: void 0
  },
  transitionName: String,
  choiceTransitionName: {
    type: String,
    default: "zoom"
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  backfill: {
    type: Boolean,
    default: void 0
  },
  // optionLabelProp: PropTypes.string.def('children'),
  filterOption: {
    type: [Boolean, Function],
    default: !1
  },
  defaultActiveFirstOption: {
    type: Boolean,
    default: !0
  },
  status: String
}), NF = gl, RF = oi, uv = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AAutoComplete",
  inheritAttrs: !1,
  props: DF(),
  // emits: ['change', 'select', 'focus', 'blur'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    Mt(!("dataSource" in n), "AutoComplete", "`dataSource` slot is deprecated, please use props `options` instead."), Mt(!("options" in n), "AutoComplete", "`options` slot is deprecated, please use props `options` instead."), Mt(!e.dropdownClassName, "AutoComplete", "`dropdownClassName` is deprecated, please use `popupClassName` instead.");
    const l = Y(), a = () => {
      var u;
      const d = It((u = n.default) === null || u === void 0 ? void 0 : u.call(n));
      return d.length ? d[0] : void 0;
    };
    r({
      focus: () => {
        var u;
        (u = l.value) === null || u === void 0 || u.focus();
      },
      blur: () => {
        var u;
        (u = l.value) === null || u === void 0 || u.blur();
      }
    });
    const {
      prefixCls: c
    } = Ie("select", e);
    return () => {
      var u, d, p;
      const {
        size: v,
        dataSource: h,
        notFoundContent: g = (u = n.notFoundContent) === null || u === void 0 ? void 0 : u.call(n)
      } = e;
      let b;
      const {
        class: y
      } = o, S = {
        [y]: !!y,
        [`${c.value}-lg`]: v === "large",
        [`${c.value}-sm`]: v === "small",
        [`${c.value}-show-search`]: !0,
        [`${c.value}-auto-complete`]: !0
      };
      if (e.options === void 0) {
        const w = ((d = n.dataSource) === null || d === void 0 ? void 0 : d.call(n)) || ((p = n.options) === null || p === void 0 ? void 0 : p.call(n)) || [];
        w.length && AF(w[0]) ? b = w : b = h ? h.map(($) => {
          if (Gt($))
            return $;
          switch (typeof $) {
            case "string":
              return f(gl, {
                key: $,
                value: $
              }, {
                default: () => [$]
              });
            case "object":
              return f(gl, {
                key: $.value,
                value: $.value
              }, {
                default: () => [$.text]
              });
            default:
              throw new Error("AutoComplete[dataSource] only supports type `string[] | Object[]`.");
          }
        }) : [];
      }
      const C = ot(m(m(m({}, e), o), {
        mode: bn.SECRET_COMBOBOX_MODE_DO_NOT_USE,
        // optionLabelProp,
        getInputElement: a,
        notFoundContent: g,
        // placeholder: '',
        class: S,
        popupClassName: e.popupClassName || e.dropdownClassName,
        ref: l
      }), ["dataSource", "loading"]);
      return f(bn, C, D({
        default: () => [b]
      }, ot(n, ["default", "dataSource", "options"])));
    };
  }
}), kF = m(uv, {
  Option: gl,
  OptGroup: oi,
  install(e) {
    return e.component(uv.name, uv), e.component(gl.displayName, gl), e.component(oi.displayName, oi), e;
  }
});
var BF = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M699 353h-46.9c-10.2 0-19.9 4.9-25.9 13.3L469 584.3l-71.2-98.8c-6-8.3-15.6-13.3-25.9-13.3H325c-6.5 0-10.3 7.4-6.5 12.7l124.6 172.8a31.8 31.8 0 0051.7 0l210.6-292c3.9-5.3.1-12.7-6.4-12.7z" } }, { tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }] }, name: "check-circle", theme: "outlined" };
function RS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      FF(e, r, n[r]);
    });
  }
  return e;
}
function FF(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Uf = function(t, n) {
  var o = RS({}, t, n.attrs);
  return f(Ge, RS({}, o, {
    icon: BF
  }), null);
};
Uf.displayName = "CheckCircleOutlined";
Uf.inheritAttrs = !1;
var LF = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M464 688a48 48 0 1096 0 48 48 0 10-96 0zm24-112h48c4.4 0 8-3.6 8-8V296c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8z" } }] }, name: "exclamation-circle", theme: "outlined" };
function kS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      zF(e, r, n[r]);
    });
  }
  return e;
}
function zF(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Yf = function(t, n) {
  var o = kS({}, t, n.attrs);
  return f(Ge, kS({}, o, {
    icon: LF
  }), null);
};
Yf.displayName = "ExclamationCircleOutlined";
Yf.inheritAttrs = !1;
var HF = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M464 336a48 48 0 1096 0 48 48 0 10-96 0zm72 112h-48c-4.4 0-8 3.6-8 8v272c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V456c0-4.4-3.6-8-8-8z" } }] }, name: "info-circle", theme: "outlined" };
function BS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      jF(e, r, n[r]);
    });
  }
  return e;
}
function jF(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var qf = function(t, n) {
  var o = BS({}, t, n.attrs);
  return f(Ge, BS({}, o, {
    icon: HF
  }), null);
};
qf.displayName = "InfoCircleOutlined";
qf.inheritAttrs = !1;
var VF = { icon: { tag: "svg", attrs: { "fill-rule": "evenodd", viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm0 76c-205.4 0-372 166.6-372 372s166.6 372 372 372 372-166.6 372-372-166.6-372-372-372zm128.01 198.83c.03 0 .05.01.09.06l45.02 45.01a.2.2 0 01.05.09.12.12 0 010 .07c0 .02-.01.04-.05.08L557.25 512l127.87 127.86a.27.27 0 01.05.06v.02a.12.12 0 010 .07c0 .03-.01.05-.05.09l-45.02 45.02a.2.2 0 01-.09.05.12.12 0 01-.07 0c-.02 0-.04-.01-.08-.05L512 557.25 384.14 685.12c-.04.04-.06.05-.08.05a.12.12 0 01-.07 0c-.03 0-.05-.01-.09-.05l-45.02-45.02a.2.2 0 01-.05-.09.12.12 0 010-.07c0-.02.01-.04.06-.08L466.75 512 338.88 384.14a.27.27 0 01-.05-.06l-.01-.02a.12.12 0 010-.07c0-.03.01-.05.05-.09l45.02-45.02a.2.2 0 01.09-.05.12.12 0 01.07 0c.02 0 .04.01.08.06L512 466.75l127.86-127.86c.04-.05.06-.06.08-.06a.12.12 0 01.07 0z" } }] }, name: "close-circle", theme: "outlined" };
function FS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      WF(e, r, n[r]);
    });
  }
  return e;
}
function WF(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Zf = function(t, n) {
  var o = FS({}, t, n.attrs);
  return f(Ge, FS({}, o, {
    icon: VF
  }), null);
};
Zf.displayName = "CloseCircleOutlined";
Zf.inheritAttrs = !1;
var KF = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, name: "check-circle", theme: "filled" };
function LS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      GF(e, r, n[r]);
    });
  }
  return e;
}
function GF(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ir = function(t, n) {
  var o = LS({}, t, n.attrs);
  return f(Ge, LS({}, o, {
    icon: KF
  }), null);
};
ir.displayName = "CheckCircleFilled";
ir.inheritAttrs = !1;
var XF = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "exclamation-circle", theme: "filled" };
function zS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      UF(e, r, n[r]);
    });
  }
  return e;
}
function UF(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var sr = function(t, n) {
  var o = zS({}, t, n.attrs);
  return f(Ge, zS({}, o, {
    icon: XF
  }), null);
};
sr.displayName = "ExclamationCircleFilled";
sr.inheritAttrs = !1;
var YF = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "info-circle", theme: "filled" };
function HS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      qF(e, r, n[r]);
    });
  }
  return e;
}
function qF(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Pl = function(t, n) {
  var o = HS({}, t, n.attrs);
  return f(Ge, HS({}, o, {
    icon: YF
  }), null);
};
Pl.displayName = "InfoCircleFilled";
Pl.inheritAttrs = !1;
const Vc = (e, t, n, o, r) => ({
  backgroundColor: e,
  border: `${o.lineWidth}px ${o.lineType} ${t}`,
  [`${r}-icon`]: {
    color: n
  }
}), ZF = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    marginXS: o,
    marginSM: r,
    fontSize: l,
    fontSizeLG: a,
    lineHeight: i,
    borderRadiusLG: s,
    motionEaseInOutCirc: c,
    alertIconSizeLG: u,
    colorText: d,
    paddingContentVerticalSM: p,
    alertPaddingHorizontal: v,
    paddingMD: h,
    paddingContentHorizontalLG: g
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      position: "relative",
      display: "flex",
      alignItems: "center",
      padding: `${p}px ${v}px`,
      wordWrap: "break-word",
      borderRadius: s,
      [`&${t}-rtl`]: {
        direction: "rtl"
      },
      [`${t}-content`]: {
        flex: 1,
        minWidth: 0
      },
      [`${t}-icon`]: {
        marginInlineEnd: o,
        lineHeight: 0
      },
      "&-description": {
        display: "none",
        fontSize: l,
        lineHeight: i
      },
      "&-message": {
        color: d
      },
      [`&${t}-motion-leave`]: {
        overflow: "hidden",
        opacity: 1,
        transition: `max-height ${n} ${c}, opacity ${n} ${c},
        padding-top ${n} ${c}, padding-bottom ${n} ${c},
        margin-bottom ${n} ${c}`
      },
      [`&${t}-motion-leave-active`]: {
        maxHeight: 0,
        marginBottom: "0 !important",
        paddingTop: 0,
        paddingBottom: 0,
        opacity: 0
      }
    }),
    [`${t}-with-description`]: {
      alignItems: "flex-start",
      paddingInline: g,
      paddingBlock: h,
      [`${t}-icon`]: {
        marginInlineEnd: r,
        fontSize: u,
        lineHeight: 0
      },
      [`${t}-message`]: {
        display: "block",
        marginBottom: o,
        color: d,
        fontSize: a
      },
      [`${t}-description`]: {
        display: "block"
      }
    },
    [`${t}-banner`]: {
      marginBottom: 0,
      border: "0 !important",
      borderRadius: 0
    }
  };
}, QF = (e) => {
  const {
    componentCls: t,
    colorSuccess: n,
    colorSuccessBorder: o,
    colorSuccessBg: r,
    colorWarning: l,
    colorWarningBorder: a,
    colorWarningBg: i,
    colorError: s,
    colorErrorBorder: c,
    colorErrorBg: u,
    colorInfo: d,
    colorInfoBorder: p,
    colorInfoBg: v
  } = e;
  return {
    [t]: {
      "&-success": Vc(r, o, n, e, t),
      "&-info": Vc(v, p, d, e, t),
      "&-warning": Vc(i, a, l, e, t),
      "&-error": m(m({}, Vc(u, c, s, e, t)), {
        [`${t}-description > pre`]: {
          margin: 0,
          padding: 0
        }
      })
    }
  };
}, JF = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    motionDurationMid: o,
    marginXS: r,
    fontSizeIcon: l,
    colorIcon: a,
    colorIconHover: i
  } = e;
  return {
    [t]: {
      "&-action": {
        marginInlineStart: r
      },
      [`${t}-close-icon`]: {
        marginInlineStart: r,
        padding: 0,
        overflow: "hidden",
        fontSize: l,
        lineHeight: `${l}px`,
        backgroundColor: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        [`${n}-close`]: {
          color: a,
          transition: `color ${o}`,
          "&:hover": {
            color: i
          }
        }
      },
      "&-close-text": {
        color: a,
        transition: `color ${o}`,
        "&:hover": {
          color: i
        }
      }
    }
  };
}, eL = (e) => [ZF(e), QF(e), JF(e)], tL = Xe("Alert", (e) => {
  const {
    fontSizeHeading3: t
  } = e, n = He(e, {
    alertIconSizeLG: t,
    alertPaddingHorizontal: 12
    // Fixed value here.
  });
  return [eL(n)];
}), nL = {
  success: ir,
  info: Pl,
  error: Gn,
  warning: sr
}, oL = {
  success: Uf,
  info: qf,
  error: Zf,
  warning: Yf
}, rL = Mn("success", "info", "warning", "error"), lL = () => ({
  /**
   * Type of Alert styles, options: `success`, `info`, `warning`, `error`
   */
  type: V.oneOf(rL),
  /** Whether Alert can be closed */
  closable: {
    type: Boolean,
    default: void 0
  },
  /** Close text to show */
  closeText: V.any,
  /** Content of Alert */
  message: V.any,
  /** Additional content of Alert */
  description: V.any,
  /** Trigger when animation ending of Alert */
  afterClose: Function,
  /** Whether to show icon */
  showIcon: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  banner: {
    type: Boolean,
    default: void 0
  },
  icon: V.any,
  closeIcon: V.any,
  onClose: Function
}), aL = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AAlert",
  inheritAttrs: !1,
  props: lL(),
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r,
      expose: l
    } = t;
    const {
      prefixCls: a,
      direction: i
    } = Ie("alert", e), [s, c] = tL(a), u = Q(!1), d = Q(!1), p = Q(), v = (y) => {
      y.preventDefault();
      const S = p.value;
      S.style.height = `${S.offsetHeight}px`, S.style.height = `${S.offsetHeight}px`, u.value = !0, o("close", y);
    }, h = () => {
      var y;
      u.value = !1, d.value = !0, (y = e.afterClose) === null || y === void 0 || y.call(e);
    }, g = P(() => {
      const {
        type: y
      } = e;
      return y !== void 0 ? y : e.banner ? "warning" : "info";
    });
    l({
      animationEnd: h
    });
    const b = Q({});
    return () => {
      var y, S, C, w, $, O, x, I, E, _;
      const {
        banner: M,
        closeIcon: R = (y = n.closeIcon) === null || y === void 0 ? void 0 : y.call(n)
      } = e;
      let {
        closable: A,
        showIcon: z
      } = e;
      const T = (S = e.closeText) !== null && S !== void 0 ? S : (C = n.closeText) === null || C === void 0 ? void 0 : C.call(n), N = (w = e.description) !== null && w !== void 0 ? w : ($ = n.description) === null || $ === void 0 ? void 0 : $.call(n), k = (O = e.message) !== null && O !== void 0 ? O : (x = n.message) === null || x === void 0 ? void 0 : x.call(n), B = (I = e.icon) !== null && I !== void 0 ? I : (E = n.icon) === null || E === void 0 ? void 0 : E.call(n), F = (_ = n.action) === null || _ === void 0 ? void 0 : _.call(n);
      z = M && z === void 0 ? !0 : z;
      const L = (N ? oL : nL)[g.value] || null;
      T && (A = !0);
      const j = a.value, H = ee(j, {
        [`${j}-${g.value}`]: !0,
        [`${j}-closing`]: u.value,
        [`${j}-with-description`]: !!N,
        [`${j}-no-icon`]: !z,
        [`${j}-banner`]: !!M,
        [`${j}-closable`]: A,
        [`${j}-rtl`]: i.value === "rtl",
        [c.value]: !0
      }), K = A ? f("button", {
        type: "button",
        onClick: v,
        class: `${j}-close-icon`,
        tabindex: 0
      }, [T ? f("span", {
        class: `${j}-close-text`
      }, [T]) : R === void 0 ? f(Kn, null, null) : R]) : null, X = B && (Gt(B) ? yt(B, {
        class: `${j}-icon`
      }) : f("span", {
        class: `${j}-icon`
      }, [B])) || f(L, {
        class: `${j}-icon`
      }, null), W = Ho(`${j}-motion`, {
        appear: !1,
        css: !0,
        onAfterLeave: h,
        onBeforeLeave: (q) => {
          q.style.maxHeight = `${q.offsetHeight}px`;
        },
        onLeave: (q) => {
          q.style.maxHeight = "0px";
        }
      });
      return s(d.value ? null : f(yn, W, {
        default: () => [Tn(f("div", D(D({
          role: "alert"
        }, r), {}, {
          style: [r.style, b.value],
          class: [r.class, H],
          "data-show": !u.value,
          ref: p
        }), [z ? X : null, f("div", {
          class: `${j}-content`
        }, [k ? f("div", {
          class: `${j}-message`
        }, [k]) : null, N ? f("div", {
          class: `${j}-description`
        }, [N]) : null]), F ? f("div", {
          class: `${j}-action`
        }, [F]) : null, K]), [[Hn, !u.value]])]
      }));
    };
  }
}), iL = kt(aL), Lr = ["xxxl", "xxl", "xl", "lg", "md", "sm", "xs"], sL = (e) => ({
  xs: `(max-width: ${e.screenXSMax}px)`,
  sm: `(min-width: ${e.screenSM}px)`,
  md: `(min-width: ${e.screenMD}px)`,
  lg: `(min-width: ${e.screenLG}px)`,
  xl: `(min-width: ${e.screenXL}px)`,
  xxl: `(min-width: ${e.screenXXL}px)`,
  xxxl: `{min-width: ${e.screenXXXL}px}`
});
function s0() {
  const [, e] = qr();
  return P(() => {
    const t = sL(e.value), n = /* @__PURE__ */ new Map();
    let o = -1, r = {};
    return {
      matchHandlers: {},
      dispatch(l) {
        return r = l, n.forEach((a) => a(r)), n.size >= 1;
      },
      subscribe(l) {
        return n.size || this.register(), o += 1, n.set(o, l), l(r), o;
      },
      unsubscribe(l) {
        n.delete(l), n.size || this.unregister();
      },
      unregister() {
        Object.keys(t).forEach((l) => {
          const a = t[l], i = this.matchHandlers[a];
          i == null || i.mql.removeListener(i == null ? void 0 : i.listener);
        }), n.clear();
      },
      register() {
        Object.keys(t).forEach((l) => {
          const a = t[l], i = (c) => {
            let {
              matches: u
            } = c;
            this.dispatch(m(m({}, r), {
              [l]: u
            }));
          }, s = window.matchMedia(a);
          s.addListener(i), this.matchHandlers[a] = {
            mql: s,
            listener: i
          }, i(s);
        });
      },
      responsiveMap: t
    };
  });
}
function ki() {
  const e = Q({});
  let t = null;
  const n = s0();
  return Ke(() => {
    t = n.value.subscribe((o) => {
      e.value = o;
    });
  }), uo(() => {
    n.value.unsubscribe(t);
  }), e;
}
function So(e) {
  const t = Q();
  return Le(() => {
    t.value = e();
  }, {
    flush: "sync"
    // needed so updates are immediate.
  }), t;
}
const cL = (e) => {
  const {
    antCls: t,
    componentCls: n,
    iconCls: o,
    avatarBg: r,
    avatarColor: l,
    containerSize: a,
    containerSizeLG: i,
    containerSizeSM: s,
    textFontSize: c,
    textFontSizeLG: u,
    textFontSizeSM: d,
    borderRadius: p,
    borderRadiusLG: v,
    borderRadiusSM: h,
    lineWidth: g,
    lineType: b
  } = e, y = (S, C, w) => ({
    width: S,
    height: S,
    lineHeight: `${S - g * 2}px`,
    borderRadius: "50%",
    [`&${n}-square`]: {
      borderRadius: w
    },
    [`${n}-string`]: {
      position: "absolute",
      left: {
        _skip_check_: !0,
        value: "50%"
      },
      transformOrigin: "0 center"
    },
    [`&${n}-icon`]: {
      fontSize: C,
      [`> ${o}`]: {
        margin: 0
      }
    }
  });
  return {
    [n]: m(m(m(m({}, qe(e)), {
      position: "relative",
      display: "inline-block",
      overflow: "hidden",
      color: l,
      whiteSpace: "nowrap",
      textAlign: "center",
      verticalAlign: "middle",
      background: r,
      border: `${g}px ${b} transparent`,
      "&-image": {
        background: "transparent"
      },
      [`${t}-image-img`]: {
        display: "block"
      }
    }), y(a, c, p)), {
      "&-lg": m({}, y(i, u, v)),
      "&-sm": m({}, y(s, d, h)),
      "> img": {
        display: "block",
        width: "100%",
        height: "100%",
        objectFit: "cover"
      }
    })
  };
}, uL = (e) => {
  const {
    componentCls: t,
    groupBorderColor: n,
    groupOverlapping: o,
    groupSpace: r
  } = e;
  return {
    [`${t}-group`]: {
      display: "inline-flex",
      [`${t}`]: {
        borderColor: n
      },
      "> *:not(:first-child)": {
        marginInlineStart: o
      }
    },
    [`${t}-group-popover`]: {
      [`${t} + ${t}`]: {
        marginInlineStart: r
      }
    }
  };
}, $O = Xe("Avatar", (e) => {
  const {
    colorTextLightSolid: t,
    colorTextPlaceholder: n
  } = e, o = He(e, {
    avatarBg: n,
    avatarColor: t
  });
  return [cL(o), uL(o)];
}, (e) => {
  const {
    controlHeight: t,
    controlHeightLG: n,
    controlHeightSM: o,
    fontSize: r,
    fontSizeLG: l,
    fontSizeXL: a,
    fontSizeHeading3: i,
    marginXS: s,
    marginXXS: c,
    colorBorderBg: u
  } = e;
  return {
    containerSize: t,
    containerSizeLG: n,
    containerSizeSM: o,
    textFontSize: Math.round((l + a) / 2),
    textFontSizeLG: i,
    textFontSizeSM: r,
    groupSpace: c,
    groupOverlapping: -s,
    groupBorderColor: u
  };
}), wO = Symbol("AvatarContextKey"), dL = () => tt(wO, {}), fL = (e) => Je(wO, e), pL = () => ({
  prefixCls: String,
  shape: {
    type: String,
    default: "circle"
  },
  size: {
    type: [Number, String, Object],
    default: () => "default"
  },
  src: String,
  /** Srcset of image avatar */
  srcset: String,
  icon: V.any,
  alt: String,
  gap: Number,
  draggable: {
    type: Boolean,
    default: void 0
  },
  crossOrigin: String,
  loadError: {
    type: Function
  }
}), ea = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatar",
  inheritAttrs: !1,
  props: pL(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = Q(!0), l = Q(!1), a = Q(1), i = Q(null), s = Q(null), {
      prefixCls: c
    } = Ie("avatar", e), [u, d] = $O(c), p = dL(), v = P(() => e.size === "default" ? p.size : e.size), h = ki(), g = So(() => {
      if (typeof e.size != "object")
        return;
      const C = Lr.find(($) => h.value[$]);
      return e.size[C];
    }), b = (C) => g.value ? {
      width: `${g.value}px`,
      height: `${g.value}px`,
      lineHeight: `${g.value}px`,
      fontSize: `${C ? g.value / 2 : 18}px`
    } : {}, y = () => {
      if (!i.value || !s.value)
        return;
      const C = i.value.offsetWidth, w = s.value.offsetWidth;
      if (C !== 0 && w !== 0) {
        const {
          gap: $ = 4
        } = e;
        $ * 2 < w && (a.value = w - $ * 2 < C ? (w - $ * 2) / C : 1);
      }
    }, S = () => {
      const {
        loadError: C
      } = e;
      (C == null ? void 0 : C()) !== !1 && (r.value = !1);
    };
    return ie(() => e.src, () => {
      rt(() => {
        r.value = !0, a.value = 1;
      });
    }), ie(() => e.gap, () => {
      rt(() => {
        y();
      });
    }), Ke(() => {
      rt(() => {
        y(), l.value = !0;
      });
    }), () => {
      var C, w;
      const {
        shape: $,
        src: O,
        alt: x,
        srcset: I,
        draggable: E,
        crossOrigin: _
      } = e, M = (C = p.shape) !== null && C !== void 0 ? C : $, R = an(n, e, "icon"), A = c.value, z = {
        [`${o.class}`]: !!o.class,
        [A]: !0,
        [`${A}-lg`]: v.value === "large",
        [`${A}-sm`]: v.value === "small",
        [`${A}-${M}`]: !0,
        [`${A}-image`]: O && r.value,
        [`${A}-icon`]: R,
        [d.value]: !0
      }, T = typeof v.value == "number" ? {
        width: `${v.value}px`,
        height: `${v.value}px`,
        lineHeight: `${v.value}px`,
        fontSize: R ? `${v.value / 2}px` : "18px"
      } : {}, N = (w = n.default) === null || w === void 0 ? void 0 : w.call(n);
      let k;
      if (O && r.value)
        k = f("img", {
          draggable: E,
          src: O,
          srcset: I,
          onError: S,
          alt: x,
          crossorigin: _
        }, null);
      else if (R)
        k = R;
      else if (l.value || a.value !== 1) {
        const B = `scale(${a.value}) translateX(-50%)`, F = {
          msTransform: B,
          WebkitTransform: B,
          transform: B
        }, L = typeof v.value == "number" ? {
          lineHeight: `${v.value}px`
        } : {};
        k = f(Fo, {
          onResize: y
        }, {
          default: () => [f("span", {
            class: `${A}-string`,
            ref: i,
            style: m(m({}, L), F)
          }, [N])]
        });
      } else
        k = f("span", {
          class: `${A}-string`,
          ref: i,
          style: {
            opacity: 0
          }
        }, [N]);
      return u(f("span", D(D({}, o), {}, {
        ref: s,
        class: z,
        style: [T, b(!!R), o.style]
      }), [k]));
    };
  }
}), Mo = {
  adjustX: 1,
  adjustY: 1
}, _o = [0, 0], xO = {
  left: {
    points: ["cr", "cl"],
    overflow: Mo,
    offset: [-4, 0],
    targetOffset: _o
  },
  right: {
    points: ["cl", "cr"],
    overflow: Mo,
    offset: [4, 0],
    targetOffset: _o
  },
  top: {
    points: ["bc", "tc"],
    overflow: Mo,
    offset: [0, -4],
    targetOffset: _o
  },
  bottom: {
    points: ["tc", "bc"],
    overflow: Mo,
    offset: [0, 4],
    targetOffset: _o
  },
  topLeft: {
    points: ["bl", "tl"],
    overflow: Mo,
    offset: [0, -4],
    targetOffset: _o
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: Mo,
    offset: [-4, 0],
    targetOffset: _o
  },
  topRight: {
    points: ["br", "tr"],
    overflow: Mo,
    offset: [0, -4],
    targetOffset: _o
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: Mo,
    offset: [4, 0],
    targetOffset: _o
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: Mo,
    offset: [0, 4],
    targetOffset: _o
  },
  rightBottom: {
    points: ["bl", "br"],
    overflow: Mo,
    offset: [4, 0],
    targetOffset: _o
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: Mo,
    offset: [0, 4],
    targetOffset: _o
  },
  leftBottom: {
    points: ["br", "bl"],
    overflow: Mo,
    offset: [-4, 0],
    targetOffset: _o
  }
}, vL = {
  prefixCls: String,
  id: String,
  overlayInnerStyle: V.any
}, gL = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TooltipContent",
  props: vL,
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return f("div", {
        class: `${e.prefixCls}-inner`,
        id: e.id,
        role: "tooltip",
        style: e.overlayInnerStyle
      }, [(o = n.overlay) === null || o === void 0 ? void 0 : o.call(n)]);
    };
  }
});
var mL = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function jS() {
}
const hL = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Tooltip",
  inheritAttrs: !1,
  props: {
    trigger: V.any.def(["hover"]),
    defaultVisible: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    placement: V.string.def("right"),
    transitionName: String,
    animation: V.any,
    afterVisibleChange: V.func.def(() => {
    }),
    overlayStyle: {
      type: Object,
      default: void 0
    },
    overlayClassName: String,
    prefixCls: V.string.def("rc-tooltip"),
    mouseEnterDelay: V.number.def(0.1),
    mouseLeaveDelay: V.number.def(0.1),
    getPopupContainer: Function,
    destroyTooltipOnHide: {
      type: Boolean,
      default: !1
    },
    align: V.object.def(() => ({})),
    arrowContent: V.any.def(null),
    tipId: String,
    builtinPlacements: V.object,
    overlayInnerStyle: {
      type: Object,
      default: void 0
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    onVisibleChange: Function,
    onPopupAlign: Function,
    arrow: {
      type: Boolean,
      default: !0
    }
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const l = Q(), a = () => {
      const {
        prefixCls: u,
        tipId: d,
        overlayInnerStyle: p
      } = e;
      return [e.arrow ? f("div", {
        class: `${u}-arrow`,
        key: "arrow"
      }, [an(n, e, "arrowContent")]) : null, f(gL, {
        key: "content",
        prefixCls: u,
        id: d,
        overlayInnerStyle: p
      }, {
        overlay: n.overlay
      })];
    };
    r({
      getPopupDomNode: () => l.value.getPopupDomNode(),
      triggerDOM: l,
      forcePopupAlign: () => {
        var u;
        return (u = l.value) === null || u === void 0 ? void 0 : u.forcePopupAlign();
      }
    });
    const s = Q(!1), c = Q(!1);
    return Le(() => {
      const {
        destroyTooltipOnHide: u
      } = e;
      if (typeof u == "boolean")
        s.value = u;
      else if (u && typeof u == "object") {
        const {
          keepParent: d
        } = u;
        s.value = d === !0, c.value = d === !1;
      }
    }), () => {
      const {
        overlayClassName: u,
        trigger: d,
        mouseEnterDelay: p,
        mouseLeaveDelay: v,
        overlayStyle: h,
        prefixCls: g,
        afterVisibleChange: b,
        transitionName: y,
        animation: S,
        placement: C,
        align: w,
        destroyTooltipOnHide: $,
        defaultVisible: O
      } = e, x = mL(e, ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "afterVisibleChange", "transitionName", "animation", "placement", "align", "destroyTooltipOnHide", "defaultVisible"]), I = m({}, x);
      e.visible !== void 0 && (I.popupVisible = e.visible);
      const E = m(m(m({
        popupClassName: u,
        prefixCls: g,
        action: d,
        builtinPlacements: xO,
        popupPlacement: C,
        popupAlign: w,
        afterPopupVisibleChange: b,
        popupTransitionName: y,
        popupAnimation: S,
        defaultPopupVisible: O,
        destroyPopupOnHide: s.value,
        autoDestroy: c.value,
        mouseLeaveDelay: v,
        popupStyle: h,
        mouseEnterDelay: p
      }, I), o), {
        onPopupVisibleChange: e.onVisibleChange || jS,
        onPopupAlign: e.onPopupAlign || jS,
        ref: l,
        arrow: !!e.arrow,
        popup: a()
      });
      return f($a, E, {
        default: n.default
      });
    };
  }
}), c0 = () => ({
  trigger: [String, Array],
  open: {
    type: Boolean,
    default: void 0
  },
  /** @deprecated Please use `open` instead. */
  visible: {
    type: Boolean,
    default: void 0
  },
  placement: String,
  color: String,
  transitionName: String,
  overlayStyle: Re(),
  overlayInnerStyle: Re(),
  overlayClassName: String,
  openClassName: String,
  prefixCls: String,
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  getPopupContainer: Function,
  /**@deprecated Please use `arrow={{ pointAtCenter: true }}` instead. */
  arrowPointAtCenter: {
    type: Boolean,
    default: void 0
  },
  arrow: {
    type: [Boolean, Object],
    default: !0
  },
  autoAdjustOverflow: {
    type: [Boolean, Object],
    default: void 0
  },
  destroyTooltipOnHide: {
    type: Boolean,
    default: void 0
  },
  align: Re(),
  builtinPlacements: Re(),
  children: Array,
  /** @deprecated Please use `onOpenChange` instead. */
  onVisibleChange: Function,
  /** @deprecated Please use `onUpdate:open` instead. */
  "onUpdate:visible": Function,
  onOpenChange: Function,
  "onUpdate:open": Function
}), bL = {
  adjustX: 1,
  adjustY: 1
}, VS = {
  adjustX: 0,
  adjustY: 0
}, yL = [0, 0];
function WS(e) {
  return typeof e == "boolean" ? e ? bL : VS : m(m({}, VS), e);
}
function u0(e) {
  const {
    arrowWidth: t = 4,
    horizontalArrowShift: n = 16,
    verticalArrowShift: o = 8,
    autoAdjustOverflow: r,
    arrowPointAtCenter: l
  } = e, a = {
    left: {
      points: ["cr", "cl"],
      offset: [-4, 0]
    },
    right: {
      points: ["cl", "cr"],
      offset: [4, 0]
    },
    top: {
      points: ["bc", "tc"],
      offset: [0, -4]
    },
    bottom: {
      points: ["tc", "bc"],
      offset: [0, 4]
    },
    topLeft: {
      points: ["bl", "tc"],
      offset: [-(n + t), -4]
    },
    leftTop: {
      points: ["tr", "cl"],
      offset: [-4, -(o + t)]
    },
    topRight: {
      points: ["br", "tc"],
      offset: [n + t, -4]
    },
    rightTop: {
      points: ["tl", "cr"],
      offset: [4, -(o + t)]
    },
    bottomRight: {
      points: ["tr", "bc"],
      offset: [n + t, 4]
    },
    rightBottom: {
      points: ["bl", "cr"],
      offset: [4, o + t]
    },
    bottomLeft: {
      points: ["tl", "bc"],
      offset: [-(n + t), 4]
    },
    leftBottom: {
      points: ["br", "cl"],
      offset: [-4, o + t]
    }
  };
  return Object.keys(a).forEach((i) => {
    a[i] = l ? m(m({}, a[i]), {
      overflow: WS(r),
      targetOffset: yL
    }) : m(m({}, xO[i]), {
      overflow: WS(r)
    }), a[i].ignoreShake = !0;
  }), a;
}
function xd() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  for (let t = 0, n = e.length; t < n; t++)
    if (e[t] !== void 0)
      return e[t];
}
const SL = Fs.map((e) => `${e}-inverse`), CL = ["success", "processing", "error", "default", "warning"];
function Qf(e) {
  return (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0) ? [...SL, ...Fs].includes(e) : Fs.includes(e);
}
function $L(e) {
  return CL.includes(e);
}
function wL(e, t) {
  const n = Qf(t), o = ee({
    [`${e}-${t}`]: t && n
  }), r = {}, l = {};
  return t && !n && (r.background = t, l["--antd-arrow-background-color"] = t), {
    className: o,
    overlayStyle: r,
    arrowStyle: l
  };
}
function Wc(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return e.map((n) => `${t}${n}`).join(",");
}
const d0 = 8;
function OO(e) {
  const t = d0, {
    sizePopupArrow: n,
    contentRadius: o,
    borderRadiusOuter: r,
    limitVerticalRadius: l
  } = e, a = n / 2 - Math.ceil(r * (Math.sqrt(2) - 1)), i = (o > 12 ? o + 2 : 12) - a, s = l ? t - a : i;
  return {
    dropdownArrowOffset: i,
    dropdownArrowOffsetVertical: s
  };
}
function f0(e, t) {
  const {
    componentCls: n,
    sizePopupArrow: o,
    marginXXS: r,
    borderRadiusXS: l,
    borderRadiusOuter: a,
    boxShadowPopoverArrow: i
  } = e, {
    colorBg: s,
    showArrowCls: c,
    contentRadius: u = e.borderRadiusLG,
    limitVerticalRadius: d
  } = t, {
    dropdownArrowOffsetVertical: p,
    dropdownArrowOffset: v
  } = OO({
    sizePopupArrow: o,
    contentRadius: u,
    borderRadiusOuter: a,
    limitVerticalRadius: d
  }), h = o / 2 + r;
  return {
    [n]: {
      // ============================ Basic ============================
      [`${n}-arrow`]: [m(m({
        position: "absolute",
        zIndex: 1,
        display: "block"
      }, dh(o, l, a, s, i)), {
        "&:before": {
          background: s
        }
      })],
      // ========================== Placement ==========================
      // Here handle the arrow position and rotate stuff
      // >>>>> Top
      [[`&-placement-top ${n}-arrow`, `&-placement-topLeft ${n}-arrow`, `&-placement-topRight ${n}-arrow`].join(",")]: {
        bottom: 0,
        transform: "translateY(100%) rotate(180deg)"
      },
      [`&-placement-top ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(100%) rotate(180deg)"
      },
      [`&-placement-topLeft ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: v
        }
      },
      [`&-placement-topRight ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: v
        }
      },
      // >>>>> Bottom
      [[`&-placement-bottom ${n}-arrow`, `&-placement-bottomLeft ${n}-arrow`, `&-placement-bottomRight ${n}-arrow`].join(",")]: {
        top: 0,
        transform: "translateY(-100%)"
      },
      [`&-placement-bottom ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%) translateY(-100%)"
      },
      [`&-placement-bottomLeft ${n}-arrow`]: {
        left: {
          _skip_check_: !0,
          value: v
        }
      },
      [`&-placement-bottomRight ${n}-arrow`]: {
        right: {
          _skip_check_: !0,
          value: v
        }
      },
      // >>>>> Left
      [[`&-placement-left ${n}-arrow`, `&-placement-leftTop ${n}-arrow`, `&-placement-leftBottom ${n}-arrow`].join(",")]: {
        right: {
          _skip_check_: !0,
          value: 0
        },
        transform: "translateX(100%) rotate(90deg)"
      },
      [`&-placement-left ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(100%) rotate(90deg)"
      },
      [`&-placement-leftTop ${n}-arrow`]: {
        top: p
      },
      [`&-placement-leftBottom ${n}-arrow`]: {
        bottom: p
      },
      // >>>>> Right
      [[`&-placement-right ${n}-arrow`, `&-placement-rightTop ${n}-arrow`, `&-placement-rightBottom ${n}-arrow`].join(",")]: {
        left: {
          _skip_check_: !0,
          value: 0
        },
        transform: "translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-right ${n}-arrow`]: {
        top: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
      },
      [`&-placement-rightTop ${n}-arrow`]: {
        top: p
      },
      [`&-placement-rightBottom ${n}-arrow`]: {
        bottom: p
      },
      // =========================== Offset ============================
      // Offset the popover to account for the dropdown arrow
      // >>>>> Top
      [Wc(["&-placement-topLeft", "&-placement-top", "&-placement-topRight"].map((g) => g += ":not(&-arrow-hidden)"), c)]: {
        paddingBottom: h
      },
      // >>>>> Bottom
      [Wc(["&-placement-bottomLeft", "&-placement-bottom", "&-placement-bottomRight"].map((g) => g += ":not(&-arrow-hidden)"), c)]: {
        paddingTop: h
      },
      // >>>>> Left
      [Wc(["&-placement-leftTop", "&-placement-left", "&-placement-leftBottom"].map((g) => g += ":not(&-arrow-hidden)"), c)]: {
        paddingRight: {
          _skip_check_: !0,
          value: h
        }
      },
      // >>>>> Right
      [Wc(["&-placement-rightTop", "&-placement-right", "&-placement-rightBottom"].map((g) => g += ":not(&-arrow-hidden)"), c)]: {
        paddingLeft: {
          _skip_check_: !0,
          value: h
        }
      }
    }
  };
}
const xL = (e) => {
  const {
    componentCls: t,
    // ant-tooltip
    tooltipMaxWidth: n,
    tooltipColor: o,
    tooltipBg: r,
    tooltipBorderRadius: l,
    zIndexPopup: a,
    controlHeight: i,
    boxShadowSecondary: s,
    paddingSM: c,
    paddingXS: u,
    tooltipRadiusOuter: d
  } = e;
  return [
    {
      [t]: m(m(m(m({}, qe(e)), {
        position: "absolute",
        zIndex: a,
        display: "block",
        "&": [{
          width: "max-content"
        }, {
          width: "intrinsic"
        }],
        maxWidth: n,
        visibility: "visible",
        "&-hidden": {
          display: "none"
        },
        "--antd-arrow-background-color": r,
        // Wrapper for the tooltip content
        [`${t}-inner`]: {
          minWidth: i,
          minHeight: i,
          padding: `${c / 2}px ${u}px`,
          color: o,
          textAlign: "start",
          textDecoration: "none",
          wordWrap: "break-word",
          backgroundColor: r,
          borderRadius: l,
          boxShadow: s
        },
        // Limit left and right placement radius
        [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
          [`${t}-inner`]: {
            borderRadius: Math.min(l, d0)
          }
        },
        [`${t}-content`]: {
          position: "relative"
        }
      }), dd(e, (p, v) => {
        let {
          darkColor: h
        } = v;
        return {
          [`&${t}-${p}`]: {
            [`${t}-inner`]: {
              backgroundColor: h
            },
            [`${t}-arrow`]: {
              "--antd-arrow-background-color": h
            }
          }
        };
      })), {
        // RTL
        "&-rtl": {
          direction: "rtl"
        }
      })
    },
    // Arrow Style
    f0(He(e, {
      borderRadiusOuter: d
    }), {
      colorBg: "var(--antd-arrow-background-color)",
      showArrowCls: "",
      contentRadius: l,
      limitVerticalRadius: !0
    }),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none"
      }
    }
  ];
}, OL = (e, t) => Xe("Tooltip", (o) => {
  if ((t == null ? void 0 : t.value) === !1)
    return [];
  const {
    borderRadius: r,
    colorTextLightSolid: l,
    colorBgDefault: a,
    borderRadiusOuter: i
  } = o, s = He(o, {
    // default variables
    tooltipMaxWidth: 250,
    tooltipColor: l,
    tooltipBorderRadius: r,
    tooltipBg: a,
    tooltipRadiusOuter: i > 4 ? 4 : i
  });
  return [xL(s), Ni(o, "zoom-big-fast")];
}, (o) => {
  let {
    zIndexPopupBase: r,
    colorBgSpotlight: l
  } = o;
  return {
    zIndexPopup: r + 70,
    colorBgDefault: l
  };
})(e), PL = (e, t) => {
  const n = {}, o = m({}, e);
  return t.forEach((r) => {
    e && r in e && (n[r] = e[r], delete o[r]);
  }), {
    picked: n,
    omitted: o
  };
}, PO = () => m(m({}, c0()), {
  title: V.any
}), IO = () => ({
  trigger: "hover",
  align: {},
  placement: "top",
  mouseEnterDelay: 0.1,
  mouseLeaveDelay: 0.1,
  arrowPointAtCenter: !1,
  autoAdjustOverflow: !0
}), IL = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATooltip",
  inheritAttrs: !1,
  props: Qe(PO(), {
    trigger: "hover",
    align: {},
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: !1,
    autoAdjustOverflow: !0
  }),
  slots: Object,
  // emits: ['update:visible', 'visibleChange'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r,
      expose: l
    } = t;
    process.env.NODE_ENV !== "production" && [["visible", "open"], ["onVisibleChange", "onOpenChange"]].forEach((_) => {
      let [M, R] = _;
      Mt(e[M] === void 0, "Tooltip", `\`${M}\` is deprecated, please use \`${R}\` instead.`);
    });
    const {
      prefixCls: a,
      getPopupContainer: i,
      direction: s,
      rootPrefixCls: c
    } = Ie("tooltip", e), u = P(() => {
      var _;
      return (_ = e.open) !== null && _ !== void 0 ? _ : e.visible;
    }), d = Y(xd([e.open, e.visible])), p = Y();
    let v;
    ie(u, (_) => {
      Ze.cancel(v), v = Ze(() => {
        d.value = !!_;
      });
    });
    const h = () => {
      var _;
      const M = (_ = e.title) !== null && _ !== void 0 ? _ : n.title;
      return !M && M !== 0;
    }, g = (_) => {
      const M = h();
      u.value === void 0 && (d.value = M ? !1 : _), M || (o("update:visible", _), o("visibleChange", _), o("update:open", _), o("openChange", _));
    };
    l({
      getPopupDomNode: () => p.value.getPopupDomNode(),
      open: d,
      forcePopupAlign: () => {
        var _;
        return (_ = p.value) === null || _ === void 0 ? void 0 : _.forcePopupAlign();
      }
    });
    const y = P(() => {
      var _;
      const {
        builtinPlacements: M,
        autoAdjustOverflow: R,
        arrow: A,
        arrowPointAtCenter: z
      } = e;
      let T = z;
      return typeof A == "object" && (T = (_ = A.pointAtCenter) !== null && _ !== void 0 ? _ : z), M || u0({
        arrowPointAtCenter: T,
        autoAdjustOverflow: R
      });
    }), S = (_) => _ || _ === "", C = (_) => {
      const M = _.type;
      if (typeof M == "object" && _.props && ((M.__ANT_BUTTON === !0 || M === "button") && S(_.props.disabled) || M.__ANT_SWITCH === !0 && (S(_.props.disabled) || S(_.props.loading)) || M.__ANT_RADIO === !0 && S(_.props.disabled))) {
        const {
          picked: R,
          omitted: A
        } = PL(Xx(_), ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]), z = m(m({
          display: "inline-block"
        }, R), {
          cursor: "not-allowed",
          lineHeight: 1,
          width: _.props && _.props.block ? "100%" : void 0
        }), T = m(m({}, A), {
          pointerEvents: "none"
        }), N = yt(_, {
          style: T
        }, !0);
        return f("span", {
          style: z,
          class: `${a.value}-disabled-compatible-wrapper`
        }, [N]);
      }
      return _;
    }, w = () => {
      var _, M;
      return (_ = e.title) !== null && _ !== void 0 ? _ : (M = n.title) === null || M === void 0 ? void 0 : M.call(n);
    }, $ = (_, M) => {
      const R = y.value, A = Object.keys(R).find((z) => {
        var T, N;
        return R[z].points[0] === ((T = M.points) === null || T === void 0 ? void 0 : T[0]) && R[z].points[1] === ((N = M.points) === null || N === void 0 ? void 0 : N[1]);
      });
      if (A) {
        const z = _.getBoundingClientRect(), T = {
          top: "50%",
          left: "50%"
        };
        A.indexOf("top") >= 0 || A.indexOf("Bottom") >= 0 ? T.top = `${z.height - M.offset[1]}px` : (A.indexOf("Top") >= 0 || A.indexOf("bottom") >= 0) && (T.top = `${-M.offset[1]}px`), A.indexOf("left") >= 0 || A.indexOf("Right") >= 0 ? T.left = `${z.width - M.offset[0]}px` : (A.indexOf("right") >= 0 || A.indexOf("Left") >= 0) && (T.left = `${-M.offset[0]}px`), _.style.transformOrigin = `${T.left} ${T.top}`;
      }
    }, O = P(() => wL(a.value, e.color)), x = P(() => r["data-popover-inject"]), [I, E] = OL(a, P(() => !x.value));
    return () => {
      var _, M;
      const {
        openClassName: R,
        overlayClassName: A,
        overlayStyle: z,
        overlayInnerStyle: T
      } = e;
      let N = (M = Lt((_ = n.default) === null || _ === void 0 ? void 0 : _.call(n))) !== null && M !== void 0 ? M : null;
      N = N.length === 1 ? N[0] : N;
      let k = d.value;
      if (u.value === void 0 && h() && (k = !1), !N)
        return null;
      const B = C(Gt(N) && !YT(N) ? N : f("span", null, [N])), F = ee({
        [R || `${a.value}-open`]: !0,
        [B.props && B.props.class]: B.props && B.props.class
      }), L = ee(A, {
        [`${a.value}-rtl`]: s.value === "rtl"
      }, O.value.className, E.value), j = m(m({}, O.value.overlayStyle), T), H = O.value.arrowStyle, K = m(m(m({}, r), e), {
        prefixCls: a.value,
        arrow: !!e.arrow,
        getPopupContainer: i == null ? void 0 : i.value,
        builtinPlacements: y.value,
        visible: k,
        ref: p,
        overlayClassName: L,
        overlayStyle: m(m({}, H), z),
        overlayInnerStyle: j,
        onVisibleChange: g,
        onPopupAlign: $,
        transitionName: Vn(c.value, "zoom-big-fast", e.transitionName)
      });
      return I(f(hL, K, {
        default: () => [d.value ? yt(B, {
          class: F
        }) : B],
        arrowContent: () => f("span", {
          class: `${a.value}-arrow-content`
        }, null),
        overlay: w
      }));
    };
  }
}), Ln = kt(IL), EL = (e) => {
  const {
    componentCls: t,
    popoverBg: n,
    popoverColor: o,
    width: r,
    fontWeightStrong: l,
    popoverPadding: a,
    boxShadowSecondary: i,
    colorTextHeading: s,
    borderRadiusLG: c,
    zIndexPopup: u,
    marginXS: d,
    colorBgElevated: p
  } = e;
  return [
    {
      [t]: m(m({}, qe(e)), {
        position: "absolute",
        top: 0,
        // use `left` to fix https://github.com/ant-design/ant-design/issues/39195
        left: {
          _skip_check_: !0,
          value: 0
        },
        zIndex: u,
        fontWeight: "normal",
        whiteSpace: "normal",
        textAlign: "start",
        cursor: "auto",
        userSelect: "text",
        "--antd-arrow-background-color": p,
        "&-rtl": {
          direction: "rtl"
        },
        "&-hidden": {
          display: "none"
        },
        [`${t}-content`]: {
          position: "relative"
        },
        [`${t}-inner`]: {
          backgroundColor: n,
          backgroundClip: "padding-box",
          borderRadius: c,
          boxShadow: i,
          padding: a
        },
        [`${t}-title`]: {
          minWidth: r,
          marginBottom: d,
          color: s,
          fontWeight: l
        },
        [`${t}-inner-content`]: {
          color: o
        }
      })
    },
    // Arrow Style
    f0(e, {
      colorBg: "var(--antd-arrow-background-color)"
    }),
    // Pure Render
    {
      [`${t}-pure`]: {
        position: "relative",
        maxWidth: "none",
        [`${t}-content`]: {
          display: "inline-block"
        }
      }
    }
  ];
}, TL = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: Fs.map((n) => {
      const o = e[`${n}-6`];
      return {
        [`&${t}-${n}`]: {
          "--antd-arrow-background-color": o,
          [`${t}-inner`]: {
            backgroundColor: o
          },
          [`${t}-arrow`]: {
            background: "transparent"
          }
        }
      };
    })
  };
}, ML = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    lineType: o,
    colorSplit: r,
    paddingSM: l,
    controlHeight: a,
    fontSize: i,
    lineHeight: s,
    padding: c
  } = e, u = a - Math.round(i * s), d = u / 2, p = u / 2 - n, v = c;
  return {
    [t]: {
      [`${t}-inner`]: {
        padding: 0
      },
      [`${t}-title`]: {
        margin: 0,
        padding: `${d}px ${v}px ${p}px`,
        borderBottom: `${n}px ${o} ${r}`
      },
      [`${t}-inner-content`]: {
        padding: `${l}px ${v}px`
      }
    }
  };
}, _L = Xe("Popover", (e) => {
  const {
    colorBgElevated: t,
    colorText: n,
    wireframe: o
  } = e, r = He(e, {
    popoverBg: t,
    popoverColor: n,
    popoverPadding: 12
    // Fixed Value
  });
  return [EL(r), TL(r), o && ML(r), Ni(r, "zoom-big")];
}, (e) => {
  let {
    zIndexPopupBase: t
  } = e;
  return {
    zIndexPopup: t + 30,
    width: 177
  };
}), AL = () => m(m({}, c0()), {
  content: _t(),
  title: _t()
}), DL = Z({
  compatConfig: {
    MODE: 3
  },
  name: "APopover",
  inheritAttrs: !1,
  props: Qe(AL(), m(m({}, IO()), {
    trigger: "hover",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1
  })),
  setup(e, t) {
    let {
      expose: n,
      slots: o,
      attrs: r
    } = t;
    const l = Y();
    Mt(e.visible === void 0, "popover", "`visible` will be removed in next major version, please use `open` instead."), n({
      getPopupDomNode: () => {
        var p, v;
        return (v = (p = l.value) === null || p === void 0 ? void 0 : p.getPopupDomNode) === null || v === void 0 ? void 0 : v.call(p);
      }
    });
    const {
      prefixCls: a,
      configProvider: i
    } = Ie("popover", e), [s, c] = _L(a), u = P(() => i.getPrefixCls()), d = () => {
      var p, v;
      const {
        title: h = Lt((p = o.title) === null || p === void 0 ? void 0 : p.call(o)),
        content: g = Lt((v = o.content) === null || v === void 0 ? void 0 : v.call(o))
      } = e, b = !!(Array.isArray(h) ? h.length : h), y = !!(Array.isArray(g) ? g.length : h);
      return !b && !y ? null : f(Fe, null, [b && f("div", {
        class: `${a.value}-title`
      }, [h]), f("div", {
        class: `${a.value}-inner-content`
      }, [g])]);
    };
    return () => {
      const p = ee(e.overlayClassName, c.value);
      return s(f(Ln, D(D(D({}, ot(e, ["title", "content"])), r), {}, {
        prefixCls: a.value,
        ref: l,
        overlayClassName: p,
        transitionName: Vn(u.value, "zoom-big", e.transitionName),
        "data-popover-inject": !0
      }), {
        title: d,
        default: o.default
      }));
    };
  }
}), p0 = kt(DL), NL = () => ({
  prefixCls: String,
  maxCount: Number,
  maxStyle: {
    type: Object,
    default: void 0
  },
  maxPopoverPlacement: {
    type: String,
    default: "top"
  },
  maxPopoverTrigger: String,
  /*
   * Size of avatar, options: `large`, `small`, `default`
   * or a custom number size
   * */
  size: {
    type: [Number, String, Object],
    default: "default"
  },
  shape: {
    type: String,
    default: "circle"
  }
}), Od = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AAvatarGroup",
  inheritAttrs: !1,
  props: NL(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("avatar", e), a = P(() => `${r.value}-group`), [i, s] = $O(r);
    return Le(() => {
      const c = {
        size: e.size,
        shape: e.shape
      };
      fL(c);
    }), () => {
      const {
        maxPopoverPlacement: c = "top",
        maxCount: u,
        maxStyle: d,
        maxPopoverTrigger: p = "hover",
        shape: v
      } = e, h = {
        [a.value]: !0,
        [`${a.value}-rtl`]: l.value === "rtl",
        [`${o.class}`]: !!o.class,
        [s.value]: !0
      }, g = an(n, e), b = It(g).map((S, C) => yt(S, {
        key: `avatar-key-${C}`
      })), y = b.length;
      if (u && u < y) {
        const S = b.slice(0, u), C = b.slice(u, y);
        return S.push(f(p0, {
          key: "avatar-popover-key",
          content: C,
          trigger: p,
          placement: c,
          overlayClassName: `${a.value}-popover`
        }, {
          default: () => [f(ea, {
            style: d,
            shape: v
          }, {
            default: () => [`+${y - u}`]
          })]
        })), i(f("div", D(D({}, o), {}, {
          class: h,
          style: o.style
        }), [S]));
      }
      return i(f("div", D(D({}, o), {}, {
        class: h,
        style: o.style
      }), [b]));
    };
  }
});
ea.Group = Od;
ea.install = function(e) {
  return e.component(ea.name, ea), e.component(Od.name, Od), e;
};
function KS(e) {
  let {
    prefixCls: t,
    value: n,
    current: o,
    offset: r = 0
  } = e, l;
  return r && (l = {
    position: "absolute",
    top: `${r}00%`,
    left: 0
  }), f("p", {
    style: l,
    class: ee(`${t}-only-unit`, {
      current: o
    })
  }, [n]);
}
function RL(e, t, n) {
  let o = e, r = 0;
  for (; (o + 10) % 10 !== t; )
    o += n, r += n;
  return r;
}
const kL = Z({
  compatConfig: {
    MODE: 3
  },
  name: "SingleNumber",
  props: {
    prefixCls: String,
    value: String,
    count: Number
  },
  setup(e) {
    const t = P(() => Number(e.value)), n = P(() => Math.abs(e.count)), o = xt({
      prevValue: t.value,
      prevCount: n.value
    }), r = () => {
      o.prevValue = t.value, o.prevCount = n.value;
    }, l = Y();
    return ie(t, () => {
      clearTimeout(l.value), l.value = setTimeout(() => {
        r();
      }, 1e3);
    }, {
      flush: "post"
    }), uo(() => {
      clearTimeout(l.value);
    }), () => {
      let a, i = {};
      const s = t.value;
      if (o.prevValue === s || Number.isNaN(s) || Number.isNaN(o.prevValue))
        a = [KS(m(m({}, e), {
          current: !0
        }))], i = {
          transition: "none"
        };
      else {
        a = [];
        const c = s + 10, u = [];
        for (let v = s; v <= c; v += 1)
          u.push(v);
        const d = u.findIndex((v) => v % 10 === o.prevValue);
        a = u.map((v, h) => {
          const g = v % 10;
          return KS(m(m({}, e), {
            value: g,
            offset: h - d,
            current: h === d
          }));
        });
        const p = o.prevCount < n.value ? 1 : -1;
        i = {
          transform: `translateY(${-RL(o.prevValue, s, p)}00%)`
        };
      }
      return f("span", {
        class: `${e.prefixCls}-only`,
        style: i,
        onTransitionend: () => r()
      }, [a]);
    };
  }
});
var BL = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const FL = {
  prefixCls: String,
  count: V.any,
  component: String,
  title: V.any,
  show: Boolean
}, LL = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ScrollNumber",
  inheritAttrs: !1,
  props: FL,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: r
    } = Ie("scroll-number", e);
    return () => {
      var l;
      const a = m(m({}, e), n), {
        prefixCls: i,
        count: s,
        title: c,
        show: u,
        component: d = "sup",
        class: p,
        style: v
      } = a, h = BL(a, ["prefixCls", "count", "title", "show", "component", "class", "style"]), g = m(m({}, h), {
        style: v,
        "data-show": e.show,
        class: ee(r.value, p),
        title: c
      });
      let b = s;
      if (s && Number(s) % 1 === 0) {
        const S = String(s).split("");
        b = S.map((C, w) => f(kL, {
          prefixCls: r.value,
          count: Number(s),
          value: C,
          key: S.length - w
        }, null));
      }
      v && v.borderColor && (g.style = m(m({}, v), {
        boxShadow: `0 0 0 1px ${v.borderColor} inset`
      }));
      const y = Lt((l = o.default) === null || l === void 0 ? void 0 : l.call(o));
      return y && y.length ? yt(y, {
        class: ee(`${r.value}-custom-component`)
      }, !1) : f(d, g, {
        default: () => [b]
      });
    };
  }
}), zL = new lt("antStatusProcessing", {
  "0%": {
    transform: "scale(0.8)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(2.4)",
    opacity: 0
  }
}), HL = new lt("antZoomBadgeIn", {
  "0%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1) translate(50%, -50%)"
  }
}), jL = new lt("antZoomBadgeOut", {
  "0%": {
    transform: "scale(1) translate(50%, -50%)"
  },
  "100%": {
    transform: "scale(0) translate(50%, -50%)",
    opacity: 0
  }
}), VL = new lt("antNoWrapperZoomBadgeIn", {
  "0%": {
    transform: "scale(0)",
    opacity: 0
  },
  "100%": {
    transform: "scale(1)"
  }
}), WL = new lt("antNoWrapperZoomBadgeOut", {
  "0%": {
    transform: "scale(1)"
  },
  "100%": {
    transform: "scale(0)",
    opacity: 0
  }
}), KL = new lt("antBadgeLoadingCircle", {
  "0%": {
    transformOrigin: "50%"
  },
  "100%": {
    transform: "translate(50%, -50%) rotate(360deg)",
    transformOrigin: "50%"
  }
}), GL = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    antCls: o,
    badgeFontHeight: r,
    badgeShadowSize: l,
    badgeHeightSm: a,
    motionDurationSlow: i,
    badgeStatusSize: s,
    marginXS: c,
    badgeRibbonOffset: u
  } = e, d = `${o}-scroll-number`, p = `${o}-ribbon`, v = `${o}-ribbon-wrapper`, h = dd(e, (b, y) => {
    let {
      darkColor: S
    } = y;
    return {
      [`&${t} ${t}-color-${b}`]: {
        background: S,
        [`&:not(${t}-count)`]: {
          color: S
        }
      }
    };
  }), g = dd(e, (b, y) => {
    let {
      darkColor: S
    } = y;
    return {
      [`&${p}-color-${b}`]: {
        background: S,
        color: S
      }
    };
  });
  return {
    [t]: m(m(m(m({}, qe(e)), {
      position: "relative",
      display: "inline-block",
      width: "fit-content",
      lineHeight: 1,
      [`${t}-count`]: {
        zIndex: e.badgeZIndex,
        minWidth: e.badgeHeight,
        height: e.badgeHeight,
        color: e.badgeTextColor,
        fontWeight: e.badgeFontWeight,
        fontSize: e.badgeFontSize,
        lineHeight: `${e.badgeHeight}px`,
        whiteSpace: "nowrap",
        textAlign: "center",
        background: e.badgeColor,
        borderRadius: e.badgeHeight / 2,
        boxShadow: `0 0 0 ${l}px ${e.badgeShadowColor}`,
        transition: `background ${e.motionDurationMid}`,
        a: {
          color: e.badgeTextColor
        },
        "a:hover": {
          color: e.badgeTextColor
        },
        "a:hover &": {
          background: e.badgeColorHover
        }
      },
      [`${t}-count-sm`]: {
        minWidth: a,
        height: a,
        fontSize: e.badgeFontSizeSm,
        lineHeight: `${a}px`,
        borderRadius: a / 2
      },
      [`${t}-multiple-words`]: {
        padding: `0 ${e.paddingXS}px`
      },
      [`${t}-dot`]: {
        zIndex: e.badgeZIndex,
        width: e.badgeDotSize,
        minWidth: e.badgeDotSize,
        height: e.badgeDotSize,
        background: e.badgeColor,
        borderRadius: "100%",
        boxShadow: `0 0 0 ${l}px ${e.badgeShadowColor}`
      },
      [`${t}-dot${d}`]: {
        transition: `background ${i}`
      },
      [`${t}-count, ${t}-dot, ${d}-custom-component`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        transform: "translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&${n}-spin`]: {
          animationName: KL,
          animationDuration: "1s",
          animationIterationCount: "infinite",
          animationTimingFunction: "linear"
        }
      },
      [`&${t}-status`]: {
        lineHeight: "inherit",
        verticalAlign: "baseline",
        [`${t}-status-dot`]: {
          position: "relative",
          top: -1,
          display: "inline-block",
          width: s,
          height: s,
          verticalAlign: "middle",
          borderRadius: "50%"
        },
        [`${t}-status-success`]: {
          backgroundColor: e.colorSuccess
        },
        [`${t}-status-processing`]: {
          overflow: "visible",
          color: e.colorPrimary,
          backgroundColor: e.colorPrimary,
          "&::after": {
            position: "absolute",
            top: 0,
            insetInlineStart: 0,
            width: "100%",
            height: "100%",
            borderWidth: l,
            borderStyle: "solid",
            borderColor: "inherit",
            borderRadius: "50%",
            animationName: zL,
            animationDuration: e.badgeProcessingDuration,
            animationIterationCount: "infinite",
            animationTimingFunction: "ease-in-out",
            content: '""'
          }
        },
        [`${t}-status-default`]: {
          backgroundColor: e.colorTextPlaceholder
        },
        [`${t}-status-error`]: {
          backgroundColor: e.colorError
        },
        [`${t}-status-warning`]: {
          backgroundColor: e.colorWarning
        },
        [`${t}-status-text`]: {
          marginInlineStart: c,
          color: e.colorText,
          fontSize: e.fontSize
        }
      }
    }), h), {
      [`${t}-zoom-appear, ${t}-zoom-enter`]: {
        animationName: HL,
        animationDuration: e.motionDurationSlow,
        animationTimingFunction: e.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`${t}-zoom-leave`]: {
        animationName: jL,
        animationDuration: e.motionDurationSlow,
        animationTimingFunction: e.motionEaseOutBack,
        animationFillMode: "both"
      },
      [`&${t}-not-a-wrapper`]: {
        [`${t}-zoom-appear, ${t}-zoom-enter`]: {
          animationName: VL,
          animationDuration: e.motionDurationSlow,
          animationTimingFunction: e.motionEaseOutBack
        },
        [`${t}-zoom-leave`]: {
          animationName: WL,
          animationDuration: e.motionDurationSlow,
          animationTimingFunction: e.motionEaseOutBack
        },
        [`&:not(${t}-status)`]: {
          verticalAlign: "middle"
        },
        [`${d}-custom-component, ${t}-count`]: {
          transform: "none"
        },
        [`${d}-custom-component, ${d}`]: {
          position: "relative",
          top: "auto",
          display: "block",
          transformOrigin: "50% 50%"
        }
      },
      [`${d}`]: {
        overflow: "hidden",
        [`${d}-only`]: {
          position: "relative",
          display: "inline-block",
          height: e.badgeHeight,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseOutBack}`,
          WebkitTransformStyle: "preserve-3d",
          WebkitBackfaceVisibility: "hidden",
          [`> p${d}-only-unit`]: {
            height: e.badgeHeight,
            margin: 0,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden"
          }
        },
        [`${d}-symbol`]: {
          verticalAlign: "top"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${t}-count, ${t}-dot, ${d}-custom-component`]: {
          transform: "translate(-50%, -50%)"
        }
      }
    }),
    [`${v}`]: {
      position: "relative"
    },
    [`${p}`]: m(m(m(m({}, qe(e)), {
      position: "absolute",
      top: c,
      padding: `0 ${e.paddingXS}px`,
      color: e.colorPrimary,
      lineHeight: `${r}px`,
      whiteSpace: "nowrap",
      backgroundColor: e.colorPrimary,
      borderRadius: e.borderRadiusSM,
      [`${p}-text`]: {
        color: e.colorTextLightSolid
      },
      [`${p}-corner`]: {
        position: "absolute",
        top: "100%",
        width: u,
        height: u,
        color: "currentcolor",
        border: `${u / 2}px solid`,
        transform: e.badgeRibbonCornerTransform,
        transformOrigin: "top",
        filter: e.badgeRibbonCornerFilter
      }
    }), g), {
      [`&${p}-placement-end`]: {
        insetInlineEnd: -u,
        borderEndEndRadius: 0,
        [`${p}-corner`]: {
          insetInlineEnd: 0,
          borderInlineEndColor: "transparent",
          borderBlockEndColor: "transparent"
        }
      },
      [`&${p}-placement-start`]: {
        insetInlineStart: -u,
        borderEndStartRadius: 0,
        [`${p}-corner`]: {
          insetInlineStart: 0,
          borderBlockEndColor: "transparent",
          borderInlineStartColor: "transparent"
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, EO = Xe("Badge", (e) => {
  const {
    fontSize: t,
    lineHeight: n,
    fontSizeSM: o,
    lineWidth: r,
    marginXS: l,
    colorBorderBg: a
  } = e, i = Math.round(t * n), s = r, c = "auto", u = i - 2 * s, d = e.colorBgContainer, p = "normal", v = o, h = e.colorError, g = e.colorErrorHover, b = t, y = o / 2, S = o, C = o / 2, w = He(e, {
    badgeFontHeight: i,
    badgeShadowSize: s,
    badgeZIndex: c,
    badgeHeight: u,
    badgeTextColor: d,
    badgeFontWeight: p,
    badgeFontSize: v,
    badgeColor: h,
    badgeColorHover: g,
    badgeShadowColor: a,
    badgeHeightSm: b,
    badgeDotSize: y,
    badgeFontSizeSm: S,
    badgeStatusSize: C,
    badgeProcessingDuration: "1.2s",
    badgeRibbonOffset: l,
    // Follow token just by Design. Not related with token
    badgeRibbonCornerTransform: "scaleY(0.75)",
    badgeRibbonCornerFilter: "brightness(75%)"
  });
  return [GL(w)];
});
var XL = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const UL = () => ({
  prefix: String,
  color: {
    type: String
  },
  text: V.any,
  placement: {
    type: String,
    default: "end"
  }
}), Pd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ABadgeRibbon",
  inheritAttrs: !1,
  props: UL(),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("ribbon", e), [a, i] = EO(r), s = P(() => Qf(e.color, !1)), c = P(() => [r.value, `${r.value}-placement-${e.placement}`, {
      [`${r.value}-rtl`]: l.value === "rtl",
      [`${r.value}-color-${e.color}`]: s.value
    }]);
    return () => {
      var u, d;
      const {
        class: p,
        style: v
      } = n, h = XL(n, ["class", "style"]), g = {}, b = {};
      return e.color && !s.value && (g.background = e.color, b.color = e.color), a(f("div", D({
        class: `${r.value}-wrapper ${i.value}`
      }, h), [(u = o.default) === null || u === void 0 ? void 0 : u.call(o), f("div", {
        class: [c.value, p, i.value],
        style: m(m({}, g), v)
      }, [f("span", {
        class: `${r.value}-text`
      }, [e.text || ((d = o.text) === null || d === void 0 ? void 0 : d.call(o))]), f("div", {
        class: `${r.value}-corner`,
        style: b
      }, null)])]));
    };
  }
}), Id = (e) => !isNaN(parseFloat(e)) && isFinite(e), YL = () => ({
  /** Number to show in badge */
  count: V.any.def(null),
  showZero: {
    type: Boolean,
    default: void 0
  },
  /** Max count to show */
  overflowCount: {
    type: Number,
    default: 99
  },
  /** whether to show red dot without number */
  dot: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  scrollNumberPrefixCls: String,
  status: {
    type: String
  },
  size: {
    type: String,
    default: "default"
  },
  color: String,
  text: V.any,
  offset: Array,
  numberStyle: {
    type: Object,
    default: void 0
  },
  title: String
}), hs = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ABadge",
  Ribbon: Pd,
  inheritAttrs: !1,
  props: YL(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("badge", e), [a, i] = EO(r), s = P(() => e.count > e.overflowCount ? `${e.overflowCount}+` : e.count), c = P(() => s.value === "0" || s.value === 0), u = P(() => e.count === null || c.value && !e.showZero), d = P(() => (e.status !== null && e.status !== void 0 || e.color !== null && e.color !== void 0) && u.value), p = P(() => e.dot && !c.value), v = P(() => p.value ? "" : s.value), h = P(() => (v.value === null || v.value === void 0 || v.value === "" || c.value && !e.showZero) && !p.value), g = Y(e.count), b = Y(v.value), y = Y(p.value);
    ie([() => e.count, v, p], () => {
      h.value || (g.value = e.count, b.value = v.value, y.value = p.value);
    }, {
      immediate: !0
    });
    const S = P(() => Qf(e.color, !1)), C = P(() => ({
      [`${r.value}-status-dot`]: d.value,
      [`${r.value}-status-${e.status}`]: !!e.status,
      [`${r.value}-color-${e.color}`]: S.value
    })), w = P(() => e.color && !S.value ? {
      background: e.color,
      color: e.color
    } : {}), $ = P(() => ({
      [`${r.value}-dot`]: y.value,
      [`${r.value}-count`]: !y.value,
      [`${r.value}-count-sm`]: e.size === "small",
      [`${r.value}-multiple-words`]: !y.value && b.value && b.value.toString().length > 1,
      [`${r.value}-status-${e.status}`]: !!e.status,
      [`${r.value}-color-${e.color}`]: S.value
    }));
    return () => {
      var O, x;
      const {
        offset: I,
        title: E,
        color: _
      } = e, M = o.style, R = an(n, e, "text"), A = r.value, z = g.value;
      let T = It((O = n.default) === null || O === void 0 ? void 0 : O.call(n));
      T = T.length ? T : null;
      const N = !!(!h.value || n.count), k = (() => {
        if (!I)
          return m({}, M);
        const X = {
          marginTop: Id(I[1]) ? `${I[1]}px` : I[1]
        };
        return l.value === "rtl" ? X.left = `${parseInt(I[0], 10)}px` : X.right = `${-parseInt(I[0], 10)}px`, m(m({}, X), M);
      })(), B = E ?? (typeof z == "string" || typeof z == "number" ? z : void 0), F = N || !R ? null : f("span", {
        class: `${A}-status-text`
      }, [R]), L = typeof z == "object" || z === void 0 && n.count ? yt(z ?? ((x = n.count) === null || x === void 0 ? void 0 : x.call(n)), {
        style: k
      }, !1) : null, j = ee(A, {
        [`${A}-status`]: d.value,
        [`${A}-not-a-wrapper`]: !T,
        [`${A}-rtl`]: l.value === "rtl"
      }, o.class, i.value);
      if (!T && d.value) {
        const X = k.color;
        return a(f("span", D(D({}, o), {}, {
          class: j,
          style: k
        }), [f("span", {
          class: C.value,
          style: w.value
        }, null), f("span", {
          style: {
            color: X
          },
          class: `${A}-status-text`
        }, [R])]));
      }
      const H = Ho(T ? `${A}-zoom` : "", {
        appear: !1
      });
      let K = m(m({}, k), e.numberStyle);
      return _ && !S.value && (K = K || {}, K.background = _), a(f("span", D(D({}, o), {}, {
        class: j
      }), [T, f(yn, H, {
        default: () => [Tn(f(LL, {
          prefixCls: e.scrollNumberPrefixCls,
          show: N,
          class: $.value,
          count: b.value,
          title: B,
          style: K,
          key: "scrollNumber"
        }, {
          default: () => [L]
        }), [[Hn, N]])]
      }), F]));
    };
  }
});
hs.install = function(e) {
  return e.component(hs.name, hs), e.component(Pd.name, Pd), e;
};
const _a = {
  adjustX: 1,
  adjustY: 1
}, Aa = [0, 0], qL = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: _a,
    offset: [0, -4],
    targetOffset: Aa
  },
  topCenter: {
    points: ["bc", "tc"],
    overflow: _a,
    offset: [0, -4],
    targetOffset: Aa
  },
  topRight: {
    points: ["br", "tr"],
    overflow: _a,
    offset: [0, -4],
    targetOffset: Aa
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: _a,
    offset: [0, 4],
    targetOffset: Aa
  },
  bottomCenter: {
    points: ["tc", "bc"],
    overflow: _a,
    offset: [0, 4],
    targetOffset: Aa
  },
  bottomRight: {
    points: ["tr", "br"],
    overflow: _a,
    offset: [0, 4],
    targetOffset: Aa
  }
};
var ZL = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const TO = Z({
  compatConfig: {
    MODE: 3
  },
  props: {
    minOverlayWidthMatchTrigger: {
      type: Boolean,
      default: void 0
    },
    arrow: {
      type: Boolean,
      default: !1
    },
    prefixCls: V.string.def("rc-dropdown"),
    transitionName: String,
    overlayClassName: V.string.def(""),
    openClassName: String,
    animation: V.any,
    align: V.object,
    overlayStyle: {
      type: Object,
      default: void 0
    },
    placement: V.string.def("bottomLeft"),
    overlay: V.any,
    trigger: V.oneOfType([V.string, V.arrayOf(V.string)]).def("hover"),
    alignPoint: {
      type: Boolean,
      default: void 0
    },
    showAction: V.array,
    hideAction: V.array,
    getPopupContainer: Function,
    visible: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: {
      type: Boolean,
      default: !1
    },
    mouseEnterDelay: V.number.def(0.15),
    mouseLeaveDelay: V.number.def(0.1)
  },
  emits: ["visibleChange", "overlayClick"],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      expose: r
    } = t;
    const l = Y(!!e.visible);
    ie(() => e.visible, (v) => {
      v !== void 0 && (l.value = v);
    });
    const a = Y();
    r({
      triggerRef: a
    });
    const i = (v) => {
      e.visible === void 0 && (l.value = !1), o("overlayClick", v);
    }, s = (v) => {
      e.visible === void 0 && (l.value = v), o("visibleChange", v);
    }, c = () => {
      var v;
      const h = (v = n.overlay) === null || v === void 0 ? void 0 : v.call(n), g = {
        prefixCls: `${e.prefixCls}-menu`,
        onClick: i
      };
      return f(Fe, {
        key: Wx
      }, [e.arrow && f("div", {
        class: `${e.prefixCls}-arrow`
      }, null), yt(h, g, !1)]);
    }, u = P(() => {
      const {
        minOverlayWidthMatchTrigger: v = !e.alignPoint
      } = e;
      return v;
    }), d = () => {
      var v;
      const h = (v = n.default) === null || v === void 0 ? void 0 : v.call(n);
      return l.value && h ? yt(h[0], {
        class: e.openClassName || `${e.prefixCls}-open`
      }, !1) : h;
    }, p = P(() => !e.hideAction && e.trigger.indexOf("contextmenu") !== -1 ? ["click"] : e.hideAction);
    return () => {
      const {
        prefixCls: v,
        arrow: h,
        showAction: g,
        overlayStyle: b,
        trigger: y,
        placement: S,
        align: C,
        getPopupContainer: w,
        transitionName: $,
        animation: O,
        overlayClassName: x
      } = e, I = ZL(e, ["prefixCls", "arrow", "showAction", "overlayStyle", "trigger", "placement", "align", "getPopupContainer", "transitionName", "animation", "overlayClassName"]);
      return f($a, D(D({}, I), {}, {
        prefixCls: v,
        ref: a,
        popupClassName: ee(x, {
          [`${v}-show-arrow`]: h
        }),
        popupStyle: b,
        builtinPlacements: qL,
        action: y,
        showAction: g,
        hideAction: p.value || [],
        popupPlacement: S,
        popupAlign: C,
        popupTransitionName: $,
        popupAnimation: O,
        popupVisible: l.value,
        stretch: u.value ? "minWidth" : "",
        onPopupVisibleChange: s,
        getPopupContainer: w
      }), {
        popup: c,
        default: d
      });
    };
  }
}), QL = (e) => {
  const {
    componentCls: t,
    colorPrimary: n
  } = e;
  return {
    [t]: {
      position: "absolute",
      background: "transparent",
      pointerEvents: "none",
      boxSizing: "border-box",
      color: `var(--wave-color, ${n})`,
      boxShadow: "0 0 0 0 currentcolor",
      opacity: 0.2,
      // =================== Motion ===================
      "&.wave-motion-appear": {
        transition: [`box-shadow 0.4s ${e.motionEaseOutCirc}`, `opacity 2s ${e.motionEaseOutCirc}`].join(","),
        "&-active": {
          boxShadow: "0 0 0 6px currentcolor",
          opacity: 0
        }
      }
    }
  };
}, JL = Xe("Wave", (e) => [QL(e)]);
function ez(e) {
  const t = (e || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
  return t && t[1] && t[2] && t[3] ? !(t[1] === t[2] && t[2] === t[3]) : !0;
}
function dv(e) {
  return e && e !== "#fff" && e !== "#ffffff" && e !== "rgb(255, 255, 255)" && e !== "rgba(255, 255, 255, 1)" && ez(e) && !/rgba\((?:\d*, ){3}0\)/.test(e) && // any transparent rgba color
  e !== "transparent";
}
function tz(e) {
  const {
    borderTopColor: t,
    borderColor: n,
    backgroundColor: o
  } = getComputedStyle(e);
  return dv(t) ? t : dv(n) ? n : dv(o) ? o : null;
}
function fv(e) {
  return Number.isNaN(e) ? 0 : e;
}
const nz = Z({
  props: {
    target: Re(),
    className: String
  },
  setup(e) {
    const t = Q(null), [n, o] = Pt(null), [r, l] = Pt([]), [a, i] = Pt(0), [s, c] = Pt(0), [u, d] = Pt(0), [p, v] = Pt(0), [h, g] = Pt(!1);
    function b() {
      const {
        target: x
      } = e, I = getComputedStyle(x);
      o(tz(x));
      const E = I.position === "static", {
        borderLeftWidth: _,
        borderTopWidth: M
      } = I;
      i(E ? x.offsetLeft : fv(-parseFloat(_))), c(E ? x.offsetTop : fv(-parseFloat(M))), d(x.offsetWidth), v(x.offsetHeight);
      const {
        borderTopLeftRadius: R,
        borderTopRightRadius: A,
        borderBottomLeftRadius: z,
        borderBottomRightRadius: T
      } = I;
      l([R, A, T, z].map((N) => fv(parseFloat(N))));
    }
    let y, S, C;
    const w = () => {
      clearTimeout(C), Ze.cancel(S), y == null || y.disconnect();
    }, $ = () => {
      var x;
      const I = (x = t.value) === null || x === void 0 ? void 0 : x.parentElement;
      I && (yl(null, I), I.parentElement && I.parentElement.removeChild(I));
    };
    Ke(() => {
      w(), C = setTimeout(() => {
        $();
      }, 5e3);
      const {
        target: x
      } = e;
      x && (S = Ze(() => {
        b(), g(!0);
      }), typeof ResizeObserver < "u" && (y = new ResizeObserver(b), y.observe(x)));
    }), et(() => {
      w();
    });
    const O = (x) => {
      x.propertyName === "opacity" && $();
    };
    return () => {
      if (!h.value)
        return null;
      const x = {
        left: `${a.value}px`,
        top: `${s.value}px`,
        width: `${u.value}px`,
        height: `${p.value}px`,
        borderRadius: r.value.map((I) => `${I}px`).join(" ")
      };
      return n && (x["--wave-color"] = n.value), f(yn, {
        appear: !0,
        name: "wave-motion",
        appearFromClass: "wave-motion-appear",
        appearActiveClass: "wave-motion-appear",
        appearToClass: "wave-motion-appear wave-motion-appear-active"
      }, {
        default: () => [f("div", {
          ref: t,
          class: e.className,
          style: x,
          onTransitionend: O
        }, null)]
      });
    };
  }
});
function oz(e, t) {
  const n = document.createElement("div");
  return n.style.position = "absolute", n.style.left = "0px", n.style.top = "0px", e == null || e.insertBefore(n, e == null ? void 0 : e.firstChild), yl(f(nz, {
    target: e,
    className: t
  }, null), n), () => {
    yl(null, n), n.parentElement && n.parentElement.removeChild(n);
  };
}
function rz(e, t) {
  const n = Wn();
  let o;
  function r() {
    var l;
    const a = qn(n);
    o == null || o(), !(!((l = t == null ? void 0 : t.value) === null || l === void 0) && l.disabled || !a) && (o = oz(a, e.value));
  }
  return et(() => {
    o == null || o();
  }), r;
}
const v0 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Wave",
  props: {
    disabled: Boolean
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Wn(), {
      prefixCls: r,
      wave: l
    } = Ie("wave", e), [, a] = JL(r), i = rz(P(() => ee(r.value, a.value)), l);
    let s;
    const c = () => {
      qn(o).removeEventListener("click", s, !0);
    };
    return Ke(() => {
      ie(() => e.disabled, () => {
        c(), rt(() => {
          const u = qn(o);
          u == null || u.removeEventListener("click", s, !0), !(!u || u.nodeType !== 1 || e.disabled) && (s = (d) => {
            d.target.tagName === "INPUT" || !If(d.target) || // No need wave
            !u.getAttribute || u.getAttribute("disabled") || u.disabled || u.className.includes("disabled") || u.className.includes("-leave") || i();
          }, u.addEventListener("click", s, !0));
        });
      }, {
        immediate: !0,
        flush: "post"
      });
    }), et(() => {
      c();
    }), () => {
      var u;
      return (u = n.default) === null || u === void 0 ? void 0 : u.call(n)[0];
    };
  }
});
function Ed(e) {
  return e === "danger" ? {
    danger: !0
  } : {
    type: e
  };
}
const MO = () => ({
  prefixCls: String,
  type: String,
  htmlType: {
    type: String,
    default: "button"
  },
  shape: {
    type: String
  },
  size: {
    type: String
  },
  loading: {
    type: [Boolean, Object],
    default: () => !1
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  ghost: {
    type: Boolean,
    default: void 0
  },
  block: {
    type: Boolean,
    default: void 0
  },
  danger: {
    type: Boolean,
    default: void 0
  },
  icon: V.any,
  href: String,
  target: String,
  title: String,
  onClick: ia(),
  onMousedown: ia()
}), GS = (e) => {
  e && (e.style.width = "0px", e.style.opacity = "0", e.style.transform = "scale(0)");
}, XS = (e) => {
  rt(() => {
    e && (e.style.width = `${e.scrollWidth}px`, e.style.opacity = "1", e.style.transform = "scale(1)");
  });
}, US = (e) => {
  e && e.style && (e.style.width = null, e.style.opacity = null, e.style.transform = null);
}, lz = Z({
  compatConfig: {
    MODE: 3
  },
  name: "LoadingIcon",
  props: {
    prefixCls: String,
    loading: [Boolean, Object],
    existIcon: Boolean
  },
  setup(e) {
    return () => {
      const {
        existIcon: t,
        prefixCls: n,
        loading: o
      } = e;
      if (t)
        return f("span", {
          class: `${n}-loading-icon`
        }, [f(Qn, null, null)]);
      const r = !!o;
      return f(yn, {
        name: `${n}-loading-icon-motion`,
        onBeforeEnter: GS,
        onEnter: XS,
        onAfterEnter: US,
        onBeforeLeave: XS,
        onLeave: (l) => {
          setTimeout(() => {
            GS(l);
          });
        },
        onAfterLeave: US
      }, {
        default: () => [r ? f("span", {
          class: `${n}-loading-icon`
        }, [f(Qn, null, null)]) : null]
      });
    };
  }
}), YS = (e, t) => ({
  // Border
  [`> span, > ${e}`]: {
    "&:not(:last-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineEndColor: t
        }
      }
    },
    "&:not(:first-child)": {
      [`&, & > ${e}`]: {
        "&:not(:disabled)": {
          borderInlineStartColor: t
        }
      }
    }
  }
}), az = (e) => {
  const {
    componentCls: t,
    fontSize: n,
    lineWidth: o,
    colorPrimaryHover: r,
    colorErrorHover: l
  } = e;
  return {
    [`${t}-group`]: [
      {
        position: "relative",
        display: "inline-flex",
        // Border
        [`> span, > ${t}`]: {
          "&:not(:last-child)": {
            [`&, & > ${t}`]: {
              borderStartEndRadius: 0,
              borderEndEndRadius: 0
            }
          },
          "&:not(:first-child)": {
            marginInlineStart: -o,
            [`&, & > ${t}`]: {
              borderStartStartRadius: 0,
              borderEndStartRadius: 0
            }
          }
        },
        [t]: {
          position: "relative",
          zIndex: 1,
          "&:hover,\n          &:focus,\n          &:active": {
            zIndex: 2
          },
          "&[disabled]": {
            zIndex: 0
          }
        },
        [`${t}-icon-only`]: {
          fontSize: n
        }
      },
      // Border Color
      YS(`${t}-primary`, r),
      YS(`${t}-danger`, l)
    ]
  };
};
function iz(e, t) {
  return {
    // border collapse
    [`&-item:not(${t}-last-item)`]: {
      marginBottom: -e.lineWidth
    },
    "&-item": {
      "&:hover,&:focus,&:active": {
        zIndex: 2
      },
      "&[disabled]": {
        zIndex: 0
      }
    }
  };
}
function sz(e, t) {
  return {
    [`&-item:not(${t}-first-item):not(${t}-last-item)`]: {
      borderRadius: 0
    },
    [`&-item${t}-first-item:not(${t}-last-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderEndEndRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&-item${t}-last-item:not(${t}-first-item)`]: {
      [`&, &${e}-sm, &${e}-lg`]: {
        borderStartStartRadius: 0,
        borderStartEndRadius: 0
      }
    }
  };
}
function cz(e) {
  const t = `${e.componentCls}-compact-vertical`;
  return {
    [t]: m(m({}, iz(e, t)), sz(e.componentCls, t))
  };
}
const uz = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: {
      outline: "none",
      position: "relative",
      display: "inline-block",
      fontWeight: 400,
      whiteSpace: "nowrap",
      textAlign: "center",
      backgroundImage: "none",
      backgroundColor: "transparent",
      border: `${e.lineWidth}px ${e.lineType} transparent`,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
      userSelect: "none",
      touchAction: "manipulation",
      lineHeight: e.lineHeight,
      color: e.colorText,
      "> span": {
        display: "inline-block"
      },
      // Leave a space between icon and text.
      [`> ${n} + span, > span + ${n}`]: {
        marginInlineStart: e.marginXS
      },
      "> a": {
        color: "currentColor"
      },
      "&:not(:disabled)": m({}, Xr(e)),
      // make `btn-icon-only` not too narrow
      [`&-icon-only${t}-compact-item`]: {
        flex: "none"
      },
      // Special styles for Primary Button
      [`&-compact-item${t}-primary`]: {
        [`&:not([disabled]) + ${t}-compact-item${t}-primary:not([disabled])`]: {
          position: "relative",
          "&:before": {
            position: "absolute",
            top: -e.lineWidth,
            insetInlineStart: -e.lineWidth,
            display: "inline-block",
            width: e.lineWidth,
            height: `calc(100% + ${e.lineWidth * 2}px)`,
            backgroundColor: e.colorPrimaryHover,
            content: '""'
          }
        }
      },
      // Special styles for Primary Button
      "&-compact-vertical-item": {
        [`&${t}-primary`]: {
          [`&:not([disabled]) + ${t}-compact-vertical-item${t}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -e.lineWidth,
              insetInlineStart: -e.lineWidth,
              display: "inline-block",
              width: `calc(100% + ${e.lineWidth * 2}px)`,
              height: e.lineWidth,
              backgroundColor: e.colorPrimaryHover,
              content: '""'
            }
          }
        }
      }
    }
  };
}, Ur = (e, t) => ({
  "&:not(:disabled)": {
    "&:hover": e,
    "&:active": t
  }
}), dz = (e) => ({
  minWidth: e.controlHeight,
  paddingInlineStart: 0,
  paddingInlineEnd: 0,
  borderRadius: "50%"
}), fz = (e) => ({
  borderRadius: e.controlHeight,
  paddingInlineStart: e.controlHeight / 2,
  paddingInlineEnd: e.controlHeight / 2
}), Zg = (e) => ({
  cursor: "not-allowed",
  borderColor: e.colorBorder,
  color: e.colorTextDisabled,
  backgroundColor: e.colorBgContainerDisabled,
  boxShadow: "none"
}), Td = (e, t, n, o, r, l, a) => ({
  [`&${e}-background-ghost`]: m(m({
    color: t || void 0,
    backgroundColor: "transparent",
    borderColor: n || void 0,
    boxShadow: "none"
  }, Ur(m({
    backgroundColor: "transparent"
  }, l), m({
    backgroundColor: "transparent"
  }, a))), {
    "&:disabled": {
      cursor: "not-allowed",
      color: o || void 0,
      borderColor: r || void 0
    }
  })
}), g0 = (e) => ({
  "&:disabled": m({}, Zg(e))
}), _O = (e) => m({}, g0(e)), Md = (e) => ({
  "&:disabled": {
    cursor: "not-allowed",
    color: e.colorTextDisabled
  }
}), AO = (e) => m(m(m(m(m({}, _O(e)), {
  backgroundColor: e.colorBgContainer,
  borderColor: e.colorBorder,
  boxShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlTmpOutline}`
}), Ur({
  color: e.colorPrimaryHover,
  borderColor: e.colorPrimaryHover
}, {
  color: e.colorPrimaryActive,
  borderColor: e.colorPrimaryActive
})), Td(e.componentCls, e.colorBgContainer, e.colorBgContainer, e.colorTextDisabled, e.colorBorder)), {
  [`&${e.componentCls}-dangerous`]: m(m(m({
    color: e.colorError,
    borderColor: e.colorError
  }, Ur({
    color: e.colorErrorHover,
    borderColor: e.colorErrorBorderHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), Td(e.componentCls, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder)), g0(e))
}), pz = (e) => m(m(m(m(m({}, _O(e)), {
  color: e.colorTextLightSolid,
  backgroundColor: e.colorPrimary,
  boxShadow: `0 ${e.controlOutlineWidth}px 0 ${e.controlOutline}`
}), Ur({
  color: e.colorTextLightSolid,
  backgroundColor: e.colorPrimaryHover
}, {
  color: e.colorTextLightSolid,
  backgroundColor: e.colorPrimaryActive
})), Td(e.componentCls, e.colorPrimary, e.colorPrimary, e.colorTextDisabled, e.colorBorder, {
  color: e.colorPrimaryHover,
  borderColor: e.colorPrimaryHover
}, {
  color: e.colorPrimaryActive,
  borderColor: e.colorPrimaryActive
})), {
  [`&${e.componentCls}-dangerous`]: m(m(m({
    backgroundColor: e.colorError,
    boxShadow: `0 ${e.controlOutlineWidth}px 0 ${e.colorErrorOutline}`
  }, Ur({
    backgroundColor: e.colorErrorHover
  }, {
    backgroundColor: e.colorErrorActive
  })), Td(e.componentCls, e.colorError, e.colorError, e.colorTextDisabled, e.colorBorder, {
    color: e.colorErrorHover,
    borderColor: e.colorErrorHover
  }, {
    color: e.colorErrorActive,
    borderColor: e.colorErrorActive
  })), g0(e))
}), vz = (e) => m(m({}, AO(e)), {
  borderStyle: "dashed"
}), gz = (e) => m(m(m({
  color: e.colorLink
}, Ur({
  color: e.colorLinkHover
}, {
  color: e.colorLinkActive
})), Md(e)), {
  [`&${e.componentCls}-dangerous`]: m(m({
    color: e.colorError
  }, Ur({
    color: e.colorErrorHover
  }, {
    color: e.colorErrorActive
  })), Md(e))
}), mz = (e) => m(m(m({}, Ur({
  color: e.colorText,
  backgroundColor: e.colorBgTextHover
}, {
  color: e.colorText,
  backgroundColor: e.colorBgTextActive
})), Md(e)), {
  [`&${e.componentCls}-dangerous`]: m(m({
    color: e.colorError
  }, Md(e)), Ur({
    color: e.colorErrorHover,
    backgroundColor: e.colorErrorBg
  }, {
    color: e.colorErrorHover,
    backgroundColor: e.colorErrorBg
  }))
}), hz = (e) => m(m({}, Zg(e)), {
  [`&${e.componentCls}:hover`]: m({}, Zg(e))
}), bz = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-default`]: AO(e),
    [`${t}-primary`]: pz(e),
    [`${t}-dashed`]: vz(e),
    [`${t}-link`]: gz(e),
    [`${t}-text`]: mz(e),
    [`${t}-disabled`]: hz(e)
  };
}, m0 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  const {
    componentCls: n,
    iconCls: o,
    controlHeight: r,
    fontSize: l,
    lineHeight: a,
    lineWidth: i,
    borderRadius: s,
    buttonPaddingHorizontal: c
  } = e, u = Math.max(0, (r - l * a) / 2 - i), d = c - i, p = `${n}-icon-only`;
  return [
    // Size
    {
      [`${n}${t}`]: {
        fontSize: l,
        height: r,
        padding: `${u}px ${d}px`,
        borderRadius: s,
        [`&${p}`]: {
          width: r,
          paddingInlineStart: 0,
          paddingInlineEnd: 0,
          [`&${n}-round`]: {
            width: "auto"
          },
          "> span": {
            transform: "scale(1.143)"
            // 14px -> 16px
          }
        },
        // Loading
        [`&${n}-loading`]: {
          opacity: e.opacityLoading,
          cursor: "default"
        },
        [`${n}-loading-icon`]: {
          transition: `width ${e.motionDurationSlow} ${e.motionEaseInOut}, opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`
        },
        [`&:not(${p}) ${n}-loading-icon > ${o}`]: {
          marginInlineEnd: e.marginXS
        }
      }
    },
    // Shape - patch prefixCls again to override solid border radius style
    {
      [`${n}${n}-circle${t}`]: dz(e)
    },
    {
      [`${n}${n}-round${t}`]: fz(e)
    }
  ];
}, yz = (e) => m0(e), Sz = (e) => {
  const t = He(e, {
    controlHeight: e.controlHeightSM,
    padding: e.paddingXS,
    buttonPaddingHorizontal: 8,
    borderRadius: e.borderRadiusSM
  });
  return m0(t, `${e.componentCls}-sm`);
}, Cz = (e) => {
  const t = He(e, {
    controlHeight: e.controlHeightLG,
    fontSize: e.fontSizeLG,
    borderRadius: e.borderRadiusLG
  });
  return m0(t, `${e.componentCls}-lg`);
}, $z = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`&${t}-block`]: {
        width: "100%"
      }
    }
  };
}, wz = Xe("Button", (e) => {
  const {
    controlTmpOutline: t,
    paddingContentHorizontal: n
  } = e, o = He(e, {
    colorOutlineDefault: t,
    buttonPaddingHorizontal: n
  });
  return [
    // Shared
    uz(o),
    // Size
    Sz(o),
    yz(o),
    Cz(o),
    // Block
    $z(o),
    // Group (type, ghost, danger, disabled, loading)
    bz(o),
    // Button Group
    az(o),
    // Space Compact
    Ri(e, {
      focus: !1
    }),
    cz(e)
  ];
}), xz = () => ({
  prefixCls: String,
  size: {
    type: String
  }
}), DO = Yh(), _d = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AButtonGroup",
  props: xz(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o,
      direction: r
    } = Ie("btn-group", e), [, , l] = qr();
    DO.useProvide(xt({
      size: P(() => e.size)
    }));
    const a = P(() => {
      const {
        size: i
      } = e;
      let s = "";
      switch (i) {
        case "large":
          s = "lg";
          break;
        case "small":
          s = "sm";
          break;
        case "middle":
        case void 0:
          break;
        default:
          nt(!i, "Button.Group", "Invalid prop `size`.");
      }
      return {
        [`${o.value}`]: !0,
        [`${o.value}-${s}`]: s,
        [`${o.value}-rtl`]: r.value === "rtl",
        [l.value]: !0
      };
    });
    return () => {
      var i;
      return f("div", {
        class: a.value
      }, [It((i = n.default) === null || i === void 0 ? void 0 : i.call(n))]);
    };
  }
}), qS = /^[\u4e00-\u9fa5]{2}$/, ZS = qS.test.bind(qS);
function Kc(e) {
  return e === "text" || e === "link";
}
const Kt = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AButton",
  inheritAttrs: !1,
  __ANT_BUTTON: !0,
  props: Qe(MO(), {
    type: "default"
  }),
  slots: Object,
  // emits: ['click', 'mousedown'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r,
      expose: l
    } = t;
    const {
      prefixCls: a,
      autoInsertSpaceInButton: i,
      direction: s,
      size: c
    } = Ie("btn", e), [u, d] = wz(a), p = DO.useInject(), v = so(), h = P(() => {
      var T;
      return (T = e.disabled) !== null && T !== void 0 ? T : v.value;
    }), g = Q(null), b = Q(void 0);
    let y = !1;
    const S = Q(!1), C = Q(!1), w = P(() => i.value !== !1), {
      compactSize: $,
      compactItemClassnames: O
    } = Ol(a, s), x = P(() => typeof e.loading == "object" && e.loading.delay ? e.loading.delay || !0 : !!e.loading);
    ie(x, (T) => {
      clearTimeout(b.value), typeof x.value == "number" ? b.value = setTimeout(() => {
        S.value = T;
      }, x.value) : S.value = T;
    }, {
      immediate: !0
    });
    const I = P(() => {
      const {
        type: T,
        shape: N = "default",
        ghost: k,
        block: B,
        danger: F
      } = e, L = a.value, j = {
        large: "lg",
        small: "sm",
        middle: void 0
      }, H = $.value || (p == null ? void 0 : p.size) || c.value, K = H && j[H] || "";
      return [O.value, {
        [d.value]: !0,
        [`${L}`]: !0,
        [`${L}-${N}`]: N !== "default" && N,
        [`${L}-${T}`]: T,
        [`${L}-${K}`]: K,
        [`${L}-loading`]: S.value,
        [`${L}-background-ghost`]: k && !Kc(T),
        [`${L}-two-chinese-chars`]: C.value && w.value,
        [`${L}-block`]: B,
        [`${L}-dangerous`]: !!F,
        [`${L}-rtl`]: s.value === "rtl"
      }];
    }), E = () => {
      const T = g.value;
      if (!T || i.value === !1)
        return;
      const N = T.textContent;
      y && ZS(N) ? C.value || (C.value = !0) : C.value && (C.value = !1);
    }, _ = (T) => {
      if (S.value || h.value) {
        T.preventDefault();
        return;
      }
      r("click", T);
    }, M = (T) => {
      r("mousedown", T);
    }, R = (T, N) => {
      const k = N ? " " : "";
      if (T.type === pf) {
        let B = T.children.trim();
        return ZS(B) && (B = B.split("").join(k)), f("span", null, [B]);
      }
      return T;
    };
    return Le(() => {
      nt(!(e.ghost && Kc(e.type)), "Button", "`link` or `text` button can't be a `ghost` button.");
    }), Ke(E), co(E), et(() => {
      b.value && clearTimeout(b.value);
    }), l({
      focus: () => {
        var T;
        (T = g.value) === null || T === void 0 || T.focus();
      },
      blur: () => {
        var T;
        (T = g.value) === null || T === void 0 || T.blur();
      }
    }), () => {
      var T, N;
      const {
        icon: k = (T = n.icon) === null || T === void 0 ? void 0 : T.call(n)
      } = e, B = It((N = n.default) === null || N === void 0 ? void 0 : N.call(n));
      y = B.length === 1 && !k && !Kc(e.type);
      const {
        type: F,
        htmlType: L,
        href: j,
        title: H,
        target: K
      } = e, X = S.value ? "loading" : k, W = m(m({}, o), {
        title: H,
        disabled: h.value,
        class: [I.value, o.class, {
          [`${a.value}-icon-only`]: B.length === 0 && !!X
        }],
        onClick: _,
        onMousedown: M
      });
      h.value || delete W.disabled;
      const q = k && !S.value ? k : f(lz, {
        existIcon: !!k,
        prefixCls: a.value,
        loading: !!S.value
      }, null), J = B.map((te) => R(te, y && w.value));
      if (j !== void 0)
        return u(f("a", D(D({}, W), {}, {
          href: j,
          target: K,
          ref: g
        }), [q, J]));
      let ne = f("button", D(D({}, W), {}, {
        ref: g,
        type: L
      }), [q, J]);
      if (!Kc(F)) {
        const te = /* @__PURE__ */ function() {
          return ne;
        }();
        ne = f(v0, {
          ref: "wave",
          disabled: !!S.value
        }, {
          default: () => [te]
        });
      }
      return u(ne);
    };
  }
});
Kt.Group = _d;
Kt.install = function(e) {
  return e.component(Kt.name, Kt), e.component(_d.name, _d), e;
};
const NO = () => ({
  arrow: je([Boolean, Object]),
  trigger: {
    type: [Array, String]
  },
  menu: Re(),
  overlay: V.any,
  /** @deprecated Please use `open` instead */
  visible: ve(),
  open: ve(),
  disabled: ve(),
  danger: ve(),
  autofocus: ve(),
  align: Re(),
  getPopupContainer: Function,
  prefixCls: String,
  transitionName: String,
  placement: String,
  overlayClassName: String,
  overlayStyle: Re(),
  forceRender: ve(),
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  openClassName: String,
  minOverlayWidthMatchTrigger: ve(),
  destroyPopupOnHide: ve(),
  /** @deprecated Please use `onOpenChange` instead */
  onVisibleChange: {
    type: Function
  },
  /** @deprecated Please use `onUpdate:open` instead */
  "onUpdate:visible": {
    type: Function
  },
  onOpenChange: {
    type: Function
  },
  "onUpdate:open": {
    type: Function
  }
}), pv = MO(), Oz = () => m(m({}, NO()), {
  type: pv.type,
  size: String,
  htmlType: pv.htmlType,
  href: String,
  disabled: ve(),
  prefixCls: String,
  icon: V.any,
  title: String,
  loading: pv.loading,
  onClick: ia()
});
var Pz = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M176 511a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0zm280 0a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "ellipsis", theme: "outlined" };
function QS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Iz(e, r, n[r]);
    });
  }
  return e;
}
function Iz(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var uc = function(t, n) {
  var o = QS({}, t, n.attrs);
  return f(Ge, QS({}, o, {
    icon: Pz
  }), null);
};
uc.displayName = "EllipsisOutlined";
uc.inheritAttrs = !1;
const Ez = (e) => {
  const {
    componentCls: t,
    antCls: n,
    paddingXS: o,
    opacityLoading: r
  } = e;
  return {
    [`${t}-button`]: {
      whiteSpace: "nowrap",
      [`&${n}-btn-group > ${n}-btn`]: {
        [`&-loading, &-loading + ${n}-btn`]: {
          cursor: "default",
          pointerEvents: "none",
          opacity: r
        },
        [`&:last-child:not(:first-child):not(${n}-btn-icon-only)`]: {
          paddingInline: o
        }
      }
    }
  };
}, Tz = (e) => {
  const {
    componentCls: t,
    menuCls: n,
    colorError: o,
    colorTextLightSolid: r
  } = e, l = `${n}-item`;
  return {
    [`${t}, ${t}-menu-submenu`]: {
      [`${n} ${l}`]: {
        [`&${l}-danger:not(${l}-disabled)`]: {
          color: o,
          "&:hover": {
            color: r,
            backgroundColor: o
          }
        }
      }
    }
  };
}, Mz = (e) => {
  const {
    componentCls: t,
    menuCls: n,
    zIndexPopup: o,
    dropdownArrowDistance: r,
    dropdownArrowOffset: l,
    sizePopupArrow: a,
    antCls: i,
    iconCls: s,
    motionDurationMid: c,
    dropdownPaddingVertical: u,
    fontSize: d,
    dropdownEdgeChildPadding: p,
    colorTextDisabled: v,
    fontSizeIcon: h,
    controlPaddingHorizontal: g,
    colorBgElevated: b,
    boxShadowPopoverArrow: y
  } = e;
  return [
    {
      [t]: m(m({}, qe(e)), {
        position: "absolute",
        top: -9999,
        left: {
          _skip_check_: !0,
          value: -9999
        },
        zIndex: o,
        display: "block",
        // A placeholder out of dropdown visible range to avoid close when user moving
        "&::before": {
          position: "absolute",
          insetBlock: -r + a / 2,
          // insetInlineStart: -7, // FIXME: Seems not work for hidden element
          zIndex: -9999,
          opacity: 1e-4,
          content: '""'
        },
        [`${t}-wrap`]: {
          position: "relative",
          [`${i}-btn > ${s}-down`]: {
            fontSize: h
          },
          [`${s}-down::before`]: {
            transition: `transform ${c}`
          }
        },
        [`${t}-wrap-open`]: {
          [`${s}-down::before`]: {
            transform: "rotate(180deg)"
          }
        },
        "\n        &-hidden,\n        &-menu-hidden,\n        &-menu-submenu-hidden\n      ": {
          display: "none"
        },
        // =============================================================
        // ==                          Arrow                          ==
        // =============================================================
        // Offset the popover to account for the dropdown arrow
        [`
        &-show-arrow${t}-placement-topLeft,
        &-show-arrow${t}-placement-top,
        &-show-arrow${t}-placement-topRight
      `]: {
          paddingBottom: r
        },
        [`
        &-show-arrow${t}-placement-bottomLeft,
        &-show-arrow${t}-placement-bottom,
        &-show-arrow${t}-placement-bottomRight
      `]: {
          paddingTop: r
        },
        // Note: .popover-arrow is outer, .popover-arrow:after is inner
        [`${t}-arrow`]: m({
          position: "absolute",
          zIndex: 1,
          display: "block"
        }, dh(a, e.borderRadiusXS, e.borderRadiusOuter, b, y)),
        [`
        &-placement-top > ${t}-arrow,
        &-placement-topLeft > ${t}-arrow,
        &-placement-topRight > ${t}-arrow
      `]: {
          bottom: r,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top > ${t}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        [`&-placement-topLeft > ${t}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: l
          }
        },
        [`&-placement-topRight > ${t}-arrow`]: {
          right: {
            _skip_check_: !0,
            value: l
          }
        },
        [`
          &-placement-bottom > ${t}-arrow,
          &-placement-bottomLeft > ${t}-arrow,
          &-placement-bottomRight > ${t}-arrow
        `]: {
          top: r,
          transform: "translateY(-100%)"
        },
        [`&-placement-bottom > ${t}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: "50%"
          },
          transform: "translateY(-100%) translateX(-50%)"
        },
        [`&-placement-bottomLeft > ${t}-arrow`]: {
          left: {
            _skip_check_: !0,
            value: l
          }
        },
        [`&-placement-bottomRight > ${t}-arrow`]: {
          right: {
            _skip_check_: !0,
            value: l
          }
        },
        // =============================================================
        // ==                         Motion                          ==
        // =============================================================
        // When position is not enough for dropdown, the placement will revert.
        // We will handle this with revert motion name.
        [`&${i}-slide-down-enter${i}-slide-down-enter-active${t}-placement-bottomLeft,
          &${i}-slide-down-appear${i}-slide-down-appear-active${t}-placement-bottomLeft,
          &${i}-slide-down-enter${i}-slide-down-enter-active${t}-placement-bottom,
          &${i}-slide-down-appear${i}-slide-down-appear-active${t}-placement-bottom,
          &${i}-slide-down-enter${i}-slide-down-enter-active${t}-placement-bottomRight,
          &${i}-slide-down-appear${i}-slide-down-appear-active${t}-placement-bottomRight`]: {
          animationName: Vf
        },
        [`&${i}-slide-up-enter${i}-slide-up-enter-active${t}-placement-topLeft,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-placement-topLeft,
          &${i}-slide-up-enter${i}-slide-up-enter-active${t}-placement-top,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-placement-top,
          &${i}-slide-up-enter${i}-slide-up-enter-active${t}-placement-topRight,
          &${i}-slide-up-appear${i}-slide-up-appear-active${t}-placement-topRight`]: {
          animationName: Kf
        },
        [`&${i}-slide-down-leave${i}-slide-down-leave-active${t}-placement-bottomLeft,
          &${i}-slide-down-leave${i}-slide-down-leave-active${t}-placement-bottom,
          &${i}-slide-down-leave${i}-slide-down-leave-active${t}-placement-bottomRight`]: {
          animationName: Wf
        },
        [`&${i}-slide-up-leave${i}-slide-up-leave-active${t}-placement-topLeft,
          &${i}-slide-up-leave${i}-slide-up-leave-active${t}-placement-top,
          &${i}-slide-up-leave${i}-slide-up-leave-active${t}-placement-topRight`]: {
          animationName: Gf
        }
      })
    },
    {
      // =============================================================
      // ==                          Menu                           ==
      // =============================================================
      [`${t} ${n}`]: {
        position: "relative",
        margin: 0
      },
      [`${n}-submenu-popup`]: {
        position: "absolute",
        zIndex: o,
        background: "transparent",
        boxShadow: "none",
        transformOrigin: "0 0",
        "ul,li": {
          listStyle: "none"
        },
        ul: {
          marginInline: "0.3em"
        }
      },
      [`${t}, ${t}-menu-submenu`]: {
        [n]: m(m({
          padding: p,
          listStyleType: "none",
          backgroundColor: b,
          backgroundClip: "padding-box",
          borderRadius: e.borderRadiusLG,
          outline: "none",
          boxShadow: e.boxShadowSecondary
        }, Xr(e)), {
          [`${n}-item-group-title`]: {
            padding: `${u}px ${g}px`,
            color: e.colorTextDescription,
            transition: `all ${c}`
          },
          // ======================= Item Content =======================
          [`${n}-item`]: {
            position: "relative",
            display: "flex",
            alignItems: "center",
            borderRadius: e.borderRadiusSM
          },
          [`${n}-item-icon`]: {
            minWidth: d,
            marginInlineEnd: e.marginXS,
            fontSize: e.fontSizeSM
          },
          [`${n}-title-content`]: {
            flex: "auto",
            "> a": {
              color: "inherit",
              transition: `all ${c}`,
              "&:hover": {
                color: "inherit"
              },
              "&::after": {
                position: "absolute",
                inset: 0,
                content: '""'
              }
            }
          },
          // =========================== Item ===========================
          [`${n}-item, ${n}-submenu-title`]: m(m({
            clear: "both",
            margin: 0,
            padding: `${u}px ${g}px`,
            color: e.colorText,
            fontWeight: "normal",
            fontSize: d,
            lineHeight: e.lineHeight,
            cursor: "pointer",
            transition: `all ${c}`,
            "&:hover, &-active": {
              backgroundColor: e.controlItemBgHover
            }
          }, Xr(e)), {
            "&-selected": {
              color: e.colorPrimary,
              backgroundColor: e.controlItemBgActive,
              "&:hover, &-active": {
                backgroundColor: e.controlItemBgActiveHover
              }
            },
            "&-disabled": {
              color: v,
              cursor: "not-allowed",
              "&:hover": {
                color: v,
                backgroundColor: b,
                cursor: "not-allowed"
              },
              a: {
                pointerEvents: "none"
              }
            },
            "&-divider": {
              height: 1,
              margin: `${e.marginXXS}px 0`,
              overflow: "hidden",
              lineHeight: 0,
              backgroundColor: e.colorSplit
            },
            [`${t}-menu-submenu-expand-icon`]: {
              position: "absolute",
              insetInlineEnd: e.paddingXS,
              [`${t}-menu-submenu-arrow-icon`]: {
                marginInlineEnd: "0 !important",
                color: e.colorTextDescription,
                fontSize: h,
                fontStyle: "normal"
              }
            }
          }),
          [`${n}-item-group-list`]: {
            margin: `0 ${e.marginXS}px`,
            padding: 0,
            listStyle: "none"
          },
          [`${n}-submenu-title`]: {
            paddingInlineEnd: g + e.fontSizeSM
          },
          [`${n}-submenu-vertical`]: {
            position: "relative"
          },
          [`${n}-submenu${n}-submenu-disabled ${t}-menu-submenu-title`]: {
            [`&, ${t}-menu-submenu-arrow-icon`]: {
              color: v,
              backgroundColor: b,
              cursor: "not-allowed"
            }
          },
          // https://github.com/ant-design/ant-design/issues/19264
          [`${n}-submenu-selected ${t}-menu-submenu-title`]: {
            color: e.colorPrimary
          }
        })
      }
    },
    // Follow code may reuse in other components
    [$r(e, "slide-up"), $r(e, "slide-down"), Ci(e, "move-up"), Ci(e, "move-down"), Ni(e, "zoom-big")]
  ];
}, RO = Xe("Dropdown", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const {
    marginXXS: o,
    sizePopupArrow: r,
    controlHeight: l,
    fontSize: a,
    lineHeight: i,
    paddingXXS: s,
    componentCls: c,
    borderRadiusOuter: u,
    borderRadiusLG: d
  } = e, p = (l - a * i) / 2, {
    dropdownArrowOffset: v
  } = OO({
    sizePopupArrow: r,
    contentRadius: d,
    borderRadiusOuter: u
  }), h = He(e, {
    menuCls: `${c}-menu`,
    rootPrefixCls: n,
    dropdownArrowDistance: r / 2 + o,
    dropdownArrowOffset: v,
    dropdownPaddingVertical: p,
    dropdownEdgeChildPadding: s
  });
  return [Mz(h), Ez(h), Tz(h)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50
}));
var _z = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Az = Kt.Group, Gs = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdownButton",
  inheritAttrs: !1,
  __ANT_BUTTON: !0,
  props: Qe(Oz(), {
    trigger: "hover",
    placement: "bottomRight",
    type: "default"
  }),
  // emits: ['click', 'visibleChange', 'update:visible'],s
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r
    } = t;
    const l = (p) => {
      r("update:visible", p), r("visibleChange", p), r("update:open", p), r("openChange", p);
    }, {
      prefixCls: a,
      direction: i,
      getPopupContainer: s
    } = Ie("dropdown", e), c = P(() => `${a.value}-button`), [u, d] = RO(a);
    return () => {
      var p, v;
      const h = m(m({}, e), o), {
        type: g = "default",
        disabled: b,
        danger: y,
        loading: S,
        htmlType: C,
        class: w = "",
        overlay: $ = (p = n.overlay) === null || p === void 0 ? void 0 : p.call(n),
        trigger: O,
        align: x,
        open: I,
        visible: E,
        onVisibleChange: _,
        placement: M = i.value === "rtl" ? "bottomLeft" : "bottomRight",
        href: R,
        title: A,
        icon: z = ((v = n.icon) === null || v === void 0 ? void 0 : v.call(n)) || f(uc, null, null),
        mouseEnterDelay: T,
        mouseLeaveDelay: N,
        overlayClassName: k,
        overlayStyle: B,
        destroyPopupOnHide: F,
        onClick: L,
        "onUpdate:open": j
      } = h, H = _z(h, ["type", "disabled", "danger", "loading", "htmlType", "class", "overlay", "trigger", "align", "open", "visible", "onVisibleChange", "placement", "href", "title", "icon", "mouseEnterDelay", "mouseLeaveDelay", "overlayClassName", "overlayStyle", "destroyPopupOnHide", "onClick", "onUpdate:open"]), K = {
        align: x,
        disabled: b,
        trigger: b ? [] : O,
        placement: M,
        getPopupContainer: s == null ? void 0 : s.value,
        onOpenChange: l,
        mouseEnterDelay: T,
        mouseLeaveDelay: N,
        open: I ?? E,
        overlayClassName: k,
        overlayStyle: B,
        destroyPopupOnHide: F
      }, X = f(Kt, {
        danger: y,
        type: g,
        disabled: b,
        loading: S,
        onClick: L,
        htmlType: C,
        href: R,
        title: A
      }, {
        default: n.default
      }), W = f(Kt, {
        danger: y,
        type: g,
        icon: z
      }, null);
      return u(f(Az, D(D({}, H), {}, {
        class: ee(c.value, w, d.value)
      }), {
        default: () => [n.leftButton ? n.leftButton({
          button: X
        }) : X, f(er, K, {
          default: () => [n.rightButton ? n.rightButton({
            button: W
          }) : W],
          overlay: () => $
        })]
      }));
    };
  }
});
var Dz = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M765.7 486.8L314.9 134.7A7.97 7.97 0 00302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 000-50.4z" } }] }, name: "right", theme: "outlined" };
function JS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Nz(e, r, n[r]);
    });
  }
  return e;
}
function Nz(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Po = function(t, n) {
  var o = JS({}, t, n.attrs);
  return f(Ge, JS({}, o, {
    icon: Dz
  }), null);
};
Po.displayName = "RightOutlined";
Po.inheritAttrs = !1;
const kO = Symbol("OverrideContextKey"), BO = () => tt(kO, void 0), h0 = (e) => {
  var t, n, o;
  const {
    prefixCls: r,
    mode: l,
    selectable: a,
    validator: i,
    onClick: s,
    expandIcon: c
  } = BO() || {};
  Je(kO, {
    prefixCls: P(() => {
      var u, d;
      return (d = (u = e.prefixCls) === null || u === void 0 ? void 0 : u.value) !== null && d !== void 0 ? d : r == null ? void 0 : r.value;
    }),
    mode: P(() => {
      var u, d;
      return (d = (u = e.mode) === null || u === void 0 ? void 0 : u.value) !== null && d !== void 0 ? d : l == null ? void 0 : l.value;
    }),
    selectable: P(() => {
      var u, d;
      return (d = (u = e.selectable) === null || u === void 0 ? void 0 : u.value) !== null && d !== void 0 ? d : a == null ? void 0 : a.value;
    }),
    validator: (t = e.validator) !== null && t !== void 0 ? t : i,
    onClick: (n = e.onClick) !== null && n !== void 0 ? n : s,
    expandIcon: (o = e.expandIcon) !== null && o !== void 0 ? o : c == null ? void 0 : c.value
  });
}, er = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ADropdown",
  inheritAttrs: !1,
  props: Qe(NO(), {
    mouseEnterDelay: 0.15,
    mouseLeaveDelay: 0.1,
    placement: "bottomLeft",
    trigger: "hover"
  }),
  // emits: ['visibleChange', 'update:visible'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r
    } = t;
    const {
      prefixCls: l,
      rootPrefixCls: a,
      direction: i,
      getPopupContainer: s
    } = Ie("dropdown", e), [c, u] = RO(l);
    process.env.NODE_ENV !== "production" && [["visible", "open"], ["onVisibleChange", "onOpenChange"], ["onUpdate:visible", "onUpdate:open"]].forEach((b) => {
      let [y, S] = b;
      Mt(e[y] === void 0, "Dropdown", `\`${y}\` is deprecated which will be removed in next major version, please use \`${S}\` instead.`);
    });
    const d = P(() => {
      const {
        placement: b = "",
        transitionName: y
      } = e;
      return y !== void 0 ? y : b.includes("top") ? `${a.value}-slide-down` : `${a.value}-slide-up`;
    });
    h0({
      prefixCls: P(() => `${l.value}-menu`),
      expandIcon: P(() => f("span", {
        class: `${l.value}-menu-submenu-arrow`
      }, [f(Po, {
        class: `${l.value}-menu-submenu-arrow-icon`
      }, null)])),
      mode: P(() => "vertical"),
      selectable: P(() => !1),
      onClick: () => {
      },
      validator: (b) => {
        let {
          mode: y
        } = b;
        Mt(!y || y === "vertical", "Dropdown", `mode="${y}" is not supported for Dropdown's Menu.`);
      }
    });
    const p = () => {
      var b, y, S;
      const C = e.overlay || ((b = n.overlay) === null || b === void 0 ? void 0 : b.call(n)), w = Array.isArray(C) ? C[0] : C;
      if (!w)
        return null;
      const $ = w.props || {};
      nt(!$.mode || $.mode === "vertical", "Dropdown", `mode="${$.mode}" is not supported for Dropdown's Menu.`);
      const {
        selectable: O = !1,
        expandIcon: x = (S = (y = w.children) === null || y === void 0 ? void 0 : y.expandIcon) === null || S === void 0 ? void 0 : S.call(y)
      } = $, I = typeof x < "u" && Gt(x) ? x : f("span", {
        class: `${l.value}-menu-submenu-arrow`
      }, [f(Po, {
        class: `${l.value}-menu-submenu-arrow-icon`
      }, null)]);
      return Gt(w) ? yt(w, {
        mode: "vertical",
        selectable: O,
        expandIcon: () => I
      }) : w;
    }, v = P(() => {
      const b = e.placement;
      if (!b)
        return i.value === "rtl" ? "bottomRight" : "bottomLeft";
      if (b.includes("Center")) {
        const y = b.slice(0, b.indexOf("Center"));
        return nt(!b.includes("Center"), "Dropdown", `You are using '${b}' placement in Dropdown, which is deprecated. Try to use '${y}' instead.`), y;
      }
      return b;
    }), h = P(() => typeof e.visible == "boolean" ? e.visible : e.open), g = (b) => {
      r("update:visible", b), r("visibleChange", b), r("update:open", b), r("openChange", b);
    };
    return () => {
      var b, y;
      const {
        arrow: S,
        trigger: C,
        disabled: w,
        overlayClassName: $
      } = e, O = (b = n.default) === null || b === void 0 ? void 0 : b.call(n)[0], x = yt(O, m({
        class: ee((y = O == null ? void 0 : O.props) === null || y === void 0 ? void 0 : y.class, {
          [`${l.value}-rtl`]: i.value === "rtl"
        }, `${l.value}-trigger`)
      }, w ? {
        disabled: w
      } : {})), I = ee($, u.value, {
        [`${l.value}-rtl`]: i.value === "rtl"
      }), E = w ? [] : C;
      let _;
      E && E.includes("contextmenu") && (_ = !0);
      const M = u0({
        arrowPointAtCenter: typeof S == "object" && S.pointAtCenter,
        autoAdjustOverflow: !0
      }), R = ot(m(m(m({}, e), o), {
        visible: h.value,
        builtinPlacements: M,
        overlayClassName: I,
        arrow: !!S,
        alignPoint: _,
        prefixCls: l.value,
        getPopupContainer: s == null ? void 0 : s.value,
        transitionName: d.value,
        trigger: E,
        onVisibleChange: g,
        placement: v.value
      }), ["overlay", "onUpdate:visible"]);
      return c(f(TO, R, {
        default: () => [x],
        overlay: p
      }));
    };
  }
});
er.Button = Gs;
var Rz = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const kz = () => ({
  prefixCls: String,
  href: String,
  separator: V.any,
  dropdownProps: Re(),
  overlay: V.any,
  onClick: ia()
}), Xs = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbItem",
  inheritAttrs: !1,
  __ANT_BREADCRUMB_ITEM: !0,
  props: kz(),
  // emits: ['click'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r
    } = t;
    const {
      prefixCls: l
    } = Ie("breadcrumb", e), a = (s, c) => {
      const u = an(n, e, "overlay");
      return u ? f(er, D(D({}, e.dropdownProps), {}, {
        overlay: u,
        placement: "bottom"
      }), {
        default: () => [f("span", {
          class: `${c}-overlay-link`
        }, [s, f(Or, null, null)])]
      }) : s;
    }, i = (s) => {
      r("click", s);
    };
    return () => {
      var s;
      const c = (s = an(n, e, "separator")) !== null && s !== void 0 ? s : "/", u = an(n, e), {
        class: d,
        style: p
      } = o, v = Rz(o, ["class", "style"]);
      let h;
      return e.href !== void 0 ? h = f("a", D({
        class: `${l.value}-link`,
        onClick: i
      }, v), [u]) : h = f("span", D({
        class: `${l.value}-link`,
        onClick: i
      }, v), [u]), h = a(h, l.value), u != null ? f("li", {
        class: d,
        style: p
      }, [h, c && f("span", {
        class: `${l.value}-separator`
      }, [c])]) : null;
    };
  }
});
function Bz(e, t, n, o) {
  let r;
  if (r !== void 0)
    return !!r;
  if (e === t)
    return !0;
  if (typeof e != "object" || !e || typeof t != "object" || !t)
    return !1;
  const l = Object.keys(e), a = Object.keys(t);
  if (l.length !== a.length)
    return !1;
  const i = Object.prototype.hasOwnProperty.bind(t);
  for (let s = 0; s < l.length; s++) {
    const c = l[s];
    if (!i(c))
      return !1;
    const u = e[c], d = t[c];
    if (r = void 0, r === !1 || r === void 0 && u !== d)
      return !1;
  }
  return !0;
}
function Ha(e, t) {
  return Bz(Yt(e), Yt(t));
}
const FO = Symbol("menuContextKey"), LO = (e) => {
  Je(FO, e);
}, Jr = () => tt(FO), zO = Symbol("ForceRenderKey"), Fz = (e) => {
  Je(zO, e);
}, HO = () => tt(zO, !1), jO = Symbol("menuFirstLevelContextKey"), VO = (e) => {
  Je(jO, e);
}, Lz = () => tt(jO, !0), Ad = Z({
  compatConfig: {
    MODE: 3
  },
  name: "MenuContextProvider",
  inheritAttrs: !1,
  props: {
    mode: {
      type: String,
      default: void 0
    },
    overflowDisabled: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Jr(), r = m({}, o);
    return e.mode !== void 0 && (r.mode = Te(e, "mode")), e.overflowDisabled !== void 0 && (r.overflowDisabled = Te(e, "overflowDisabled")), LO(r), () => {
      var l;
      return (l = n.default) === null || l === void 0 ? void 0 : l.call(n);
    };
  }
}), zz = LO, WO = Symbol("siderCollapsed"), KO = Symbol("siderHookProvider"), Gc = "$$__vc-menu-more__key", GO = Symbol("KeyPathContext"), b0 = () => tt(GO, {
  parentEventKeys: P(() => []),
  parentKeys: P(() => []),
  parentInfo: {}
}), Hz = (e, t, n) => {
  const {
    parentEventKeys: o,
    parentKeys: r
  } = b0(), l = P(() => [...o.value, e]), a = P(() => [...r.value, t]);
  return Je(GO, {
    parentEventKeys: l,
    parentKeys: a,
    parentInfo: n
  }), a;
}, XO = Symbol("measure"), eC = Z({
  compatConfig: {
    MODE: 3
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Je(XO, !0), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), y0 = () => tt(XO, !1), jz = Hz;
function UO(e) {
  const {
    mode: t,
    rtl: n,
    inlineIndent: o
  } = Jr();
  return P(() => t.value !== "inline" ? null : n.value ? {
    paddingRight: `${e.value * o.value}px`
  } : {
    paddingLeft: `${e.value * o.value}px`
  });
}
let Vz = 0;
const Wz = () => ({
  id: String,
  role: String,
  disabled: Boolean,
  danger: Boolean,
  title: {
    type: [String, Boolean],
    default: void 0
  },
  icon: V.any,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function,
  onKeydown: Function,
  onFocus: Function,
  // Internal user prop
  originItemValue: Re()
}), hr = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItem",
  inheritAttrs: !1,
  props: Wz(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const l = Wn(), a = y0(), i = typeof l.vnode.key == "symbol" ? String(l.vnode.key) : l.vnode.key;
    nt(typeof l.vnode.key != "symbol", "MenuItem", `MenuItem \`:key="${String(i)}"\` not support Symbol type`);
    const s = `menu_item_${++Vz}_$$_${i}`, {
      parentEventKeys: c,
      parentKeys: u
    } = b0(), {
      prefixCls: d,
      activeKeys: p,
      disabled: v,
      changeActiveKeys: h,
      rtl: g,
      inlineCollapsed: b,
      siderCollapsed: y,
      onItemClick: S,
      selectedKeys: C,
      registerMenuInfo: w,
      unRegisterMenuInfo: $
    } = Jr(), O = Lz(), x = Q(!1), I = P(() => [...u.value, i]);
    w(s, {
      eventKey: s,
      key: i,
      parentEventKeys: c,
      parentKeys: u,
      isLeaf: !0
    }), et(() => {
      $(s);
    }), ie(p, () => {
      x.value = !!p.value.find((j) => j === i);
    }, {
      immediate: !0
    });
    const _ = P(() => v.value || e.disabled), M = P(() => C.value.includes(i)), R = P(() => {
      const j = `${d.value}-item`;
      return {
        [`${j}`]: !0,
        [`${j}-danger`]: e.danger,
        [`${j}-active`]: x.value,
        [`${j}-selected`]: M.value,
        [`${j}-disabled`]: _.value
      };
    }), A = (j) => ({
      key: i,
      eventKey: s,
      keyPath: I.value,
      eventKeyPath: [...c.value, s],
      domEvent: j,
      item: m(m({}, e), r)
    }), z = (j) => {
      if (_.value)
        return;
      const H = A(j);
      o("click", j), S(H);
    }, T = (j) => {
      _.value || (h(I.value), o("mouseenter", j));
    }, N = (j) => {
      _.value || (h([]), o("mouseleave", j));
    }, k = (j) => {
      if (o("keydown", j), j.which === ce.ENTER) {
        const H = A(j);
        o("click", j), S(H);
      }
    }, B = (j) => {
      h(I.value), o("focus", j);
    }, F = (j, H) => {
      const K = f("span", {
        class: `${d.value}-title-content`
      }, [H]);
      return (!j || Gt(H) && H.type === "span") && H && b.value && O && typeof H == "string" ? f("div", {
        class: `${d.value}-inline-collapsed-noicon`
      }, [H.charAt(0)]) : K;
    }, L = UO(P(() => I.value.length));
    return () => {
      var j, H, K, X, W;
      if (a)
        return null;
      const q = (j = e.title) !== null && j !== void 0 ? j : (H = n.title) === null || H === void 0 ? void 0 : H.call(n), J = It((K = n.default) === null || K === void 0 ? void 0 : K.call(n)), ne = J.length;
      let te = q;
      typeof q > "u" ? te = O && ne ? J : "" : q === !1 && (te = "");
      const G = {
        title: te
      };
      !y.value && !b.value && (G.title = null, G.open = !1);
      const U = {};
      e.role === "option" && (U["aria-selected"] = M.value);
      const re = (X = e.icon) !== null && X !== void 0 ? X : (W = n.icon) === null || W === void 0 ? void 0 : W.call(n, e);
      return f(Ln, D(D({}, G), {}, {
        placement: g.value ? "left" : "right",
        overlayClassName: `${d.value}-inline-collapsed-tooltip`
      }), {
        default: () => [f(Vr.Item, D(D(D({
          component: "li"
        }, r), {}, {
          id: e.id,
          style: m(m({}, r.style || {}), L.value),
          class: [R.value, {
            [`${r.class}`]: !!r.class,
            [`${d.value}-item-only-child`]: (re ? ne + 1 : ne) === 1
          }],
          role: e.role || "menuitem",
          tabindex: e.disabled ? null : -1,
          "data-menu-id": i,
          "aria-disabled": e.disabled
        }, U), {}, {
          onMouseenter: T,
          onMouseleave: N,
          onClick: z,
          onKeydown: k,
          onFocus: B,
          title: typeof q == "string" ? q : void 0
        }), {
          default: () => [yt(typeof re == "function" ? re(e.originItemValue) : re, {
            class: `${d.value}-item-icon`
          }, !1), F(re, J)]
        })]
      });
    };
  }
}), fl = {
  adjustX: 1,
  adjustY: 1
}, Kz = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: fl,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: fl,
    offset: [0, 7]
  },
  leftTop: {
    points: ["tr", "tl"],
    overflow: fl,
    offset: [-4, 0]
  },
  rightTop: {
    points: ["tl", "tr"],
    overflow: fl,
    offset: [4, 0]
  }
}, Gz = {
  topLeft: {
    points: ["bl", "tl"],
    overflow: fl,
    offset: [0, -7]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    overflow: fl,
    offset: [0, 7]
  },
  rightTop: {
    points: ["tr", "tl"],
    overflow: fl,
    offset: [-4, 0]
  },
  leftTop: {
    points: ["tl", "tr"],
    overflow: fl,
    offset: [4, 0]
  }
}, Xz = {
  horizontal: "bottomLeft",
  vertical: "rightTop",
  "vertical-left": "rightTop",
  "vertical-right": "leftTop"
}, tC = Z({
  compatConfig: {
    MODE: 3
  },
  name: "PopupTrigger",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    mode: String,
    visible: Boolean,
    // popup: React.ReactNode;
    popupClassName: String,
    popupOffset: Array,
    disabled: Boolean,
    onVisibleChange: Function
  },
  slots: Object,
  emits: ["visibleChange"],
  setup(e, t) {
    let {
      slots: n,
      emit: o
    } = t;
    const r = Q(!1), {
      getPopupContainer: l,
      rtl: a,
      subMenuOpenDelay: i,
      subMenuCloseDelay: s,
      builtinPlacements: c,
      triggerSubMenuAction: u,
      forceSubMenuRender: d,
      motion: p,
      defaultMotions: v,
      rootClassName: h
    } = Jr(), g = HO(), b = P(() => a.value ? m(m({}, Gz), c.value) : m(m({}, Kz), c.value)), y = P(() => Xz[e.mode]), S = Q();
    ie(() => e.visible, ($) => {
      Ze.cancel(S.value), S.value = Ze(() => {
        r.value = $;
      });
    }, {
      immediate: !0
    }), et(() => {
      Ze.cancel(S.value);
    });
    const C = ($) => {
      o("visibleChange", $);
    }, w = P(() => {
      var $, O;
      const x = p.value || (($ = v.value) === null || $ === void 0 ? void 0 : $[e.mode]) || ((O = v.value) === null || O === void 0 ? void 0 : O.other), I = typeof x == "function" ? x() : x;
      return I ? Ho(I.name, {
        css: !0
      }) : void 0;
    });
    return () => {
      const {
        prefixCls: $,
        popupClassName: O,
        mode: x,
        popupOffset: I,
        disabled: E
      } = e;
      return f($a, {
        prefixCls: $,
        popupClassName: ee(`${$}-popup`, {
          [`${$}-rtl`]: a.value
        }, O, h.value),
        stretch: x === "horizontal" ? "minWidth" : null,
        getPopupContainer: l.value,
        builtinPlacements: b.value,
        popupPlacement: y.value,
        popupVisible: r.value,
        popupAlign: I && {
          offset: I
        },
        action: E ? [] : [u.value],
        mouseEnterDelay: i.value,
        mouseLeaveDelay: s.value,
        onPopupVisibleChange: C,
        forceRender: g || d.value,
        popupAnimation: w.value
      }, {
        popup: n.popup,
        default: n.default
      });
    };
  }
}), S0 = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  var r;
  const {
    prefixCls: l,
    mode: a
  } = Jr();
  return f("ul", D(D({}, o), {}, {
    class: ee(l.value, `${l.value}-sub`, `${l.value}-${a.value === "inline" ? "inline" : "vertical"}`),
    "data-menu-list": !0
  }), [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)]);
};
S0.displayName = "SubMenuList";
const Uz = Z({
  compatConfig: {
    MODE: 3
  },
  name: "InlineSubMenuList",
  inheritAttrs: !1,
  props: {
    id: String,
    open: Boolean,
    keyPath: Array
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = P(() => "inline"), {
      motion: r,
      mode: l,
      defaultMotions: a
    } = Jr(), i = P(() => l.value === o.value), s = Y(!i.value), c = P(() => i.value ? e.open : !1);
    ie(l, () => {
      i.value && (s.value = !1);
    }, {
      flush: "post"
    });
    const u = P(() => {
      var d, p;
      const v = r.value || ((d = a.value) === null || d === void 0 ? void 0 : d[o.value]) || ((p = a.value) === null || p === void 0 ? void 0 : p.other), h = typeof v == "function" ? v() : v;
      return m(m({}, h), {
        appear: e.keyPath.length <= 1
      });
    });
    return () => {
      var d;
      return s.value ? null : f(Ad, {
        mode: o.value
      }, {
        default: () => [f(yn, u.value, {
          default: () => [Tn(f(S0, {
            id: e.id
          }, {
            default: () => [(d = n.default) === null || d === void 0 ? void 0 : d.call(n)]
          }), [[Hn, c.value]])]
        })]
      });
    };
  }
});
let nC = 0;
const Yz = () => ({
  icon: V.any,
  title: V.any,
  disabled: Boolean,
  level: Number,
  popupClassName: String,
  popupOffset: Array,
  internalPopupClose: Boolean,
  eventKey: String,
  expandIcon: Function,
  theme: String,
  onMouseenter: Function,
  onMouseleave: Function,
  onTitleClick: Function,
  // Internal user prop
  originItemValue: Re()
}), fa = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASubMenu",
  inheritAttrs: !1,
  props: Yz(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r
    } = t;
    var l, a;
    VO(!1);
    const i = y0(), s = Wn(), c = typeof s.vnode.key == "symbol" ? String(s.vnode.key) : s.vnode.key;
    nt(typeof s.vnode.key != "symbol", "SubMenu", `SubMenu \`:key="${String(c)}"\` not support Symbol type`);
    const u = mg(c) ? c : `sub_menu_${++nC}_$$_not_set_key`, d = (l = e.eventKey) !== null && l !== void 0 ? l : mg(c) ? `sub_menu_${++nC}_$$_${c}` : u, {
      parentEventKeys: p,
      parentInfo: v,
      parentKeys: h
    } = b0(), g = P(() => [...h.value, u]), b = Q([]), y = {
      eventKey: d,
      key: u,
      parentEventKeys: p,
      childrenEventKeys: b,
      parentKeys: h
    };
    (a = v.childrenEventKeys) === null || a === void 0 || a.value.push(d), et(() => {
      var de;
      v.childrenEventKeys && (v.childrenEventKeys.value = (de = v.childrenEventKeys) === null || de === void 0 ? void 0 : de.value.filter((Se) => Se != d));
    }), jz(d, u, y);
    const {
      prefixCls: S,
      activeKeys: C,
      disabled: w,
      changeActiveKeys: $,
      mode: O,
      inlineCollapsed: x,
      openKeys: I,
      overflowDisabled: E,
      onOpenChange: _,
      registerMenuInfo: M,
      unRegisterMenuInfo: R,
      selectedSubMenuKeys: A,
      expandIcon: z,
      theme: T
    } = Jr(), N = c != null, k = !i && (HO() || !N);
    Fz(k), (i && N || !i && !N || k) && (M(d, y), et(() => {
      R(d);
    }));
    const B = P(() => `${S.value}-submenu`), F = P(() => w.value || e.disabled), L = Q(), j = Q(), H = P(() => I.value.includes(u)), K = P(() => !E.value && H.value), X = P(() => A.value.includes(u)), W = Q(!1);
    ie(C, () => {
      W.value = !!C.value.find((de) => de === u);
    }, {
      immediate: !0
    });
    const q = (de) => {
      F.value || (r("titleClick", de, u), O.value === "inline" && _(u, !H.value));
    }, J = (de) => {
      F.value || ($(g.value), r("mouseenter", de));
    }, ne = (de) => {
      F.value || ($([]), r("mouseleave", de));
    }, te = UO(P(() => g.value.length)), G = (de) => {
      O.value !== "inline" && _(u, de);
    }, U = () => {
      $(g.value);
    }, re = d && `${d}-popup`, se = P(() => ee(S.value, `${S.value}-${e.theme || T.value}`, e.popupClassName)), me = (de, Se) => {
      if (!Se)
        return x.value && !h.value.length && de && typeof de == "string" ? f("div", {
          class: `${S.value}-inline-collapsed-noicon`
        }, [de.charAt(0)]) : f("span", {
          class: `${S.value}-title-content`
        }, [de]);
      const xe = Gt(de) && de.type === "span";
      return f(Fe, null, [yt(typeof Se == "function" ? Se(e.originItemValue) : Se, {
        class: `${S.value}-item-icon`
      }, !1), xe ? de : f("span", {
        class: `${S.value}-title-content`
      }, [de])]);
    }, Ce = P(() => O.value !== "inline" && g.value.length > 1 ? "vertical" : O.value), fe = P(() => O.value === "horizontal" ? "vertical" : O.value), be = P(() => Ce.value === "horizontal" ? "vertical" : Ce.value), ue = () => {
      var de, Se;
      const xe = B.value, he = (de = e.icon) !== null && de !== void 0 ? de : (Se = n.icon) === null || Se === void 0 ? void 0 : Se.call(n, e), we = e.expandIcon || n.expandIcon || z.value, Me = me(an(n, e, "title"), he);
      return f("div", {
        style: te.value,
        class: `${xe}-title`,
        tabindex: F.value ? null : -1,
        ref: L,
        title: typeof Me == "string" ? Me : null,
        "data-menu-id": u,
        "aria-expanded": K.value,
        "aria-haspopup": !0,
        "aria-controls": re,
        "aria-disabled": F.value,
        onClick: q,
        onFocus: U
      }, [Me, O.value !== "horizontal" && we ? we(m(m({}, e), {
        isOpen: K.value
      })) : f("i", {
        class: `${xe}-arrow`
      }, null)]);
    };
    return () => {
      var de;
      if (i)
        return N ? (de = n.default) === null || de === void 0 ? void 0 : de.call(n) : null;
      const Se = B.value;
      let xe = () => null;
      if (!E.value && O.value !== "inline") {
        const he = O.value === "horizontal" ? [0, 8] : [10, 0];
        xe = () => f(tC, {
          mode: Ce.value,
          prefixCls: Se,
          visible: !e.internalPopupClose && K.value,
          popupClassName: se.value,
          popupOffset: e.popupOffset || he,
          disabled: F.value,
          onVisibleChange: G
        }, {
          default: () => [ue()],
          popup: () => f(Ad, {
            mode: be.value
          }, {
            default: () => [f(S0, {
              id: re,
              ref: j
            }, {
              default: n.default
            })]
          })
        });
      } else
        xe = () => f(tC, null, {
          default: ue
        });
      return f(Ad, {
        mode: fe.value
      }, {
        default: () => [f(Vr.Item, D(D({
          component: "li"
        }, o), {}, {
          role: "none",
          class: ee(Se, `${Se}-${O.value}`, o.class, {
            [`${Se}-open`]: K.value,
            [`${Se}-active`]: W.value,
            [`${Se}-selected`]: X.value,
            [`${Se}-disabled`]: F.value
          }),
          onMouseenter: J,
          onMouseleave: ne,
          "data-submenu-id": u
        }), {
          default: () => f(Fe, null, [xe(), !E.value && f(Uz, {
            id: re,
            open: K.value,
            keyPath: g.value
          }, {
            default: n.default
          })])
        })]
      });
    };
  }
});
function YO(e, t) {
  return e.classList ? e.classList.contains(t) : ` ${e.className} `.indexOf(` ${t} `) > -1;
}
function Dd(e, t) {
  e.classList ? e.classList.add(t) : YO(e, t) || (e.className = `${e.className} ${t}`);
}
function Nd(e, t) {
  if (e.classList)
    e.classList.remove(t);
  else if (YO(e, t)) {
    const n = e.className;
    e.className = ` ${n} `.replace(` ${t} `, " ");
  }
}
const dc = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "ant-motion-collapse", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  return {
    name: e,
    appear: t,
    css: !0,
    onBeforeEnter: (n) => {
      n.style.height = "0px", n.style.opacity = "0", Dd(n, e);
    },
    onEnter: (n) => {
      rt(() => {
        n.style.height = `${n.scrollHeight}px`, n.style.opacity = "1";
      });
    },
    onAfterEnter: (n) => {
      n && (Nd(n, e), n.style.height = null, n.style.opacity = null);
    },
    onBeforeLeave: (n) => {
      Dd(n, e), n.style.height = `${n.offsetHeight}px`, n.style.opacity = null;
    },
    onLeave: (n) => {
      setTimeout(() => {
        n.style.height = "0px", n.style.opacity = "0";
      });
    },
    onAfterLeave: (n) => {
      n && (Nd(n, e), n.style && (n.style.height = null, n.style.opacity = null));
    }
  };
}, qz = () => ({
  title: V.any,
  // Internal user prop
  originItemValue: Re()
}), Us = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuItemGroup",
  inheritAttrs: !1,
  props: qz(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r
    } = Jr(), l = P(() => `${r.value}-item-group`), a = y0();
    return () => {
      var i, s;
      return a ? (i = n.default) === null || i === void 0 ? void 0 : i.call(n) : f("li", D(D({}, o), {}, {
        onClick: (c) => c.stopPropagation(),
        class: l.value
      }), [f("div", {
        title: typeof e.title == "string" ? e.title : void 0,
        class: `${l.value}-title`
      }, [an(n, e, "title")]), f("ul", {
        class: `${l.value}-list`
      }, [(s = n.default) === null || s === void 0 ? void 0 : s.call(n)])]);
    };
  }
}), Zz = () => ({
  prefixCls: String,
  dashed: Boolean
}), Ys = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AMenuDivider",
  props: Zz(),
  setup(e) {
    const {
      prefixCls: t
    } = Jr(), n = P(() => ({
      [`${t.value}-item-divider`]: !0,
      [`${t.value}-item-divider-dashed`]: !!e.dashed
    }));
    return () => f("li", {
      class: n.value
    }, null);
  }
});
var Qz = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function Qg(e, t, n) {
  return (e || []).map((o, r) => {
    if (o && typeof o == "object") {
      const l = o, {
        label: a,
        children: i,
        key: s,
        type: c
      } = l, u = Qz(l, ["label", "children", "key", "type"]), d = s ?? `tmp-${r}`, p = n ? n.parentKeys.slice() : [], v = [], h = {
        eventKey: d,
        key: d,
        parentEventKeys: Y(p),
        parentKeys: Y(p),
        childrenEventKeys: Y(v),
        isLeaf: !1
      };
      if (i || c === "group") {
        if (c === "group") {
          const b = Qg(i, t, n);
          return f(Us, D(D({
            key: d
          }, u), {}, {
            title: a,
            originItemValue: o
          }), {
            default: () => [b]
          });
        }
        t.set(d, h), n && n.childrenEventKeys.push(d);
        const g = Qg(i, t, {
          childrenEventKeys: v,
          parentKeys: [].concat(p, d)
        });
        return f(fa, D(D({
          key: d
        }, u), {}, {
          title: a,
          originItemValue: o
        }), {
          default: () => [g]
        });
      }
      return c === "divider" ? f(Ys, D({
        key: d
      }, u), null) : (h.isLeaf = !0, t.set(d, h), f(hr, D(D({
        key: d
      }, u), {}, {
        originItemValue: o
      }), {
        default: () => [a]
      }));
    }
    return null;
  }).filter((o) => o);
}
function Jz(e) {
  const t = Q([]), n = Q(!1), o = Q(/* @__PURE__ */ new Map());
  return ie(() => e.items, () => {
    const r = /* @__PURE__ */ new Map();
    n.value = !1, e.items ? (n.value = !0, t.value = Qg(e.items, r)) : t.value = void 0, o.value = r;
  }, {
    immediate: !0,
    deep: !0
  }), {
    itemsNodes: t,
    store: o,
    hasItmes: n
  };
}
const eH = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    menuHorizontalHeight: o,
    colorSplit: r,
    lineWidth: l,
    lineType: a,
    menuItemPaddingInline: i
  } = e;
  return {
    [`${t}-horizontal`]: {
      lineHeight: `${o}px`,
      border: 0,
      borderBottom: `${l}px ${a} ${r}`,
      boxShadow: "none",
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        content: '"\\20"'
      },
      // ======================= Item =======================
      [`${t}-item, ${t}-submenu`]: {
        position: "relative",
        display: "inline-block",
        verticalAlign: "bottom",
        paddingInline: i
      },
      [`> ${t}-item:hover,
        > ${t}-item-active,
        > ${t}-submenu ${t}-submenu-title:hover`]: {
        backgroundColor: "transparent"
      },
      [`${t}-item, ${t}-submenu-title`]: {
        transition: [`border-color ${n}`, `background ${n}`].join(",")
      },
      // ===================== Sub Menu =====================
      [`${t}-submenu-arrow`]: {
        display: "none"
      }
    }
  };
}, tH = (e) => {
  let {
    componentCls: t,
    menuArrowOffset: n
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl"
    },
    [`${t}-submenu-rtl`]: {
      transformOrigin: "100% 0"
    },
    // Vertical Arrow
    [`${t}-rtl${t}-vertical,
    ${t}-submenu-rtl ${t}-vertical`]: {
      [`${t}-submenu-arrow`]: {
        "&::before": {
          transform: `rotate(-45deg) translateY(-${n})`
        },
        "&::after": {
          transform: `rotate(45deg) translateY(${n})`
        }
      }
    }
  };
}, oC = (e) => m({}, Gr(e)), rC = (e, t) => {
  const {
    componentCls: n,
    colorItemText: o,
    colorItemTextSelected: r,
    colorGroupTitle: l,
    colorItemBg: a,
    colorSubItemBg: i,
    colorItemBgSelected: s,
    colorActiveBarHeight: c,
    colorActiveBarWidth: u,
    colorActiveBarBorderSize: d,
    motionDurationSlow: p,
    motionEaseInOut: v,
    motionEaseOut: h,
    menuItemPaddingInline: g,
    motionDurationMid: b,
    colorItemTextHover: y,
    lineType: S,
    colorSplit: C,
    // Disabled
    colorItemTextDisabled: w,
    // Danger
    colorDangerItemText: $,
    colorDangerItemTextHover: O,
    colorDangerItemTextSelected: x,
    colorDangerItemBgActive: I,
    colorDangerItemBgSelected: E,
    colorItemBgHover: _,
    menuSubMenuBg: M,
    // Horizontal
    colorItemTextSelectedHorizontal: R,
    colorItemBgSelectedHorizontal: A
  } = e;
  return {
    [`${n}-${t}`]: {
      color: o,
      background: a,
      [`&${n}-root:focus-visible`]: m({}, oC(e)),
      // ======================== Item ========================
      [`${n}-item-group-title`]: {
        color: l
      },
      [`${n}-submenu-selected`]: {
        [`> ${n}-submenu-title`]: {
          color: r
        }
      },
      // Disabled
      [`${n}-item-disabled, ${n}-submenu-disabled`]: {
        color: `${w} !important`
      },
      // Hover
      [`${n}-item:hover, ${n}-submenu-title:hover`]: {
        [`&:not(${n}-item-selected):not(${n}-submenu-selected)`]: {
          color: y
        }
      },
      [`&:not(${n}-horizontal)`]: {
        [`${n}-item:not(${n}-item-selected)`]: {
          "&:hover": {
            backgroundColor: _
          },
          "&:active": {
            backgroundColor: s
          }
        },
        [`${n}-submenu-title`]: {
          "&:hover": {
            backgroundColor: _
          },
          "&:active": {
            backgroundColor: s
          }
        }
      },
      // Danger - only Item has
      [`${n}-item-danger`]: {
        color: $,
        [`&${n}-item:hover`]: {
          [`&:not(${n}-item-selected):not(${n}-submenu-selected)`]: {
            color: O
          }
        },
        [`&${n}-item:active`]: {
          background: I
        }
      },
      [`${n}-item a`]: {
        "&, &:hover": {
          color: "inherit"
        }
      },
      [`${n}-item-selected`]: {
        color: r,
        // Danger
        [`&${n}-item-danger`]: {
          color: x
        },
        "a, a:hover": {
          color: "inherit"
        }
      },
      [`& ${n}-item-selected`]: {
        backgroundColor: s,
        // Danger
        [`&${n}-item-danger`]: {
          backgroundColor: E
        }
      },
      [`${n}-item, ${n}-submenu-title`]: {
        [`&:not(${n}-item-disabled):focus-visible`]: m({}, oC(e))
      },
      [`&${n}-submenu > ${n}`]: {
        backgroundColor: M
      },
      [`&${n}-popup > ${n}`]: {
        backgroundColor: a
      },
      // ====================== Horizontal ======================
      [`&${n}-horizontal`]: m(m({}, t === "dark" ? {
        borderBottom: 0
      } : {}), {
        [`> ${n}-item, > ${n}-submenu`]: {
          top: d,
          marginTop: -d,
          marginBottom: 0,
          borderRadius: 0,
          "&::after": {
            position: "absolute",
            insetInline: g,
            bottom: 0,
            borderBottom: `${c}px solid transparent`,
            transition: `border-color ${p} ${v}`,
            content: '""'
          },
          "&:hover, &-active, &-open": {
            "&::after": {
              borderBottomWidth: c,
              borderBottomColor: R
            }
          },
          "&-selected": {
            color: R,
            backgroundColor: A,
            "&::after": {
              borderBottomWidth: c,
              borderBottomColor: R
            }
          }
        }
      }),
      // ================== Inline & Vertical ===================
      //
      [`&${n}-root`]: {
        [`&${n}-inline, &${n}-vertical`]: {
          borderInlineEnd: `${d}px ${S} ${C}`
        }
      },
      // ======================== Inline ========================
      [`&${n}-inline`]: {
        // Sub
        [`${n}-sub${n}-inline`]: {
          background: i
        },
        // Item
        [`${n}-item, ${n}-submenu-title`]: d && u ? {
          width: `calc(100% + ${d}px)`
        } : {},
        [`${n}-item`]: {
          position: "relative",
          "&::after": {
            position: "absolute",
            insetBlock: 0,
            insetInlineEnd: 0,
            borderInlineEnd: `${u}px solid ${r}`,
            transform: "scaleY(0.0001)",
            opacity: 0,
            transition: [`transform ${b} ${h}`, `opacity ${b} ${h}`].join(","),
            content: '""'
          },
          // Danger
          [`&${n}-item-danger`]: {
            "&::after": {
              borderInlineEndColor: x
            }
          }
        },
        [`${n}-selected, ${n}-item-selected`]: {
          "&::after": {
            transform: "scaleY(1)",
            opacity: 1,
            transition: [`transform ${b} ${v}`, `opacity ${b} ${v}`].join(",")
          }
        }
      }
    }
  };
}, lC = (e) => {
  const {
    componentCls: t,
    menuItemHeight: n,
    itemMarginInline: o,
    padding: r,
    menuArrowSize: l,
    marginXS: a,
    marginXXS: i
  } = e, s = r + l + a;
  return {
    [`${t}-item`]: {
      position: "relative"
    },
    [`${t}-item, ${t}-submenu-title`]: {
      height: n,
      lineHeight: `${n}px`,
      paddingInline: r,
      overflow: "hidden",
      textOverflow: "ellipsis",
      marginInline: o,
      marginBlock: i,
      width: `calc(100% - ${o * 2}px)`
    },
    // disable margin collapsed
    [`${t}-submenu`]: {
      paddingBottom: 0.02
    },
    [`> ${t}-item,
            > ${t}-submenu > ${t}-submenu-title`]: {
      height: n,
      lineHeight: `${n}px`
    },
    [`${t}-item-group-list ${t}-submenu-title,
            ${t}-submenu-title`]: {
      paddingInlineEnd: s
    }
  };
}, nH = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    menuItemHeight: o,
    colorTextLightSolid: r,
    dropdownWidth: l,
    controlHeightLG: a,
    motionDurationMid: i,
    motionEaseOut: s,
    paddingXL: c,
    fontSizeSM: u,
    fontSizeLG: d,
    motionDurationSlow: p,
    paddingXS: v,
    boxShadowSecondary: h
  } = e, g = {
    height: o,
    lineHeight: `${o}px`,
    listStylePosition: "inside",
    listStyleType: "disc"
  };
  return [
    {
      [t]: {
        "&-inline, &-vertical": m({
          [`&${t}-root`]: {
            boxShadow: "none"
          }
        }, lC(e))
      },
      [`${t}-submenu-popup`]: {
        [`${t}-vertical`]: m(m({}, lC(e)), {
          boxShadow: h
        })
      }
    },
    // Vertical only
    {
      [`${t}-submenu-popup ${t}-vertical${t}-sub`]: {
        minWidth: l,
        maxHeight: `calc(100vh - ${a * 2.5}px)`,
        padding: "0",
        overflow: "hidden",
        borderInlineEnd: 0,
        // https://github.com/ant-design/ant-design/issues/22244
        // https://github.com/ant-design/ant-design/issues/26812
        "&:not([class*='-active'])": {
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    },
    // Inline Only
    {
      [`${t}-inline`]: {
        width: "100%",
        // Motion enhance for first level
        [`&${t}-root`]: {
          [`${t}-item, ${t}-submenu-title`]: {
            display: "flex",
            alignItems: "center",
            transition: [`border-color ${p}`, `background ${p}`, `padding ${i} ${s}`].join(","),
            [`> ${t}-title-content`]: {
              flex: "auto",
              minWidth: 0,
              overflow: "hidden",
              textOverflow: "ellipsis"
            },
            "> *": {
              flex: "none"
            }
          }
        },
        // >>>>> Sub
        [`${t}-sub${t}-inline`]: {
          padding: 0,
          border: 0,
          borderRadius: 0,
          boxShadow: "none",
          [`& > ${t}-submenu > ${t}-submenu-title`]: g,
          [`& ${t}-item-group-title`]: {
            paddingInlineStart: c
          }
        },
        // >>>>> Item
        [`${t}-item`]: g
      }
    },
    // Inline Collapse Only
    {
      [`${t}-inline-collapsed`]: {
        width: o * 2,
        [`&${t}-root`]: {
          [`${t}-item, ${t}-submenu ${t}-submenu-title`]: {
            [`> ${t}-inline-collapsed-noicon`]: {
              fontSize: d,
              textAlign: "center"
            }
          }
        },
        [`> ${t}-item,
          > ${t}-item-group > ${t}-item-group-list > ${t}-item,
          > ${t}-item-group > ${t}-item-group-list > ${t}-submenu > ${t}-submenu-title,
          > ${t}-submenu > ${t}-submenu-title`]: {
          insetInlineStart: 0,
          paddingInline: `calc(50% - ${u}px)`,
          textOverflow: "clip",
          [`
            ${t}-submenu-arrow,
            ${t}-submenu-expand-icon
          `]: {
            opacity: 0
          },
          [`${t}-item-icon, ${n}`]: {
            margin: 0,
            fontSize: d,
            lineHeight: `${o}px`,
            "+ span": {
              display: "inline-block",
              opacity: 0
            }
          }
        },
        [`${t}-item-icon, ${n}`]: {
          display: "inline-block"
        },
        "&-tooltip": {
          pointerEvents: "none",
          [`${t}-item-icon, ${n}`]: {
            display: "none"
          },
          "a, a:hover": {
            color: r
          }
        },
        [`${t}-item-group-title`]: m(m({}, tn), {
          paddingInline: v
        })
      }
    }
  ];
}, aC = (e) => {
  const {
    componentCls: t,
    fontSize: n,
    motionDurationSlow: o,
    motionDurationMid: r,
    motionEaseInOut: l,
    motionEaseOut: a,
    iconCls: i,
    controlHeightSM: s
  } = e;
  return {
    // >>>>> Item
    [`${t}-item, ${t}-submenu-title`]: {
      position: "relative",
      display: "block",
      margin: 0,
      whiteSpace: "nowrap",
      cursor: "pointer",
      transition: [`border-color ${o}`, `background ${o}`, `padding ${o} ${l}`].join(","),
      [`${t}-item-icon, ${i}`]: {
        minWidth: n,
        fontSize: n,
        transition: [`font-size ${r} ${a}`, `margin ${o} ${l}`, `color ${o}`].join(","),
        "+ span": {
          marginInlineStart: s - n,
          opacity: 1,
          transition: [`opacity ${o} ${l}`, `margin ${o}`, `color ${o}`].join(",")
        }
      },
      [`${t}-item-icon`]: m({}, ha()),
      [`&${t}-item-only-child`]: {
        [`> ${i}, > ${t}-item-icon`]: {
          marginInlineEnd: 0
        }
      }
    },
    // Disabled state sets text to gray and nukes hover/tab effects
    [`${t}-item-disabled, ${t}-submenu-disabled`]: {
      background: "none !important",
      cursor: "not-allowed",
      "&::after": {
        borderColor: "transparent !important"
      },
      a: {
        color: "inherit !important"
      },
      [`> ${t}-submenu-title`]: {
        color: "inherit !important",
        cursor: "not-allowed"
      }
    }
  };
}, iC = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n,
    motionEaseInOut: o,
    borderRadius: r,
    menuArrowSize: l,
    menuArrowOffset: a
  } = e;
  return {
    [`${t}-submenu`]: {
      "&-expand-icon, &-arrow": {
        position: "absolute",
        top: "50%",
        insetInlineEnd: e.margin,
        width: l,
        color: "currentcolor",
        transform: "translateY(-50%)",
        transition: `transform ${n} ${o}, opacity ${n}`
      },
      "&-arrow": {
        // →
        "&::before, &::after": {
          position: "absolute",
          width: l * 0.6,
          height: l * 0.15,
          backgroundColor: "currentcolor",
          borderRadius: r,
          transition: [`background ${n} ${o}`, `transform ${n} ${o}`, `top ${n} ${o}`, `color ${n} ${o}`].join(","),
          content: '""'
        },
        "&::before": {
          transform: `rotate(45deg) translateY(-${a})`
        },
        "&::after": {
          transform: `rotate(-45deg) translateY(${a})`
        }
      }
    }
  };
}, oH = (e) => {
  const {
    antCls: t,
    componentCls: n,
    fontSize: o,
    motionDurationSlow: r,
    motionDurationMid: l,
    motionEaseInOut: a,
    lineHeight: i,
    paddingXS: s,
    padding: c,
    colorSplit: u,
    lineWidth: d,
    zIndexPopup: p,
    borderRadiusLG: v,
    radiusSubMenuItem: h,
    menuArrowSize: g,
    menuArrowOffset: b,
    lineType: y,
    menuPanelMaskInset: S
  } = e;
  return [
    // Misc
    {
      "": {
        [`${n}`]: m(m({}, nr()), {
          // Hidden
          "&-hidden": {
            display: "none"
          }
        })
      },
      [`${n}-submenu-hidden`]: {
        display: "none"
      }
    },
    {
      [n]: m(m(m(m(m(m(m({}, qe(e)), nr()), {
        marginBottom: 0,
        paddingInlineStart: 0,
        // Override default ul/ol
        fontSize: o,
        lineHeight: 0,
        listStyle: "none",
        outline: "none",
        transition: `width ${r} cubic-bezier(0.2, 0, 0, 1) 0s`,
        "ul, ol": {
          margin: 0,
          padding: 0,
          listStyle: "none"
        },
        // Overflow ellipsis
        "&-overflow": {
          display: "flex",
          [`${n}-item`]: {
            flex: "none"
          }
        },
        [`${n}-item, ${n}-submenu, ${n}-submenu-title`]: {
          borderRadius: e.radiusItem
        },
        [`${n}-item-group-title`]: {
          padding: `${s}px ${c}px`,
          fontSize: o,
          lineHeight: i,
          transition: `all ${r}`
        },
        [`&-horizontal ${n}-submenu`]: {
          transition: [`border-color ${r} ${a}`, `background ${r} ${a}`].join(",")
        },
        [`${n}-submenu, ${n}-submenu-inline`]: {
          transition: [`border-color ${r} ${a}`, `background ${r} ${a}`, `padding ${l} ${a}`].join(",")
        },
        [`${n}-submenu ${n}-sub`]: {
          cursor: "initial",
          transition: [`background ${r} ${a}`, `padding ${r} ${a}`].join(",")
        },
        [`${n}-title-content`]: {
          transition: `color ${r}`
        },
        [`${n}-item a`]: {
          "&::before": {
            position: "absolute",
            inset: 0,
            backgroundColor: "transparent",
            content: '""'
          }
        },
        // Removed a Badge related style seems it's safe
        // https://github.com/ant-design/ant-design/issues/19809
        // >>>>> Divider
        [`${n}-item-divider`]: {
          overflow: "hidden",
          lineHeight: 0,
          borderColor: u,
          borderStyle: y,
          borderWidth: 0,
          borderTopWidth: d,
          marginBlock: d,
          padding: 0,
          "&-dashed": {
            borderStyle: "dashed"
          }
        }
      }), aC(e)), {
        [`${n}-item-group`]: {
          [`${n}-item-group-list`]: {
            margin: 0,
            padding: 0,
            [`${n}-item, ${n}-submenu-title`]: {
              paddingInline: `${o * 2}px ${c}px`
            }
          }
        },
        // ======================= Sub Menu =======================
        "&-submenu": {
          "&-popup": {
            position: "absolute",
            zIndex: p,
            background: "transparent",
            borderRadius: v,
            boxShadow: "none",
            transformOrigin: "0 0",
            // https://github.com/ant-design/ant-design/issues/13955
            "&::before": {
              position: "absolute",
              inset: `${S}px 0 0`,
              zIndex: -1,
              width: "100%",
              height: "100%",
              opacity: 0,
              content: '""'
            }
          },
          // https://github.com/ant-design/ant-design/issues/13955
          "&-placement-rightTop::before": {
            top: 0,
            insetInlineStart: S
          },
          [`> ${n}`]: m(m(m({
            borderRadius: v
          }, aC(e)), iC(e)), {
            [`${n}-item, ${n}-submenu > ${n}-submenu-title`]: {
              borderRadius: h
            },
            [`${n}-submenu-title::after`]: {
              transition: `transform ${r} ${a}`
            }
          })
        }
      }), iC(e)), {
        [`&-inline-collapsed ${n}-submenu-arrow,
        &-inline ${n}-submenu-arrow`]: {
          // ↓
          "&::before": {
            transform: `rotate(-45deg) translateX(${b})`
          },
          "&::after": {
            transform: `rotate(45deg) translateX(-${b})`
          }
        },
        [`${n}-submenu-open${n}-submenu-inline > ${n}-submenu-title > ${n}-submenu-arrow`]: {
          // ↑
          transform: `translateY(-${g * 0.2}px)`,
          "&::after": {
            transform: `rotate(-45deg) translateX(-${b})`
          },
          "&::before": {
            transform: `rotate(45deg) translateX(${b})`
          }
        }
      })
    },
    // Integration with header element so menu items have the same height
    {
      [`${t}-layout-header`]: {
        [n]: {
          lineHeight: "inherit"
        }
      }
    }
  ];
}, rH = (e, t) => Xe("Menu", (o, r) => {
  let {
    overrideComponentToken: l
  } = r;
  if ((t == null ? void 0 : t.value) === !1)
    return [];
  const {
    colorBgElevated: a,
    colorPrimary: i,
    colorError: s,
    colorErrorHover: c,
    colorTextLightSolid: u
  } = o, {
    controlHeightLG: d,
    fontSize: p
  } = o, v = p / 7 * 5, h = He(o, {
    menuItemHeight: d,
    menuItemPaddingInline: o.margin,
    menuArrowSize: v,
    menuHorizontalHeight: d * 1.15,
    menuArrowOffset: `${v * 0.25}px`,
    menuPanelMaskInset: -7,
    menuSubMenuBg: a
  }), g = new Ct(u).setAlpha(0.65).toRgbString(), b = He(h, {
    colorItemText: g,
    colorItemTextHover: u,
    colorGroupTitle: g,
    colorItemTextSelected: u,
    colorItemBg: "#001529",
    colorSubItemBg: "#000c17",
    colorItemBgActive: "transparent",
    colorItemBgSelected: i,
    colorActiveBarWidth: 0,
    colorActiveBarHeight: 0,
    colorActiveBarBorderSize: 0,
    // Disabled
    colorItemTextDisabled: new Ct(u).setAlpha(0.25).toRgbString(),
    // Danger
    colorDangerItemText: s,
    colorDangerItemTextHover: c,
    colorDangerItemTextSelected: u,
    colorDangerItemBgActive: s,
    colorDangerItemBgSelected: s,
    menuSubMenuBg: "#001529",
    // Horizontal
    colorItemTextSelectedHorizontal: u,
    colorItemBgSelectedHorizontal: i
  }, m({}, l));
  return [
    // Basic
    oH(h),
    // Horizontal
    eH(h),
    // Vertical
    nH(h),
    // Theme
    rC(h, "light"),
    rC(b, "dark"),
    // RTL
    tH(h),
    // Motion
    cc(h),
    $r(h, "slide-up"),
    $r(h, "slide-down"),
    Ni(h, "zoom-big")
  ];
}, (o) => {
  const {
    colorPrimary: r,
    colorError: l,
    colorTextDisabled: a,
    colorErrorBg: i,
    colorText: s,
    colorTextDescription: c,
    colorBgContainer: u,
    colorFillAlter: d,
    colorFillContent: p,
    lineWidth: v,
    lineWidthBold: h,
    controlItemBgActive: g,
    colorBgTextHover: b
  } = o;
  return {
    dropdownWidth: 160,
    zIndexPopup: o.zIndexPopupBase + 50,
    radiusItem: o.borderRadiusLG,
    radiusSubMenuItem: o.borderRadiusSM,
    colorItemText: s,
    colorItemTextHover: s,
    colorItemTextHoverHorizontal: r,
    colorGroupTitle: c,
    colorItemTextSelected: r,
    colorItemTextSelectedHorizontal: r,
    colorItemBg: u,
    colorItemBgHover: b,
    colorItemBgActive: p,
    colorSubItemBg: d,
    colorItemBgSelected: g,
    colorItemBgSelectedHorizontal: "transparent",
    colorActiveBarWidth: 0,
    colorActiveBarHeight: h,
    colorActiveBarBorderSize: v,
    // Disabled
    colorItemTextDisabled: a,
    // Danger
    colorDangerItemText: l,
    colorDangerItemTextHover: l,
    colorDangerItemTextSelected: l,
    colorDangerItemBgActive: i,
    colorDangerItemBgSelected: i,
    itemMarginInline: o.marginXXS
  };
})(e), lH = () => ({
  id: String,
  prefixCls: String,
  // donot use items, now only support inner use
  items: Array,
  disabled: Boolean,
  inlineCollapsed: Boolean,
  disabledOverflow: Boolean,
  forceSubMenuRender: Boolean,
  openKeys: Array,
  selectedKeys: Array,
  activeKey: String,
  selectable: {
    type: Boolean,
    default: !0
  },
  multiple: {
    type: Boolean,
    default: !1
  },
  tabindex: {
    type: [Number, String]
  },
  motion: Object,
  role: String,
  theme: {
    type: String,
    default: "light"
  },
  mode: {
    type: String,
    default: "vertical"
  },
  inlineIndent: {
    type: Number,
    default: 24
  },
  subMenuOpenDelay: {
    type: Number,
    default: 0
  },
  subMenuCloseDelay: {
    type: Number,
    default: 0.1
  },
  builtinPlacements: {
    type: Object
  },
  triggerSubMenuAction: {
    type: String,
    default: "hover"
  },
  getPopupContainer: Function,
  expandIcon: Function,
  onOpenChange: Function,
  onSelect: Function,
  onDeselect: Function,
  onClick: [Function, Array],
  onFocus: Function,
  onBlur: Function,
  onMousedown: Function,
  "onUpdate:openKeys": Function,
  "onUpdate:selectedKeys": Function,
  "onUpdate:activeKey": Function
}), sC = [], en = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AMenu",
  inheritAttrs: !1,
  props: lH(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const {
      direction: l,
      getPrefixCls: a
    } = Ie("menu", e), i = BO(), s = P(() => {
      var J;
      return a("menu", e.prefixCls || ((J = i == null ? void 0 : i.prefixCls) === null || J === void 0 ? void 0 : J.value));
    }), [c, u] = rH(s, P(() => !i)), d = Q(/* @__PURE__ */ new Map()), p = tt(WO, Y(void 0)), v = P(() => p.value !== void 0 ? p.value : e.inlineCollapsed), {
      itemsNodes: h
    } = Jz(e), g = Q(!1);
    Ke(() => {
      g.value = !0;
    }), Le(() => {
      nt(!(e.inlineCollapsed === !0 && e.mode !== "inline"), "Menu", "`inlineCollapsed` should only be used when `mode` is inline."), nt(!(p.value !== void 0 && e.inlineCollapsed === !0), "Menu", "`inlineCollapsed` not control Menu under Sider. Should set `collapsed` on Sider instead.");
    });
    const b = Y([]), y = Y([]), S = Y({});
    ie(d, () => {
      const J = {};
      for (const ne of d.value.values())
        J[ne.key] = ne;
      S.value = J;
    }, {
      flush: "post"
    }), Le(() => {
      if (e.activeKey !== void 0) {
        let J = [];
        const ne = e.activeKey ? S.value[e.activeKey] : void 0;
        ne && e.activeKey !== void 0 ? J = av([].concat(hn(ne.parentKeys), e.activeKey)) : J = [], Ha(b.value, J) || (b.value = J);
      }
    }), ie(() => e.selectedKeys, (J) => {
      J && (y.value = J.slice());
    }, {
      immediate: !0,
      deep: !0
    });
    const C = Y([]);
    ie([S, y], () => {
      let J = [];
      y.value.forEach((ne) => {
        const te = S.value[ne];
        te && (J = J.concat(hn(te.parentKeys)));
      }), J = av(J), Ha(C.value, J) || (C.value = J);
    }, {
      immediate: !0
    });
    const w = (J) => {
      if (e.selectable) {
        const {
          key: ne
        } = J, te = y.value.includes(ne);
        let G;
        e.multiple ? te ? G = y.value.filter((re) => re !== ne) : G = [...y.value, ne] : G = [ne];
        const U = m(m({}, J), {
          selectedKeys: G
        });
        Ha(G, y.value) || (e.selectedKeys === void 0 && (y.value = G), o("update:selectedKeys", G), te && e.multiple ? o("deselect", U) : o("select", U));
      }
      _.value !== "inline" && !e.multiple && $.value.length && A(sC);
    }, $ = Y([]);
    ie(() => e.openKeys, function() {
      let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : $.value;
      Ha($.value, J) || ($.value = J.slice());
    }, {
      immediate: !0,
      deep: !0
    });
    let O;
    const x = (J) => {
      clearTimeout(O), O = setTimeout(() => {
        e.activeKey === void 0 && (b.value = J), o("update:activeKey", J[J.length - 1]);
      });
    }, I = P(() => !!e.disabled), E = P(() => l.value === "rtl"), _ = Y("vertical"), M = Q(!1);
    Le(() => {
      var J;
      (e.mode === "inline" || e.mode === "vertical") && v.value ? (_.value = "vertical", M.value = v.value) : (_.value = e.mode, M.value = !1), !((J = i == null ? void 0 : i.mode) === null || J === void 0) && J.value && (_.value = i.mode.value);
    });
    const R = P(() => _.value === "inline"), A = (J) => {
      $.value = J, o("update:openKeys", J), o("openChange", J);
    }, z = Y($.value), T = Q(!1);
    ie($, () => {
      R.value && (z.value = $.value);
    }, {
      immediate: !0
    }), ie(R, () => {
      if (!T.value) {
        T.value = !0;
        return;
      }
      R.value ? $.value = z.value : A(sC);
    }, {
      immediate: !0
    });
    const N = P(() => ({
      [`${s.value}`]: !0,
      [`${s.value}-root`]: !0,
      [`${s.value}-${_.value}`]: !0,
      [`${s.value}-inline-collapsed`]: M.value,
      [`${s.value}-rtl`]: E.value,
      [`${s.value}-${e.theme}`]: !0
    })), k = P(() => a()), B = P(() => ({
      horizontal: {
        name: `${k.value}-slide-up`
      },
      inline: dc(`${k.value}-motion-collapse`),
      other: {
        name: `${k.value}-zoom-big`
      }
    }));
    VO(!0);
    const F = function() {
      let J = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      const ne = [], te = d.value;
      return J.forEach((G) => {
        const {
          key: U,
          childrenEventKeys: re
        } = te.get(G);
        ne.push(U, ...F(hn(re)));
      }), ne;
    }, L = (J) => {
      var ne;
      o("click", J), w(J), (ne = i == null ? void 0 : i.onClick) === null || ne === void 0 || ne.call(i);
    }, j = (J, ne) => {
      var te;
      const G = ((te = S.value[J]) === null || te === void 0 ? void 0 : te.childrenEventKeys) || [];
      let U = $.value.filter((re) => re !== J);
      if (ne)
        U.push(J);
      else if (_.value !== "inline") {
        const re = F(hn(G));
        U = av(U.filter((se) => !re.includes(se)));
      }
      Ha($, U) || A(U);
    }, H = (J, ne) => {
      d.value.set(J, ne), d.value = new Map(d.value);
    }, K = (J) => {
      d.value.delete(J), d.value = new Map(d.value);
    }, X = Y(0), W = P(() => {
      var J;
      return e.expandIcon || n.expandIcon || !((J = i == null ? void 0 : i.expandIcon) === null || J === void 0) && J.value ? (ne) => {
        let te = e.expandIcon || n.expandIcon;
        return te = typeof te == "function" ? te(ne) : te, yt(te, {
          class: `${s.value}-submenu-expand-icon`
        }, !1);
      } : null;
    });
    zz({
      prefixCls: s,
      activeKeys: b,
      openKeys: $,
      selectedKeys: y,
      changeActiveKeys: x,
      disabled: I,
      rtl: E,
      mode: _,
      inlineIndent: P(() => e.inlineIndent),
      subMenuCloseDelay: P(() => e.subMenuCloseDelay),
      subMenuOpenDelay: P(() => e.subMenuOpenDelay),
      builtinPlacements: P(() => e.builtinPlacements),
      triggerSubMenuAction: P(() => e.triggerSubMenuAction),
      getPopupContainer: P(() => e.getPopupContainer),
      inlineCollapsed: M,
      theme: P(() => e.theme),
      siderCollapsed: p,
      defaultMotions: P(() => g.value ? B.value : null),
      motion: P(() => g.value ? e.motion : null),
      overflowDisabled: Q(void 0),
      onOpenChange: j,
      onItemClick: L,
      registerMenuInfo: H,
      unRegisterMenuInfo: K,
      selectedSubMenuKeys: C,
      expandIcon: W,
      forceSubMenuRender: P(() => e.forceSubMenuRender),
      rootClassName: u
    });
    const q = () => {
      var J;
      return h.value || It((J = n.default) === null || J === void 0 ? void 0 : J.call(n));
    };
    return () => {
      var J;
      const ne = q(), te = X.value >= ne.length - 1 || _.value !== "horizontal" || e.disabledOverflow, G = (re) => _.value !== "horizontal" || e.disabledOverflow ? re : (
        // Need wrap for overflow dropdown that do not response for open
        re.map((se, me) => (
          // Always wrap provider to avoid sub node re-mount
          f(Ad, {
            key: se.key,
            overflowDisabled: me > X.value
          }, {
            default: () => se
          })
        ))
      ), U = ((J = n.overflowedIndicator) === null || J === void 0 ? void 0 : J.call(n)) || f(uc, null, null);
      return c(f(Vr, D(D({}, r), {}, {
        onMousedown: e.onMousedown,
        prefixCls: `${s.value}-overflow`,
        component: "ul",
        itemComponent: hr,
        class: [N.value, r.class, u.value],
        role: "menu",
        id: e.id,
        data: G(ne),
        renderRawItem: (re) => re,
        renderRawRest: (re) => {
          const se = re.length, me = se ? ne.slice(-se) : null;
          return f(Fe, null, [f(fa, {
            eventKey: Gc,
            key: Gc,
            title: U,
            disabled: te,
            internalPopupClose: se === 0
          }, {
            default: () => me
          }), f(eC, null, {
            default: () => [f(fa, {
              eventKey: Gc,
              key: Gc,
              title: U,
              disabled: te,
              internalPopupClose: se === 0
            }, {
              default: () => me
            })]
          })]);
        },
        maxCount: _.value !== "horizontal" || e.disabledOverflow ? Vr.INVALIDATE : Vr.RESPONSIVE,
        ssr: "full",
        "data-menu-list": !0,
        onVisibleChange: (re) => {
          X.value = re;
        }
      }), {
        default: () => [f(Jm, {
          to: "body"
        }, {
          default: () => [f("div", {
            style: {
              display: "none"
            },
            "aria-hidden": !0
          }, [f(eC, null, {
            default: () => [G(q())]
          })])]
        })]
      }));
    };
  }
});
en.install = function(e) {
  return e.component(en.name, en), e.component(hr.name, hr), e.component(fa.name, fa), e.component(Ys.name, Ys), e.component(Us.name, Us), e;
};
en.Item = hr;
en.Divider = Ys;
en.SubMenu = fa;
en.ItemGroup = Us;
const aH = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      color: e.breadcrumbBaseColor,
      fontSize: e.breadcrumbFontSize,
      [n]: {
        fontSize: e.breadcrumbIconFontSize
      },
      ol: {
        display: "flex",
        flexWrap: "wrap",
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      a: m({
        color: e.breadcrumbLinkColor,
        transition: `color ${e.motionDurationMid}`,
        padding: `0 ${e.paddingXXS}px`,
        borderRadius: e.borderRadiusSM,
        height: e.lineHeight * e.fontSize,
        display: "inline-block",
        marginInline: -e.marginXXS,
        "&:hover": {
          color: e.breadcrumbLinkColorHover,
          backgroundColor: e.colorBgTextHover
        }
      }, Xr(e)),
      "li:last-child": {
        color: e.breadcrumbLastItemColor,
        [`& > ${t}-separator`]: {
          display: "none"
        }
      },
      [`${t}-separator`]: {
        marginInline: e.breadcrumbSeparatorMargin,
        color: e.breadcrumbSeparatorColor
      },
      [`${t}-link`]: {
        [`
          > ${n} + span,
          > ${n} + a
        `]: {
          marginInlineStart: e.marginXXS
        }
      },
      [`${t}-overlay-link`]: {
        borderRadius: e.borderRadiusSM,
        height: e.lineHeight * e.fontSize,
        display: "inline-block",
        padding: `0 ${e.paddingXXS}px`,
        marginInline: -e.marginXXS,
        [`> ${n}`]: {
          marginInlineStart: e.marginXXS,
          fontSize: e.fontSizeIcon
        },
        "&:hover": {
          color: e.breadcrumbLinkColorHover,
          backgroundColor: e.colorBgTextHover,
          a: {
            color: e.breadcrumbLinkColorHover
          }
        },
        a: {
          "&:hover": {
            backgroundColor: "transparent"
          }
        }
      },
      // rtl style
      [`&${e.componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
}, iH = Xe("Breadcrumb", (e) => {
  const t = He(e, {
    breadcrumbBaseColor: e.colorTextDescription,
    breadcrumbFontSize: e.fontSize,
    breadcrumbIconFontSize: e.fontSize,
    breadcrumbLinkColor: e.colorTextDescription,
    breadcrumbLinkColorHover: e.colorText,
    breadcrumbLastItemColor: e.colorText,
    breadcrumbSeparatorMargin: e.marginXS,
    breadcrumbSeparatorColor: e.colorTextDescription
  });
  return [aH(t)];
}), sH = () => ({
  prefixCls: String,
  routes: {
    type: Array
  },
  params: V.any,
  separator: V.any,
  itemRender: {
    type: Function
  }
});
function cH(e, t) {
  if (!e.breadcrumbName)
    return null;
  const n = Object.keys(t).join("|");
  return e.breadcrumbName.replace(new RegExp(`:(${n})`, "g"), (r, l) => t[l] || r);
}
function cC(e) {
  const {
    route: t,
    params: n,
    routes: o,
    paths: r
  } = e, l = o.indexOf(t) === o.length - 1, a = cH(t, n);
  return l ? f("span", null, [a]) : f("a", {
    href: `#/${r.join("/")}`
  }, [a]);
}
const ta = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumb",
  inheritAttrs: !1,
  props: sH(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("breadcrumb", e), [a, i] = iH(r), s = (d, p) => (d = (d || "").replace(/^\//, ""), Object.keys(p).forEach((v) => {
      d = d.replace(`:${v}`, p[v]);
    }), d), c = (d, p, v) => {
      const h = [...d], g = s(p || "", v);
      return g && h.push(g), h;
    }, u = (d) => {
      let {
        routes: p = [],
        params: v = {},
        separator: h,
        itemRender: g = cC
      } = d;
      const b = [];
      return p.map((y) => {
        const S = s(y.path, v);
        S && b.push(S);
        const C = [...b];
        let w = null;
        y.children && y.children.length && (w = f(en, {
          items: y.children.map((O) => ({
            key: O.path || O.breadcrumbName,
            label: g({
              route: O,
              params: v,
              routes: p,
              paths: c(C, O.path, v)
            })
          }))
        }, null));
        const $ = {
          separator: h
        };
        return w && ($.overlay = w), f(Xs, D(D({}, $), {}, {
          key: S || y.breadcrumbName
        }), {
          default: () => [g({
            route: y,
            params: v,
            routes: p,
            paths: C
          })]
        });
      });
    };
    return () => {
      var d;
      let p;
      const {
        routes: v,
        params: h = {}
      } = e, g = It(an(n, e)), b = (d = an(n, e, "separator")) !== null && d !== void 0 ? d : "/", y = e.itemRender || n.itemRender || cC;
      v && v.length > 0 ? p = u({
        routes: v,
        params: h,
        separator: b,
        itemRender: y
      }) : g.length && (p = g.map((C, w) => (Mt(typeof C.type == "object" && (C.type.__ANT_BREADCRUMB_ITEM || C.type.__ANT_BREADCRUMB_SEPARATOR), "Breadcrumb", "Only accepts Breadcrumb.Item and Breadcrumb.Separator as it's children"), tr(C, {
        separator: b,
        key: w
      }))));
      const S = {
        [r.value]: !0,
        [`${r.value}-rtl`]: l.value === "rtl",
        [`${o.class}`]: !!o.class,
        [i.value]: !0
      };
      return a(f("nav", D(D({}, o), {}, {
        class: S
      }), [f("ol", null, [p])]));
    };
  }
});
var uH = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const dH = () => ({
  prefixCls: String
}), Rd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ABreadcrumbSeparator",
  __ANT_BREADCRUMB_SEPARATOR: !0,
  inheritAttrs: !1,
  props: dH(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r
    } = Ie("breadcrumb", e);
    return () => {
      var l;
      const {
        separator: a,
        class: i
      } = o, s = uH(o, ["separator", "class"]), c = It((l = n.default) === null || l === void 0 ? void 0 : l.call(n));
      return f("span", D({
        class: [`${r.value}-separator`, i]
      }, s), [c.length > 0 ? c : "/"]);
    };
  }
});
ta.Item = Xs;
ta.Separator = Rd;
ta.install = function(e) {
  return e.component(ta.name, ta), e.component(Xs.name, Xs), e.component(Rd.name, Rd), e;
};
var Il = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function El(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var qO = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Il, function() {
    var n = 1e3, o = 6e4, r = 36e5, l = "millisecond", a = "second", i = "minute", s = "hour", c = "day", u = "week", d = "month", p = "quarter", v = "year", h = "date", g = "Invalid Date", b = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, S = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(z) {
      var T = ["th", "st", "nd", "rd"], N = z % 100;
      return "[" + z + (T[(N - 20) % 10] || T[N] || T[0]) + "]";
    } }, C = function(z, T, N) {
      var k = String(z);
      return !k || k.length >= T ? z : "" + Array(T + 1 - k.length).join(N) + z;
    }, w = { s: C, z: function(z) {
      var T = -z.utcOffset(), N = Math.abs(T), k = Math.floor(N / 60), B = N % 60;
      return (T <= 0 ? "+" : "-") + C(k, 2, "0") + ":" + C(B, 2, "0");
    }, m: function z(T, N) {
      if (T.date() < N.date())
        return -z(N, T);
      var k = 12 * (N.year() - T.year()) + (N.month() - T.month()), B = T.clone().add(k, d), F = N - B < 0, L = T.clone().add(k + (F ? -1 : 1), d);
      return +(-(k + (N - B) / (F ? B - L : L - B)) || 0);
    }, a: function(z) {
      return z < 0 ? Math.ceil(z) || 0 : Math.floor(z);
    }, p: function(z) {
      return { M: d, y: v, w: u, d: c, D: h, h: s, m: i, s: a, ms: l, Q: p }[z] || String(z || "").toLowerCase().replace(/s$/, "");
    }, u: function(z) {
      return z === void 0;
    } }, $ = "en", O = {};
    O[$] = S;
    var x = "$isDayjsObject", I = function(z) {
      return z instanceof R || !(!z || !z[x]);
    }, E = function z(T, N, k) {
      var B;
      if (!T)
        return $;
      if (typeof T == "string") {
        var F = T.toLowerCase();
        O[F] && (B = F), N && (O[F] = N, B = F);
        var L = T.split("-");
        if (!B && L.length > 1)
          return z(L[0]);
      } else {
        var j = T.name;
        O[j] = T, B = j;
      }
      return !k && B && ($ = B), B || !k && $;
    }, _ = function(z, T) {
      if (I(z))
        return z.clone();
      var N = typeof T == "object" ? T : {};
      return N.date = z, N.args = arguments, new R(N);
    }, M = w;
    M.l = E, M.i = I, M.w = function(z, T) {
      return _(z, { locale: T.$L, utc: T.$u, x: T.$x, $offset: T.$offset });
    };
    var R = function() {
      function z(N) {
        this.$L = E(N.locale, null, !0), this.parse(N), this.$x = this.$x || N.x || {}, this[x] = !0;
      }
      var T = z.prototype;
      return T.parse = function(N) {
        this.$d = function(k) {
          var B = k.date, F = k.utc;
          if (B === null)
            return /* @__PURE__ */ new Date(NaN);
          if (M.u(B))
            return /* @__PURE__ */ new Date();
          if (B instanceof Date)
            return new Date(B);
          if (typeof B == "string" && !/Z$/i.test(B)) {
            var L = B.match(b);
            if (L) {
              var j = L[2] - 1 || 0, H = (L[7] || "0").substring(0, 3);
              return F ? new Date(Date.UTC(L[1], j, L[3] || 1, L[4] || 0, L[5] || 0, L[6] || 0, H)) : new Date(L[1], j, L[3] || 1, L[4] || 0, L[5] || 0, L[6] || 0, H);
            }
          }
          return new Date(B);
        }(N), this.init();
      }, T.init = function() {
        var N = this.$d;
        this.$y = N.getFullYear(), this.$M = N.getMonth(), this.$D = N.getDate(), this.$W = N.getDay(), this.$H = N.getHours(), this.$m = N.getMinutes(), this.$s = N.getSeconds(), this.$ms = N.getMilliseconds();
      }, T.$utils = function() {
        return M;
      }, T.isValid = function() {
        return this.$d.toString() !== g;
      }, T.isSame = function(N, k) {
        var B = _(N);
        return this.startOf(k) <= B && B <= this.endOf(k);
      }, T.isAfter = function(N, k) {
        return _(N) < this.startOf(k);
      }, T.isBefore = function(N, k) {
        return this.endOf(k) < _(N);
      }, T.$g = function(N, k, B) {
        return M.u(N) ? this[k] : this.set(B, N);
      }, T.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, T.valueOf = function() {
        return this.$d.getTime();
      }, T.startOf = function(N, k) {
        var B = this, F = !!M.u(k) || k, L = M.p(N), j = function(te, G) {
          var U = M.w(B.$u ? Date.UTC(B.$y, G, te) : new Date(B.$y, G, te), B);
          return F ? U : U.endOf(c);
        }, H = function(te, G) {
          return M.w(B.toDate()[te].apply(B.toDate("s"), (F ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(G)), B);
        }, K = this.$W, X = this.$M, W = this.$D, q = "set" + (this.$u ? "UTC" : "");
        switch (L) {
          case v:
            return F ? j(1, 0) : j(31, 11);
          case d:
            return F ? j(1, X) : j(0, X + 1);
          case u:
            var J = this.$locale().weekStart || 0, ne = (K < J ? K + 7 : K) - J;
            return j(F ? W - ne : W + (6 - ne), X);
          case c:
          case h:
            return H(q + "Hours", 0);
          case s:
            return H(q + "Minutes", 1);
          case i:
            return H(q + "Seconds", 2);
          case a:
            return H(q + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, T.endOf = function(N) {
        return this.startOf(N, !1);
      }, T.$set = function(N, k) {
        var B, F = M.p(N), L = "set" + (this.$u ? "UTC" : ""), j = (B = {}, B[c] = L + "Date", B[h] = L + "Date", B[d] = L + "Month", B[v] = L + "FullYear", B[s] = L + "Hours", B[i] = L + "Minutes", B[a] = L + "Seconds", B[l] = L + "Milliseconds", B)[F], H = F === c ? this.$D + (k - this.$W) : k;
        if (F === d || F === v) {
          var K = this.clone().set(h, 1);
          K.$d[j](H), K.init(), this.$d = K.set(h, Math.min(this.$D, K.daysInMonth())).$d;
        } else
          j && this.$d[j](H);
        return this.init(), this;
      }, T.set = function(N, k) {
        return this.clone().$set(N, k);
      }, T.get = function(N) {
        return this[M.p(N)]();
      }, T.add = function(N, k) {
        var B, F = this;
        N = Number(N);
        var L = M.p(k), j = function(X) {
          var W = _(F);
          return M.w(W.date(W.date() + Math.round(X * N)), F);
        };
        if (L === d)
          return this.set(d, this.$M + N);
        if (L === v)
          return this.set(v, this.$y + N);
        if (L === c)
          return j(1);
        if (L === u)
          return j(7);
        var H = (B = {}, B[i] = o, B[s] = r, B[a] = n, B)[L] || 1, K = this.$d.getTime() + N * H;
        return M.w(K, this);
      }, T.subtract = function(N, k) {
        return this.add(-1 * N, k);
      }, T.format = function(N) {
        var k = this, B = this.$locale();
        if (!this.isValid())
          return B.invalidDate || g;
        var F = N || "YYYY-MM-DDTHH:mm:ssZ", L = M.z(this), j = this.$H, H = this.$m, K = this.$M, X = B.weekdays, W = B.months, q = B.meridiem, J = function(G, U, re, se) {
          return G && (G[U] || G(k, F)) || re[U].slice(0, se);
        }, ne = function(G) {
          return M.s(j % 12 || 12, G, "0");
        }, te = q || function(G, U, re) {
          var se = G < 12 ? "AM" : "PM";
          return re ? se.toLowerCase() : se;
        };
        return F.replace(y, function(G, U) {
          return U || function(re) {
            switch (re) {
              case "YY":
                return String(k.$y).slice(-2);
              case "YYYY":
                return M.s(k.$y, 4, "0");
              case "M":
                return K + 1;
              case "MM":
                return M.s(K + 1, 2, "0");
              case "MMM":
                return J(B.monthsShort, K, W, 3);
              case "MMMM":
                return J(W, K);
              case "D":
                return k.$D;
              case "DD":
                return M.s(k.$D, 2, "0");
              case "d":
                return String(k.$W);
              case "dd":
                return J(B.weekdaysMin, k.$W, X, 2);
              case "ddd":
                return J(B.weekdaysShort, k.$W, X, 3);
              case "dddd":
                return X[k.$W];
              case "H":
                return String(j);
              case "HH":
                return M.s(j, 2, "0");
              case "h":
                return ne(1);
              case "hh":
                return ne(2);
              case "a":
                return te(j, H, !0);
              case "A":
                return te(j, H, !1);
              case "m":
                return String(H);
              case "mm":
                return M.s(H, 2, "0");
              case "s":
                return String(k.$s);
              case "ss":
                return M.s(k.$s, 2, "0");
              case "SSS":
                return M.s(k.$ms, 3, "0");
              case "Z":
                return L;
            }
            return null;
          }(G) || L.replace(":", "");
        });
      }, T.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, T.diff = function(N, k, B) {
        var F, L = this, j = M.p(k), H = _(N), K = (H.utcOffset() - this.utcOffset()) * o, X = this - H, W = function() {
          return M.m(L, H);
        };
        switch (j) {
          case v:
            F = W() / 12;
            break;
          case d:
            F = W();
            break;
          case p:
            F = W() / 3;
            break;
          case u:
            F = (X - K) / 6048e5;
            break;
          case c:
            F = (X - K) / 864e5;
            break;
          case s:
            F = X / r;
            break;
          case i:
            F = X / o;
            break;
          case a:
            F = X / n;
            break;
          default:
            F = X;
        }
        return B ? F : M.a(F);
      }, T.daysInMonth = function() {
        return this.endOf(d).$D;
      }, T.$locale = function() {
        return O[this.$L];
      }, T.locale = function(N, k) {
        if (!N)
          return this.$L;
        var B = this.clone(), F = E(N, k, !0);
        return F && (B.$L = F), B;
      }, T.clone = function() {
        return M.w(this.$d, this);
      }, T.toDate = function() {
        return new Date(this.valueOf());
      }, T.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, T.toISOString = function() {
        return this.$d.toISOString();
      }, T.toString = function() {
        return this.$d.toUTCString();
      }, z;
    }(), A = R.prototype;
    return _.prototype = A, [["$ms", l], ["$s", a], ["$m", i], ["$H", s], ["$W", c], ["$M", d], ["$y", v], ["$D", h]].forEach(function(z) {
      A[z[1]] = function(T) {
        return this.$g(T, z[0], z[1]);
      };
    }), _.extend = function(z, T) {
      return z.$i || (z(T, R, _), z.$i = !0), _;
    }, _.locale = E, _.isDayjs = I, _.unix = function(z) {
      return _(1e3 * z);
    }, _.en = O[$], _.Ls = O, _.p = {}, _;
  });
})(qO);
var fH = qO.exports;
const mn = /* @__PURE__ */ El(fH);
var ZO = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Il, function() {
    return function(n, o) {
      o.prototype.weekday = function(r) {
        var l = this.$locale().weekStart || 0, a = this.$W, i = (a < l ? a + 7 : a) - l;
        return this.$utils().u(r) ? i : this.subtract(i, "day").add(r, "day");
      };
    };
  });
})(ZO);
var pH = ZO.exports;
const vH = /* @__PURE__ */ El(pH);
var QO = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Il, function() {
    return function(n, o, r) {
      var l = o.prototype, a = function(d) {
        return d && (d.indexOf ? d : d.s);
      }, i = function(d, p, v, h, g) {
        var b = d.name ? d : d.$locale(), y = a(b[p]), S = a(b[v]), C = y || S.map(function($) {
          return $.slice(0, h);
        });
        if (!g)
          return C;
        var w = b.weekStart;
        return C.map(function($, O) {
          return C[(O + (w || 0)) % 7];
        });
      }, s = function() {
        return r.Ls[r.locale()];
      }, c = function(d, p) {
        return d.formats[p] || function(v) {
          return v.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(h, g, b) {
            return g || b.slice(1);
          });
        }(d.formats[p.toUpperCase()]);
      }, u = function() {
        var d = this;
        return { months: function(p) {
          return p ? p.format("MMMM") : i(d, "months");
        }, monthsShort: function(p) {
          return p ? p.format("MMM") : i(d, "monthsShort", "months", 3);
        }, firstDayOfWeek: function() {
          return d.$locale().weekStart || 0;
        }, weekdays: function(p) {
          return p ? p.format("dddd") : i(d, "weekdays");
        }, weekdaysMin: function(p) {
          return p ? p.format("dd") : i(d, "weekdaysMin", "weekdays", 2);
        }, weekdaysShort: function(p) {
          return p ? p.format("ddd") : i(d, "weekdaysShort", "weekdays", 3);
        }, longDateFormat: function(p) {
          return c(d.$locale(), p);
        }, meridiem: this.$locale().meridiem, ordinal: this.$locale().ordinal };
      };
      l.localeData = function() {
        return u.bind(this)();
      }, r.localeData = function() {
        var d = s();
        return { firstDayOfWeek: function() {
          return d.weekStart || 0;
        }, weekdays: function() {
          return r.weekdays();
        }, weekdaysShort: function() {
          return r.weekdaysShort();
        }, weekdaysMin: function() {
          return r.weekdaysMin();
        }, months: function() {
          return r.months();
        }, monthsShort: function() {
          return r.monthsShort();
        }, longDateFormat: function(p) {
          return c(d, p);
        }, meridiem: d.meridiem, ordinal: d.ordinal };
      }, r.months = function() {
        return i(s(), "months");
      }, r.monthsShort = function() {
        return i(s(), "monthsShort", "months", 3);
      }, r.weekdays = function(d) {
        return i(s(), "weekdays", null, null, d);
      }, r.weekdaysShort = function(d) {
        return i(s(), "weekdaysShort", "weekdays", 3, d);
      }, r.weekdaysMin = function(d) {
        return i(s(), "weekdaysMin", "weekdays", 2, d);
      };
    };
  });
})(QO);
var gH = QO.exports;
const mH = /* @__PURE__ */ El(gH);
var JO = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Il, function() {
    var n = "week", o = "year";
    return function(r, l, a) {
      var i = l.prototype;
      i.week = function(s) {
        if (s === void 0 && (s = null), s !== null)
          return this.add(7 * (s - this.week()), "day");
        var c = this.$locale().yearStart || 1;
        if (this.month() === 11 && this.date() > 25) {
          var u = a(this).startOf(o).add(1, o).date(c), d = a(this).endOf(n);
          if (u.isBefore(d))
            return 1;
        }
        var p = a(this).startOf(o).date(c).startOf(n).subtract(1, "millisecond"), v = this.diff(p, n, !0);
        return v < 0 ? a(this).startOf("week").week() : Math.ceil(v);
      }, i.weeks = function(s) {
        return s === void 0 && (s = null), this.week(s);
      };
    };
  });
})(JO);
var hH = JO.exports;
const bH = /* @__PURE__ */ El(hH);
var e3 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Il, function() {
    return function(n, o) {
      o.prototype.weekYear = function() {
        var r = this.month(), l = this.week(), a = this.year();
        return l === 1 && r === 11 ? a + 1 : r === 0 && l >= 52 ? a - 1 : a;
      };
    };
  });
})(e3);
var yH = e3.exports;
const SH = /* @__PURE__ */ El(yH);
var t3 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Il, function() {
    var n = "month", o = "quarter";
    return function(r, l) {
      var a = l.prototype;
      a.quarter = function(c) {
        return this.$utils().u(c) ? Math.ceil((this.month() + 1) / 3) : this.month(this.month() % 3 + 3 * (c - 1));
      };
      var i = a.add;
      a.add = function(c, u) {
        return c = Number(c), this.$utils().p(u) === o ? this.add(3 * c, n) : i.bind(this)(c, u);
      };
      var s = a.startOf;
      a.startOf = function(c, u) {
        var d = this.$utils(), p = !!d.u(u) || u;
        if (d.p(c) === o) {
          var v = this.quarter() - 1;
          return p ? this.month(3 * v).startOf(n).startOf("day") : this.month(3 * v + 2).endOf(n).endOf("day");
        }
        return s.bind(this)(c, u);
      };
    };
  });
})(t3);
var CH = t3.exports;
const $H = /* @__PURE__ */ El(CH);
var n3 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Il, function() {
    return function(n, o) {
      var r = o.prototype, l = r.format;
      r.format = function(a) {
        var i = this, s = this.$locale();
        if (!this.isValid())
          return l.bind(this)(a);
        var c = this.$utils(), u = (a || "YYYY-MM-DDTHH:mm:ssZ").replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function(d) {
          switch (d) {
            case "Q":
              return Math.ceil((i.$M + 1) / 3);
            case "Do":
              return s.ordinal(i.$D);
            case "gggg":
              return i.weekYear();
            case "GGGG":
              return i.isoWeekYear();
            case "wo":
              return s.ordinal(i.week(), "W");
            case "w":
            case "ww":
              return c.s(i.week(), d === "w" ? 1 : 2, "0");
            case "W":
            case "WW":
              return c.s(i.isoWeek(), d === "W" ? 1 : 2, "0");
            case "k":
            case "kk":
              return c.s(String(i.$H === 0 ? 24 : i.$H), d === "k" ? 1 : 2, "0");
            case "X":
              return Math.floor(i.$d.getTime() / 1e3);
            case "x":
              return i.$d.getTime();
            case "z":
              return "[" + i.offsetName() + "]";
            case "zzz":
              return "[" + i.offsetName("long") + "]";
            default:
              return d;
          }
        });
        return l.bind(this)(u);
      };
    };
  });
})(n3);
var wH = n3.exports;
const xH = /* @__PURE__ */ El(wH);
var o3 = { exports: {} };
(function(e, t) {
  (function(n, o) {
    e.exports = o();
  })(Il, function() {
    var n = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, o = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g, r = /\d\d/, l = /\d\d?/, a = /\d*[^-_:/,()\s\d]+/, i = {}, s = function(g) {
      return (g = +g) + (g > 68 ? 1900 : 2e3);
    }, c = function(g) {
      return function(b) {
        this[g] = +b;
      };
    }, u = [/[+-]\d\d:?(\d\d)?|Z/, function(g) {
      (this.zone || (this.zone = {})).offset = function(b) {
        if (!b || b === "Z")
          return 0;
        var y = b.match(/([+-]|\d\d)/g), S = 60 * y[1] + (+y[2] || 0);
        return S === 0 ? 0 : y[0] === "+" ? -S : S;
      }(g);
    }], d = function(g) {
      var b = i[g];
      return b && (b.indexOf ? b : b.s.concat(b.f));
    }, p = function(g, b) {
      var y, S = i.meridiem;
      if (S) {
        for (var C = 1; C <= 24; C += 1)
          if (g.indexOf(S(C, 0, b)) > -1) {
            y = C > 12;
            break;
          }
      } else
        y = g === (b ? "pm" : "PM");
      return y;
    }, v = { A: [a, function(g) {
      this.afternoon = p(g, !1);
    }], a: [a, function(g) {
      this.afternoon = p(g, !0);
    }], S: [/\d/, function(g) {
      this.milliseconds = 100 * +g;
    }], SS: [r, function(g) {
      this.milliseconds = 10 * +g;
    }], SSS: [/\d{3}/, function(g) {
      this.milliseconds = +g;
    }], s: [l, c("seconds")], ss: [l, c("seconds")], m: [l, c("minutes")], mm: [l, c("minutes")], H: [l, c("hours")], h: [l, c("hours")], HH: [l, c("hours")], hh: [l, c("hours")], D: [l, c("day")], DD: [r, c("day")], Do: [a, function(g) {
      var b = i.ordinal, y = g.match(/\d+/);
      if (this.day = y[0], b)
        for (var S = 1; S <= 31; S += 1)
          b(S).replace(/\[|\]/g, "") === g && (this.day = S);
    }], M: [l, c("month")], MM: [r, c("month")], MMM: [a, function(g) {
      var b = d("months"), y = (d("monthsShort") || b.map(function(S) {
        return S.slice(0, 3);
      })).indexOf(g) + 1;
      if (y < 1)
        throw new Error();
      this.month = y % 12 || y;
    }], MMMM: [a, function(g) {
      var b = d("months").indexOf(g) + 1;
      if (b < 1)
        throw new Error();
      this.month = b % 12 || b;
    }], Y: [/[+-]?\d+/, c("year")], YY: [r, function(g) {
      this.year = s(g);
    }], YYYY: [/\d{4}/, c("year")], Z: u, ZZ: u };
    function h(g) {
      var b, y;
      b = g, y = i && i.formats;
      for (var S = (g = b.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function(E, _, M) {
        var R = M && M.toUpperCase();
        return _ || y[M] || n[M] || y[R].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function(A, z, T) {
          return z || T.slice(1);
        });
      })).match(o), C = S.length, w = 0; w < C; w += 1) {
        var $ = S[w], O = v[$], x = O && O[0], I = O && O[1];
        S[w] = I ? { regex: x, parser: I } : $.replace(/^\[|\]$/g, "");
      }
      return function(E) {
        for (var _ = {}, M = 0, R = 0; M < C; M += 1) {
          var A = S[M];
          if (typeof A == "string")
            R += A.length;
          else {
            var z = A.regex, T = A.parser, N = E.slice(R), k = z.exec(N)[0];
            T.call(_, k), E = E.replace(k, "");
          }
        }
        return function(B) {
          var F = B.afternoon;
          if (F !== void 0) {
            var L = B.hours;
            F ? L < 12 && (B.hours += 12) : L === 12 && (B.hours = 0), delete B.afternoon;
          }
        }(_), _;
      };
    }
    return function(g, b, y) {
      y.p.customParseFormat = !0, g && g.parseTwoDigitYear && (s = g.parseTwoDigitYear);
      var S = b.prototype, C = S.parse;
      S.parse = function(w) {
        var $ = w.date, O = w.utc, x = w.args;
        this.$u = O;
        var I = x[1];
        if (typeof I == "string") {
          var E = x[2] === !0, _ = x[3] === !0, M = E || _, R = x[2];
          _ && (R = x[2]), i = this.$locale(), !E && R && (i = y.Ls[R]), this.$d = function(N, k, B) {
            try {
              if (["x", "X"].indexOf(k) > -1)
                return new Date((k === "X" ? 1e3 : 1) * N);
              var F = h(k)(N), L = F.year, j = F.month, H = F.day, K = F.hours, X = F.minutes, W = F.seconds, q = F.milliseconds, J = F.zone, ne = /* @__PURE__ */ new Date(), te = H || (L || j ? 1 : ne.getDate()), G = L || ne.getFullYear(), U = 0;
              L && !j || (U = j > 0 ? j - 1 : ne.getMonth());
              var re = K || 0, se = X || 0, me = W || 0, Ce = q || 0;
              return J ? new Date(Date.UTC(G, U, te, re, se, me, Ce + 60 * J.offset * 1e3)) : B ? new Date(Date.UTC(G, U, te, re, se, me, Ce)) : new Date(G, U, te, re, se, me, Ce);
            } catch {
              return /* @__PURE__ */ new Date("");
            }
          }($, I, O), this.init(), R && R !== !0 && (this.$L = this.locale(R).$L), M && $ != this.format(I) && (this.$d = /* @__PURE__ */ new Date("")), i = {};
        } else if (I instanceof Array)
          for (var A = I.length, z = 1; z <= A; z += 1) {
            x[1] = I[z - 1];
            var T = y.apply(this, x);
            if (T.isValid()) {
              this.$d = T.$d, this.$L = T.$L, this.init();
              break;
            }
            z === A && (this.$d = /* @__PURE__ */ new Date(""));
          }
        else
          C.call(this, w);
      };
    };
  });
})(o3);
var OH = o3.exports;
const PH = /* @__PURE__ */ El(OH);
mn.extend(PH);
mn.extend(xH);
mn.extend(vH);
mn.extend(mH);
mn.extend(bH);
mn.extend(SH);
mn.extend($H);
mn.extend((e, t) => {
  const n = t.prototype, o = n.format;
  n.format = function(l) {
    const a = (l || "").replace("Wo", "wo");
    return o.bind(this)(a);
  };
});
const IH = {
  // ar_EG:
  // az_AZ:
  // bg_BG:
  bn_BD: "bn-bd",
  by_BY: "be",
  // ca_ES:
  // cs_CZ:
  // da_DK:
  // de_DE:
  // el_GR:
  en_GB: "en-gb",
  en_US: "en",
  // es_ES:
  // et_EE:
  // fa_IR:
  // fi_FI:
  fr_BE: "fr",
  fr_CA: "fr-ca",
  // fr_FR:
  // ga_IE:
  // gl_ES:
  // he_IL:
  // hi_IN:
  // hr_HR:
  // hu_HU:
  hy_AM: "hy-am",
  // id_ID:
  // is_IS:
  // it_IT:
  // ja_JP:
  // ka_GE:
  // kk_KZ:
  // km_KH:
  kmr_IQ: "ku",
  // kn_IN:
  // ko_KR:
  // ku_IQ: // previous ku in antd
  // lt_LT:
  // lv_LV:
  // mk_MK:
  // ml_IN:
  // mn_MN:
  // ms_MY:
  // nb_NO:
  // ne_NP:
  nl_BE: "nl-be",
  // nl_NL:
  // pl_PL:
  pt_BR: "pt-br",
  // pt_PT:
  // ro_RO:
  // ru_RU:
  // sk_SK:
  // sl_SI:
  // sr_RS:
  // sv_SE:
  // ta_IN:
  // th_TH:
  // tr_TR:
  // uk_UA:
  // ur_PK:
  // vi_VN:
  zh_CN: "zh-cn",
  zh_HK: "zh-hk",
  zh_TW: "zh-tw"
}, Dl = (e) => IH[e] || e.split("_")[0], uC = () => {
  Cg(!1, "Not match any format. Please help to fire a issue about this.");
}, EH = /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|k{1,2}|S/g;
function dC(e, t, n) {
  const o = [...new Set(e.split(n))];
  let r = 0;
  for (let l = 0; l < o.length; l++) {
    const a = o[l];
    if (r += a.length, r > t)
      return a;
    r += n.length;
  }
}
const fC = (e, t) => {
  if (!e)
    return null;
  if (mn.isDayjs(e))
    return e;
  const n = t.matchAll(EH);
  let o = mn(e, t);
  if (n === null)
    return o;
  for (const r of n) {
    const l = r[0], a = r.index;
    if (l === "Q") {
      const i = e.slice(a - 1, a), s = dC(e, a, i).match(/\d+/)[0];
      o = o.quarter(parseInt(s));
    }
    if (l.toLowerCase() === "wo") {
      const i = e.slice(a - 1, a), s = dC(e, a, i).match(/\d+/)[0];
      o = o.week(parseInt(s));
    }
    l.toLowerCase() === "ww" && (o = o.week(parseInt(e.slice(a, a + l.length)))), l.toLowerCase() === "w" && (o = o.week(parseInt(e.slice(a, a + l.length + 1))));
  }
  return o;
}, C0 = {
  // get
  getNow: () => mn(),
  getFixedDate: (e) => mn(e, ["YYYY-M-DD", "YYYY-MM-DD"]),
  getEndDate: (e) => e.endOf("month"),
  getWeekDay: (e) => {
    const t = e.locale("en");
    return t.weekday() + t.localeData().firstDayOfWeek();
  },
  getYear: (e) => e.year(),
  getMonth: (e) => e.month(),
  getDate: (e) => e.date(),
  getHour: (e) => e.hour(),
  getMinute: (e) => e.minute(),
  getSecond: (e) => e.second(),
  // set
  addYear: (e, t) => e.add(t, "year"),
  addMonth: (e, t) => e.add(t, "month"),
  addDate: (e, t) => e.add(t, "day"),
  setYear: (e, t) => e.year(t),
  setMonth: (e, t) => e.month(t),
  setDate: (e, t) => e.date(t),
  setHour: (e, t) => e.hour(t),
  setMinute: (e, t) => e.minute(t),
  setSecond: (e, t) => e.second(t),
  // Compare
  isAfter: (e, t) => e.isAfter(t),
  isValidate: (e) => e.isValid(),
  locale: {
    getWeekFirstDay: (e) => mn().locale(Dl(e)).localeData().firstDayOfWeek(),
    getWeekFirstDate: (e, t) => t.locale(Dl(e)).weekday(0),
    getWeek: (e, t) => t.locale(Dl(e)).week(),
    getShortWeekDays: (e) => mn().locale(Dl(e)).localeData().weekdaysMin(),
    getShortMonths: (e) => mn().locale(Dl(e)).localeData().monthsShort(),
    format: (e, t, n) => t.locale(Dl(e)).format(n),
    parse: (e, t, n) => {
      const o = Dl(e);
      for (let r = 0; r < n.length; r += 1) {
        const l = n[r], a = t;
        if (l.includes("wo") || l.includes("Wo")) {
          const s = a.split("-")[0], c = a.split("-")[1], u = mn(s, "YYYY").startOf("year").locale(o);
          for (let d = 0; d <= 52; d += 1) {
            const p = u.add(d, "week");
            if (p.format("Wo") === c)
              return p;
          }
          return uC(), null;
        }
        const i = mn(a, l, !0).locale(o);
        if (i.isValid())
          return i;
      }
      return t || uC(), null;
    }
  },
  toDate: (e, t) => Array.isArray(e) ? e.map((n) => fC(n, t)) : fC(e, t),
  toString: (e, t) => Array.isArray(e) ? e.map((n) => mn.isDayjs(n) ? n.format(t) : n) : mn.isDayjs(e) ? e.format(t) : e
};
function nn(e) {
  const t = rT();
  return m(m({}, e), t);
}
const r3 = Symbol("PanelContextProps"), $0 = (e) => {
  Je(r3, e);
}, Pr = () => tt(r3, {}), Xc = {
  visibility: "hidden"
};
function Tl(e, t) {
  let {
    slots: n
  } = t;
  var o;
  const r = nn(e), {
    prefixCls: l,
    prevIcon: a = "‹",
    nextIcon: i = "›",
    superPrevIcon: s = "«",
    superNextIcon: c = "»",
    onSuperPrev: u,
    onSuperNext: d,
    onPrev: p,
    onNext: v
  } = r, {
    hideNextBtn: h,
    hidePrevBtn: g
  } = Pr();
  return f("div", {
    class: l
  }, [u && f("button", {
    type: "button",
    onClick: u,
    tabindex: -1,
    class: `${l}-super-prev-btn`,
    style: g.value ? Xc : {}
  }, [s]), p && f("button", {
    type: "button",
    onClick: p,
    tabindex: -1,
    class: `${l}-prev-btn`,
    style: g.value ? Xc : {}
  }, [a]), f("div", {
    class: `${l}-view`
  }, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]), v && f("button", {
    type: "button",
    onClick: v,
    tabindex: -1,
    class: `${l}-next-btn`,
    style: h.value ? Xc : {}
  }, [i]), d && f("button", {
    type: "button",
    onClick: d,
    tabindex: -1,
    class: `${l}-super-next-btn`,
    style: h.value ? Xc : {}
  }, [c])]);
}
Tl.displayName = "Header";
Tl.inheritAttrs = !1;
function w0(e) {
  const t = nn(e), {
    prefixCls: n,
    generateConfig: o,
    viewDate: r,
    onPrevDecades: l,
    onNextDecades: a
  } = t, {
    hideHeader: i
  } = Pr();
  if (i)
    return null;
  const s = `${n}-header`, c = o.getYear(r), u = Math.floor(c / zr) * zr, d = u + zr - 1;
  return f(Tl, D(D({}, t), {}, {
    prefixCls: s,
    onSuperPrev: l,
    onSuperNext: a
  }), {
    default: () => [u, Ot("-"), d]
  });
}
w0.displayName = "DecadeHeader";
w0.inheritAttrs = !1;
function l3(e, t, n, o, r) {
  let l = e.setHour(t, n);
  return l = e.setMinute(l, o), l = e.setSecond(l, r), l;
}
function Su(e, t, n) {
  if (!n)
    return t;
  let o = t;
  return o = e.setHour(o, e.getHour(n)), o = e.setMinute(o, e.getMinute(n)), o = e.setSecond(o, e.getSecond(n)), o;
}
function TH(e, t, n, o, r, l) {
  const a = Math.floor(e / o) * o;
  if (a < e)
    return [a, 60 - r, 60 - l];
  const i = Math.floor(t / r) * r;
  if (i < t)
    return [a, i, 60 - l];
  const s = Math.floor(n / l) * l;
  return [a, i, s];
}
function MH(e, t) {
  const n = e.getYear(t), o = e.getMonth(t) + 1, r = e.getEndDate(e.getFixedDate(`${n}-${o}-01`)), l = e.getDate(r), a = o < 10 ? `0${o}` : `${o}`;
  return `${n}-${a}-${l}`;
}
function wa(e) {
  const {
    prefixCls: t,
    disabledDate: n,
    onSelect: o,
    picker: r,
    rowNum: l,
    colNum: a,
    prefixColumn: i,
    rowClassName: s,
    baseDate: c,
    getCellClassName: u,
    getCellText: d,
    getCellNode: p,
    getCellDate: v,
    generateConfig: h,
    titleCell: g,
    headerCells: b
  } = nn(e), {
    onDateMouseenter: y,
    onDateMouseleave: S,
    mode: C
  } = Pr(), w = `${t}-cell`, $ = [];
  for (let O = 0; O < l; O += 1) {
    const x = [];
    let I;
    for (let E = 0; E < a; E += 1) {
      const _ = O * a + E, M = v(c, _), R = nm({
        cellDate: M,
        mode: C.value,
        disabledDate: n,
        generateConfig: h
      });
      E === 0 && (I = M, i && x.push(i(I)));
      const A = g && g(M);
      x.push(f("td", {
        key: E,
        title: A,
        class: ee(w, m({
          [`${w}-disabled`]: R,
          [`${w}-start`]: d(M) === 1 || r === "year" && Number(A) % 10 === 0,
          [`${w}-end`]: A === MH(h, M) || r === "year" && Number(A) % 10 === 9
        }, u(M))),
        onClick: (z) => {
          z.stopPropagation(), R || o(M);
        },
        onMouseenter: () => {
          !R && y && y(M);
        },
        onMouseleave: () => {
          !R && S && S(M);
        }
      }, [p ? p(M) : f("div", {
        class: `${w}-inner`
      }, [d(M)])]));
    }
    $.push(f("tr", {
      key: O,
      class: s && s(I)
    }, [x]));
  }
  return f("div", {
    class: `${t}-body`
  }, [f("table", {
    class: `${t}-content`
  }, [b && f("thead", null, [f("tr", null, [b])]), f("tbody", null, [$])])]);
}
wa.displayName = "PanelBody";
wa.inheritAttrs = !1;
const Jg = 3, pC = 4;
function x0(e) {
  const t = nn(e), n = Zo - 1, {
    prefixCls: o,
    viewDate: r,
    generateConfig: l
  } = t, a = `${o}-cell`, i = l.getYear(r), s = Math.floor(i / Zo) * Zo, c = Math.floor(i / zr) * zr, u = c + zr - 1, d = l.setYear(r, c - Math.ceil((Jg * pC * Zo - zr) / 2)), p = (v) => {
    const h = l.getYear(v), g = h + n;
    return {
      [`${a}-in-view`]: c <= h && g <= u,
      [`${a}-selected`]: h === s
    };
  };
  return f(wa, D(D({}, t), {}, {
    rowNum: pC,
    colNum: Jg,
    baseDate: d,
    getCellText: (v) => {
      const h = l.getYear(v);
      return `${h}-${h + n}`;
    },
    getCellClassName: p,
    getCellDate: (v, h) => l.addYear(v, h * Zo)
  }), null);
}
x0.displayName = "DecadeBody";
x0.inheritAttrs = !1;
const Uc = /* @__PURE__ */ new Map();
function _H(e, t) {
  let n;
  function o() {
    If(e) ? t() : n = Ze(() => {
      o();
    });
  }
  return o(), () => {
    Ze.cancel(n);
  };
}
function em(e, t, n) {
  if (Uc.get(e) && Ze.cancel(Uc.get(e)), n <= 0) {
    Uc.set(e, Ze(() => {
      e.scrollTop = t;
    }));
    return;
  }
  const r = (t - e.scrollTop) / n * 10;
  Uc.set(e, Ze(() => {
    e.scrollTop += r, e.scrollTop !== t && em(e, t, n - 10);
  }));
}
function Bi(e, t) {
  let {
    onLeftRight: n,
    onCtrlLeftRight: o,
    onUpDown: r,
    onPageUpDown: l,
    onEnter: a
  } = t;
  const {
    which: i,
    ctrlKey: s,
    metaKey: c
  } = e;
  switch (i) {
    case ce.LEFT:
      if (s || c) {
        if (o)
          return o(-1), !0;
      } else if (n)
        return n(-1), !0;
      break;
    case ce.RIGHT:
      if (s || c) {
        if (o)
          return o(1), !0;
      } else if (n)
        return n(1), !0;
      break;
    case ce.UP:
      if (r)
        return r(-1), !0;
      break;
    case ce.DOWN:
      if (r)
        return r(1), !0;
      break;
    case ce.PAGE_UP:
      if (l)
        return l(-1), !0;
      break;
    case ce.PAGE_DOWN:
      if (l)
        return l(1), !0;
      break;
    case ce.ENTER:
      if (a)
        return a(), !0;
      break;
  }
  return !1;
}
function a3(e, t, n, o) {
  let r = e;
  if (!r)
    switch (t) {
      case "time":
        r = o ? "hh:mm:ss a" : "HH:mm:ss";
        break;
      case "week":
        r = "gggg-wo";
        break;
      case "month":
        r = "YYYY-MM";
        break;
      case "quarter":
        r = "YYYY-[Q]Q";
        break;
      case "year":
        r = "YYYY";
        break;
      default:
        r = n ? "YYYY-MM-DD HH:mm:ss" : "YYYY-MM-DD";
    }
  return r;
}
function i3(e, t, n) {
  const o = e === "time" ? 8 : 10, r = typeof t == "function" ? t(n.getNow()).length : t.length;
  return Math.max(o, r) + 2;
}
let Yi = null;
const Yc = /* @__PURE__ */ new Set();
function AH(e) {
  return !Yi && typeof window < "u" && window.addEventListener && (Yi = (t) => {
    [...Yc].forEach((n) => {
      n(t);
    });
  }, window.addEventListener("mousedown", Yi)), Yc.add(e), () => {
    Yc.delete(e), Yc.size === 0 && (window.removeEventListener("mousedown", Yi), Yi = null);
  };
}
function DH(e) {
  var t;
  const n = e.target;
  return e.composed && n.shadowRoot && ((t = e.composedPath) === null || t === void 0 ? void 0 : t.call(e)[0]) || n;
}
const NH = (e) => e === "month" || e === "date" ? "year" : e, RH = (e) => e === "date" ? "month" : e, kH = (e) => e === "month" || e === "date" ? "quarter" : e, BH = (e) => e === "date" ? "week" : e, FH = {
  year: NH,
  month: RH,
  quarter: kH,
  week: BH,
  time: null,
  date: null
};
function s3(e, t) {
  return process.env.NODE_ENV === "test" ? !1 : e.some((n) => n && n.contains(t));
}
const Zo = 10, zr = Zo * 10;
function O0(e) {
  const t = nn(e), {
    prefixCls: n,
    onViewDateChange: o,
    generateConfig: r,
    viewDate: l,
    operationRef: a,
    onSelect: i,
    onPanelChange: s
  } = t, c = `${n}-decade-panel`;
  a.value = {
    onKeydown: (p) => Bi(p, {
      onLeftRight: (v) => {
        i(r.addYear(l, v * Zo), "key");
      },
      onCtrlLeftRight: (v) => {
        i(r.addYear(l, v * zr), "key");
      },
      onUpDown: (v) => {
        i(r.addYear(l, v * Zo * Jg), "key");
      },
      onEnter: () => {
        s("year", l);
      }
    })
  };
  const u = (p) => {
    const v = r.addYear(l, p * zr);
    o(v), s(null, v);
  }, d = (p) => {
    i(p, "mouse"), s("year", p);
  };
  return f("div", {
    class: c
  }, [f(w0, D(D({}, t), {}, {
    prefixCls: n,
    onPrevDecades: () => {
      u(-1);
    },
    onNextDecades: () => {
      u(1);
    }
  }), null), f(x0, D(D({}, t), {}, {
    prefixCls: n,
    onSelect: d
  }), null)]);
}
O0.displayName = "DecadePanel";
O0.inheritAttrs = !1;
const Cu = 7;
function xa(e, t) {
  if (!e && !t)
    return !0;
  if (!e || !t)
    return !1;
}
function LH(e, t, n) {
  const o = xa(t, n);
  if (typeof o == "boolean")
    return o;
  const r = Math.floor(e.getYear(t) / 10), l = Math.floor(e.getYear(n) / 10);
  return r === l;
}
function Jf(e, t, n) {
  const o = xa(t, n);
  return typeof o == "boolean" ? o : e.getYear(t) === e.getYear(n);
}
function tm(e, t) {
  return Math.floor(e.getMonth(t) / 3) + 1;
}
function c3(e, t, n) {
  const o = xa(t, n);
  return typeof o == "boolean" ? o : Jf(e, t, n) && tm(e, t) === tm(e, n);
}
function P0(e, t, n) {
  const o = xa(t, n);
  return typeof o == "boolean" ? o : Jf(e, t, n) && e.getMonth(t) === e.getMonth(n);
}
function Hr(e, t, n) {
  const o = xa(t, n);
  return typeof o == "boolean" ? o : e.getYear(t) === e.getYear(n) && e.getMonth(t) === e.getMonth(n) && e.getDate(t) === e.getDate(n);
}
function zH(e, t, n) {
  const o = xa(t, n);
  return typeof o == "boolean" ? o : e.getHour(t) === e.getHour(n) && e.getMinute(t) === e.getMinute(n) && e.getSecond(t) === e.getSecond(n);
}
function u3(e, t, n, o) {
  const r = xa(n, o);
  return typeof r == "boolean" ? r : e.locale.getWeek(t, n) === e.locale.getWeek(t, o);
}
function ri(e, t, n) {
  return Hr(e, t, n) && zH(e, t, n);
}
function qc(e, t, n, o) {
  return !t || !n || !o ? !1 : !Hr(e, t, o) && !Hr(e, n, o) && e.isAfter(o, t) && e.isAfter(n, o);
}
function HH(e, t, n) {
  const o = t.locale.getWeekFirstDay(e), r = t.setDate(n, 1), l = t.getWeekDay(r);
  let a = t.addDate(r, o - l);
  return t.getMonth(a) === t.getMonth(n) && t.getDate(a) > 1 && (a = t.addDate(a, -7)), a;
}
function bs(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  switch (t) {
    case "year":
      return n.addYear(e, o * 10);
    case "quarter":
    case "month":
      return n.addYear(e, o);
    default:
      return n.addMonth(e, o);
  }
}
function Pn(e, t) {
  let {
    generateConfig: n,
    locale: o,
    format: r
  } = t;
  return typeof r == "function" ? r(e) : n.locale.format(o.locale, e, r);
}
function d3(e, t) {
  let {
    generateConfig: n,
    locale: o,
    formatList: r
  } = t;
  return !e || typeof r[0] == "function" ? null : n.locale.parse(o.locale, e, r);
}
function nm(e) {
  let {
    cellDate: t,
    mode: n,
    disabledDate: o,
    generateConfig: r
  } = e;
  if (!o)
    return !1;
  const l = (a, i, s) => {
    let c = i;
    for (; c <= s; ) {
      let u;
      switch (a) {
        case "date": {
          if (u = r.setDate(t, c), !o(u))
            return !1;
          break;
        }
        case "month": {
          if (u = r.setMonth(t, c), !nm({
            cellDate: u,
            mode: "month",
            generateConfig: r,
            disabledDate: o
          }))
            return !1;
          break;
        }
        case "year": {
          if (u = r.setYear(t, c), !nm({
            cellDate: u,
            mode: "year",
            generateConfig: r,
            disabledDate: o
          }))
            return !1;
          break;
        }
      }
      c += 1;
    }
    return !0;
  };
  switch (n) {
    case "date":
    case "week":
      return o(t);
    case "month": {
      const i = r.getDate(r.getEndDate(t));
      return l("date", 1, i);
    }
    case "quarter": {
      const a = Math.floor(r.getMonth(t) / 3) * 3, i = a + 2;
      return l("month", a, i);
    }
    case "year":
      return l("month", 0, 11);
    case "decade": {
      const a = r.getYear(t), i = Math.floor(a / Zo) * Zo, s = i + Zo - 1;
      return l("year", i, s);
    }
  }
}
function I0(e) {
  const t = nn(e), {
    hideHeader: n
  } = Pr();
  if (n.value)
    return null;
  const {
    prefixCls: o,
    generateConfig: r,
    locale: l,
    value: a,
    format: i
  } = t, s = `${o}-header`;
  return f(Tl, {
    prefixCls: s
  }, {
    default: () => [a ? Pn(a, {
      locale: l,
      format: i,
      generateConfig: r
    }) : " "]
  });
}
I0.displayName = "TimeHeader";
I0.inheritAttrs = !1;
const Zc = Z({
  name: "TimeUnitColumn",
  props: ["prefixCls", "units", "onSelect", "value", "active", "hideDisabledOptions"],
  setup(e) {
    const {
      open: t
    } = Pr(), n = Q(null), o = Y(/* @__PURE__ */ new Map()), r = Y();
    return ie(() => e.value, () => {
      const l = o.value.get(e.value);
      l && t.value !== !1 && em(n.value, l.offsetTop, 120);
    }), et(() => {
      var l;
      (l = r.value) === null || l === void 0 || l.call(r);
    }), ie(t, () => {
      var l;
      (l = r.value) === null || l === void 0 || l.call(r), rt(() => {
        if (t.value) {
          const a = o.value.get(e.value);
          a && (r.value = _H(a, () => {
            em(n.value, a.offsetTop, 0);
          }));
        }
      });
    }, {
      immediate: !0,
      flush: "post"
    }), () => {
      const {
        prefixCls: l,
        units: a,
        onSelect: i,
        value: s,
        active: c,
        hideDisabledOptions: u
      } = e, d = `${l}-cell`;
      return f("ul", {
        class: ee(`${l}-column`, {
          [`${l}-column-active`]: c
        }),
        ref: n,
        style: {
          position: "relative"
        }
      }, [a.map((p) => u && p.disabled ? null : f("li", {
        key: p.value,
        ref: (v) => {
          o.value.set(p.value, v);
        },
        class: ee(d, {
          [`${d}-disabled`]: p.disabled,
          [`${d}-selected`]: s === p.value
        }),
        onClick: () => {
          p.disabled || i(p.value);
        }
      }, [f("div", {
        class: `${d}-inner`
      }, [p.label])]))]);
    };
  }
});
function f3(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "0", o = String(e);
  for (; o.length < t; )
    o = `${n}${e}`;
  return o;
}
const jH = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t;
};
function p3(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function v3(e) {
  const t = {};
  return Object.keys(e).forEach((n) => {
    (n.startsWith("data-") || n.startsWith("aria-") || n === "role" || n === "name") && !n.startsWith("data-__") && (t[n] = e[n]);
  }), t;
}
function $t(e, t) {
  return e ? e[t] : null;
}
function Do(e, t, n) {
  const o = [$t(e, 0), $t(e, 1)];
  return o[n] = typeof t == "function" ? t(o[n]) : t, !o[0] && !o[1] ? null : o;
}
function vv(e, t, n, o) {
  const r = [];
  for (let l = e; l <= t; l += n)
    r.push({
      label: f3(l, 2),
      value: l,
      disabled: (o || []).includes(l)
    });
  return r;
}
const VH = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TimeBody",
  inheritAttrs: !1,
  props: ["generateConfig", "prefixCls", "operationRef", "activeColumnIndex", "value", "showHour", "showMinute", "showSecond", "use12Hours", "hourStep", "minuteStep", "secondStep", "disabledHours", "disabledMinutes", "disabledSeconds", "disabledTime", "hideDisabledOptions", "onSelect"],
  setup(e) {
    const t = P(() => e.value ? e.generateConfig.getHour(e.value) : -1), n = P(() => e.use12Hours ? t.value >= 12 : !1), o = P(() => e.use12Hours ? t.value % 12 : t.value), r = P(() => e.value ? e.generateConfig.getMinute(e.value) : -1), l = P(() => e.value ? e.generateConfig.getSecond(e.value) : -1), a = Y(e.generateConfig.getNow()), i = Y(), s = Y(), c = Y();
    eh(() => {
      a.value = e.generateConfig.getNow();
    }), Le(() => {
      if (e.disabledTime) {
        const b = e.disabledTime(a);
        [i.value, s.value, c.value] = [b.disabledHours, b.disabledMinutes, b.disabledSeconds];
      } else
        [i.value, s.value, c.value] = [e.disabledHours, e.disabledMinutes, e.disabledSeconds];
    });
    const u = (b, y, S, C) => {
      let w = e.value || e.generateConfig.getNow();
      const $ = Math.max(0, y), O = Math.max(0, S), x = Math.max(0, C);
      return w = l3(e.generateConfig, w, !e.use12Hours || !b ? $ : $ + 12, O, x), w;
    }, d = P(() => {
      var b;
      return vv(0, 23, (b = e.hourStep) !== null && b !== void 0 ? b : 1, i.value && i.value());
    }), p = P(() => {
      if (!e.use12Hours)
        return [!1, !1];
      const b = [!0, !0];
      return d.value.forEach((y) => {
        let {
          disabled: S,
          value: C
        } = y;
        S || (C >= 12 ? b[1] = !1 : b[0] = !1);
      }), b;
    }), v = P(() => e.use12Hours ? d.value.filter(n.value ? (b) => b.value >= 12 : (b) => b.value < 12).map((b) => {
      const y = b.value % 12, S = y === 0 ? "12" : f3(y, 2);
      return m(m({}, b), {
        label: S,
        value: y
      });
    }) : d.value), h = P(() => {
      var b;
      return vv(0, 59, (b = e.minuteStep) !== null && b !== void 0 ? b : 1, s.value && s.value(t.value));
    }), g = P(() => {
      var b;
      return vv(0, 59, (b = e.secondStep) !== null && b !== void 0 ? b : 1, c.value && c.value(t.value, r.value));
    });
    return () => {
      const {
        prefixCls: b,
        operationRef: y,
        activeColumnIndex: S,
        showHour: C,
        showMinute: w,
        showSecond: $,
        use12Hours: O,
        hideDisabledOptions: x,
        onSelect: I
      } = e, E = [], _ = `${b}-content`, M = `${b}-time-panel`;
      y.value = {
        onUpDown: (z) => {
          const T = E[S];
          if (T) {
            const N = T.units.findIndex((B) => B.value === T.value), k = T.units.length;
            for (let B = 1; B < k; B += 1) {
              const F = T.units[(N + z * B + k) % k];
              if (F.disabled !== !0) {
                T.onSelect(F.value);
                break;
              }
            }
          }
        }
      };
      function R(z, T, N, k, B) {
        z !== !1 && E.push({
          node: yt(T, {
            prefixCls: M,
            value: N,
            active: S === E.length,
            onSelect: B,
            units: k,
            hideDisabledOptions: x
          }),
          onSelect: B,
          value: N,
          units: k
        });
      }
      R(C, f(Zc, {
        key: "hour"
      }, null), o.value, v.value, (z) => {
        I(u(n.value, z, r.value, l.value), "mouse");
      }), R(w, f(Zc, {
        key: "minute"
      }, null), r.value, h.value, (z) => {
        I(u(n.value, o.value, z, l.value), "mouse");
      }), R($, f(Zc, {
        key: "second"
      }, null), l.value, g.value, (z) => {
        I(u(n.value, o.value, r.value, z), "mouse");
      });
      let A = -1;
      return typeof n.value == "boolean" && (A = n.value ? 1 : 0), R(O === !0, f(Zc, {
        key: "12hours"
      }, null), A, [{
        label: "AM",
        value: 0,
        disabled: p.value[0]
      }, {
        label: "PM",
        value: 1,
        disabled: p.value[1]
      }], (z) => {
        I(u(!!z, o.value, r.value, l.value), "mouse");
      }), f("div", {
        class: _
      }, [E.map((z) => {
        let {
          node: T
        } = z;
        return T;
      })]);
    };
  }
}), WH = (e) => e.filter((t) => t !== !1).length;
function ep(e) {
  const t = nn(e), {
    generateConfig: n,
    format: o = "HH:mm:ss",
    prefixCls: r,
    active: l,
    operationRef: a,
    showHour: i,
    showMinute: s,
    showSecond: c,
    use12Hours: u = !1,
    onSelect: d,
    value: p
  } = t, v = `${r}-time-panel`, h = Y(), g = Y(-1), b = WH([i, s, c, u]);
  return a.value = {
    onKeydown: (y) => Bi(y, {
      onLeftRight: (S) => {
        g.value = (g.value + S + b) % b;
      },
      onUpDown: (S) => {
        g.value === -1 ? g.value = 0 : h.value && h.value.onUpDown(S);
      },
      onEnter: () => {
        d(p || n.getNow(), "key"), g.value = -1;
      }
    }),
    onBlur: () => {
      g.value = -1;
    }
  }, f("div", {
    class: ee(v, {
      [`${v}-active`]: l
    })
  }, [f(I0, D(D({}, t), {}, {
    format: o,
    prefixCls: r
  }), null), f(VH, D(D({}, t), {}, {
    prefixCls: r,
    activeColumnIndex: g.value,
    operationRef: h
  }), null)]);
}
ep.displayName = "TimePanel";
ep.inheritAttrs = !1;
function tp(e) {
  let {
    cellPrefixCls: t,
    generateConfig: n,
    rangedValue: o,
    hoverRangedValue: r,
    isInView: l,
    isSameCell: a,
    offsetCell: i,
    today: s,
    value: c
  } = e;
  function u(d) {
    const p = i(d, -1), v = i(d, 1), h = $t(o, 0), g = $t(o, 1), b = $t(r, 0), y = $t(r, 1), S = qc(n, b, y, d);
    function C(E) {
      return a(h, E);
    }
    function w(E) {
      return a(g, E);
    }
    const $ = a(b, d), O = a(y, d), x = (S || O) && (!l(p) || w(p)), I = (S || $) && (!l(v) || C(v));
    return {
      // In view
      [`${t}-in-view`]: l(d),
      // Range
      [`${t}-in-range`]: qc(n, h, g, d),
      [`${t}-range-start`]: C(d),
      [`${t}-range-end`]: w(d),
      [`${t}-range-start-single`]: C(d) && !g,
      [`${t}-range-end-single`]: w(d) && !h,
      [`${t}-range-start-near-hover`]: C(d) && (a(p, b) || qc(n, b, y, p)),
      [`${t}-range-end-near-hover`]: w(d) && (a(v, y) || qc(n, b, y, v)),
      // Range Hover
      [`${t}-range-hover`]: S,
      [`${t}-range-hover-start`]: $,
      [`${t}-range-hover-end`]: O,
      // Range Edge
      [`${t}-range-hover-edge-start`]: x,
      [`${t}-range-hover-edge-end`]: I,
      [`${t}-range-hover-edge-start-near-range`]: x && a(p, g),
      [`${t}-range-hover-edge-end-near-range`]: I && a(v, h),
      // Others
      [`${t}-today`]: a(s, d),
      [`${t}-selected`]: a(c, d)
    };
  }
  return u;
}
const g3 = Symbol("RangeContextProps"), KH = (e) => {
  Je(g3, e);
}, fc = () => tt(g3, {
  rangedValue: Y(),
  hoverRangedValue: Y(),
  inRange: Y(),
  panelPosition: Y()
}), GH = Z({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContextProvider",
  inheritAttrs: !1,
  props: {
    value: {
      type: Object,
      default: () => ({})
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = {
      rangedValue: Y(e.value.rangedValue),
      hoverRangedValue: Y(e.value.hoverRangedValue),
      inRange: Y(e.value.inRange),
      panelPosition: Y(e.value.panelPosition)
    };
    return KH(o), ie(() => e.value, () => {
      Object.keys(e.value).forEach((r) => {
        o[r] && (o[r].value = e.value[r]);
      });
    }), () => {
      var r;
      return (r = n.default) === null || r === void 0 ? void 0 : r.call(n);
    };
  }
});
function np(e) {
  const t = nn(e), {
    prefixCls: n,
    generateConfig: o,
    prefixColumn: r,
    locale: l,
    rowCount: a,
    viewDate: i,
    value: s,
    dateRender: c
  } = t, {
    rangedValue: u,
    hoverRangedValue: d
  } = fc(), p = HH(l.locale, o, i), v = `${n}-cell`, h = o.locale.getWeekFirstDay(l.locale), g = o.getNow(), b = [], y = l.shortWeekDays || (o.locale.getShortWeekDays ? o.locale.getShortWeekDays(l.locale) : []);
  r && b.push(f("th", {
    key: "empty",
    "aria-label": "empty cell"
  }, null));
  for (let w = 0; w < Cu; w += 1)
    b.push(f("th", {
      key: w
    }, [y[(w + h) % Cu]]));
  const S = tp({
    cellPrefixCls: v,
    today: g,
    value: s,
    generateConfig: o,
    rangedValue: r ? null : u.value,
    hoverRangedValue: r ? null : d.value,
    isSameCell: (w, $) => Hr(o, w, $),
    isInView: (w) => P0(o, w, i),
    offsetCell: (w, $) => o.addDate(w, $)
  }), C = c ? (w) => c({
    current: w,
    today: g
  }) : void 0;
  return f(wa, D(D({}, t), {}, {
    rowNum: a,
    colNum: Cu,
    baseDate: p,
    getCellNode: C,
    getCellText: o.getDate,
    getCellClassName: S,
    getCellDate: o.addDate,
    titleCell: (w) => Pn(w, {
      locale: l,
      format: "YYYY-MM-DD",
      generateConfig: o
    }),
    headerCells: b
  }), null);
}
np.displayName = "DateBody";
np.inheritAttrs = !1;
np.props = [
  "prefixCls",
  "generateConfig",
  "value?",
  "viewDate",
  "locale",
  "rowCount",
  "onSelect",
  "dateRender?",
  "disabledDate?",
  // Used for week panel
  "prefixColumn?",
  "rowClassName?"
];
function E0(e) {
  const t = nn(e), {
    prefixCls: n,
    generateConfig: o,
    locale: r,
    viewDate: l,
    onNextMonth: a,
    onPrevMonth: i,
    onNextYear: s,
    onPrevYear: c,
    onYearClick: u,
    onMonthClick: d
  } = t, {
    hideHeader: p
  } = Pr();
  if (p.value)
    return null;
  const v = `${n}-header`, h = r.shortMonths || (o.locale.getShortMonths ? o.locale.getShortMonths(r.locale) : []), g = o.getMonth(l), b = f("button", {
    type: "button",
    key: "year",
    onClick: u,
    tabindex: -1,
    class: `${n}-year-btn`
  }, [Pn(l, {
    locale: r,
    format: r.yearFormat,
    generateConfig: o
  })]), y = f("button", {
    type: "button",
    key: "month",
    onClick: d,
    tabindex: -1,
    class: `${n}-month-btn`
  }, [r.monthFormat ? Pn(l, {
    locale: r,
    format: r.monthFormat,
    generateConfig: o
  }) : h[g]]), S = r.monthBeforeYear ? [y, b] : [b, y];
  return f(Tl, D(D({}, t), {}, {
    prefixCls: v,
    onSuperPrev: c,
    onPrev: i,
    onNext: a,
    onSuperNext: s
  }), {
    default: () => [S]
  });
}
E0.displayName = "DateHeader";
E0.inheritAttrs = !1;
const XH = 6;
function pc(e) {
  const t = nn(e), {
    prefixCls: n,
    panelName: o = "date",
    keyboardConfig: r,
    active: l,
    operationRef: a,
    generateConfig: i,
    value: s,
    viewDate: c,
    onViewDateChange: u,
    onPanelChange: d,
    onSelect: p
  } = t, v = `${n}-${o}-panel`;
  a.value = {
    onKeydown: (b) => Bi(b, m({
      onLeftRight: (y) => {
        p(i.addDate(s || c, y), "key");
      },
      onCtrlLeftRight: (y) => {
        p(i.addYear(s || c, y), "key");
      },
      onUpDown: (y) => {
        p(i.addDate(s || c, y * Cu), "key");
      },
      onPageUpDown: (y) => {
        p(i.addMonth(s || c, y), "key");
      }
    }, r))
  };
  const h = (b) => {
    const y = i.addYear(c, b);
    u(y), d(null, y);
  }, g = (b) => {
    const y = i.addMonth(c, b);
    u(y), d(null, y);
  };
  return f("div", {
    class: ee(v, {
      [`${v}-active`]: l
    })
  }, [f(E0, D(D({}, t), {}, {
    prefixCls: n,
    value: s,
    viewDate: c,
    onPrevYear: () => {
      h(-1);
    },
    onNextYear: () => {
      h(1);
    },
    onPrevMonth: () => {
      g(-1);
    },
    onNextMonth: () => {
      g(1);
    },
    onMonthClick: () => {
      d("month", c);
    },
    onYearClick: () => {
      d("year", c);
    }
  }), null), f(np, D(D({}, t), {}, {
    onSelect: (b) => p(b, "mouse"),
    prefixCls: n,
    value: s,
    viewDate: c,
    rowCount: XH
  }), null)]);
}
pc.displayName = "DatePanel";
pc.inheritAttrs = !1;
const vC = jH("date", "time");
function T0(e) {
  const t = nn(e), {
    prefixCls: n,
    operationRef: o,
    generateConfig: r,
    value: l,
    defaultValue: a,
    disabledTime: i,
    showTime: s,
    onSelect: c
  } = t, u = `${n}-datetime-panel`, d = Y(null), p = Y({}), v = Y({}), h = typeof s == "object" ? m({}, s) : {};
  function g(C) {
    const w = vC.indexOf(d.value) + C;
    return vC[w] || null;
  }
  const b = (C) => {
    v.value.onBlur && v.value.onBlur(C), d.value = null;
  };
  o.value = {
    onKeydown: (C) => {
      if (C.which === ce.TAB) {
        const w = g(C.shiftKey ? -1 : 1);
        return d.value = w, w && C.preventDefault(), !0;
      }
      if (d.value) {
        const w = d.value === "date" ? p : v;
        return w.value && w.value.onKeydown && w.value.onKeydown(C), !0;
      }
      return [ce.LEFT, ce.RIGHT, ce.UP, ce.DOWN].includes(C.which) ? (d.value = "date", !0) : !1;
    },
    onBlur: b,
    onClose: b
  };
  const y = (C, w) => {
    let $ = C;
    w === "date" && !l && h.defaultValue ? ($ = r.setHour($, r.getHour(h.defaultValue)), $ = r.setMinute($, r.getMinute(h.defaultValue)), $ = r.setSecond($, r.getSecond(h.defaultValue))) : w === "time" && !l && a && ($ = r.setYear($, r.getYear(a)), $ = r.setMonth($, r.getMonth(a)), $ = r.setDate($, r.getDate(a))), c && c($, "mouse");
  }, S = i ? i(l || null) : {};
  return f("div", {
    class: ee(u, {
      [`${u}-active`]: d.value
    })
  }, [f(pc, D(D({}, t), {}, {
    operationRef: p,
    active: d.value === "date",
    onSelect: (C) => {
      y(Su(r, C, !l && typeof s == "object" ? s.defaultValue : null), "date");
    }
  }), null), f(ep, D(D(D(D({}, t), {}, {
    format: void 0
  }, h), S), {}, {
    disabledTime: null,
    defaultValue: void 0,
    operationRef: v,
    active: d.value === "time",
    onSelect: (C) => {
      y(C, "time");
    }
  }), null)]);
}
T0.displayName = "DatetimePanel";
T0.inheritAttrs = !1;
function M0(e) {
  const t = nn(e), {
    prefixCls: n,
    generateConfig: o,
    locale: r,
    value: l
  } = t, a = `${n}-cell`, i = (u) => f("td", {
    key: "week",
    class: ee(a, `${a}-week`)
  }, [o.locale.getWeek(r.locale, u)]), s = `${n}-week-panel-row`, c = (u) => ee(s, {
    [`${s}-selected`]: u3(o, r.locale, l, u)
  });
  return f(pc, D(D({}, t), {}, {
    panelName: "week",
    prefixColumn: i,
    rowClassName: c,
    keyboardConfig: {
      onLeftRight: null
    }
  }), null);
}
M0.displayName = "WeekPanel";
M0.inheritAttrs = !1;
function _0(e) {
  const t = nn(e), {
    prefixCls: n,
    generateConfig: o,
    locale: r,
    viewDate: l,
    onNextYear: a,
    onPrevYear: i,
    onYearClick: s
  } = t, {
    hideHeader: c
  } = Pr();
  if (c.value)
    return null;
  const u = `${n}-header`;
  return f(Tl, D(D({}, t), {}, {
    prefixCls: u,
    onSuperPrev: i,
    onSuperNext: a
  }), {
    default: () => [f("button", {
      type: "button",
      onClick: s,
      class: `${n}-year-btn`
    }, [Pn(l, {
      locale: r,
      format: r.yearFormat,
      generateConfig: o
    })])]
  });
}
_0.displayName = "MonthHeader";
_0.inheritAttrs = !1;
const m3 = 3, UH = 4;
function A0(e) {
  const t = nn(e), {
    prefixCls: n,
    locale: o,
    value: r,
    viewDate: l,
    generateConfig: a,
    monthCellRender: i
  } = t, {
    rangedValue: s,
    hoverRangedValue: c
  } = fc(), u = `${n}-cell`, d = tp({
    cellPrefixCls: u,
    value: r,
    generateConfig: a,
    rangedValue: s.value,
    hoverRangedValue: c.value,
    isSameCell: (g, b) => P0(a, g, b),
    isInView: () => !0,
    offsetCell: (g, b) => a.addMonth(g, b)
  }), p = o.shortMonths || (a.locale.getShortMonths ? a.locale.getShortMonths(o.locale) : []), v = a.setMonth(l, 0), h = i ? (g) => i({
    current: g,
    locale: o
  }) : void 0;
  return f(wa, D(D({}, t), {}, {
    rowNum: UH,
    colNum: m3,
    baseDate: v,
    getCellNode: h,
    getCellText: (g) => o.monthFormat ? Pn(g, {
      locale: o,
      format: o.monthFormat,
      generateConfig: a
    }) : p[a.getMonth(g)],
    getCellClassName: d,
    getCellDate: a.addMonth,
    titleCell: (g) => Pn(g, {
      locale: o,
      format: "YYYY-MM",
      generateConfig: a
    })
  }), null);
}
A0.displayName = "MonthBody";
A0.inheritAttrs = !1;
function D0(e) {
  const t = nn(e), {
    prefixCls: n,
    operationRef: o,
    onViewDateChange: r,
    generateConfig: l,
    value: a,
    viewDate: i,
    onPanelChange: s,
    onSelect: c
  } = t, u = `${n}-month-panel`;
  o.value = {
    onKeydown: (p) => Bi(p, {
      onLeftRight: (v) => {
        c(l.addMonth(a || i, v), "key");
      },
      onCtrlLeftRight: (v) => {
        c(l.addYear(a || i, v), "key");
      },
      onUpDown: (v) => {
        c(l.addMonth(a || i, v * m3), "key");
      },
      onEnter: () => {
        s("date", a || i);
      }
    })
  };
  const d = (p) => {
    const v = l.addYear(i, p);
    r(v), s(null, v);
  };
  return f("div", {
    class: u
  }, [f(_0, D(D({}, t), {}, {
    prefixCls: n,
    onPrevYear: () => {
      d(-1);
    },
    onNextYear: () => {
      d(1);
    },
    onYearClick: () => {
      s("year", i);
    }
  }), null), f(A0, D(D({}, t), {}, {
    prefixCls: n,
    onSelect: (p) => {
      c(p, "mouse"), s("date", p);
    }
  }), null)]);
}
D0.displayName = "MonthPanel";
D0.inheritAttrs = !1;
function N0(e) {
  const t = nn(e), {
    prefixCls: n,
    generateConfig: o,
    locale: r,
    viewDate: l,
    onNextYear: a,
    onPrevYear: i,
    onYearClick: s
  } = t, {
    hideHeader: c
  } = Pr();
  if (c.value)
    return null;
  const u = `${n}-header`;
  return f(Tl, D(D({}, t), {}, {
    prefixCls: u,
    onSuperPrev: i,
    onSuperNext: a
  }), {
    default: () => [f("button", {
      type: "button",
      onClick: s,
      class: `${n}-year-btn`
    }, [Pn(l, {
      locale: r,
      format: r.yearFormat,
      generateConfig: o
    })])]
  });
}
N0.displayName = "QuarterHeader";
N0.inheritAttrs = !1;
const YH = 4, qH = 1;
function R0(e) {
  const t = nn(e), {
    prefixCls: n,
    locale: o,
    value: r,
    viewDate: l,
    generateConfig: a
  } = t, {
    rangedValue: i,
    hoverRangedValue: s
  } = fc(), c = `${n}-cell`, u = tp({
    cellPrefixCls: c,
    value: r,
    generateConfig: a,
    rangedValue: i.value,
    hoverRangedValue: s.value,
    isSameCell: (p, v) => c3(a, p, v),
    isInView: () => !0,
    offsetCell: (p, v) => a.addMonth(p, v * 3)
  }), d = a.setDate(a.setMonth(l, 0), 1);
  return f(wa, D(D({}, t), {}, {
    rowNum: qH,
    colNum: YH,
    baseDate: d,
    getCellText: (p) => Pn(p, {
      locale: o,
      format: o.quarterFormat || "[Q]Q",
      generateConfig: a
    }),
    getCellClassName: u,
    getCellDate: (p, v) => a.addMonth(p, v * 3),
    titleCell: (p) => Pn(p, {
      locale: o,
      format: "YYYY-[Q]Q",
      generateConfig: a
    })
  }), null);
}
R0.displayName = "QuarterBody";
R0.inheritAttrs = !1;
function k0(e) {
  const t = nn(e), {
    prefixCls: n,
    operationRef: o,
    onViewDateChange: r,
    generateConfig: l,
    value: a,
    viewDate: i,
    onPanelChange: s,
    onSelect: c
  } = t, u = `${n}-quarter-panel`;
  o.value = {
    onKeydown: (p) => Bi(p, {
      onLeftRight: (v) => {
        c(l.addMonth(a || i, v * 3), "key");
      },
      onCtrlLeftRight: (v) => {
        c(l.addYear(a || i, v), "key");
      },
      onUpDown: (v) => {
        c(l.addYear(a || i, v), "key");
      }
    })
  };
  const d = (p) => {
    const v = l.addYear(i, p);
    r(v), s(null, v);
  };
  return f("div", {
    class: u
  }, [f(N0, D(D({}, t), {}, {
    prefixCls: n,
    onPrevYear: () => {
      d(-1);
    },
    onNextYear: () => {
      d(1);
    },
    onYearClick: () => {
      s("year", i);
    }
  }), null), f(R0, D(D({}, t), {}, {
    prefixCls: n,
    onSelect: (p) => {
      c(p, "mouse");
    }
  }), null)]);
}
k0.displayName = "QuarterPanel";
k0.inheritAttrs = !1;
function B0(e) {
  const t = nn(e), {
    prefixCls: n,
    generateConfig: o,
    viewDate: r,
    onPrevDecade: l,
    onNextDecade: a,
    onDecadeClick: i
  } = t, {
    hideHeader: s
  } = Pr();
  if (s.value)
    return null;
  const c = `${n}-header`, u = o.getYear(r), d = Math.floor(u / pl) * pl, p = d + pl - 1;
  return f(Tl, D(D({}, t), {}, {
    prefixCls: c,
    onSuperPrev: l,
    onSuperNext: a
  }), {
    default: () => [f("button", {
      type: "button",
      onClick: i,
      class: `${n}-decade-btn`
    }, [d, Ot("-"), p])]
  });
}
B0.displayName = "YearHeader";
B0.inheritAttrs = !1;
const om = 3, gC = 4;
function F0(e) {
  const t = nn(e), {
    prefixCls: n,
    value: o,
    viewDate: r,
    locale: l,
    generateConfig: a
  } = t, {
    rangedValue: i,
    hoverRangedValue: s
  } = fc(), c = `${n}-cell`, u = a.getYear(r), d = Math.floor(u / pl) * pl, p = d + pl - 1, v = a.setYear(r, d - Math.ceil((om * gC - pl) / 2)), h = (b) => {
    const y = a.getYear(b);
    return d <= y && y <= p;
  }, g = tp({
    cellPrefixCls: c,
    value: o,
    generateConfig: a,
    rangedValue: i.value,
    hoverRangedValue: s.value,
    isSameCell: (b, y) => Jf(a, b, y),
    isInView: h,
    offsetCell: (b, y) => a.addYear(b, y)
  });
  return f(wa, D(D({}, t), {}, {
    rowNum: gC,
    colNum: om,
    baseDate: v,
    getCellText: a.getYear,
    getCellClassName: g,
    getCellDate: a.addYear,
    titleCell: (b) => Pn(b, {
      locale: l,
      format: "YYYY",
      generateConfig: a
    })
  }), null);
}
F0.displayName = "YearBody";
F0.inheritAttrs = !1;
const pl = 10;
function L0(e) {
  const t = nn(e), {
    prefixCls: n,
    operationRef: o,
    onViewDateChange: r,
    generateConfig: l,
    value: a,
    viewDate: i,
    sourceMode: s,
    onSelect: c,
    onPanelChange: u
  } = t, d = `${n}-year-panel`;
  o.value = {
    onKeydown: (v) => Bi(v, {
      onLeftRight: (h) => {
        c(l.addYear(a || i, h), "key");
      },
      onCtrlLeftRight: (h) => {
        c(l.addYear(a || i, h * pl), "key");
      },
      onUpDown: (h) => {
        c(l.addYear(a || i, h * om), "key");
      },
      onEnter: () => {
        u(s === "date" ? "date" : "month", a || i);
      }
    })
  };
  const p = (v) => {
    const h = l.addYear(i, v * 10);
    r(h), u(null, h);
  };
  return f("div", {
    class: d
  }, [f(B0, D(D({}, t), {}, {
    prefixCls: n,
    onPrevDecade: () => {
      p(-1);
    },
    onNextDecade: () => {
      p(1);
    },
    onDecadeClick: () => {
      u("decade", i);
    }
  }), null), f(F0, D(D({}, t), {}, {
    prefixCls: n,
    onSelect: (v) => {
      u(s === "date" ? "date" : "month", v), c(v, "mouse");
    }
  }), null)]);
}
L0.displayName = "YearPanel";
L0.inheritAttrs = !1;
function h3(e, t, n) {
  return n ? f("div", {
    class: `${e}-footer-extra`
  }, [n(t)]) : null;
}
function b3(e) {
  let {
    prefixCls: t,
    components: n = {},
    needConfirmButton: o,
    onNow: r,
    onOk: l,
    okDisabled: a,
    showNow: i,
    locale: s
  } = e, c, u;
  if (o) {
    const d = n.button || "button";
    r && i !== !1 && (c = f("li", {
      class: `${t}-now`
    }, [f("a", {
      class: `${t}-now-btn`,
      onClick: r
    }, [s.now])])), u = o && f("li", {
      class: `${t}-ok`
    }, [f(d, {
      disabled: a,
      onClick: (p) => {
        p.stopPropagation(), l && l();
      }
    }, {
      default: () => [s.ok]
    })]);
  }
  return !c && !u ? null : f("ul", {
    class: `${t}-ranges`
  }, [c, u]);
}
function ZH() {
  return Z({
    name: "PickerPanel",
    inheritAttrs: !1,
    props: {
      prefixCls: String,
      locale: Object,
      generateConfig: Object,
      value: Object,
      defaultValue: Object,
      pickerValue: Object,
      defaultPickerValue: Object,
      disabledDate: Function,
      mode: String,
      picker: {
        type: String,
        default: "date"
      },
      tabindex: {
        type: [Number, String],
        default: 0
      },
      showNow: {
        type: Boolean,
        default: void 0
      },
      showTime: [Boolean, Object],
      showToday: Boolean,
      renderExtraFooter: Function,
      dateRender: Function,
      hideHeader: {
        type: Boolean,
        default: void 0
      },
      onSelect: Function,
      onChange: Function,
      onPanelChange: Function,
      onMousedown: Function,
      onPickerValueChange: Function,
      onOk: Function,
      components: Object,
      direction: String,
      hourStep: {
        type: Number,
        default: 1
      },
      minuteStep: {
        type: Number,
        default: 1
      },
      secondStep: {
        type: Number,
        default: 1
      }
    },
    setup(e, t) {
      let {
        attrs: n
      } = t;
      const o = P(() => e.picker === "date" && !!e.showTime || e.picker === "time"), r = P(() => 24 % e.hourStep === 0), l = P(() => 60 % e.minuteStep === 0), a = P(() => 60 % e.secondStep === 0);
      process.env.NODE_ENV !== "production" && Le(() => {
        const {
          generateConfig: k,
          value: B,
          hourStep: F = 1,
          minuteStep: L = 1,
          secondStep: j = 1
        } = e;
        ct(!B || k.isValidate(B), "Invalidate date pass to `value`."), ct(!B || k.isValidate(B), "Invalidate date pass to `defaultValue`."), ct(r.value, `\`hourStep\` ${F} is invalid. It should be a factor of 24.`), ct(l.value, `\`minuteStep\` ${L} is invalid. It should be a factor of 60.`), ct(a.value, `\`secondStep\` ${j} is invalid. It should be a factor of 60.`);
      });
      const i = Pr(), {
        operationRef: s,
        onSelect: c,
        hideRanges: u,
        defaultOpenValue: d
      } = i, {
        inRange: p,
        panelPosition: v,
        rangedValue: h,
        hoverRangedValue: g
      } = fc(), b = Y({}), [y, S] = Rt(null, {
        value: Te(e, "value"),
        defaultValue: e.defaultValue,
        postState: (k) => !k && (d != null && d.value) && e.picker === "time" ? d.value : k
      }), [C, w] = Rt(null, {
        value: Te(e, "pickerValue"),
        defaultValue: e.defaultPickerValue || y.value,
        postState: (k) => {
          const {
            generateConfig: B,
            showTime: F,
            defaultValue: L
          } = e, j = B.getNow();
          return k ? !y.value && e.showTime ? typeof F == "object" ? Su(B, Array.isArray(k) ? k[0] : k, F.defaultValue || j) : L ? Su(B, Array.isArray(k) ? k[0] : k, L) : Su(B, Array.isArray(k) ? k[0] : k, j) : k : j;
        }
      }), $ = (k) => {
        w(k), e.onPickerValueChange && e.onPickerValueChange(k);
      }, O = (k) => {
        const B = FH[e.picker];
        return B ? B(k) : k;
      }, [x, I] = Rt(() => e.picker === "time" ? "time" : O("date"), {
        value: Te(e, "mode")
      });
      ie(() => e.picker, () => {
        I(e.picker);
      });
      const E = Y(x.value), _ = (k) => {
        E.value = k;
      }, M = (k, B) => {
        const {
          onPanelChange: F,
          generateConfig: L
        } = e, j = O(k || x.value);
        _(x.value), I(j), F && (x.value !== j || ri(L, C.value, C.value)) && F(B, j);
      }, R = function(k, B) {
        let F = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
        const {
          picker: L,
          generateConfig: j,
          onSelect: H,
          onChange: K,
          disabledDate: X
        } = e;
        (x.value === L || F) && (S(k), H && H(k), c && c(k, B), K && !ri(j, k, y.value) && !(X != null && X(k)) && K(k));
      }, A = (k) => b.value && b.value.onKeydown ? ([ce.LEFT, ce.RIGHT, ce.UP, ce.DOWN, ce.PAGE_UP, ce.PAGE_DOWN, ce.ENTER].includes(k.which) && k.preventDefault(), b.value.onKeydown(k)) : (ct(!1, "Panel not correct handle keyDown event. Please help to fire issue about this."), !1), z = (k) => {
        b.value && b.value.onBlur && b.value.onBlur(k);
      }, T = () => {
        const {
          generateConfig: k,
          hourStep: B,
          minuteStep: F,
          secondStep: L
        } = e, j = k.getNow(), H = TH(k.getHour(j), k.getMinute(j), k.getSecond(j), r.value ? B : 1, l.value ? F : 1, a.value ? L : 1), K = l3(
          k,
          j,
          H[0],
          // hour
          H[1],
          // minute
          H[2]
        );
        R(K, "submit");
      }, N = P(() => {
        const {
          prefixCls: k,
          direction: B
        } = e;
        return ee(`${k}-panel`, {
          [`${k}-panel-has-range`]: h && h.value && h.value[0] && h.value[1],
          [`${k}-panel-has-range-hover`]: g && g.value && g.value[0] && g.value[1],
          [`${k}-panel-rtl`]: B === "rtl"
        });
      });
      return $0(m(m({}, i), {
        mode: x,
        hideHeader: P(() => {
          var k;
          return e.hideHeader !== void 0 ? e.hideHeader : (k = i.hideHeader) === null || k === void 0 ? void 0 : k.value;
        }),
        hidePrevBtn: P(() => p.value && v.value === "right"),
        hideNextBtn: P(() => p.value && v.value === "left")
      })), ie(() => e.value, () => {
        e.value && w(e.value);
      }), () => {
        const {
          prefixCls: k = "ant-picker",
          locale: B,
          generateConfig: F,
          disabledDate: L,
          picker: j = "date",
          tabindex: H = 0,
          showNow: K,
          showTime: X,
          showToday: W,
          renderExtraFooter: q,
          onMousedown: J,
          onOk: ne,
          components: te
        } = e;
        s && v.value !== "right" && (s.value = {
          onKeydown: A,
          onClose: () => {
            b.value && b.value.onClose && b.value.onClose();
          }
        });
        let G;
        const U = m(m(m({}, n), e), {
          operationRef: b,
          prefixCls: k,
          viewDate: C.value,
          value: y.value,
          onViewDateChange: $,
          sourceMode: E.value,
          onPanelChange: M,
          disabledDate: L
        });
        switch (delete U.onChange, delete U.onSelect, x.value) {
          case "decade":
            G = f(O0, D(D({}, U), {}, {
              onSelect: (Ce, fe) => {
                $(Ce), R(Ce, fe);
              }
            }), null);
            break;
          case "year":
            G = f(L0, D(D({}, U), {}, {
              onSelect: (Ce, fe) => {
                $(Ce), R(Ce, fe);
              }
            }), null);
            break;
          case "month":
            G = f(D0, D(D({}, U), {}, {
              onSelect: (Ce, fe) => {
                $(Ce), R(Ce, fe);
              }
            }), null);
            break;
          case "quarter":
            G = f(k0, D(D({}, U), {}, {
              onSelect: (Ce, fe) => {
                $(Ce), R(Ce, fe);
              }
            }), null);
            break;
          case "week":
            G = f(M0, D(D({}, U), {}, {
              onSelect: (Ce, fe) => {
                $(Ce), R(Ce, fe);
              }
            }), null);
            break;
          case "time":
            delete U.showTime, G = f(ep, D(D(D({}, U), typeof X == "object" ? X : null), {}, {
              onSelect: (Ce, fe) => {
                $(Ce), R(Ce, fe);
              }
            }), null);
            break;
          default:
            X ? G = f(T0, D(D({}, U), {}, {
              onSelect: (Ce, fe) => {
                $(Ce), R(Ce, fe);
              }
            }), null) : G = f(pc, D(D({}, U), {}, {
              onSelect: (Ce, fe) => {
                $(Ce), R(Ce, fe);
              }
            }), null);
        }
        let re, se;
        u != null && u.value || (re = h3(k, x.value, q), se = b3({
          prefixCls: k,
          components: te,
          needConfirmButton: o.value,
          okDisabled: !y.value || L && L(y.value),
          locale: B,
          showNow: K,
          onNow: o.value && T,
          onOk: () => {
            y.value && (R(y.value, "submit", !0), ne && ne(y.value));
          }
        }));
        let me;
        if (W && x.value === "date" && j === "date" && !X) {
          const Ce = F.getNow(), fe = `${k}-today-btn`, be = L && L(Ce);
          me = f("a", {
            class: ee(fe, be && `${fe}-disabled`),
            "aria-disabled": be,
            onClick: () => {
              be || R(Ce, "mouse", !0);
            }
          }, [B.today]);
        }
        return f("div", {
          tabindex: H,
          class: ee(N.value, n.class),
          style: n.style,
          onKeydown: A,
          onBlur: z,
          onMousedown: J
        }, [G, re || se || me ? f("div", {
          class: `${k}-footer`
        }, [re, se, me]) : null]);
      };
    }
  });
}
const QH = ZH(), z0 = (e) => f(QH, e), JH = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
};
function y3(e, t) {
  let {
    slots: n
  } = t;
  const {
    prefixCls: o,
    popupStyle: r,
    visible: l,
    dropdownClassName: a,
    dropdownAlign: i,
    transitionName: s,
    getPopupContainer: c,
    range: u,
    popupPlacement: d,
    direction: p
  } = nn(e), v = `${o}-dropdown`;
  return f($a, {
    showAction: [],
    hideAction: [],
    popupPlacement: d !== void 0 ? d : p === "rtl" ? "bottomRight" : "bottomLeft",
    builtinPlacements: JH,
    prefixCls: v,
    popupTransitionName: s,
    popupAlign: i,
    popupVisible: l,
    popupClassName: ee(a, {
      [`${v}-range`]: u,
      [`${v}-rtl`]: p === "rtl"
    }),
    popupStyle: r,
    getPopupContainer: c
  }, {
    default: n.default,
    popup: n.popupElement
  });
}
const S3 = Z({
  name: "PresetPanel",
  props: {
    prefixCls: String,
    presets: {
      type: Array,
      default: () => []
    },
    onClick: Function,
    onHover: Function
  },
  setup(e) {
    return () => e.presets.length ? f("div", {
      class: `${e.prefixCls}-presets`
    }, [f("ul", null, [e.presets.map((t, n) => {
      let {
        label: o,
        value: r
      } = t;
      return f("li", {
        key: n,
        onClick: (l) => {
          l.stopPropagation(), e.onClick(r);
        },
        onMouseenter: () => {
          var l;
          (l = e.onHover) === null || l === void 0 || l.call(e, r);
        },
        onMouseleave: () => {
          var l;
          (l = e.onHover) === null || l === void 0 || l.call(e, null);
        }
      }, [o]);
    })])]) : null;
  }
});
function rm(e) {
  let {
    open: t,
    value: n,
    isClickOutside: o,
    triggerOpen: r,
    forwardKeydown: l,
    onKeydown: a,
    blurToCancel: i,
    onSubmit: s,
    onCancel: c,
    onFocus: u,
    onBlur: d
  } = e;
  const p = Q(!1), v = Q(!1), h = Q(!1), g = Q(!1), b = Q(!1), y = P(() => ({
    onMousedown: () => {
      p.value = !0, r(!0);
    },
    onKeydown: (C) => {
      if (a(C, () => {
        b.value = !0;
      }), !b.value) {
        switch (C.which) {
          case ce.ENTER: {
            t.value ? s() !== !1 && (p.value = !0) : r(!0), C.preventDefault();
            return;
          }
          case ce.TAB: {
            p.value && t.value && !C.shiftKey ? (p.value = !1, C.preventDefault()) : !p.value && t.value && !l(C) && C.shiftKey && (p.value = !0, C.preventDefault());
            return;
          }
          case ce.ESC: {
            p.value = !0, c();
            return;
          }
        }
        !t.value && ![ce.SHIFT].includes(C.which) ? r(!0) : p.value || l(C);
      }
    },
    onFocus: (C) => {
      p.value = !0, v.value = !0, u && u(C);
    },
    onBlur: (C) => {
      if (h.value || !o(document.activeElement)) {
        h.value = !1;
        return;
      }
      i.value ? setTimeout(() => {
        let {
          activeElement: w
        } = document;
        for (; w && w.shadowRoot; )
          w = w.shadowRoot.activeElement;
        o(w) && c();
      }, 0) : t.value && (r(!1), g.value && s()), v.value = !1, d && d(C);
    }
  }));
  ie(t, () => {
    g.value = !1;
  }), ie(n, () => {
    g.value = !0;
  });
  const S = Q();
  return Ke(() => {
    S.value = AH((C) => {
      const w = DH(C);
      if (t.value) {
        const $ = o(w);
        $ ? (!v.value || $) && r(!1) : (h.value = !0, Ze(() => {
          h.value = !1;
        }));
      }
    });
  }), et(() => {
    S.value && S.value();
  }), [y, {
    focused: v,
    typing: p
  }];
}
function lm(e) {
  let {
    valueTexts: t,
    onTextChange: n
  } = e;
  const o = Y("");
  function r(a) {
    o.value = a, n(a);
  }
  function l() {
    o.value = t.value[0];
  }
  return ie(() => [...t.value], function(a) {
    let i = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    a.join("||") !== i.join("||") && t.value.every((s) => s !== o.value) && l();
  }, {
    immediate: !0
  }), [o, r, l];
}
function kd(e, t) {
  let {
    formatList: n,
    generateConfig: o,
    locale: r
  } = t;
  const l = zh(() => {
    if (!e.value)
      return [[""], ""];
    let s = "";
    const c = [];
    for (let u = 0; u < n.value.length; u += 1) {
      const d = n.value[u], p = Pn(e.value, {
        generateConfig: o.value,
        locale: r.value,
        format: d
      });
      c.push(p), u === 0 && (s = p);
    }
    return [c, s];
  }, [e, n], (s, c) => c[0] !== s[0] || !Ha(c[1], s[1])), a = P(() => l.value[0]), i = P(() => l.value[1]);
  return [a, i];
}
function am(e, t) {
  let {
    formatList: n,
    generateConfig: o,
    locale: r
  } = t;
  const l = Y(null);
  let a;
  function i(d) {
    let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (Ze.cancel(a), p) {
      l.value = d;
      return;
    }
    a = Ze(() => {
      l.value = d;
    });
  }
  const [, s] = kd(l, {
    formatList: n,
    generateConfig: o,
    locale: r
  });
  function c(d) {
    i(d);
  }
  function u() {
    let d = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
    i(null, d);
  }
  return ie(e, () => {
    u(!0);
  }), et(() => {
    Ze.cancel(a);
  }), [s, c, u];
}
function C3(e, t) {
  return P(() => e != null && e.value ? e.value : t != null && t.value ? (lo(!1, "`ranges` is deprecated. Please use `presets` instead."), Object.keys(t.value).map((o) => {
    const r = t.value[o], l = typeof r == "function" ? r() : r;
    return {
      label: o,
      value: l
    };
  })) : []);
}
function $3(e) {
  const {
    picker: t,
    disabledHours: n,
    disabledMinutes: o,
    disabledSeconds: r
  } = e;
  t === "time" && (n || o || r) && ct(!1, "'disabledHours', 'disabledMinutes', 'disabledSeconds' will be removed in the next major version, please use 'disabledTime' instead.");
}
function ej() {
  return Z({
    name: "Picker",
    inheritAttrs: !1,
    props: ["prefixCls", "id", "tabindex", "dropdownClassName", "dropdownAlign", "popupStyle", "transitionName", "generateConfig", "locale", "inputReadOnly", "allowClear", "autofocus", "showTime", "showNow", "showHour", "showMinute", "showSecond", "picker", "format", "use12Hours", "value", "defaultValue", "open", "defaultOpen", "defaultOpenValue", "suffixIcon", "presets", "clearIcon", "disabled", "disabledDate", "placeholder", "getPopupContainer", "panelRender", "inputRender", "onChange", "onOpenChange", "onPanelChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onContextmenu", "onClick", "onKeydown", "onSelect", "direction", "autocomplete", "showToday", "renderExtraFooter", "dateRender", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions"],
    setup(e, t) {
      let {
        attrs: n,
        expose: o
      } = t;
      const r = Y(null), l = P(() => e.presets), a = C3(l), i = P(() => {
        var L;
        return (L = e.picker) !== null && L !== void 0 ? L : "date";
      }), s = P(() => i.value === "date" && !!e.showTime || i.value === "time");
      process.env.NODE_ENV !== "production" && $3(e);
      const c = P(() => p3(a3(e.format, i.value, e.showTime, e.use12Hours))), u = Y(null), d = Y(null), p = Y(null), [v, h] = Rt(null, {
        value: Te(e, "value"),
        defaultValue: e.defaultValue
      }), g = Y(v.value), b = (L) => {
        g.value = L;
      }, y = Y(null), [S, C] = Rt(!1, {
        value: Te(e, "open"),
        defaultValue: e.defaultOpen,
        postState: (L) => e.disabled ? !1 : L,
        onChange: (L) => {
          e.onOpenChange && e.onOpenChange(L), !L && y.value && y.value.onClose && y.value.onClose();
        }
      }), [w, $] = kd(g, {
        formatList: c,
        generateConfig: Te(e, "generateConfig"),
        locale: Te(e, "locale")
      }), [O, x, I] = lm({
        valueTexts: w,
        onTextChange: (L) => {
          const j = d3(L, {
            locale: e.locale,
            formatList: c.value,
            generateConfig: e.generateConfig
          });
          j && (!e.disabledDate || !e.disabledDate(j)) && b(j);
        }
      }), E = (L) => {
        const {
          onChange: j,
          generateConfig: H,
          locale: K
        } = e;
        b(L), h(L), j && !ri(H, v.value, L) && j(L, L ? Pn(L, {
          generateConfig: H,
          locale: K,
          format: c.value[0]
        }) : "");
      }, _ = (L) => {
        e.disabled && L || C(L);
      }, M = (L) => S.value && y.value && y.value.onKeydown ? y.value.onKeydown(L) : (ct(!1, "Picker not correct forward Keydown operation. Please help to fire issue about this."), !1), R = function() {
        e.onMouseup && e.onMouseup(...arguments), r.value && (r.value.focus(), _(!0));
      }, [A, {
        focused: z,
        typing: T
      }] = rm({
        blurToCancel: s,
        open: S,
        value: O,
        triggerOpen: _,
        forwardKeydown: M,
        isClickOutside: (L) => !s3([u.value, d.value, p.value], L),
        onSubmit: () => (
          // When user typing disabledDate with keyboard and enter, this value will be empty
          !g.value || // Normal disabled check
          e.disabledDate && e.disabledDate(g.value) ? !1 : (E(g.value), _(!1), I(), !0)
        ),
        onCancel: () => {
          _(!1), b(v.value), I();
        },
        onKeydown: (L, j) => {
          var H;
          (H = e.onKeydown) === null || H === void 0 || H.call(e, L, j);
        },
        onFocus: (L) => {
          var j;
          (j = e.onFocus) === null || j === void 0 || j.call(e, L);
        },
        onBlur: (L) => {
          var j;
          (j = e.onBlur) === null || j === void 0 || j.call(e, L);
        }
      });
      ie([S, w], () => {
        S.value || (b(v.value), !w.value.length || w.value[0] === "" ? x("") : $.value !== O.value && I());
      }), ie(i, () => {
        S.value || I();
      }), ie(v, () => {
        b(v.value);
      });
      const [N, k, B] = am(O, {
        formatList: c,
        generateConfig: Te(e, "generateConfig"),
        locale: Te(e, "locale")
      }), F = (L, j) => {
        (j === "submit" || j !== "key" && !s.value) && (E(L), _(!1));
      };
      return $0({
        operationRef: y,
        hideHeader: P(() => i.value === "time"),
        onSelect: F,
        open: S,
        defaultOpenValue: Te(e, "defaultOpenValue"),
        onDateMouseenter: k,
        onDateMouseleave: B
      }), o({
        focus: () => {
          r.value && r.value.focus();
        },
        blur: () => {
          r.value && r.value.blur();
        }
      }), () => {
        const {
          prefixCls: L = "rc-picker",
          id: j,
          tabindex: H,
          dropdownClassName: K,
          dropdownAlign: X,
          popupStyle: W,
          transitionName: q,
          generateConfig: J,
          locale: ne,
          inputReadOnly: te,
          allowClear: G,
          autofocus: U,
          picker: re = "date",
          defaultOpenValue: se,
          suffixIcon: me,
          clearIcon: Ce,
          disabled: fe,
          placeholder: be,
          getPopupContainer: ue,
          panelRender: de,
          onMousedown: Se,
          onMouseenter: xe,
          onMouseleave: he,
          onContextmenu: we,
          onClick: Me,
          onSelect: ae,
          direction: oe,
          autocomplete: pe = "off"
        } = e, Pe = m(m(m({}, e), n), {
          class: ee({
            [`${L}-panel-focused`]: !T.value
          }),
          style: void 0,
          pickerValue: void 0,
          onPickerValueChange: void 0,
          onChange: null
        });
        let Ee = f("div", {
          class: `${L}-panel-layout`
        }, [f(S3, {
          prefixCls: L,
          presets: a.value,
          onClick: (De) => {
            E(De), _(!1);
          }
        }, null), f(z0, D(D({}, Pe), {}, {
          generateConfig: J,
          value: g.value,
          locale: ne,
          tabindex: -1,
          onSelect: (De) => {
            ae == null || ae(De), b(De);
          },
          direction: oe,
          onPanelChange: (De, We) => {
            const {
              onPanelChange: at
            } = e;
            B(!0), at == null || at(De, We);
          }
        }), null)]);
        de && (Ee = de(Ee));
        const ze = f("div", {
          class: `${L}-panel-container`,
          ref: u,
          onMousedown: (De) => {
            De.preventDefault();
          }
        }, [Ee]);
        let ge;
        me && (ge = f("span", {
          class: `${L}-suffix`
        }, [me]));
        let ye;
        G && v.value && !fe && (ye = f("span", {
          onMousedown: (De) => {
            De.preventDefault(), De.stopPropagation();
          },
          onMouseup: (De) => {
            De.preventDefault(), De.stopPropagation(), E(null), _(!1);
          },
          class: `${L}-clear`,
          role: "button"
        }, [Ce || f("span", {
          class: `${L}-clear-btn`
        }, null)]));
        const $e = m(m(m(m({
          id: j,
          tabindex: H,
          disabled: fe,
          readonly: te || typeof c.value[0] == "function" || !T.value,
          value: N.value || O.value,
          onInput: (De) => {
            x(De.target.value);
          },
          autofocus: U,
          placeholder: be,
          ref: r,
          title: O.value
        }, A.value), {
          size: i3(re, c.value[0], J)
        }), v3(e)), {
          autocomplete: pe
        }), Ae = e.inputRender ? e.inputRender($e) : f("input", $e, null);
        process.env.NODE_ENV !== "production" && ct(!se, "`defaultOpenValue` may confuse user for the current value status. Please use `defaultValue` instead.");
        const Ve = oe === "rtl" ? "bottomRight" : "bottomLeft";
        return f("div", {
          ref: p,
          class: ee(L, n.class, {
            [`${L}-disabled`]: fe,
            [`${L}-focused`]: z.value,
            [`${L}-rtl`]: oe === "rtl"
          }),
          style: n.style,
          onMousedown: Se,
          onMouseup: R,
          onMouseenter: xe,
          onMouseleave: he,
          onContextmenu: we,
          onClick: Me
        }, [f("div", {
          class: ee(`${L}-input`, {
            [`${L}-input-placeholder`]: !!N.value
          }),
          ref: d
        }, [Ae, ge, ye]), f(y3, {
          visible: S.value,
          popupStyle: W,
          prefixCls: L,
          dropdownClassName: K,
          dropdownAlign: X,
          getPopupContainer: ue,
          transitionName: q,
          popupPlacement: Ve,
          direction: oe
        }, {
          default: () => [f("div", {
            style: {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => ze
        })]);
      };
    }
  });
}
const tj = ej();
function nj(e, t) {
  let {
    picker: n,
    locale: o,
    selectedValue: r,
    disabledDate: l,
    disabled: a,
    generateConfig: i
  } = e;
  const s = P(() => $t(r.value, 0)), c = P(() => $t(r.value, 1));
  function u(g) {
    return i.value.locale.getWeekFirstDate(o.value.locale, g);
  }
  function d(g) {
    const b = i.value.getYear(g), y = i.value.getMonth(g);
    return b * 100 + y;
  }
  function p(g) {
    const b = i.value.getYear(g), y = tm(i.value, g);
    return b * 10 + y;
  }
  return [(g) => {
    var b;
    if (l && (!((b = l == null ? void 0 : l.value) === null || b === void 0) && b.call(l, g)))
      return !0;
    if (a[1] && c)
      return !Hr(i.value, g, c.value) && i.value.isAfter(g, c.value);
    if (t.value[1] && c.value)
      switch (n.value) {
        case "quarter":
          return p(g) > p(c.value);
        case "month":
          return d(g) > d(c.value);
        case "week":
          return u(g) > u(c.value);
        default:
          return !Hr(i.value, g, c.value) && i.value.isAfter(g, c.value);
      }
    return !1;
  }, (g) => {
    var b;
    if (!((b = l.value) === null || b === void 0) && b.call(l, g))
      return !0;
    if (a[0] && s)
      return !Hr(i.value, g, c.value) && i.value.isAfter(s.value, g);
    if (t.value[0] && s.value)
      switch (n.value) {
        case "quarter":
          return p(g) < p(s.value);
        case "month":
          return d(g) < d(s.value);
        case "week":
          return u(g) < u(s.value);
        default:
          return !Hr(i.value, g, s.value) && i.value.isAfter(s.value, g);
      }
    return !1;
  }];
}
function oj(e, t, n, o) {
  const r = bs(e, n, o, 1);
  function l(a) {
    return a(e, t) ? "same" : a(r, t) ? "closing" : "far";
  }
  switch (n) {
    case "year":
      return l((a, i) => LH(o, a, i));
    case "quarter":
    case "month":
      return l((a, i) => Jf(o, a, i));
    default:
      return l((a, i) => P0(o, a, i));
  }
}
function rj(e, t, n, o) {
  const r = $t(e, 0), l = $t(e, 1);
  if (t === 0)
    return r;
  if (r && l)
    switch (oj(r, l, n, o)) {
      case "same":
        return r;
      case "closing":
        return r;
      default:
        return bs(l, n, o, -1);
    }
  return r;
}
function lj(e) {
  let {
    values: t,
    picker: n,
    defaultDates: o,
    generateConfig: r
  } = e;
  const l = Y([$t(o, 0), $t(o, 1)]), a = Y(null), i = P(() => $t(t.value, 0)), s = P(() => $t(t.value, 1)), c = (v) => l.value[v] ? l.value[v] : $t(a.value, v) || rj(t.value, v, n.value, r.value) || i.value || s.value || r.value.getNow(), u = Y(null), d = Y(null);
  Le(() => {
    u.value = c(0), d.value = c(1);
  });
  function p(v, h) {
    if (v) {
      let g = Do(a.value, v, h);
      l.value = Do(l.value, null, h) || [null, null];
      const b = (h + 1) % 2;
      $t(t.value, b) || (g = Do(g, v, b)), a.value = g;
    } else
      (i.value || s.value) && (a.value = null);
  }
  return [u, d, p];
}
function w3(e) {
  return lT() ? (aT(e), !0) : !1;
}
function aj(e) {
  return typeof e == "function" ? e() : hn(e);
}
function H0(e) {
  var t;
  const n = aj(e);
  return (t = n == null ? void 0 : n.$el) !== null && t !== void 0 ? t : n;
}
function ij(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !0;
  Wn() ? Ke(e) : t ? e() : rt(e);
}
function x3(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = Q(), o = () => n.value = !!e();
  return o(), ij(o, t), n;
}
var gv;
const O3 = typeof window < "u";
O3 && (!((gv = window == null ? void 0 : window.navigator) === null || gv === void 0) && gv.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
const P3 = O3 ? window : void 0;
var sj = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function cj(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    window: o = P3
  } = n, r = sj(n, ["window"]);
  let l;
  const a = x3(() => o && "ResizeObserver" in o), i = () => {
    l && (l.disconnect(), l = void 0);
  }, s = ie(() => H0(e), (u) => {
    i(), a.value && o && u && (l = new ResizeObserver(t), l.observe(u, r));
  }, {
    immediate: !0,
    flush: "post"
  }), c = () => {
    i(), s();
  };
  return w3(c), {
    isSupported: a,
    stop: c
  };
}
function qi(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    width: 0,
    height: 0
  }, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    box: o = "content-box"
  } = n, r = Q(t.width), l = Q(t.height);
  return cj(e, (a) => {
    let [i] = a;
    const s = o === "border-box" ? i.borderBoxSize : o === "content-box" ? i.contentBoxSize : i.devicePixelContentBoxSize;
    s ? (r.value = s.reduce((c, u) => {
      let {
        inlineSize: d
      } = u;
      return c + d;
    }, 0), l.value = s.reduce((c, u) => {
      let {
        blockSize: d
      } = u;
      return c + d;
    }, 0)) : (r.value = i.contentRect.width, l.value = i.contentRect.height);
  }, n), ie(() => H0(e), (a) => {
    r.value = a ? t.width : 0, l.value = a ? t.height : 0;
  }), {
    width: r,
    height: l
  };
}
function mC(e, t) {
  return e && e[0] && e[1] && t.isAfter(e[0], e[1]) ? [e[1], e[0]] : e;
}
function hC(e, t, n, o) {
  return !!(e || o && o[t] || n[(t + 1) % 2]);
}
function uj() {
  return Z({
    name: "RangerPicker",
    inheritAttrs: !1,
    props: ["prefixCls", "id", "popupStyle", "dropdownClassName", "transitionName", "dropdownAlign", "getPopupContainer", "generateConfig", "locale", "placeholder", "autofocus", "disabled", "format", "picker", "showTime", "showNow", "showHour", "showMinute", "showSecond", "use12Hours", "separator", "value", "defaultValue", "defaultPickerValue", "open", "defaultOpen", "disabledDate", "disabledTime", "dateRender", "panelRender", "ranges", "allowEmpty", "allowClear", "suffixIcon", "clearIcon", "pickerRef", "inputReadOnly", "mode", "renderExtraFooter", "onChange", "onOpenChange", "onPanelChange", "onCalendarChange", "onFocus", "onBlur", "onMousedown", "onMouseup", "onMouseenter", "onMouseleave", "onClick", "onOk", "onKeydown", "components", "order", "direction", "activePickerIndex", "autocomplete", "minuteStep", "hourStep", "secondStep", "hideDisabledOptions", "disabledMinutes", "presets", "prevIcon", "nextIcon", "superPrevIcon", "superNextIcon"],
    setup(e, t) {
      let {
        attrs: n,
        expose: o
      } = t;
      const r = P(() => e.picker === "date" && !!e.showTime || e.picker === "time"), l = P(() => e.presets), a = P(() => e.ranges), i = C3(l, a), s = Y({}), c = Y(null), u = Y(null), d = Y(null), p = Y(null), v = Y(null), h = Y(null), g = Y(null), b = Y(null);
      process.env.NODE_ENV !== "production" && $3(e);
      const y = P(() => p3(a3(e.format, e.picker, e.showTime, e.use12Hours))), [S, C] = Rt(0, {
        value: Te(e, "activePickerIndex")
      }), w = Y(null), $ = P(() => {
        const {
          disabled: Oe
        } = e;
        return Array.isArray(Oe) ? Oe : [Oe || !1, Oe || !1];
      }), [O, x] = Rt(null, {
        value: Te(e, "value"),
        defaultValue: e.defaultValue,
        postState: (Oe) => e.picker === "time" && !e.order ? Oe : mC(Oe, e.generateConfig)
      }), [I, E, _] = lj({
        values: O,
        picker: Te(e, "picker"),
        defaultDates: e.defaultPickerValue,
        generateConfig: Te(e, "generateConfig")
      }), [M, R] = Rt(O.value, {
        postState: (Oe) => {
          let Ue = Oe;
          if ($.value[0] && $.value[1])
            return Ue;
          for (let Ye = 0; Ye < 2; Ye += 1)
            $.value[Ye] && !$t(Ue, Ye) && !$t(e.allowEmpty, Ye) && (Ue = Do(Ue, e.generateConfig.getNow(), Ye));
          return Ue;
        }
      }), [A, z] = Rt([e.picker, e.picker], {
        value: Te(e, "mode")
      });
      ie(() => e.picker, () => {
        z([e.picker, e.picker]);
      });
      const T = (Oe, Ue) => {
        var Ye;
        z(Oe), (Ye = e.onPanelChange) === null || Ye === void 0 || Ye.call(e, Ue, Oe);
      }, [N, k] = nj({
        picker: Te(e, "picker"),
        selectedValue: M,
        locale: Te(e, "locale"),
        disabled: $,
        disabledDate: Te(e, "disabledDate"),
        generateConfig: Te(e, "generateConfig")
      }, s), [B, F] = Rt(!1, {
        value: Te(e, "open"),
        defaultValue: e.defaultOpen,
        postState: (Oe) => $.value[S.value] ? !1 : Oe,
        onChange: (Oe) => {
          var Ue;
          (Ue = e.onOpenChange) === null || Ue === void 0 || Ue.call(e, Oe), !Oe && w.value && w.value.onClose && w.value.onClose();
        }
      }), L = P(() => B.value && S.value === 0), j = P(() => B.value && S.value === 1), H = Y(0), K = Y(0), X = Y(0), {
        width: W
      } = qi(c);
      ie([B, W], () => {
        !B.value && c.value && (X.value = W.value);
      });
      const {
        width: q
      } = qi(u), {
        width: J
      } = qi(b), {
        width: ne
      } = qi(d), {
        width: te
      } = qi(v);
      ie([S, B, q, J, ne, te, () => e.direction], () => {
        K.value = 0, S.value ? d.value && v.value && (K.value = ne.value + te.value, q.value && J.value && K.value > q.value - J.value - (e.direction === "rtl" || b.value.offsetLeft > K.value ? 0 : b.value.offsetLeft) && (H.value = K.value)) : S.value === 0 && (H.value = 0);
      }, {
        immediate: !0
      });
      const G = Y();
      function U(Oe, Ue) {
        if (Oe)
          clearTimeout(G.value), s.value[Ue] = !0, C(Ue), F(Oe), B.value || _(null, Ue);
        else if (S.value === Ue) {
          F(Oe);
          const Ye = s.value;
          G.value = setTimeout(() => {
            Ye === s.value && (s.value = {});
          });
        }
      }
      function re(Oe) {
        U(!0, Oe), setTimeout(() => {
          const Ue = [h, g][Oe];
          Ue.value && Ue.value.focus();
        }, 0);
      }
      function se(Oe, Ue) {
        let Ye = Oe, Dt = $t(Ye, 0), cn = $t(Ye, 1);
        const {
          generateConfig: Qt,
          locale: to,
          picker: $n,
          order: cr,
          onCalendarChange: fo,
          allowEmpty: Eo,
          onChange: zt,
          showTime: Wo
        } = e;
        Dt && cn && Qt.isAfter(Dt, cn) && (// WeekPicker only compare week
        $n === "week" && !u3(Qt, to.locale, Dt, cn) || // QuotaPicker only compare week
        $n === "quarter" && !c3(Qt, Dt, cn) || // Other non-TimePicker compare date
        $n !== "week" && $n !== "quarter" && $n !== "time" && !(Wo ? ri(Qt, Dt, cn) : Hr(Qt, Dt, cn)) ? (Ue === 0 ? (Ye = [Dt, null], cn = null) : (Dt = null, Ye = [null, cn]), s.value = {
          [Ue]: !0
        }) : ($n !== "time" || cr !== !1) && (Ye = mC(Ye, Qt))), R(Ye);
        const To = Ye && Ye[0] ? Pn(Ye[0], {
          generateConfig: Qt,
          locale: to,
          format: y.value[0]
        }) : "", tl = Ye && Ye[1] ? Pn(Ye[1], {
          generateConfig: Qt,
          locale: to,
          format: y.value[0]
        }) : "";
        fo && fo(Ye, [To, tl], {
          range: Ue === 0 ? "start" : "end"
        });
        const nl = hC(Dt, 0, $.value, Eo), Ko = hC(cn, 1, $.value, Eo);
        (Ye === null || nl && Ko) && (x(Ye), zt && (!ri(Qt, $t(O.value, 0), Dt) || !ri(Qt, $t(O.value, 1), cn)) && zt(Ye, [To, tl]));
        let Go = null;
        Ue === 0 && !$.value[1] ? Go = 1 : Ue === 1 && !$.value[0] && (Go = 0), Go !== null && Go !== S.value && (!s.value[Go] || !$t(Ye, Go)) && $t(Ye, Ue) ? re(Go) : U(!1, Ue);
      }
      const me = (Oe) => B && w.value && w.value.onKeydown ? w.value.onKeydown(Oe) : (ct(!1, "Picker not correct forward Keydown operation. Please help to fire issue about this."), !1), Ce = {
        formatList: y,
        generateConfig: Te(e, "generateConfig"),
        locale: Te(e, "locale")
      }, [fe, be] = kd(P(() => $t(M.value, 0)), Ce), [ue, de] = kd(P(() => $t(M.value, 1)), Ce), Se = (Oe, Ue) => {
        const Ye = d3(Oe, {
          locale: e.locale,
          formatList: y.value,
          generateConfig: e.generateConfig
        });
        Ye && !(Ue === 0 ? N : k)(Ye) && (R(Do(M.value, Ye, Ue)), _(Ye, Ue));
      }, [xe, he, we] = lm({
        valueTexts: fe,
        onTextChange: (Oe) => Se(Oe, 0)
      }), [Me, ae, oe] = lm({
        valueTexts: ue,
        onTextChange: (Oe) => Se(Oe, 1)
      }), [pe, Pe] = Pt(null), [Ee, ze] = Pt(null), [ge, ye, $e] = am(xe, Ce), [Ae, Ve, De] = am(Me, Ce), We = (Oe) => {
        ze(Do(M.value, Oe, S.value)), S.value === 0 ? ye(Oe) : Ve(Oe);
      }, at = () => {
        ze(Do(M.value, null, S.value)), S.value === 0 ? $e() : De();
      }, gt = (Oe, Ue) => ({
        forwardKeydown: me,
        onBlur: (Ye) => {
          var Dt;
          (Dt = e.onBlur) === null || Dt === void 0 || Dt.call(e, Ye);
        },
        isClickOutside: (Ye) => !s3([u.value, d.value, p.value, c.value], Ye),
        onFocus: (Ye) => {
          var Dt;
          C(Oe), (Dt = e.onFocus) === null || Dt === void 0 || Dt.call(e, Ye);
        },
        triggerOpen: (Ye) => {
          U(Ye, Oe);
        },
        onSubmit: () => {
          if (
            // When user typing disabledDate with keyboard and enter, this value will be empty
            !M.value || // Normal disabled check
            e.disabledDate && e.disabledDate(M.value[Oe])
          )
            return !1;
          se(M.value, Oe), Ue();
        },
        onCancel: () => {
          U(!1, Oe), R(O.value), Ue();
        }
      }), [ut, {
        focused: St,
        typing: wt
      }] = rm(m(m({}, gt(0, we)), {
        blurToCancel: r,
        open: L,
        value: xe,
        onKeydown: (Oe, Ue) => {
          var Ye;
          (Ye = e.onKeydown) === null || Ye === void 0 || Ye.call(e, Oe, Ue);
        }
      })), [Xt, {
        focused: qt,
        typing: gn
      }] = rm(m(m({}, gt(1, oe)), {
        blurToCancel: r,
        open: j,
        value: Me,
        onKeydown: (Oe, Ue) => {
          var Ye;
          (Ye = e.onKeydown) === null || Ye === void 0 || Ye.call(e, Oe, Ue);
        }
      })), Zt = (Oe) => {
        var Ue;
        (Ue = e.onClick) === null || Ue === void 0 || Ue.call(e, Oe), !B.value && !h.value.contains(Oe.target) && !g.value.contains(Oe.target) && ($.value[0] ? $.value[1] || re(1) : re(0));
      }, An = (Oe) => {
        var Ue;
        (Ue = e.onMousedown) === null || Ue === void 0 || Ue.call(e, Oe), B.value && (St.value || qt.value) && !h.value.contains(Oe.target) && !g.value.contains(Oe.target) && Oe.preventDefault();
      }, Jn = P(() => {
        var Oe;
        return !((Oe = O.value) === null || Oe === void 0) && Oe[0] ? Pn(O.value[0], {
          locale: e.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: e.generateConfig
        }) : "";
      }), Io = P(() => {
        var Oe;
        return !((Oe = O.value) === null || Oe === void 0) && Oe[1] ? Pn(O.value[1], {
          locale: e.locale,
          format: "YYYYMMDDHHmmss",
          generateConfig: e.generateConfig
        }) : "";
      });
      ie([B, fe, ue], () => {
        B.value || (R(O.value), !fe.value.length || fe.value[0] === "" ? he("") : be.value !== xe.value && we(), !ue.value.length || ue.value[0] === "" ? ae("") : de.value !== Me.value && oe());
      }), ie([Jn, Io], () => {
        R(O.value);
      }), process.env.NODE_ENV !== "production" && Le(() => {
        const {
          value: Oe,
          disabled: Ue
        } = e;
        Oe && Array.isArray(Ue) && ($t(Ue, 0) && !$t(Oe, 0) || $t(Ue, 1) && !$t(Oe, 1)) && ct(!1, "`disabled` should not set with empty `value`. You should set `allowEmpty` or `value` instead.");
      }), o({
        focus: () => {
          h.value && h.value.focus();
        },
        blur: () => {
          h.value && h.value.blur(), g.value && g.value.blur();
        }
      });
      const Vo = P(() => B.value && Ee.value && Ee.value[0] && Ee.value[1] && e.generateConfig.isAfter(Ee.value[1], Ee.value[0]) ? Ee.value : null);
      function eo() {
        let Oe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, Ue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        const {
          generateConfig: Ye,
          showTime: Dt,
          dateRender: cn,
          direction: Qt,
          disabledTime: to,
          prefixCls: $n,
          locale: cr
        } = e;
        let fo = Dt;
        if (Dt && typeof Dt == "object" && Dt.defaultValue) {
          const zt = Dt.defaultValue;
          fo = m(m({}, Dt), {
            defaultValue: $t(zt, S.value) || void 0
          });
        }
        let Eo = null;
        return cn && (Eo = (zt) => {
          let {
            current: Wo,
            today: To
          } = zt;
          return cn({
            current: Wo,
            today: To,
            info: {
              range: S.value ? "end" : "start"
            }
          });
        }), f(GH, {
          value: {
            inRange: !0,
            panelPosition: Oe,
            rangedValue: pe.value || M.value,
            hoverRangedValue: Vo.value
          }
        }, {
          default: () => [f(z0, D(D(D({}, e), Ue), {}, {
            dateRender: Eo,
            showTime: fo,
            mode: A.value[S.value],
            generateConfig: Ye,
            style: void 0,
            direction: Qt,
            disabledDate: S.value === 0 ? N : k,
            disabledTime: (zt) => to ? to(zt, S.value === 0 ? "start" : "end") : !1,
            class: ee({
              [`${$n}-panel-focused`]: S.value === 0 ? !wt.value : !gn.value
            }),
            value: $t(M.value, S.value),
            locale: cr,
            tabIndex: -1,
            onPanelChange: (zt, Wo) => {
              S.value === 0 && $e(!0), S.value === 1 && De(!0), T(Do(A.value, Wo, S.value), Do(M.value, zt, S.value));
              let To = zt;
              Oe === "right" && A.value[S.value] === Wo && (To = bs(To, Wo, Ye, -1)), _(To, S.value);
            },
            onOk: null,
            onSelect: void 0,
            onChange: void 0,
            defaultValue: S.value === 0 ? $t(M.value, 1) : $t(M.value, 0)
          }), null)]
        });
      }
      const Ml = (Oe, Ue) => {
        const Ye = Do(M.value, Oe, S.value);
        Ue === "submit" || Ue !== "key" && !r.value ? (se(Ye, S.value), S.value === 0 ? $e() : De()) : R(Ye);
      };
      return $0({
        operationRef: w,
        hideHeader: P(() => e.picker === "time"),
        onDateMouseenter: We,
        onDateMouseleave: at,
        hideRanges: P(() => !0),
        onSelect: Ml,
        open: B
      }), () => {
        const {
          prefixCls: Oe = "rc-picker",
          id: Ue,
          popupStyle: Ye,
          dropdownClassName: Dt,
          transitionName: cn,
          dropdownAlign: Qt,
          getPopupContainer: to,
          generateConfig: $n,
          locale: cr,
          placeholder: fo,
          autofocus: Eo,
          picker: zt = "date",
          showTime: Wo,
          separator: To = "~",
          disabledDate: tl,
          panelRender: nl,
          allowClear: Ko,
          suffixIcon: Ea,
          clearIcon: Go,
          inputReadOnly: Np,
          renderExtraFooter: XE,
          onMouseenter: UE,
          onMouseleave: YE,
          onMouseup: qE,
          onOk: xy,
          components: ZE,
          direction: Wi,
          autocomplete: Oy = "off"
        } = e, QE = Wi === "rtl" ? {
          right: `${K.value}px`
        } : {
          left: `${K.value}px`
        };
        function JE() {
          let no;
          const ol = h3(Oe, A.value[S.value], XE), Ty = b3({
            prefixCls: Oe,
            components: ZE,
            needConfirmButton: r.value,
            okDisabled: !$t(M.value, S.value) || tl && tl(M.value[S.value]),
            locale: cr,
            onOk: () => {
              $t(M.value, S.value) && (se(M.value, S.value), xy && xy(M.value));
            }
          });
          if (zt !== "time" && !Wo) {
            const rl = S.value === 0 ? I.value : E.value, nT = bs(rl, zt, $n), Fp = A.value[S.value] === zt, My = eo(Fp ? "left" : !1, {
              pickerValue: rl,
              onPickerValueChange: (Lp) => {
                _(Lp, S.value);
              }
            }), _y = eo("right", {
              pickerValue: nT,
              onPickerValueChange: (Lp) => {
                _(bs(Lp, zt, $n, -1), S.value);
              }
            });
            Wi === "rtl" ? no = f(Fe, null, [_y, Fp && My]) : no = f(Fe, null, [My, Fp && _y]);
          } else
            no = eo();
          let Bp = f("div", {
            class: `${Oe}-panel-layout`
          }, [f(S3, {
            prefixCls: Oe,
            presets: i.value,
            onClick: (rl) => {
              se(rl, null), U(!1, S.value);
            },
            onHover: (rl) => {
              Pe(rl);
            }
          }, null), f("div", null, [f("div", {
            class: `${Oe}-panels`
          }, [no]), (ol || Ty) && f("div", {
            class: `${Oe}-footer`
          }, [ol, Ty])])]);
          return nl && (Bp = nl(Bp)), f("div", {
            class: `${Oe}-panel-container`,
            style: {
              marginLeft: `${H.value}px`
            },
            ref: u,
            onMousedown: (rl) => {
              rl.preventDefault();
            }
          }, [Bp]);
        }
        const eT = f("div", {
          class: ee(`${Oe}-range-wrapper`, `${Oe}-${zt}-range-wrapper`),
          style: {
            minWidth: `${X.value}px`
          }
        }, [f("div", {
          ref: b,
          class: `${Oe}-range-arrow`,
          style: QE
        }, null), JE()]);
        let Py;
        Ea && (Py = f("span", {
          class: `${Oe}-suffix`
        }, [Ea]));
        let Iy;
        Ko && ($t(O.value, 0) && !$.value[0] || $t(O.value, 1) && !$.value[1]) && (Iy = f("span", {
          onMousedown: (no) => {
            no.preventDefault(), no.stopPropagation();
          },
          onMouseup: (no) => {
            no.preventDefault(), no.stopPropagation();
            let ol = O.value;
            $.value[0] || (ol = Do(ol, null, 0)), $.value[1] || (ol = Do(ol, null, 1)), se(ol, null), U(!1, S.value);
          },
          class: `${Oe}-clear`
        }, [Go || f("span", {
          class: `${Oe}-clear-btn`
        }, null)]));
        const Ey = {
          size: i3(zt, y.value[0], $n)
        };
        let Rp = 0, kp = 0;
        d.value && p.value && v.value && (S.value === 0 ? kp = d.value.offsetWidth : (Rp = K.value, kp = p.value.offsetWidth));
        const tT = Wi === "rtl" ? {
          right: `${Rp}px`
        } : {
          left: `${Rp}px`
        };
        return f("div", D({
          ref: c,
          class: ee(Oe, `${Oe}-range`, n.class, {
            [`${Oe}-disabled`]: $.value[0] && $.value[1],
            [`${Oe}-focused`]: S.value === 0 ? St.value : qt.value,
            [`${Oe}-rtl`]: Wi === "rtl"
          }),
          style: n.style,
          onClick: Zt,
          onMouseenter: UE,
          onMouseleave: YE,
          onMousedown: An,
          onMouseup: qE
        }, v3(e)), [f("div", {
          class: ee(`${Oe}-input`, {
            [`${Oe}-input-active`]: S.value === 0,
            [`${Oe}-input-placeholder`]: !!ge.value
          }),
          ref: d
        }, [f("input", D(D(D({
          id: Ue,
          disabled: $.value[0],
          readonly: Np || typeof y.value[0] == "function" || !wt.value,
          value: ge.value || xe.value,
          onInput: (no) => {
            he(no.target.value);
          },
          autofocus: Eo,
          placeholder: $t(fo, 0) || "",
          ref: h
        }, ut.value), Ey), {}, {
          autocomplete: Oy
        }), null)]), f("div", {
          class: `${Oe}-range-separator`,
          ref: v
        }, [To]), f("div", {
          class: ee(`${Oe}-input`, {
            [`${Oe}-input-active`]: S.value === 1,
            [`${Oe}-input-placeholder`]: !!Ae.value
          }),
          ref: p
        }, [f("input", D(D(D({
          disabled: $.value[1],
          readonly: Np || typeof y.value[0] == "function" || !gn.value,
          value: Ae.value || Me.value,
          onInput: (no) => {
            ae(no.target.value);
          },
          placeholder: $t(fo, 1) || "",
          ref: g
        }, Xt.value), Ey), {}, {
          autocomplete: Oy
        }), null)]), f("div", {
          class: `${Oe}-active-bar`,
          style: m(m({}, tT), {
            width: `${kp}px`,
            position: "absolute"
          })
        }, null), Py, Iy, f(y3, {
          visible: B.value,
          popupStyle: Ye,
          prefixCls: Oe,
          dropdownClassName: Dt,
          dropdownAlign: Qt,
          getPopupContainer: to,
          transitionName: cn,
          range: !0,
          direction: Wi
        }, {
          default: () => [f("div", {
            style: {
              pointerEvents: "none",
              position: "absolute",
              top: 0,
              bottom: 0,
              left: 0,
              right: 0
            }
          }, null)],
          popupElement: () => eT
        })]);
      };
    }
  });
}
const dj = uj();
var fj = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const pj = {
  prefixCls: String,
  name: String,
  id: String,
  type: String,
  defaultChecked: {
    type: [Boolean, Number],
    default: void 0
  },
  checked: {
    type: [Boolean, Number],
    default: void 0
  },
  disabled: Boolean,
  tabindex: {
    type: [Number, String]
  },
  readonly: Boolean,
  autofocus: Boolean,
  value: V.any,
  required: Boolean
}, I3 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Checkbox",
  inheritAttrs: !1,
  props: Qe(pj, {
    prefixCls: "rc-checkbox",
    type: "checkbox",
    defaultChecked: !1
  }),
  emits: ["click", "change"],
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      expose: r
    } = t;
    const l = Y(e.checked === void 0 ? e.defaultChecked : e.checked), a = Y();
    ie(() => e.checked, () => {
      l.value = e.checked;
    }), r({
      focus() {
        var u;
        (u = a.value) === null || u === void 0 || u.focus();
      },
      blur() {
        var u;
        (u = a.value) === null || u === void 0 || u.blur();
      }
    });
    const i = Y(), s = (u) => {
      if (e.disabled)
        return;
      e.checked === void 0 && (l.value = u.target.checked), u.shiftKey = i.value;
      const d = {
        target: m(m({}, e), {
          checked: u.target.checked
        }),
        stopPropagation() {
          u.stopPropagation();
        },
        preventDefault() {
          u.preventDefault();
        },
        nativeEvent: u
      };
      e.checked !== void 0 && (a.value.checked = !!e.checked), o("change", d), i.value = !1;
    }, c = (u) => {
      o("click", u), i.value = u.shiftKey;
    };
    return () => {
      const {
        prefixCls: u,
        name: d,
        id: p,
        type: v,
        disabled: h,
        readonly: g,
        tabindex: b,
        autofocus: y,
        value: S,
        required: C
      } = e, w = fj(e, ["prefixCls", "name", "id", "type", "disabled", "readonly", "tabindex", "autofocus", "value", "required"]), {
        class: $,
        onFocus: O,
        onBlur: x,
        onKeydown: I,
        onKeypress: E,
        onKeyup: _
      } = n, M = m(m({}, w), n), R = Object.keys(M).reduce((T, N) => ((N.startsWith("data-") || N.startsWith("aria-") || N === "role") && (T[N] = M[N]), T), {}), A = ee(u, $, {
        [`${u}-checked`]: l.value,
        [`${u}-disabled`]: h
      }), z = m(m({
        name: d,
        id: p,
        type: v,
        readonly: g,
        disabled: h,
        tabindex: b,
        class: `${u}-input`,
        checked: !!l.value,
        autofocus: y,
        value: S
      }, R), {
        onChange: s,
        onClick: c,
        onFocus: O,
        onBlur: x,
        onKeydown: I,
        onKeypress: E,
        onKeyup: _,
        required: C
      });
      return f("span", {
        class: A
      }, [f("input", D({
        ref: a
      }, z), null), f("span", {
        class: `${u}-inner`
      }, null)]);
    };
  }
}), E3 = Symbol("radioGroupContextKey"), vj = (e) => {
  Je(E3, e);
}, gj = () => tt(E3, void 0), T3 = Symbol("radioOptionTypeContextKey"), mj = (e) => {
  Je(T3, e);
}, hj = () => tt(T3, void 0), bj = new lt("antRadioEffect", {
  "0%": {
    transform: "scale(1)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(1.6)",
    opacity: 0
  }
}), yj = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, o = `${t}-group`;
  return {
    [o]: m(m({}, qe(e)), {
      display: "inline-block",
      fontSize: 0,
      // RTL
      [`&${o}-rtl`]: {
        direction: "rtl"
      },
      [`${n}-badge ${n}-badge-count`]: {
        zIndex: 1
      },
      [`> ${n}-badge:not(:first-child) > ${n}-button-wrapper`]: {
        borderInlineStart: "none"
      }
    })
  };
}, Sj = (e) => {
  const {
    componentCls: t,
    radioWrapperMarginRight: n,
    radioCheckedColor: o,
    radioSize: r,
    motionDurationSlow: l,
    motionDurationMid: a,
    motionEaseInOut: i,
    motionEaseInOutCirc: s,
    radioButtonBg: c,
    colorBorder: u,
    lineWidth: d,
    radioDotSize: p,
    colorBgContainerDisabled: v,
    colorTextDisabled: h,
    paddingXS: g,
    radioDotDisabledColor: b,
    lineType: y,
    radioDotDisabledSize: S,
    wireframe: C,
    colorWhite: w
  } = e, $ = `${t}-inner`;
  return {
    [`${t}-wrapper`]: m(m({}, qe(e)), {
      position: "relative",
      display: "inline-flex",
      alignItems: "baseline",
      marginInlineStart: 0,
      marginInlineEnd: n,
      cursor: "pointer",
      // RTL
      [`&${t}-wrapper-rtl`]: {
        direction: "rtl"
      },
      "&-disabled": {
        cursor: "not-allowed",
        color: e.colorTextDisabled
      },
      "&::after": {
        display: "inline-block",
        width: 0,
        overflow: "hidden",
        content: '"\\a0"'
      },
      // hashId 在 wrapper 上，只能铺平
      [`${t}-checked::after`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: "100%",
        height: "100%",
        border: `${d}px ${y} ${o}`,
        borderRadius: "50%",
        visibility: "hidden",
        animationName: bj,
        animationDuration: l,
        animationTimingFunction: i,
        animationFillMode: "both",
        content: '""'
      },
      [t]: m(m({}, qe(e)), {
        position: "relative",
        display: "inline-block",
        outline: "none",
        cursor: "pointer",
        alignSelf: "center"
      }),
      [`${t}-wrapper:hover &,
        &:hover ${$}`]: {
        borderColor: o
      },
      [`${t}-input:focus-visible + ${$}`]: m({}, Gr(e)),
      [`${t}:hover::after, ${t}-wrapper:hover &::after`]: {
        visibility: "visible"
      },
      [`${t}-inner`]: {
        "&::after": {
          boxSizing: "border-box",
          position: "absolute",
          insetBlockStart: "50%",
          insetInlineStart: "50%",
          display: "block",
          width: r,
          height: r,
          marginBlockStart: r / -2,
          marginInlineStart: r / -2,
          backgroundColor: C ? o : w,
          borderBlockStart: 0,
          borderInlineStart: 0,
          borderRadius: r,
          transform: "scale(0)",
          opacity: 0,
          transition: `all ${l} ${s}`,
          content: '""'
        },
        boxSizing: "border-box",
        position: "relative",
        insetBlockStart: 0,
        insetInlineStart: 0,
        display: "block",
        width: r,
        height: r,
        backgroundColor: c,
        borderColor: u,
        borderStyle: "solid",
        borderWidth: d,
        borderRadius: "50%",
        transition: `all ${a}`
      },
      [`${t}-input`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        insetBlockEnd: 0,
        insetInlineStart: 0,
        zIndex: 1,
        cursor: "pointer",
        opacity: 0
      },
      // 选中状态
      [`${t}-checked`]: {
        [$]: {
          borderColor: o,
          backgroundColor: C ? c : o,
          "&::after": {
            transform: `scale(${p / r})`,
            opacity: 1,
            transition: `all ${l} ${s}`
          }
        }
      },
      [`${t}-disabled`]: {
        cursor: "not-allowed",
        [$]: {
          backgroundColor: v,
          borderColor: u,
          cursor: "not-allowed",
          "&::after": {
            backgroundColor: b
          }
        },
        [`${t}-input`]: {
          cursor: "not-allowed"
        },
        [`${t}-disabled + span`]: {
          color: h,
          cursor: "not-allowed"
        },
        [`&${t}-checked`]: {
          [$]: {
            "&::after": {
              transform: `scale(${S / r})`
            }
          }
        }
      },
      [`span${t} + *`]: {
        paddingInlineStart: g,
        paddingInlineEnd: g
      }
    })
  };
}, Cj = (e) => {
  const {
    radioButtonColor: t,
    controlHeight: n,
    componentCls: o,
    lineWidth: r,
    lineType: l,
    colorBorder: a,
    motionDurationSlow: i,
    motionDurationMid: s,
    radioButtonPaddingHorizontal: c,
    fontSize: u,
    radioButtonBg: d,
    fontSizeLG: p,
    controlHeightLG: v,
    controlHeightSM: h,
    paddingXS: g,
    borderRadius: b,
    borderRadiusSM: y,
    borderRadiusLG: S,
    radioCheckedColor: C,
    radioButtonCheckedBg: w,
    radioButtonHoverColor: $,
    radioButtonActiveColor: O,
    radioSolidCheckedColor: x,
    colorTextDisabled: I,
    colorBgContainerDisabled: E,
    radioDisabledButtonCheckedColor: _,
    radioDisabledButtonCheckedBg: M
  } = e;
  return {
    [`${o}-button-wrapper`]: {
      position: "relative",
      display: "inline-block",
      height: n,
      margin: 0,
      paddingInline: c,
      paddingBlock: 0,
      color: t,
      fontSize: u,
      lineHeight: `${n - r * 2}px`,
      background: d,
      border: `${r}px ${l} ${a}`,
      // strange align fix for chrome but works
      // https://gw.alipayobjects.com/zos/rmsportal/VFTfKXJuogBAXcvfAUWJ.gif
      borderBlockStartWidth: r + 0.02,
      borderInlineStartWidth: 0,
      borderInlineEndWidth: r,
      cursor: "pointer",
      transition: [`color ${s}`, `background ${s}`, `border-color ${s}`, `box-shadow ${s}`].join(","),
      a: {
        color: t
      },
      [`> ${o}-button`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: -1,
        width: "100%",
        height: "100%"
      },
      "&:not(:first-child)": {
        "&::before": {
          position: "absolute",
          insetBlockStart: -r,
          insetInlineStart: -r,
          display: "block",
          boxSizing: "content-box",
          width: 1,
          height: "100%",
          paddingBlock: r,
          paddingInline: 0,
          backgroundColor: a,
          transition: `background-color ${i}`,
          content: '""'
        }
      },
      "&:first-child": {
        borderInlineStart: `${r}px ${l} ${a}`,
        borderStartStartRadius: b,
        borderEndStartRadius: b
      },
      "&:last-child": {
        borderStartEndRadius: b,
        borderEndEndRadius: b
      },
      "&:first-child:last-child": {
        borderRadius: b
      },
      [`${o}-group-large &`]: {
        height: v,
        fontSize: p,
        lineHeight: `${v - r * 2}px`,
        "&:first-child": {
          borderStartStartRadius: S,
          borderEndStartRadius: S
        },
        "&:last-child": {
          borderStartEndRadius: S,
          borderEndEndRadius: S
        }
      },
      [`${o}-group-small &`]: {
        height: h,
        paddingInline: g - r,
        paddingBlock: 0,
        lineHeight: `${h - r * 2}px`,
        "&:first-child": {
          borderStartStartRadius: y,
          borderEndStartRadius: y
        },
        "&:last-child": {
          borderStartEndRadius: y,
          borderEndEndRadius: y
        }
      },
      "&:hover": {
        position: "relative",
        color: C
      },
      "&:has(:focus-visible)": m({}, Gr(e)),
      [`${o}-inner, input[type='checkbox'], input[type='radio']`]: {
        width: 0,
        height: 0,
        opacity: 0,
        pointerEvents: "none"
      },
      [`&-checked:not(${o}-button-wrapper-disabled)`]: {
        zIndex: 1,
        color: C,
        background: w,
        borderColor: C,
        "&::before": {
          backgroundColor: C
        },
        "&:first-child": {
          borderColor: C
        },
        "&:hover": {
          color: $,
          borderColor: $,
          "&::before": {
            backgroundColor: $
          }
        },
        "&:active": {
          color: O,
          borderColor: O,
          "&::before": {
            backgroundColor: O
          }
        }
      },
      [`${o}-group-solid &-checked:not(${o}-button-wrapper-disabled)`]: {
        color: x,
        background: C,
        borderColor: C,
        "&:hover": {
          color: x,
          background: $,
          borderColor: $
        },
        "&:active": {
          color: x,
          background: O,
          borderColor: O
        }
      },
      "&-disabled": {
        color: I,
        backgroundColor: E,
        borderColor: a,
        cursor: "not-allowed",
        "&:first-child, &:hover": {
          color: I,
          backgroundColor: E,
          borderColor: a
        }
      },
      [`&-disabled${o}-button-wrapper-checked`]: {
        color: _,
        backgroundColor: M,
        borderColor: a,
        boxShadow: "none"
      }
    }
  };
}, M3 = Xe("Radio", (e) => {
  const {
    padding: t,
    lineWidth: n,
    controlItemBgActiveDisabled: o,
    colorTextDisabled: r,
    colorBgContainer: l,
    fontSizeLG: a,
    controlOutline: i,
    colorPrimaryHover: s,
    colorPrimaryActive: c,
    colorText: u,
    colorPrimary: d,
    marginXS: p,
    controlOutlineWidth: v,
    colorTextLightSolid: h,
    wireframe: g
  } = e, b = `0 0 0 ${v}px ${i}`, y = b, S = a, C = 4, w = S - C * 2, $ = g ? w : S - (C + n) * 2, O = d, x = u, I = s, E = c, _ = t - n, A = He(e, {
    radioFocusShadow: b,
    radioButtonFocusShadow: y,
    radioSize: S,
    radioDotSize: $,
    radioDotDisabledSize: w,
    radioCheckedColor: O,
    radioDotDisabledColor: r,
    radioSolidCheckedColor: h,
    radioButtonBg: l,
    radioButtonCheckedBg: l,
    radioButtonColor: x,
    radioButtonHoverColor: I,
    radioButtonActiveColor: E,
    radioButtonPaddingHorizontal: _,
    radioDisabledButtonCheckedBg: o,
    radioDisabledButtonCheckedColor: r,
    radioWrapperMarginRight: p
  });
  return [yj(A), Sj(A), Cj(A)];
});
var $j = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const _3 = () => ({
  prefixCls: String,
  checked: ve(),
  disabled: ve(),
  isGroup: ve(),
  value: V.any,
  name: String,
  id: String,
  autofocus: ve(),
  onChange: le(),
  onFocus: le(),
  onBlur: le(),
  onClick: le(),
  "onUpdate:checked": le(),
  "onUpdate:value": le()
}), Un = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ARadio",
  inheritAttrs: !1,
  props: _3(),
  setup(e, t) {
    let {
      emit: n,
      expose: o,
      slots: r,
      attrs: l
    } = t;
    const a = sn(), i = Sn.useInject(), s = hj(), c = gj(), u = so(), d = P(() => {
      var I;
      return (I = g.value) !== null && I !== void 0 ? I : u.value;
    }), p = Y(), {
      prefixCls: v,
      direction: h,
      disabled: g
    } = Ie("radio", e), b = P(() => (c == null ? void 0 : c.optionType.value) === "button" || s === "button" ? `${v.value}-button` : v.value), y = so(), [S, C] = M3(v);
    o({
      focus: () => {
        p.value.focus();
      },
      blur: () => {
        p.value.blur();
      }
    });
    const O = (I) => {
      const E = I.target.checked;
      n("update:checked", E), n("update:value", E), n("change", I), a.onFieldChange();
    }, x = (I) => {
      n("change", I), c && c.onChange && c.onChange(I);
    };
    return () => {
      var I;
      const E = c, {
        prefixCls: _,
        id: M = a.id.value
      } = e, R = $j(e, ["prefixCls", "id"]), A = m(m({
        prefixCls: b.value,
        id: M
      }, ot(R, ["onUpdate:checked", "onUpdate:value"])), {
        disabled: (I = g.value) !== null && I !== void 0 ? I : y.value
      });
      E ? (A.name = E.name.value, A.onChange = x, A.checked = e.value === E.value.value, A.disabled = d.value || E.disabled.value) : A.onChange = O;
      const z = ee({
        [`${b.value}-wrapper`]: !0,
        [`${b.value}-wrapper-checked`]: A.checked,
        [`${b.value}-wrapper-disabled`]: A.disabled,
        [`${b.value}-wrapper-rtl`]: h.value === "rtl",
        [`${b.value}-wrapper-in-form-item`]: i.isFormItemInput
      }, l.class, C.value);
      return S(f("label", D(D({}, l), {}, {
        class: z
      }), [f(I3, D(D({}, A), {}, {
        type: "radio",
        ref: p
      }), null), r.default && f("span", null, [r.default()])]));
    };
  }
}), wj = () => ({
  prefixCls: String,
  value: V.any,
  size: ke(),
  options: vt(),
  disabled: ve(),
  name: String,
  buttonStyle: ke("outline"),
  id: String,
  optionType: ke("default"),
  onChange: le(),
  "onUpdate:value": le()
}), j0 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioGroup",
  inheritAttrs: !1,
  props: wj(),
  // emits: ['update:value', 'change'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const l = sn(), {
      prefixCls: a,
      direction: i,
      size: s
    } = Ie("radio", e), [c, u] = M3(a), d = Y(e.value), p = Y(!1);
    return ie(() => e.value, (h) => {
      d.value = h, p.value = !1;
    }), vj({
      onChange: (h) => {
        const g = d.value, {
          value: b
        } = h.target;
        "value" in e || (d.value = b), !p.value && b !== g && (p.value = !0, o("update:value", b), o("change", h), l.onFieldChange()), rt(() => {
          p.value = !1;
        });
      },
      value: d,
      disabled: P(() => e.disabled),
      name: P(() => e.name),
      optionType: P(() => e.optionType)
    }), () => {
      var h;
      const {
        options: g,
        buttonStyle: b,
        id: y = l.id.value
      } = e, S = `${a.value}-group`, C = ee(S, `${S}-${b}`, {
        [`${S}-${s.value}`]: s.value,
        [`${S}-rtl`]: i.value === "rtl"
      }, r.class, u.value);
      let w = null;
      return g && g.length > 0 ? w = g.map(($) => {
        if (typeof $ == "string" || typeof $ == "number")
          return f(Un, {
            key: $,
            prefixCls: a.value,
            disabled: e.disabled,
            value: $,
            checked: d.value === $
          }, {
            default: () => [$]
          });
        const {
          value: O,
          disabled: x,
          label: I
        } = $;
        return f(Un, {
          key: `radio-group-value-options-${O}`,
          prefixCls: a.value,
          disabled: x || e.disabled,
          value: O,
          checked: d.value === O
        }, {
          default: () => [I]
        });
      }) : w = (h = n.default) === null || h === void 0 ? void 0 : h.call(n), c(f("div", D(D({}, r), {}, {
        class: C,
        id: y
      }), [w]));
    };
  }
}), Bd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ARadioButton",
  inheritAttrs: !1,
  props: _3(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r
    } = Ie("radio", e);
    return mj("button"), () => {
      var l;
      return f(Un, D(D(D({}, o), e), {}, {
        prefixCls: r.value
      }), {
        default: () => [(l = n.default) === null || l === void 0 ? void 0 : l.call(n)]
      });
    };
  }
});
Un.Group = j0;
Un.Button = Bd;
Un.install = function(e) {
  return e.component(Un.name, Un), e.component(Un.Group.name, Un.Group), e.component(Un.Button.name, Un.Button), e;
};
const xj = 10, Oj = 20;
function A3(e) {
  const {
    fullscreen: t,
    validRange: n,
    generateConfig: o,
    locale: r,
    prefixCls: l,
    value: a,
    onChange: i,
    divRef: s
  } = e, c = o.getYear(a || o.getNow());
  let u = c - xj, d = u + Oj;
  n && (u = o.getYear(n[0]), d = o.getYear(n[1]) + 1);
  const p = r && r.year === "年" ? "年" : "", v = [];
  for (let h = u; h < d; h++)
    v.push({
      label: `${h}${p}`,
      value: h
    });
  return f(bn, {
    size: t ? void 0 : "small",
    options: v,
    value: c,
    class: `${l}-year-select`,
    onChange: (h) => {
      let g = o.setYear(a, h);
      if (n) {
        const [b, y] = n, S = o.getYear(g), C = o.getMonth(g);
        S === o.getYear(y) && C > o.getMonth(y) && (g = o.setMonth(g, o.getMonth(y))), S === o.getYear(b) && C < o.getMonth(b) && (g = o.setMonth(g, o.getMonth(b)));
      }
      i(g);
    },
    getPopupContainer: () => s.value
  }, null);
}
A3.inheritAttrs = !1;
function D3(e) {
  const {
    prefixCls: t,
    fullscreen: n,
    validRange: o,
    value: r,
    generateConfig: l,
    locale: a,
    onChange: i,
    divRef: s
  } = e, c = l.getMonth(r || l.getNow());
  let u = 0, d = 11;
  if (o) {
    const [h, g] = o, b = l.getYear(r);
    l.getYear(g) === b && (d = l.getMonth(g)), l.getYear(h) === b && (u = l.getMonth(h));
  }
  const p = a.shortMonths || l.locale.getShortMonths(a.locale), v = [];
  for (let h = u; h <= d; h += 1)
    v.push({
      label: p[h],
      value: h
    });
  return f(bn, {
    size: n ? void 0 : "small",
    class: `${t}-month-select`,
    value: c,
    options: v,
    onChange: (h) => {
      i(l.setMonth(r, h));
    },
    getPopupContainer: () => s.value
  }, null);
}
D3.inheritAttrs = !1;
function N3(e) {
  const {
    prefixCls: t,
    locale: n,
    mode: o,
    fullscreen: r,
    onModeChange: l
  } = e;
  return f(j0, {
    onChange: (a) => {
      let {
        target: {
          value: i
        }
      } = a;
      l(i);
    },
    value: o,
    size: r ? void 0 : "small",
    class: `${t}-mode-switch`
  }, {
    default: () => [f(Bd, {
      value: "month"
    }, {
      default: () => [n.month]
    }), f(Bd, {
      value: "year"
    }, {
      default: () => [n.year]
    })]
  });
}
N3.inheritAttrs = !1;
const Pj = Z({
  name: "CalendarHeader",
  inheritAttrs: !1,
  props: ["mode", "prefixCls", "value", "validRange", "generateConfig", "locale", "mode", "fullscreen"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const o = Y(null), r = Sn.useInject();
    return Sn.useProvide(r, {
      isFormItemInput: !1
    }), () => {
      const l = m(m({}, e), n), {
        prefixCls: a,
        fullscreen: i,
        mode: s,
        onChange: c,
        onModeChange: u
      } = l, d = m(m({}, l), {
        fullscreen: i,
        divRef: o
      });
      return f("div", {
        class: `${a}-header`,
        ref: o
      }, [f(A3, D(D({}, d), {}, {
        onChange: (p) => {
          c(p, "year");
        }
      }), null), s === "month" && f(D3, D(D({}, d), {}, {
        onChange: (p) => {
          c(p, "month");
        }
      }), null), f(N3, D(D({}, d), {}, {
        onModeChange: u
      }), null)]);
    };
  }
}), V0 = (e) => ({
  // Firefox
  "&::-moz-placeholder": {
    opacity: 1
  },
  "&::placeholder": {
    color: e,
    userSelect: "none"
    // https://github.com/ant-design/ant-design/pull/32639
  },
  "&:placeholder-shown": {
    textOverflow: "ellipsis"
  }
}), Fi = (e) => ({
  borderColor: e.inputBorderHoverColor,
  borderInlineEndWidth: e.lineWidth
}), Sl = (e) => ({
  borderColor: e.inputBorderHoverColor,
  boxShadow: `0 0 0 ${e.controlOutlineWidth}px ${e.controlOutline}`,
  borderInlineEndWidth: e.lineWidth,
  outline: 0
}), W0 = (e) => ({
  color: e.colorTextDisabled,
  backgroundColor: e.colorBgContainerDisabled,
  borderColor: e.colorBorder,
  boxShadow: "none",
  cursor: "not-allowed",
  opacity: 1,
  "&:hover": m({}, Fi(He(e, {
    inputBorderHoverColor: e.colorBorder
  })))
}), R3 = (e) => {
  const {
    inputPaddingVerticalLG: t,
    fontSizeLG: n,
    lineHeightLG: o,
    borderRadiusLG: r,
    inputPaddingHorizontalLG: l
  } = e;
  return {
    padding: `${t}px ${l}px`,
    fontSize: n,
    lineHeight: o,
    borderRadius: r
  };
}, K0 = (e) => ({
  padding: `${e.inputPaddingVerticalSM}px ${e.controlPaddingHorizontalSM - 1}px`,
  borderRadius: e.borderRadiusSM
}), vc = (e, t) => {
  const {
    componentCls: n,
    colorError: o,
    colorWarning: r,
    colorErrorOutline: l,
    colorWarningOutline: a,
    colorErrorBorderHover: i,
    colorWarningBorderHover: s
  } = e;
  return {
    [`&-status-error:not(${t}-disabled):not(${t}-borderless)${t}`]: {
      borderColor: o,
      "&:hover": {
        borderColor: i
      },
      "&:focus, &-focused": m({}, Sl(He(e, {
        inputBorderActiveColor: o,
        inputBorderHoverColor: o,
        controlOutline: l
      }))),
      [`${n}-prefix`]: {
        color: o
      }
    },
    [`&-status-warning:not(${t}-disabled):not(${t}-borderless)${t}`]: {
      borderColor: r,
      "&:hover": {
        borderColor: s
      },
      "&:focus, &-focused": m({}, Sl(He(e, {
        inputBorderActiveColor: r,
        inputBorderHoverColor: r,
        controlOutline: a
      }))),
      [`${n}-prefix`]: {
        color: r
      }
    }
  };
}, Oa = (e) => m(m({
  position: "relative",
  display: "inline-block",
  width: "100%",
  minWidth: 0,
  padding: `${e.inputPaddingVertical}px ${e.inputPaddingHorizontal}px`,
  color: e.colorText,
  fontSize: e.fontSize,
  lineHeight: e.lineHeight,
  backgroundColor: e.colorBgContainer,
  backgroundImage: "none",
  borderWidth: e.lineWidth,
  borderStyle: e.lineType,
  borderColor: e.colorBorder,
  borderRadius: e.borderRadius,
  transition: `all ${e.motionDurationMid}`
}, V0(e.colorTextPlaceholder)), {
  "&:hover": m({}, Fi(e)),
  "&:focus, &-focused": m({}, Sl(e)),
  "&-disabled, &[disabled]": m({}, W0(e)),
  "&-borderless": {
    "&, &:hover, &:focus, &-focused, &-disabled, &[disabled]": {
      backgroundColor: "transparent",
      border: "none",
      boxShadow: "none"
    }
  },
  // Reset height for `textarea`s
  "textarea&": {
    maxWidth: "100%",
    height: "auto",
    minHeight: e.controlHeight,
    lineHeight: e.lineHeight,
    verticalAlign: "bottom",
    transition: `all ${e.motionDurationSlow}, height 0s`,
    resize: "vertical"
  },
  // Size
  "&-lg": m({}, R3(e)),
  "&-sm": m({}, K0(e)),
  // RTL
  "&-rtl": {
    direction: "rtl"
  },
  "&-textarea-rtl": {
    direction: "rtl"
  }
}), k3 = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return {
    position: "relative",
    display: "table",
    width: "100%",
    borderCollapse: "separate",
    borderSpacing: 0,
    // Undo padding and float of grid classes
    "&[class*='col-']": {
      paddingInlineEnd: e.paddingXS,
      "&:last-child": {
        paddingInlineEnd: 0
      }
    },
    // Sizing options
    [`&-lg ${t}, &-lg > ${t}-group-addon`]: m({}, R3(e)),
    [`&-sm ${t}, &-sm > ${t}-group-addon`]: m({}, K0(e)),
    [`> ${t}`]: {
      display: "table-cell",
      "&:not(:first-child):not(:last-child)": {
        borderRadius: 0
      }
    },
    [`${t}-group`]: {
      "&-addon, &-wrap": {
        display: "table-cell",
        width: 1,
        whiteSpace: "nowrap",
        verticalAlign: "middle",
        "&:not(:first-child):not(:last-child)": {
          borderRadius: 0
        }
      },
      "&-wrap > *": {
        display: "block !important"
      },
      "&-addon": {
        position: "relative",
        padding: `0 ${e.inputPaddingHorizontal}px`,
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize,
        textAlign: "center",
        backgroundColor: e.colorFillAlter,
        border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
        borderRadius: e.borderRadius,
        transition: `all ${e.motionDurationSlow}`,
        lineHeight: 1,
        // Reset Select's style in addon
        [`${n}-select`]: {
          margin: `-${e.inputPaddingVertical + 1}px -${e.inputPaddingHorizontal}px`,
          [`&${n}-select-single:not(${n}-select-customize-input)`]: {
            [`${n}-select-selector`]: {
              backgroundColor: "inherit",
              border: `${e.lineWidth}px ${e.lineType} transparent`,
              boxShadow: "none"
            }
          },
          "&-open, &-focused": {
            [`${n}-select-selector`]: {
              color: e.colorPrimary
            }
          }
        },
        // https://github.com/ant-design/ant-design/issues/31333
        [`${n}-cascader-picker`]: {
          margin: `-9px -${e.inputPaddingHorizontal}px`,
          backgroundColor: "transparent",
          [`${n}-cascader-input`]: {
            textAlign: "start",
            border: 0,
            boxShadow: "none"
          }
        }
      },
      "&-addon:first-child": {
        borderInlineEnd: 0
      },
      "&-addon:last-child": {
        borderInlineStart: 0
      }
    },
    [`${t}`]: {
      float: "inline-start",
      width: "100%",
      marginBottom: 0,
      textAlign: "inherit",
      "&:focus": {
        zIndex: 1,
        borderInlineEndWidth: 1
      },
      "&:hover": {
        zIndex: 1,
        borderInlineEndWidth: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }
    },
    // Reset rounded corners
    [`> ${t}:first-child, ${t}-group-addon:first-child`]: {
      borderStartEndRadius: 0,
      borderEndEndRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}-affix-wrapper`]: {
      [`&:not(:first-child) ${t}`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      },
      [`&:not(:last-child) ${t}`]: {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0
      }
    },
    [`> ${t}:last-child, ${t}-group-addon:last-child`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      // Reset Select's style in addon
      [`${n}-select ${n}-select-selector`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`${t}-affix-wrapper`]: {
      "&:not(:last-child)": {
        borderStartEndRadius: 0,
        borderEndEndRadius: 0,
        [`${t}-search &`]: {
          borderStartStartRadius: e.borderRadius,
          borderEndStartRadius: e.borderRadius
        }
      },
      [`&:not(:first-child), ${t}-search &:not(:first-child)`]: {
        borderStartStartRadius: 0,
        borderEndStartRadius: 0
      }
    },
    [`&${t}-group-compact`]: m(m({
      display: "block"
    }, nr()), {
      [`${t}-group-addon, ${t}-group-wrap, > ${t}`]: {
        "&:not(:first-child):not(:last-child)": {
          borderInlineEndWidth: e.lineWidth,
          "&:hover": {
            zIndex: 1
          },
          "&:focus": {
            zIndex: 1
          }
        }
      },
      "& > *": {
        display: "inline-block",
        float: "none",
        verticalAlign: "top",
        borderRadius: 0
      },
      [`& > ${t}-affix-wrapper`]: {
        display: "inline-flex"
      },
      [`& > ${n}-picker-range`]: {
        display: "inline-flex"
      },
      "& > *:not(:last-child)": {
        marginInlineEnd: -e.lineWidth,
        borderInlineEndWidth: e.lineWidth
      },
      // Undo float for .ant-input-group .ant-input
      [`${t}`]: {
        float: "none"
      },
      // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
      [`& > ${n}-select > ${n}-select-selector,
      & > ${n}-select-auto-complete ${t},
      & > ${n}-cascader-picker ${t},
      & > ${t}-group-wrapper ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderRadius: 0,
        "&:hover": {
          zIndex: 1
        },
        "&:focus": {
          zIndex: 1
        }
      },
      [`& > ${n}-select-focused`]: {
        zIndex: 1
      },
      // update z-index for arrow icon
      [`& > ${n}-select > ${n}-select-arrow`]: {
        zIndex: 1
        // https://github.com/ant-design/ant-design/issues/20371
      },
      [`& > *:first-child,
      & > ${n}-select:first-child > ${n}-select-selector,
      & > ${n}-select-auto-complete:first-child ${t},
      & > ${n}-cascader-picker:first-child ${t}`]: {
        borderStartStartRadius: e.borderRadius,
        borderEndStartRadius: e.borderRadius
      },
      [`& > *:last-child,
      & > ${n}-select:last-child > ${n}-select-selector,
      & > ${n}-cascader-picker:last-child ${t},
      & > ${n}-cascader-picker-focused:last-child ${t}`]: {
        borderInlineEndWidth: e.lineWidth,
        borderStartEndRadius: e.borderRadius,
        borderEndEndRadius: e.borderRadius
      },
      // https://github.com/ant-design/ant-design/issues/12493
      [`& > ${n}-select-auto-complete ${t}`]: {
        verticalAlign: "top"
      },
      [`${t}-group-wrapper + ${t}-group-wrapper`]: {
        marginInlineStart: -e.lineWidth,
        [`${t}-affix-wrapper`]: {
          borderRadius: 0
        }
      },
      [`${t}-group-wrapper:not(:last-child)`]: {
        [`&${t}-search > ${t}-group`]: {
          [`& > ${t}-group-addon > ${t}-search-button`]: {
            borderRadius: 0
          },
          [`& > ${t}`]: {
            borderStartStartRadius: e.borderRadius,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            borderEndStartRadius: e.borderRadius
          }
        }
      }
    }),
    [`&&-sm ${n}-btn`]: {
      fontSize: e.fontSizeSM,
      height: e.controlHeightSM,
      lineHeight: "normal"
    },
    [`&&-lg ${n}-btn`]: {
      fontSize: e.fontSizeLG,
      height: e.controlHeightLG,
      lineHeight: "normal"
    },
    // Fix https://github.com/ant-design/ant-design/issues/5754
    [`&&-lg ${n}-select-single ${n}-select-selector`]: {
      height: `${e.controlHeightLG}px`,
      [`${n}-select-selection-item, ${n}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${e.controlHeightLG - 2}px`
      },
      [`${n}-select-selection-search-input`]: {
        height: `${e.controlHeightLG}px`
      }
    },
    [`&&-sm ${n}-select-single ${n}-select-selector`]: {
      height: `${e.controlHeightSM}px`,
      [`${n}-select-selection-item, ${n}-select-selection-placeholder`]: {
        // -2 is for the border size & override default
        lineHeight: `${e.controlHeightSM - 2}px`
      },
      [`${n}-select-selection-search-input`]: {
        height: `${e.controlHeightSM}px`
      }
    }
  };
}, Ij = (e) => {
  const {
    componentCls: t,
    controlHeightSM: n,
    lineWidth: o
  } = e, l = (n - o * 2 - 16) / 2;
  return {
    [t]: m(m(m(m({}, qe(e)), Oa(e)), vc(e, t)), {
      '&[type="color"]': {
        height: e.controlHeight,
        [`&${t}-lg`]: {
          height: e.controlHeightLG
        },
        [`&${t}-sm`]: {
          height: n,
          paddingTop: l,
          paddingBottom: l
        }
      }
    })
  };
}, Ej = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ========================= Input =========================
    [`${t}-clear-icon`]: {
      margin: 0,
      color: e.colorTextQuaternary,
      fontSize: e.fontSizeIcon,
      verticalAlign: -1,
      // https://github.com/ant-design/ant-design/pull/18151
      // https://codesandbox.io/s/wizardly-sun-u10br
      cursor: "pointer",
      transition: `color ${e.motionDurationSlow}`,
      "&:hover": {
        color: e.colorTextTertiary
      },
      "&:active": {
        color: e.colorText
      },
      "&-hidden": {
        visibility: "hidden"
      },
      "&-has-suffix": {
        margin: `0 ${e.inputAffixPadding}px`
      }
    },
    // ======================= TextArea ========================
    "&-textarea-with-clear-btn": {
      padding: "0 !important",
      border: "0 !important",
      [`${t}-clear-icon`]: {
        position: "absolute",
        insetBlockStart: e.paddingXS,
        insetInlineEnd: e.paddingXS,
        zIndex: 1
      }
    }
  };
}, Tj = (e) => {
  const {
    componentCls: t,
    inputAffixPadding: n,
    colorTextDescription: o,
    motionDurationSlow: r,
    colorIcon: l,
    colorIconHover: a,
    iconCls: i
  } = e;
  return {
    [`${t}-affix-wrapper`]: m(m(m(m(m({}, Oa(e)), {
      display: "inline-flex",
      [`&:not(${t}-affix-wrapper-disabled):hover`]: m(m({}, Fi(e)), {
        zIndex: 1,
        [`${t}-search-with-button &`]: {
          zIndex: 0
        }
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${t}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> input${t}`]: {
        padding: 0,
        fontSize: "inherit",
        border: "none",
        borderRadius: 0,
        outline: "none",
        "&:focus": {
          boxShadow: "none !important"
        }
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}`]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          "> *:not(:last-child)": {
            marginInlineEnd: e.paddingXS
          }
        },
        "&-show-count-suffix": {
          color: o
        },
        "&-show-count-has-suffix": {
          marginInlineEnd: e.paddingXXS
        },
        "&-prefix": {
          marginInlineEnd: n
        },
        "&-suffix": {
          marginInlineStart: n
        }
      }
    }), Ej(e)), {
      // password
      [`${i}${t}-password-icon`]: {
        color: l,
        cursor: "pointer",
        transition: `all ${r}`,
        "&:hover": {
          color: a
        }
      }
    }), vc(e, `${t}-affix-wrapper`))
  };
}, Mj = (e) => {
  const {
    componentCls: t,
    colorError: n,
    colorSuccess: o,
    borderRadiusLG: r,
    borderRadiusSM: l
  } = e;
  return {
    [`${t}-group`]: m(m(m({}, qe(e)), k3(e)), {
      "&-rtl": {
        direction: "rtl"
      },
      "&-wrapper": {
        display: "inline-block",
        width: "100%",
        textAlign: "start",
        verticalAlign: "top",
        "&-rtl": {
          direction: "rtl"
        },
        // Size
        "&-lg": {
          [`${t}-group-addon`]: {
            borderRadius: r
          }
        },
        "&-sm": {
          [`${t}-group-addon`]: {
            borderRadius: l
          }
        },
        // Status
        "&-status-error": {
          [`${t}-group-addon`]: {
            color: n,
            borderColor: n
          }
        },
        "&-status-warning": {
          [`${t}-group-addon:last-child`]: {
            color: o,
            borderColor: o
          }
        }
      }
    })
  };
}, _j = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, o = `${t}-search`;
  return {
    [o]: {
      [`${t}`]: {
        "&:hover, &:focus": {
          borderColor: e.colorPrimaryHover,
          [`+ ${t}-group-addon ${o}-button:not(${n}-btn-primary)`]: {
            borderInlineStartColor: e.colorPrimaryHover
          }
        }
      },
      [`${t}-affix-wrapper`]: {
        borderRadius: 0
      },
      // fix slight height diff in Firefox:
      // https://ant.design/components/auto-complete-cn/#components-auto-complete-demo-certain-category
      [`${t}-lg`]: {
        lineHeight: e.lineHeightLG - 2e-4
      },
      [`> ${t}-group`]: {
        [`> ${t}-group-addon:last-child`]: {
          insetInlineStart: -1,
          padding: 0,
          border: 0,
          [`${o}-button`]: {
            paddingTop: 0,
            paddingBottom: 0,
            borderStartStartRadius: 0,
            borderStartEndRadius: e.borderRadius,
            borderEndEndRadius: e.borderRadius,
            borderEndStartRadius: 0
          },
          [`${o}-button:not(${n}-btn-primary)`]: {
            color: e.colorTextDescription,
            "&:hover": {
              color: e.colorPrimaryHover
            },
            "&:active": {
              color: e.colorPrimaryActive
            },
            [`&${n}-btn-loading::before`]: {
              insetInlineStart: 0,
              insetInlineEnd: 0,
              insetBlockStart: 0,
              insetBlockEnd: 0
            }
          }
        }
      },
      [`${o}-button`]: {
        height: e.controlHeight,
        "&:hover, &:focus": {
          zIndex: 1
        }
      },
      [`&-large ${o}-button`]: {
        height: e.controlHeightLG
      },
      [`&-small ${o}-button`]: {
        height: e.controlHeightSM
      },
      "&-rtl": {
        direction: "rtl"
      },
      // ===================== Compact Item Customized Styles =====================
      [`&${t}-compact-item`]: {
        [`&:not(${t}-compact-last-item)`]: {
          [`${t}-group-addon`]: {
            [`${t}-search-button`]: {
              marginInlineEnd: -e.lineWidth,
              borderRadius: 0
            }
          }
        },
        [`&:not(${t}-compact-first-item)`]: {
          [`${t},${t}-affix-wrapper`]: {
            borderRadius: 0
          }
        },
        [`> ${t}-group-addon ${t}-search-button,
        > ${t},
        ${t}-affix-wrapper`]: {
          "&:hover,&:focus,&:active": {
            zIndex: 2
          }
        },
        [`> ${t}-affix-wrapper-focused`]: {
          zIndex: 2
        }
      }
    }
  };
};
function Pa(e) {
  return He(e, {
    inputAffixPadding: e.paddingXXS,
    inputPaddingVertical: Math.max(Math.round((e.controlHeight - e.fontSize * e.lineHeight) / 2 * 10) / 10 - e.lineWidth, 3),
    inputPaddingVerticalLG: Math.ceil((e.controlHeightLG - e.fontSizeLG * e.lineHeightLG) / 2 * 10) / 10 - e.lineWidth,
    inputPaddingVerticalSM: Math.max(Math.round((e.controlHeightSM - e.fontSize * e.lineHeight) / 2 * 10) / 10 - e.lineWidth, 0),
    inputPaddingHorizontal: e.paddingSM - e.lineWidth,
    inputPaddingHorizontalSM: e.paddingXS - e.lineWidth,
    inputPaddingHorizontalLG: e.controlPaddingHorizontal - e.lineWidth,
    inputBorderHoverColor: e.colorPrimaryHover,
    inputBorderActiveColor: e.colorPrimaryHover
  });
}
const Aj = (e) => {
  const {
    componentCls: t,
    inputPaddingHorizontal: n,
    paddingLG: o
  } = e, r = `${t}-textarea`;
  return {
    [r]: {
      position: "relative",
      [`${r}-suffix`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: n,
        bottom: 0,
        zIndex: 1,
        display: "inline-flex",
        alignItems: "center",
        margin: "auto"
      },
      "&-status-error,\n        &-status-warning,\n        &-status-success,\n        &-status-validating": {
        [`&${r}-has-feedback`]: {
          [`${t}`]: {
            paddingInlineEnd: o
          }
        }
      },
      "&-show-count": {
        // https://github.com/ant-design/ant-design/issues/33049
        [`> ${t}`]: {
          height: "100%"
        },
        "&::after": {
          color: e.colorTextDescription,
          whiteSpace: "nowrap",
          content: "attr(data-count)",
          pointerEvents: "none",
          float: "right"
        }
      },
      "&-rtl": {
        "&::after": {
          float: "left"
        }
      }
    }
  };
}, G0 = Xe("Input", (e) => {
  const t = Pa(e);
  return [
    Ij(t),
    Aj(t),
    Tj(t),
    Mj(t),
    _j(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Ri(t)
  ];
}), mv = (e, t, n, o) => {
  const {
    lineHeight: r
  } = e, l = Math.floor(n * r) + 2, a = Math.max((t - l) / 2, 0), i = Math.max(t - l - a, 0);
  return {
    padding: `${a}px ${o}px ${i}px`
  };
}, Dj = (e) => {
  const {
    componentCls: t,
    pickerCellCls: n,
    pickerCellInnerCls: o,
    pickerPanelCellHeight: r,
    motionDurationSlow: l,
    borderRadiusSM: a,
    motionDurationMid: i,
    controlItemBgHover: s,
    lineWidth: c,
    lineType: u,
    colorPrimary: d,
    controlItemBgActive: p,
    colorTextLightSolid: v,
    controlHeightSM: h,
    pickerDateHoverRangeBorderColor: g,
    pickerCellBorderGap: b,
    pickerBasicCellHoverWithRangeColor: y,
    pickerPanelCellWidth: S,
    colorTextDisabled: C,
    colorBgContainerDisabled: w
  } = e;
  return {
    "&::before": {
      position: "absolute",
      top: "50%",
      insetInlineStart: 0,
      insetInlineEnd: 0,
      zIndex: 1,
      height: r,
      transform: "translateY(-50%)",
      transition: `all ${l}`,
      content: '""'
    },
    // >>> Default
    [o]: {
      position: "relative",
      zIndex: 2,
      display: "inline-block",
      minWidth: r,
      height: r,
      lineHeight: `${r}px`,
      borderRadius: a,
      transition: `background ${i}, border ${i}`
    },
    // >>> Hover
    [`&:hover:not(${n}-in-view),
    &:hover:not(${n}-selected):not(${n}-range-start):not(${n}-range-end):not(${n}-range-hover-start):not(${n}-range-hover-end)`]: {
      [o]: {
        background: s
      }
    },
    // >>> Today
    [`&-in-view${n}-today ${o}`]: {
      "&::before": {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 1,
        border: `${c}px ${u} ${d}`,
        borderRadius: a,
        content: '""'
      }
    },
    // >>> In Range
    [`&-in-view${n}-in-range`]: {
      position: "relative",
      "&::before": {
        background: p
      }
    },
    // >>> Selected
    [`&-in-view${n}-selected ${o},
      &-in-view${n}-range-start ${o},
      &-in-view${n}-range-end ${o}`]: {
      color: v,
      background: d
    },
    [`&-in-view${n}-range-start:not(${n}-range-start-single),
      &-in-view${n}-range-end:not(${n}-range-end-single)`]: {
      "&::before": {
        background: p
      }
    },
    [`&-in-view${n}-range-start::before`]: {
      insetInlineStart: "50%"
    },
    [`&-in-view${n}-range-end::before`]: {
      insetInlineEnd: "50%"
    },
    // >>> Range Hover
    [`&-in-view${n}-range-hover-start:not(${n}-in-range):not(${n}-range-start):not(${n}-range-end),
      &-in-view${n}-range-hover-end:not(${n}-in-range):not(${n}-range-start):not(${n}-range-end),
      &-in-view${n}-range-hover-start${n}-range-start-single,
      &-in-view${n}-range-hover-start${n}-range-start${n}-range-end${n}-range-end-near-hover,
      &-in-view${n}-range-hover-end${n}-range-start${n}-range-end${n}-range-start-near-hover,
      &-in-view${n}-range-hover-end${n}-range-end-single,
      &-in-view${n}-range-hover:not(${n}-in-range)`]: {
      "&::after": {
        position: "absolute",
        top: "50%",
        zIndex: 0,
        height: h,
        borderTop: `${c}px dashed ${g}`,
        borderBottom: `${c}px dashed ${g}`,
        transform: "translateY(-50%)",
        transition: `all ${l}`,
        content: '""'
      }
    },
    // Add space for stash
    "&-range-hover-start::after,\n      &-range-hover-end::after,\n      &-range-hover::after": {
      insetInlineEnd: 0,
      insetInlineStart: b
    },
    // Hover with in range
    [`&-in-view${n}-in-range${n}-range-hover::before,
      &-in-view${n}-range-start${n}-range-hover::before,
      &-in-view${n}-range-end${n}-range-hover::before,
      &-in-view${n}-range-start:not(${n}-range-start-single)${n}-range-hover-start::before,
      &-in-view${n}-range-end:not(${n}-range-end-single)${n}-range-hover-end::before,
      ${t}-panel
      > :not(${t}-date-panel)
      &-in-view${n}-in-range${n}-range-hover-start::before,
      ${t}-panel
      > :not(${t}-date-panel)
      &-in-view${n}-in-range${n}-range-hover-end::before`]: {
      background: y
    },
    // range start border-radius
    [`&-in-view${n}-range-start:not(${n}-range-start-single):not(${n}-range-end) ${o}`]: {
      borderStartStartRadius: a,
      borderEndStartRadius: a,
      borderStartEndRadius: 0,
      borderEndEndRadius: 0
    },
    // range end border-radius
    [`&-in-view${n}-range-end:not(${n}-range-end-single):not(${n}-range-start) ${o}`]: {
      borderStartStartRadius: 0,
      borderEndStartRadius: 0,
      borderStartEndRadius: a,
      borderEndEndRadius: a
    },
    [`&-range-hover${n}-range-end::after`]: {
      insetInlineStart: "50%"
    },
    // Edge start
    [`tr > &-in-view${n}-range-hover:first-child::after,
      tr > &-in-view${n}-range-hover-end:first-child::after,
      &-in-view${n}-start${n}-range-hover-edge-start${n}-range-hover-edge-start-near-range::after,
      &-in-view${n}-range-hover-edge-start:not(${n}-range-hover-edge-start-near-range)::after,
      &-in-view${n}-range-hover-start::after`]: {
      insetInlineStart: (S - r) / 2,
      borderInlineStart: `${c}px dashed ${g}`,
      borderStartStartRadius: c,
      borderEndStartRadius: c
    },
    // Edge end
    [`tr > &-in-view${n}-range-hover:last-child::after,
      tr > &-in-view${n}-range-hover-start:last-child::after,
      &-in-view${n}-end${n}-range-hover-edge-end${n}-range-hover-edge-end-near-range::after,
      &-in-view${n}-range-hover-edge-end:not(${n}-range-hover-edge-end-near-range)::after,
      &-in-view${n}-range-hover-end::after`]: {
      insetInlineEnd: (S - r) / 2,
      borderInlineEnd: `${c}px dashed ${g}`,
      borderStartEndRadius: c,
      borderEndEndRadius: c
    },
    // >>> Disabled
    "&-disabled": {
      color: C,
      pointerEvents: "none",
      [o]: {
        background: "transparent"
      },
      "&::before": {
        background: w
      }
    },
    [`&-disabled${n}-today ${o}::before`]: {
      borderColor: C
    }
  };
}, B3 = (e) => {
  const {
    componentCls: t,
    pickerCellInnerCls: n,
    pickerYearMonthCellWidth: o,
    pickerControlIconSize: r,
    pickerPanelCellWidth: l,
    paddingSM: a,
    paddingXS: i,
    paddingXXS: s,
    colorBgContainer: c,
    lineWidth: u,
    lineType: d,
    borderRadiusLG: p,
    colorPrimary: v,
    colorTextHeading: h,
    colorSplit: g,
    pickerControlIconBorderWidth: b,
    colorIcon: y,
    pickerTextHeight: S,
    motionDurationMid: C,
    colorIconHover: w,
    fontWeightStrong: $,
    pickerPanelCellHeight: O,
    pickerCellPaddingVertical: x,
    colorTextDisabled: I,
    colorText: E,
    fontSize: _,
    pickerBasicCellHoverWithRangeColor: M,
    motionDurationSlow: R,
    pickerPanelWithoutTimeCellHeight: A,
    pickerQuarterPanelContentHeight: z,
    colorLink: T,
    colorLinkActive: N,
    colorLinkHover: k,
    pickerDateHoverRangeBorderColor: B,
    borderRadiusSM: F,
    colorTextLightSolid: L,
    borderRadius: j,
    controlItemBgHover: H,
    pickerTimePanelColumnHeight: K,
    pickerTimePanelColumnWidth: X,
    pickerTimePanelCellHeight: W,
    controlItemBgActive: q,
    marginXXS: J
  } = e, ne = l * 7 + a * 2 + 4, te = (ne - i * 2) / 3 - o - a;
  return {
    [t]: {
      "&-panel": {
        display: "inline-flex",
        flexDirection: "column",
        textAlign: "center",
        background: c,
        border: `${u}px ${d} ${g}`,
        borderRadius: p,
        outline: "none",
        "&-focused": {
          borderColor: v
        },
        "&-rtl": {
          direction: "rtl",
          [`${t}-prev-icon,
              ${t}-super-prev-icon`]: {
            transform: "rotate(45deg)"
          },
          [`${t}-next-icon,
              ${t}-super-next-icon`]: {
            transform: "rotate(-135deg)"
          }
        }
      },
      // ========================================================
      // =                     Shared Panel                     =
      // ========================================================
      "&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel,\n        &-week-panel,\n        &-date-panel,\n        &-time-panel": {
        display: "flex",
        flexDirection: "column",
        width: ne
      },
      // ======================= Header =======================
      "&-header": {
        display: "flex",
        padding: `0 ${i}px`,
        color: h,
        borderBottom: `${u}px ${d} ${g}`,
        "> *": {
          flex: "none"
        },
        button: {
          padding: 0,
          color: y,
          lineHeight: `${S}px`,
          background: "transparent",
          border: 0,
          cursor: "pointer",
          transition: `color ${C}`
        },
        "> button": {
          minWidth: "1.6em",
          fontSize: _,
          "&:hover": {
            color: w
          }
        },
        "&-view": {
          flex: "auto",
          fontWeight: $,
          lineHeight: `${S}px`,
          button: {
            color: "inherit",
            fontWeight: "inherit",
            verticalAlign: "top",
            "&:not(:first-child)": {
              marginInlineStart: i
            },
            "&:hover": {
              color: v
            }
          }
        }
      },
      // Arrow button
      "&-prev-icon,\n        &-next-icon,\n        &-super-prev-icon,\n        &-super-next-icon": {
        position: "relative",
        display: "inline-block",
        width: r,
        height: r,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          display: "inline-block",
          width: r,
          height: r,
          border: "0 solid currentcolor",
          borderBlockStartWidth: b,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: b,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      "&-super-prev-icon,\n        &-super-next-icon": {
        "&::after": {
          position: "absolute",
          top: Math.ceil(r / 2),
          insetInlineStart: Math.ceil(r / 2),
          display: "inline-block",
          width: r,
          height: r,
          border: "0 solid currentcolor",
          borderBlockStartWidth: b,
          borderBlockEndWidth: 0,
          borderInlineStartWidth: b,
          borderInlineEndWidth: 0,
          content: '""'
        }
      },
      "&-prev-icon,\n        &-super-prev-icon": {
        transform: "rotate(-45deg)"
      },
      "&-next-icon,\n        &-super-next-icon": {
        transform: "rotate(135deg)"
      },
      // ======================== Body ========================
      "&-content": {
        width: "100%",
        tableLayout: "fixed",
        borderCollapse: "collapse",
        "th, td": {
          position: "relative",
          minWidth: O,
          fontWeight: "normal"
        },
        th: {
          height: O + x * 2,
          color: E,
          verticalAlign: "middle"
        }
      },
      "&-cell": m({
        padding: `${x}px 0`,
        color: I,
        cursor: "pointer",
        // In view
        "&-in-view": {
          color: E
        }
      }, Dj(e)),
      // DatePanel only
      [`&-date-panel ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-start ${n},
        &-date-panel ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-end ${n}`]: {
        "&::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: -1,
          background: M,
          transition: `all ${R}`,
          content: '""'
        }
      },
      [`&-date-panel
        ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-start
        ${n}::after`]: {
        insetInlineEnd: -(l - O) / 2,
        insetInlineStart: 0
      },
      [`&-date-panel ${t}-cell-in-view${t}-cell-in-range${t}-cell-range-hover-end ${n}::after`]: {
        insetInlineEnd: 0,
        insetInlineStart: -(l - O) / 2
      },
      // Hover with range start & end
      [`&-range-hover${t}-range-start::after`]: {
        insetInlineEnd: "50%"
      },
      "&-decade-panel,\n        &-year-panel,\n        &-quarter-panel,\n        &-month-panel": {
        [`${t}-content`]: {
          height: A * 4
        },
        [n]: {
          padding: `0 ${i}px`
        }
      },
      "&-quarter-panel": {
        [`${t}-content`]: {
          height: z
        }
      },
      // ======================== Footer ========================
      [`&-panel ${t}-footer`]: {
        borderTop: `${u}px ${d} ${g}`
      },
      "&-footer": {
        width: "min-content",
        minWidth: "100%",
        lineHeight: `${S - 2 * u}px`,
        textAlign: "center",
        "&-extra": {
          padding: `0 ${a}`,
          lineHeight: `${S - 2 * u}px`,
          textAlign: "start",
          "&:not(:last-child)": {
            borderBottom: `${u}px ${d} ${g}`
          }
        }
      },
      "&-now": {
        textAlign: "start"
      },
      "&-today-btn": {
        color: T,
        "&:hover": {
          color: k
        },
        "&:active": {
          color: N
        },
        [`&${t}-today-btn-disabled`]: {
          color: I,
          cursor: "not-allowed"
        }
      },
      // ========================================================
      // =                       Special                        =
      // ========================================================
      // ===================== Decade Panel =====================
      "&-decade-panel": {
        [n]: {
          padding: `0 ${i / 2}px`
        },
        [`${t}-cell::before`]: {
          display: "none"
        }
      },
      // ============= Year & Quarter & Month Panel =============
      "&-year-panel,\n        &-quarter-panel,\n        &-month-panel": {
        [`${t}-body`]: {
          padding: `0 ${i}px`
        },
        [n]: {
          width: o
        },
        [`${t}-cell-range-hover-start::after`]: {
          insetInlineStart: te,
          borderInlineStart: `${u}px dashed ${B}`,
          borderStartStartRadius: F,
          borderBottomStartRadius: F,
          borderStartEndRadius: 0,
          borderBottomEndRadius: 0,
          [`${t}-panel-rtl &`]: {
            insetInlineEnd: te,
            borderInlineEnd: `${u}px dashed ${B}`,
            borderStartStartRadius: 0,
            borderBottomStartRadius: 0,
            borderStartEndRadius: F,
            borderBottomEndRadius: F
          }
        },
        [`${t}-cell-range-hover-end::after`]: {
          insetInlineEnd: te,
          borderInlineEnd: `${u}px dashed ${B}`,
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          borderStartEndRadius: j,
          borderEndEndRadius: j,
          [`${t}-panel-rtl &`]: {
            insetInlineStart: te,
            borderInlineStart: `${u}px dashed ${B}`,
            borderStartStartRadius: j,
            borderEndStartRadius: j,
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        }
      },
      // ====================== Week Panel ======================
      "&-week-panel": {
        [`${t}-body`]: {
          padding: `${i}px ${a}px`
        },
        // Clear cell style
        [`${t}-cell`]: {
          [`&:hover ${n},
            &-selected ${n},
            ${n}`]: {
            background: "transparent !important"
          }
        },
        "&-row": {
          td: {
            transition: `background ${C}`,
            "&:first-child": {
              borderStartStartRadius: F,
              borderEndStartRadius: F
            },
            "&:last-child": {
              borderStartEndRadius: F,
              borderEndEndRadius: F
            }
          },
          "&:hover td": {
            background: H
          },
          "&-selected td,\n            &-selected:hover td": {
            background: v,
            [`&${t}-cell-week`]: {
              color: new Ct(L).setAlpha(0.5).toHexString()
            },
            [`&${t}-cell-today ${n}::before`]: {
              borderColor: L
            },
            [n]: {
              color: L
            }
          }
        }
      },
      // ====================== Date Panel ======================
      "&-date-panel": {
        [`${t}-body`]: {
          padding: `${i}px ${a}px`
        },
        [`${t}-content`]: {
          width: l * 7,
          th: {
            width: l
          }
        }
      },
      // ==================== Datetime Panel ====================
      "&-datetime-panel": {
        display: "flex",
        [`${t}-time-panel`]: {
          borderInlineStart: `${u}px ${d} ${g}`
        },
        [`${t}-date-panel,
          ${t}-time-panel`]: {
          transition: `opacity ${R}`
        },
        // Keyboard
        "&-active": {
          [`${t}-date-panel,
            ${t}-time-panel`]: {
            opacity: 0.3,
            "&-active": {
              opacity: 1
            }
          }
        }
      },
      // ====================== Time Panel ======================
      "&-time-panel": {
        width: "auto",
        minWidth: "auto",
        direction: "ltr",
        [`${t}-content`]: {
          display: "flex",
          flex: "auto",
          height: K
        },
        "&-column": {
          flex: "1 0 auto",
          width: X,
          margin: `${s}px 0`,
          padding: 0,
          overflowY: "hidden",
          textAlign: "start",
          listStyle: "none",
          transition: `background ${C}`,
          overflowX: "hidden",
          "&::after": {
            display: "block",
            height: K - W,
            content: '""'
          },
          "&:not(:first-child)": {
            borderInlineStart: `${u}px ${d} ${g}`
          },
          "&-active": {
            background: new Ct(q).setAlpha(0.2).toHexString()
          },
          "&:hover": {
            overflowY: "auto"
          },
          "> li": {
            margin: 0,
            padding: 0,
            [`&${t}-time-panel-cell`]: {
              marginInline: J,
              [`${t}-time-panel-cell-inner`]: {
                display: "block",
                width: X - 2 * J,
                height: W,
                margin: 0,
                paddingBlock: 0,
                paddingInlineEnd: 0,
                paddingInlineStart: (X - W) / 2,
                color: E,
                lineHeight: `${W}px`,
                borderRadius: F,
                cursor: "pointer",
                transition: `background ${C}`,
                "&:hover": {
                  background: H
                }
              },
              "&-selected": {
                [`${t}-time-panel-cell-inner`]: {
                  background: q
                }
              },
              "&-disabled": {
                [`${t}-time-panel-cell-inner`]: {
                  color: I,
                  background: "transparent",
                  cursor: "not-allowed"
                }
              }
            }
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/39227
      [`&-datetime-panel ${t}-time-panel-column:after`]: {
        height: K - W + s * 2
      }
    }
  };
}, Nj = (e) => {
  const {
    componentCls: t,
    colorBgContainer: n,
    colorError: o,
    colorErrorOutline: r,
    colorWarning: l,
    colorWarningOutline: a
  } = e;
  return {
    [t]: {
      [`&-status-error${t}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: n,
          borderColor: o
        },
        "&-focused, &:focus": m({}, Sl(He(e, {
          inputBorderActiveColor: o,
          inputBorderHoverColor: o,
          controlOutline: r
        }))),
        [`${t}-active-bar`]: {
          background: o
        }
      },
      [`&-status-warning${t}`]: {
        "&, &:not([disabled]):hover": {
          backgroundColor: n,
          borderColor: l
        },
        "&-focused, &:focus": m({}, Sl(He(e, {
          inputBorderActiveColor: l,
          inputBorderHoverColor: l,
          controlOutline: a
        }))),
        [`${t}-active-bar`]: {
          background: l
        }
      }
    }
  };
}, Rj = (e) => {
  const {
    componentCls: t,
    antCls: n,
    boxShadowPopoverArrow: o,
    controlHeight: r,
    fontSize: l,
    inputPaddingHorizontal: a,
    colorBgContainer: i,
    lineWidth: s,
    lineType: c,
    colorBorder: u,
    borderRadius: d,
    motionDurationMid: p,
    colorBgContainerDisabled: v,
    colorTextDisabled: h,
    colorTextPlaceholder: g,
    controlHeightLG: b,
    fontSizeLG: y,
    controlHeightSM: S,
    inputPaddingHorizontalSM: C,
    paddingXS: w,
    marginXS: $,
    colorTextDescription: O,
    lineWidthBold: x,
    lineHeight: I,
    colorPrimary: E,
    motionDurationSlow: _,
    zIndexPopup: M,
    paddingXXS: R,
    paddingSM: A,
    pickerTextHeight: z,
    controlItemBgActive: T,
    colorPrimaryBorder: N,
    sizePopupArrow: k,
    borderRadiusXS: B,
    borderRadiusOuter: F,
    colorBgElevated: L,
    borderRadiusLG: j,
    boxShadowSecondary: H,
    borderRadiusSM: K,
    colorSplit: X,
    controlItemBgHover: W,
    presetsWidth: q,
    presetsMaxWidth: J
  } = e;
  return [
    {
      [t]: m(m(m({}, qe(e)), mv(e, r, l, a)), {
        position: "relative",
        display: "inline-flex",
        alignItems: "center",
        background: i,
        lineHeight: 1,
        border: `${s}px ${c} ${u}`,
        borderRadius: d,
        transition: `border ${p}, box-shadow ${p}`,
        "&:hover, &-focused": m({}, Fi(e)),
        "&-focused": m({}, Sl(e)),
        [`&${t}-disabled`]: {
          background: v,
          borderColor: u,
          cursor: "not-allowed",
          [`${t}-suffix`]: {
            color: h
          }
        },
        [`&${t}-borderless`]: {
          backgroundColor: "transparent !important",
          borderColor: "transparent !important",
          boxShadow: "none !important"
        },
        // ======================== Input =========================
        [`${t}-input`]: {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          width: "100%",
          "> input": m(m({}, Oa(e)), {
            flex: "auto",
            // Fix Firefox flex not correct:
            // https://github.com/ant-design/ant-design/pull/20023#issuecomment-564389553
            minWidth: 1,
            height: "auto",
            padding: 0,
            background: "transparent",
            border: 0,
            "&:focus": {
              boxShadow: "none"
            },
            "&[disabled]": {
              background: "transparent"
            }
          }),
          "&:hover": {
            [`${t}-clear`]: {
              opacity: 1
            }
          },
          "&-placeholder": {
            "> input": {
              color: g
            }
          }
        },
        // Size
        "&-large": m(m({}, mv(e, b, y, a)), {
          [`${t}-input > input`]: {
            fontSize: y
          }
        }),
        "&-small": m({}, mv(e, S, l, C)),
        [`${t}-suffix`]: {
          display: "flex",
          flex: "none",
          alignSelf: "center",
          marginInlineStart: w / 2,
          color: h,
          lineHeight: 1,
          pointerEvents: "none",
          "> *": {
            verticalAlign: "top",
            "&:not(:last-child)": {
              marginInlineEnd: $
            }
          }
        },
        [`${t}-clear`]: {
          position: "absolute",
          top: "50%",
          insetInlineEnd: 0,
          color: h,
          lineHeight: 1,
          background: i,
          transform: "translateY(-50%)",
          cursor: "pointer",
          opacity: 0,
          transition: `opacity ${p}, color ${p}`,
          "> *": {
            verticalAlign: "top"
          },
          "&:hover": {
            color: O
          }
        },
        [`${t}-separator`]: {
          position: "relative",
          display: "inline-block",
          width: "1em",
          height: y,
          color: h,
          fontSize: y,
          verticalAlign: "top",
          cursor: "default",
          [`${t}-focused &`]: {
            color: O
          },
          [`${t}-range-separator &`]: {
            [`${t}-disabled &`]: {
              cursor: "not-allowed"
            }
          }
        },
        // ======================== Range =========================
        "&-range": {
          position: "relative",
          display: "inline-flex",
          // Clear
          [`${t}-clear`]: {
            insetInlineEnd: a
          },
          "&:hover": {
            [`${t}-clear`]: {
              opacity: 1
            }
          },
          // Active bar
          [`${t}-active-bar`]: {
            bottom: -s,
            height: x,
            marginInlineStart: a,
            background: E,
            opacity: 0,
            transition: `all ${_} ease-out`,
            pointerEvents: "none"
          },
          [`&${t}-focused`]: {
            [`${t}-active-bar`]: {
              opacity: 1
            }
          },
          [`${t}-range-separator`]: {
            alignItems: "center",
            padding: `0 ${w}px`,
            lineHeight: 1
          },
          [`&${t}-small`]: {
            [`${t}-clear`]: {
              insetInlineEnd: C
            },
            [`${t}-active-bar`]: {
              marginInlineStart: C
            }
          }
        },
        // ======================= Dropdown =======================
        "&-dropdown": m(m(m({}, qe(e)), B3(e)), {
          position: "absolute",
          // Fix incorrect position of picker popup
          // https://github.com/ant-design/ant-design/issues/35590
          top: -9999,
          left: {
            _skip_check_: !0,
            value: -9999
          },
          zIndex: M,
          [`&${t}-dropdown-hidden`]: {
            display: "none"
          },
          [`&${t}-dropdown-placement-bottomLeft`]: {
            [`${t}-range-arrow`]: {
              top: 0,
              display: "block",
              transform: "translateY(-100%)"
            }
          },
          [`&${t}-dropdown-placement-topLeft`]: {
            [`${t}-range-arrow`]: {
              bottom: 0,
              display: "block",
              transform: "translateY(100%) rotate(180deg)"
            }
          },
          [`&${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-topLeft,
          &${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-topRight,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-topLeft,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-topRight`]: {
            animationName: Kf
          },
          [`&${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-bottomLeft,
          &${n}-slide-up-enter${n}-slide-up-enter-active${t}-dropdown-placement-bottomRight,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-bottomLeft,
          &${n}-slide-up-appear${n}-slide-up-appear-active${t}-dropdown-placement-bottomRight`]: {
            animationName: Vf
          },
          [`&${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-topLeft,
          &${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-topRight`]: {
            animationName: Gf
          },
          [`&${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-bottomLeft,
          &${n}-slide-up-leave${n}-slide-up-leave-active${t}-dropdown-placement-bottomRight`]: {
            animationName: Wf
          },
          // Time picker with additional style
          [`${t}-panel > ${t}-time-panel`]: {
            paddingTop: R
          },
          // ======================== Ranges ========================
          [`${t}-ranges`]: {
            marginBottom: 0,
            padding: `${R}px ${A}px`,
            overflow: "hidden",
            lineHeight: `${z - 2 * s - w / 2}px`,
            textAlign: "start",
            listStyle: "none",
            display: "flex",
            justifyContent: "space-between",
            "> li": {
              display: "inline-block"
            },
            // https://github.com/ant-design/ant-design/issues/23687
            [`${t}-preset > ${n}-tag-blue`]: {
              color: E,
              background: T,
              borderColor: N,
              cursor: "pointer"
            },
            [`${t}-ok`]: {
              marginInlineStart: "auto"
            }
          },
          [`${t}-range-wrapper`]: {
            display: "flex",
            position: "relative"
          },
          [`${t}-range-arrow`]: m({
            position: "absolute",
            zIndex: 1,
            display: "none",
            marginInlineStart: a * 1.5,
            transition: `left ${_} ease-out`
          }, dh(k, B, F, L, o)),
          [`${t}-panel-container`]: {
            overflow: "hidden",
            verticalAlign: "top",
            background: L,
            borderRadius: j,
            boxShadow: H,
            transition: `margin ${_}`,
            // ======================== Layout ========================
            [`${t}-panel-layout`]: {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "stretch"
            },
            // ======================== Preset ========================
            [`${t}-presets`]: {
              display: "flex",
              flexDirection: "column",
              minWidth: q,
              maxWidth: J,
              ul: {
                height: 0,
                flex: "auto",
                listStyle: "none",
                overflow: "auto",
                margin: 0,
                padding: w,
                borderInlineEnd: `${s}px ${c} ${X}`,
                li: m(m({}, tn), {
                  borderRadius: K,
                  paddingInline: w,
                  paddingBlock: (S - Math.round(l * I)) / 2,
                  cursor: "pointer",
                  transition: `all ${_}`,
                  "+ li": {
                    marginTop: $
                  },
                  "&:hover": {
                    background: W
                  }
                })
              }
            },
            // ======================== Panels ========================
            [`${t}-panels`]: {
              display: "inline-flex",
              flexWrap: "nowrap",
              direction: "ltr",
              [`${t}-panel`]: {
                borderWidth: `0 0 ${s}px`
              },
              "&:last-child": {
                [`${t}-panel`]: {
                  borderWidth: 0
                }
              }
            },
            [`${t}-panel`]: {
              verticalAlign: "top",
              background: "transparent",
              borderRadius: 0,
              borderWidth: 0,
              [`${t}-content,
            table`]: {
                textAlign: "center"
              },
              "&-focused": {
                borderColor: u
              }
            }
          }
        }),
        "&-dropdown-range": {
          padding: `${k * 2 / 3}px 0`,
          "&-hidden": {
            display: "none"
          }
        },
        "&-rtl": {
          direction: "rtl",
          [`${t}-separator`]: {
            transform: "rotate(180deg)"
          },
          [`${t}-footer`]: {
            "&-extra": {
              direction: "rtl"
            }
          }
        }
      })
    },
    // Follow code may reuse in other components
    $r(e, "slide-up"),
    $r(e, "slide-down"),
    Ci(e, "move-up"),
    Ci(e, "move-down")
  ];
}, F3 = (e) => {
  const {
    componentCls: n,
    controlHeightLG: o,
    controlHeightSM: r,
    colorPrimary: l,
    paddingXXS: a
  } = e;
  return {
    pickerCellCls: `${n}-cell`,
    pickerCellInnerCls: `${n}-cell-inner`,
    pickerTextHeight: o,
    pickerPanelCellWidth: r * 1.5,
    pickerPanelCellHeight: r,
    pickerDateHoverRangeBorderColor: new Ct(l).lighten(20).toHexString(),
    pickerBasicCellHoverWithRangeColor: new Ct(l).lighten(35).toHexString(),
    pickerPanelWithoutTimeCellHeight: o * 1.65,
    pickerYearMonthCellWidth: o * 1.5,
    pickerTimePanelColumnHeight: 28 * 8,
    pickerTimePanelColumnWidth: o * 1.4,
    pickerTimePanelCellHeight: 28,
    pickerQuarterPanelContentHeight: o * 1.4,
    pickerCellPaddingVertical: a,
    pickerCellBorderGap: 2,
    pickerControlIconSize: 7,
    pickerControlIconBorderWidth: 1.5
  };
}, L3 = Xe("DatePicker", (e) => {
  const t = He(Pa(e), F3(e));
  return [
    Rj(t),
    Nj(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Ri(e, {
      focusElCls: `${e.componentCls}-focused`
    })
  ];
}, (e) => ({
  presetsWidth: 120,
  presetsMaxWidth: 200,
  zIndexPopup: e.zIndexPopupBase + 50
})), kj = (e) => {
  const {
    calendarCls: t,
    componentCls: n,
    calendarFullBg: o,
    calendarFullPanelBg: r,
    calendarItemActiveBg: l
  } = e;
  return {
    [t]: m(m(m({}, B3(e)), qe(e)), {
      background: o,
      "&-rtl": {
        direction: "rtl"
      },
      [`${t}-header`]: {
        display: "flex",
        justifyContent: "flex-end",
        padding: `${e.paddingSM}px 0`,
        [`${t}-year-select`]: {
          minWidth: e.yearControlWidth
        },
        [`${t}-month-select`]: {
          minWidth: e.monthControlWidth,
          marginInlineStart: e.marginXS
        },
        [`${t}-mode-switch`]: {
          marginInlineStart: e.marginXS
        }
      }
    }),
    [`${t} ${n}-panel`]: {
      background: r,
      border: 0,
      borderTop: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
      borderRadius: 0,
      [`${n}-month-panel, ${n}-date-panel`]: {
        width: "auto"
      },
      [`${n}-body`]: {
        padding: `${e.paddingXS}px 0`
      },
      [`${n}-content`]: {
        width: "100%"
      }
    },
    [`${t}-mini`]: {
      borderRadius: e.borderRadiusLG,
      [`${t}-header`]: {
        paddingInlineEnd: e.paddingXS,
        paddingInlineStart: e.paddingXS
      },
      [`${n}-panel`]: {
        borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`
      },
      [`${n}-content`]: {
        height: e.miniContentHeight,
        th: {
          height: "auto",
          padding: 0,
          lineHeight: `${e.weekHeight}px`
        }
      },
      [`${n}-cell::before`]: {
        pointerEvents: "none"
      }
    },
    [`${t}${t}-full`]: {
      [`${n}-panel`]: {
        display: "block",
        width: "100%",
        textAlign: "end",
        background: o,
        border: 0,
        [`${n}-body`]: {
          "th, td": {
            padding: 0
          },
          th: {
            height: "auto",
            paddingInlineEnd: e.paddingSM,
            paddingBottom: e.paddingXXS,
            lineHeight: `${e.weekHeight}px`
          }
        }
      },
      [`${n}-cell`]: {
        "&::before": {
          display: "none"
        },
        "&:hover": {
          [`${t}-date`]: {
            background: e.controlItemBgHover
          }
        },
        [`${t}-date-today::before`]: {
          display: "none"
        },
        // >>> Selected
        [`&-in-view${n}-cell-selected`]: {
          [`${t}-date, ${t}-date-today`]: {
            background: l
          }
        },
        "&-selected, &-selected:hover": {
          [`${t}-date, ${t}-date-today`]: {
            [`${t}-date-value`]: {
              color: e.colorPrimary
            }
          }
        }
      },
      [`${t}-date`]: {
        display: "block",
        width: "auto",
        height: "auto",
        margin: `0 ${e.marginXS / 2}px`,
        padding: `${e.paddingXS / 2}px ${e.paddingXS}px 0`,
        border: 0,
        borderTop: `${e.lineWidthBold}px ${e.lineType} ${e.colorSplit}`,
        borderRadius: 0,
        transition: `background ${e.motionDurationSlow}`,
        "&-value": {
          lineHeight: `${e.dateValueHeight}px`,
          transition: `color ${e.motionDurationSlow}`
        },
        "&-content": {
          position: "static",
          width: "auto",
          height: e.dateContentHeight,
          overflowY: "auto",
          color: e.colorText,
          lineHeight: e.lineHeight,
          textAlign: "start"
        },
        "&-today": {
          borderColor: e.colorPrimary,
          [`${t}-date-value`]: {
            color: e.colorText
          }
        }
      }
    },
    [`@media only screen and (max-width: ${e.screenXS}px) `]: {
      [`${t}`]: {
        [`${t}-header`]: {
          display: "block",
          [`${t}-year-select`]: {
            width: "50%"
          },
          [`${t}-month-select`]: {
            width: `calc(50% - ${e.paddingXS}px)`
          },
          [`${t}-mode-switch`]: {
            width: "100%",
            marginTop: e.marginXS,
            marginInlineStart: 0,
            "> label": {
              width: "50%",
              textAlign: "center"
            }
          }
        }
      }
    }
  };
}, Bj = Xe("Calendar", (e) => {
  const t = `${e.componentCls}-calendar`, n = He(Pa(e), F3(e), {
    calendarCls: t,
    pickerCellInnerCls: `${e.componentCls}-cell-inner`,
    calendarFullBg: e.colorBgContainer,
    calendarFullPanelBg: e.colorBgContainer,
    calendarItemActiveBg: e.controlItemBgActive,
    dateValueHeight: e.controlHeightSM,
    weekHeight: e.controlHeightSM * 0.75,
    dateContentHeight: (e.fontSizeSM * e.lineHeightSM + e.marginXS) * 3 + e.lineWidth * 2
  });
  return [kj(n)];
}, {
  yearControlWidth: 80,
  monthControlWidth: 70,
  miniContentHeight: 256
});
function Fj(e) {
  function t(l, a) {
    return l && a && e.getYear(l) === e.getYear(a);
  }
  function n(l, a) {
    return t(l, a) && e.getMonth(l) === e.getMonth(a);
  }
  function o(l, a) {
    return n(l, a) && e.getDate(l) === e.getDate(a);
  }
  const r = Z({
    name: "ACalendar",
    inheritAttrs: !1,
    props: {
      prefixCls: String,
      locale: {
        type: Object,
        default: void 0
      },
      validRange: {
        type: Array,
        default: void 0
      },
      disabledDate: {
        type: Function,
        default: void 0
      },
      dateFullCellRender: {
        type: Function,
        default: void 0
      },
      dateCellRender: {
        type: Function,
        default: void 0
      },
      monthFullCellRender: {
        type: Function,
        default: void 0
      },
      monthCellRender: {
        type: Function,
        default: void 0
      },
      headerRender: {
        type: Function,
        default: void 0
      },
      value: {
        type: [Object, String],
        default: void 0
      },
      defaultValue: {
        type: [Object, String],
        default: void 0
      },
      mode: {
        type: String,
        default: void 0
      },
      fullscreen: {
        type: Boolean,
        default: void 0
      },
      onChange: {
        type: Function,
        default: void 0
      },
      "onUpdate:value": {
        type: Function,
        default: void 0
      },
      onPanelChange: {
        type: Function,
        default: void 0
      },
      onSelect: {
        type: Function,
        default: void 0
      },
      valueFormat: {
        type: String,
        default: void 0
      }
    },
    slots: Object,
    setup(l, a) {
      let {
        emit: i,
        slots: s,
        attrs: c
      } = a;
      const u = l, {
        prefixCls: d,
        direction: p
      } = Ie("picker", u), [v, h] = Bj(d), g = P(() => `${d.value}-calendar`), b = (T) => u.valueFormat ? e.toString(T, u.valueFormat) : T, y = P(() => u.value ? u.valueFormat ? e.toDate(u.value, u.valueFormat) : u.value : u.value === "" ? void 0 : u.value), S = P(() => u.defaultValue ? u.valueFormat ? e.toDate(u.defaultValue, u.valueFormat) : u.defaultValue : u.defaultValue === "" ? void 0 : u.defaultValue), [C, w] = Rt(() => y.value || e.getNow(), {
        defaultValue: S.value,
        value: y
      }), [$, O] = Rt("month", {
        value: Te(u, "mode")
      }), x = P(() => $.value === "year" ? "month" : "date"), I = P(() => (T) => {
        var N;
        return (u.validRange ? e.isAfter(u.validRange[0], T) || e.isAfter(T, u.validRange[1]) : !1) || !!(!((N = u.disabledDate) === null || N === void 0) && N.call(u, T));
      }), E = (T, N) => {
        i("panelChange", b(T), N);
      }, _ = (T) => {
        if (w(T), !o(T, C.value)) {
          (x.value === "date" && !n(T, C.value) || x.value === "month" && !t(T, C.value)) && E(T, $.value);
          const N = b(T);
          i("update:value", N), i("change", N);
        }
      }, M = (T) => {
        O(T), E(C.value, T);
      }, R = (T, N) => {
        _(T), i("select", b(T), {
          source: N
        });
      }, A = P(() => {
        const {
          locale: T
        } = u, N = m(m({}, Ds), T);
        return N.lang = m(m({}, N.lang), (T || {}).lang), N;
      }), [z] = jo("Calendar", A);
      return () => {
        const T = e.getNow(), {
          dateFullCellRender: N = s == null ? void 0 : s.dateFullCellRender,
          dateCellRender: k = s == null ? void 0 : s.dateCellRender,
          monthFullCellRender: B = s == null ? void 0 : s.monthFullCellRender,
          monthCellRender: F = s == null ? void 0 : s.monthCellRender,
          headerRender: L = s == null ? void 0 : s.headerRender,
          fullscreen: j = !0,
          validRange: H
        } = u, K = (W) => {
          let {
            current: q
          } = W;
          return N ? N({
            current: q
          }) : f("div", {
            class: ee(`${d.value}-cell-inner`, `${g.value}-date`, {
              [`${g.value}-date-today`]: o(T, q)
            })
          }, [f("div", {
            class: `${g.value}-date-value`
          }, [String(e.getDate(q)).padStart(2, "0")]), f("div", {
            class: `${g.value}-date-content`
          }, [k && k({
            current: q
          })])]);
        }, X = (W, q) => {
          let {
            current: J
          } = W;
          if (B)
            return B({
              current: J
            });
          const ne = q.shortMonths || e.locale.getShortMonths(q.locale);
          return f("div", {
            class: ee(`${d.value}-cell-inner`, `${g.value}-date`, {
              [`${g.value}-date-today`]: n(T, J)
            })
          }, [f("div", {
            class: `${g.value}-date-value`
          }, [ne[e.getMonth(J)]]), f("div", {
            class: `${g.value}-date-content`
          }, [F && F({
            current: J
          })])]);
        };
        return v(f("div", D(D({}, c), {}, {
          class: ee(g.value, {
            [`${g.value}-full`]: j,
            [`${g.value}-mini`]: !j,
            [`${g.value}-rtl`]: p.value === "rtl"
          }, c.class, h.value)
        }), [L ? L({
          value: C.value,
          type: $.value,
          onChange: (W) => {
            R(W, "customize");
          },
          onTypeChange: M
        }) : f(Pj, {
          prefixCls: g.value,
          value: C.value,
          generateConfig: e,
          mode: $.value,
          fullscreen: j,
          locale: z.value.lang,
          validRange: H,
          onChange: R,
          onModeChange: M
        }, null), f(z0, {
          value: C.value,
          prefixCls: d.value,
          locale: z.value.lang,
          generateConfig: e,
          dateRender: K,
          monthCellRender: (W) => X(W, z.value.lang),
          onSelect: (W) => {
            R(W, x.value);
          },
          mode: x.value,
          picker: x.value,
          disabledDate: I.value,
          hideHeader: !0
        }, null)]));
      };
    }
  });
  return r.install = function(l) {
    return l.component(r.name, r), l;
  }, r;
}
const Lj = Fj(C0), zj = kt(Lj);
function Hj(e) {
  const t = Q(), n = Q(!1);
  function o() {
    for (var r = arguments.length, l = new Array(r), a = 0; a < r; a++)
      l[a] = arguments[a];
    n.value || (Ze.cancel(t.value), t.value = Ze(() => {
      e(...l);
    }));
  }
  return et(() => {
    n.value = !0, Ze.cancel(t.value);
  }), o;
}
function jj(e) {
  const t = Q([]), n = Q(typeof e == "function" ? e() : e), o = Hj(() => {
    let l = n.value;
    t.value.forEach((a) => {
      l = a(l);
    }), t.value = [], n.value = l;
  });
  function r(l) {
    t.value.push(l), o();
  }
  return [n, r];
}
const Vj = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TabNode",
  props: {
    id: {
      type: String
    },
    prefixCls: {
      type: String
    },
    tab: {
      type: Object
    },
    active: {
      type: Boolean
    },
    closable: {
      type: Boolean
    },
    editable: {
      type: Object
    },
    onClick: {
      type: Function
    },
    onResize: {
      type: Function
    },
    renderWrapper: {
      type: Function
    },
    removeAriaLabel: {
      type: String
    },
    // onRemove: { type: Function as PropType<() => void> },
    onFocus: {
      type: Function
    }
  },
  emits: ["click", "resize", "remove", "focus"],
  setup(e, t) {
    let {
      expose: n,
      attrs: o
    } = t;
    const r = Y();
    function l(s) {
      var c;
      !((c = e.tab) === null || c === void 0) && c.disabled || e.onClick(s);
    }
    n({
      domRef: r
    });
    function a(s) {
      var c;
      s.preventDefault(), s.stopPropagation(), e.editable.onEdit("remove", {
        key: (c = e.tab) === null || c === void 0 ? void 0 : c.key,
        event: s
      });
    }
    const i = P(() => {
      var s;
      return e.editable && e.closable !== !1 && !(!((s = e.tab) === null || s === void 0) && s.disabled);
    });
    return () => {
      var s;
      const {
        prefixCls: c,
        id: u,
        active: d,
        tab: {
          key: p,
          tab: v,
          disabled: h,
          closeIcon: g
        },
        renderWrapper: b,
        removeAriaLabel: y,
        editable: S,
        onFocus: C
      } = e, w = `${c}-tab`, $ = f("div", {
        key: p,
        ref: r,
        class: ee(w, {
          [`${w}-with-remove`]: i.value,
          [`${w}-active`]: d,
          [`${w}-disabled`]: h
        }),
        style: o.style,
        onClick: l
      }, [f("div", {
        role: "tab",
        "aria-selected": d,
        id: u && `${u}-tab-${p}`,
        class: `${w}-btn`,
        "aria-controls": u && `${u}-panel-${p}`,
        "aria-disabled": h,
        tabindex: h ? null : 0,
        onClick: (O) => {
          O.stopPropagation(), l(O);
        },
        onKeydown: (O) => {
          [ce.SPACE, ce.ENTER].includes(O.which) && (O.preventDefault(), l(O));
        },
        onFocus: C
      }, [typeof v == "function" ? v() : v]), i.value && f("button", {
        type: "button",
        "aria-label": y || "remove",
        tabindex: 0,
        class: `${w}-remove`,
        onClick: (O) => {
          O.stopPropagation(), a(O);
        }
      }, [(g == null ? void 0 : g()) || ((s = S.removeIcon) === null || s === void 0 ? void 0 : s.call(S)) || "×"])]);
      return b ? b($) : $;
    };
  }
}), bC = {
  width: 0,
  height: 0,
  left: 0,
  top: 0
};
function Wj(e, t) {
  const n = Y(/* @__PURE__ */ new Map());
  return Le(() => {
    var o, r;
    const l = /* @__PURE__ */ new Map(), a = e.value, i = t.value.get((o = a[0]) === null || o === void 0 ? void 0 : o.key) || bC, s = i.left + i.width;
    for (let c = 0; c < a.length; c += 1) {
      const {
        key: u
      } = a[c];
      let d = t.value.get(u);
      d || (d = t.value.get((r = a[c - 1]) === null || r === void 0 ? void 0 : r.key) || bC);
      const p = l.get(u) || m({}, d);
      p.right = s - p.left - p.width, l.set(u, p);
    }
    n.value = new Map(l);
  }), n;
}
const z3 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AddButton",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    editable: {
      type: Object
    },
    locale: {
      type: Object,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      expose: n,
      attrs: o
    } = t;
    const r = Y();
    return n({
      domRef: r
    }), () => {
      const {
        prefixCls: l,
        editable: a,
        locale: i
      } = e;
      return !a || a.showAdd === !1 ? null : f("button", {
        ref: r,
        type: "button",
        class: `${l}-nav-add`,
        style: o.style,
        "aria-label": (i == null ? void 0 : i.addAriaLabel) || "Add tab",
        onClick: (s) => {
          a.onEdit("add", {
            event: s
          });
        }
      }, [a.addIcon ? a.addIcon() : "+"]);
    };
  }
}), Kj = {
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  tabs: {
    type: Object
  },
  rtl: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  activeKey: {
    type: [String, Number]
  },
  mobile: {
    type: Boolean
  },
  moreIcon: V.any,
  moreTransitionName: {
    type: String
  },
  editable: {
    type: Object
  },
  locale: {
    type: Object,
    default: void 0
  },
  removeAriaLabel: String,
  onTabClick: {
    type: Function
  },
  popupClassName: String,
  getPopupContainer: le()
}, Gj = Z({
  compatConfig: {
    MODE: 3
  },
  name: "OperationNode",
  inheritAttrs: !1,
  props: Kj,
  emits: ["tabClick"],
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const [r, l] = Pt(!1), [a, i] = Pt(null), s = (v) => {
      const h = e.tabs.filter((y) => !y.disabled);
      let g = h.findIndex((y) => y.key === a.value) || 0;
      const b = h.length;
      for (let y = 0; y < b; y += 1) {
        g = (g + v + b) % b;
        const S = h[g];
        if (!S.disabled) {
          i(S.key);
          return;
        }
      }
    }, c = (v) => {
      const {
        which: h
      } = v;
      if (!r.value) {
        [ce.DOWN, ce.SPACE, ce.ENTER].includes(h) && (l(!0), v.preventDefault());
        return;
      }
      switch (h) {
        case ce.UP:
          s(-1), v.preventDefault();
          break;
        case ce.DOWN:
          s(1), v.preventDefault();
          break;
        case ce.ESC:
          l(!1);
          break;
        case ce.SPACE:
        case ce.ENTER:
          a.value !== null && e.onTabClick(a.value, v);
          break;
      }
    }, u = P(() => `${e.id}-more-popup`), d = P(() => a.value !== null ? `${u.value}-${a.value}` : null), p = (v, h) => {
      v.preventDefault(), v.stopPropagation(), e.editable.onEdit("remove", {
        key: h,
        event: v
      });
    };
    return Ke(() => {
      ie(a, () => {
        const v = document.getElementById(d.value);
        v && v.scrollIntoView && v.scrollIntoView(!1);
      }, {
        flush: "post",
        immediate: !0
      });
    }), ie(r, () => {
      r.value || i(null);
    }), h0({}), () => {
      var v;
      const {
        prefixCls: h,
        id: g,
        tabs: b,
        locale: y,
        mobile: S,
        moreIcon: C = ((v = o.moreIcon) === null || v === void 0 ? void 0 : v.call(o)) || f(uc, null, null),
        moreTransitionName: w,
        editable: $,
        tabBarGutter: O,
        rtl: x,
        onTabClick: I,
        popupClassName: E
      } = e;
      if (!b.length)
        return null;
      const _ = `${h}-dropdown`, M = y == null ? void 0 : y.dropdownAriaLabel, R = {
        [x ? "marginRight" : "marginLeft"]: O
      };
      b.length || (R.visibility = "hidden", R.order = 1);
      const A = ee({
        [`${_}-rtl`]: x,
        [`${E}`]: !0
      }), z = S ? null : f(TO, {
        prefixCls: _,
        trigger: ["hover"],
        visible: r.value,
        transitionName: w,
        onVisibleChange: l,
        overlayClassName: A,
        mouseEnterDelay: 0.1,
        mouseLeaveDelay: 0.1,
        getPopupContainer: e.getPopupContainer
      }, {
        overlay: () => f(en, {
          onClick: (T) => {
            let {
              key: N,
              domEvent: k
            } = T;
            I(N, k), l(!1);
          },
          id: u.value,
          tabindex: -1,
          role: "listbox",
          "aria-activedescendant": d.value,
          selectedKeys: [a.value],
          "aria-label": M !== void 0 ? M : "expanded dropdown"
        }, {
          default: () => [b.map((T) => {
            var N, k;
            const B = $ && T.closable !== !1 && !T.disabled;
            return f(hr, {
              key: T.key,
              id: `${u.value}-${T.key}`,
              role: "option",
              "aria-controls": g && `${g}-panel-${T.key}`,
              disabled: T.disabled
            }, {
              default: () => [f("span", null, [typeof T.tab == "function" ? T.tab() : T.tab]), B && f("button", {
                type: "button",
                "aria-label": e.removeAriaLabel || "remove",
                tabindex: 0,
                class: `${_}-menu-item-remove`,
                onClick: (F) => {
                  F.stopPropagation(), p(F, T.key);
                }
              }, [((N = T.closeIcon) === null || N === void 0 ? void 0 : N.call(T)) || ((k = $.removeIcon) === null || k === void 0 ? void 0 : k.call($)) || "×"])]
            });
          })]
        }),
        default: () => f("button", {
          type: "button",
          class: `${h}-nav-more`,
          style: R,
          tabindex: -1,
          "aria-hidden": "true",
          "aria-haspopup": "listbox",
          "aria-controls": u.value,
          id: `${g}-more`,
          "aria-expanded": r.value,
          onKeydown: c
        }, [C])
      });
      return f("div", {
        class: ee(`${h}-nav-operations`, n.class),
        style: n.style
      }, [z, f(z3, {
        prefixCls: h,
        locale: y,
        editable: $
      }, null)]);
    };
  }
}), H3 = Symbol("tabsContextKey"), j3 = (e) => {
  Je(H3, e);
}, V3 = () => tt(H3, {
  tabs: Y([]),
  prefixCls: Y()
});
Z({
  compatConfig: {
    MODE: 3
  },
  name: "TabsContextProvider",
  inheritAttrs: !1,
  props: {
    tabs: {
      type: Object,
      default: void 0
    },
    prefixCls: {
      type: String,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return j3(Qo(e)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
});
const Xj = 0.1, yC = 0.01, $u = 20, SC = Math.pow(0.995, $u);
function Uj(e, t) {
  const [n, o] = Pt(), [r, l] = Pt(0), [a, i] = Pt(0), [s, c] = Pt(), u = Y();
  function d($) {
    const {
      screenX: O,
      screenY: x
    } = $.touches[0];
    o({
      x: O,
      y: x
    }), clearInterval(u.value);
  }
  function p($) {
    if (!n.value)
      return;
    $.preventDefault();
    const {
      screenX: O,
      screenY: x
    } = $.touches[0], I = O - n.value.x, E = x - n.value.y;
    t(I, E), o({
      x: O,
      y: x
    });
    const _ = Date.now();
    i(_ - r.value), l(_), c({
      x: I,
      y: E
    });
  }
  function v() {
    if (!n.value)
      return;
    const $ = s.value;
    if (o(null), c(null), $) {
      const O = $.x / a.value, x = $.y / a.value, I = Math.abs(O), E = Math.abs(x);
      if (Math.max(I, E) < Xj)
        return;
      let _ = O, M = x;
      u.value = setInterval(() => {
        if (Math.abs(_) < yC && Math.abs(M) < yC) {
          clearInterval(u.value);
          return;
        }
        _ *= SC, M *= SC, t(_ * $u, M * $u);
      }, $u);
    }
  }
  const h = Y();
  function g($) {
    const {
      deltaX: O,
      deltaY: x
    } = $;
    let I = 0;
    const E = Math.abs(O), _ = Math.abs(x);
    E === _ ? I = h.value === "x" ? O : x : E > _ ? (I = O, h.value = "x") : (I = x, h.value = "y"), t(-I, -I) && $.preventDefault();
  }
  const b = Y({
    onTouchStart: d,
    onTouchMove: p,
    onTouchEnd: v,
    onWheel: g
  });
  function y($) {
    b.value.onTouchStart($);
  }
  function S($) {
    b.value.onTouchMove($);
  }
  function C($) {
    b.value.onTouchEnd($);
  }
  function w($) {
    b.value.onWheel($);
  }
  Ke(() => {
    var $, O;
    document.addEventListener("touchmove", S, {
      passive: !1
    }), document.addEventListener("touchend", C, {
      passive: !1
    }), ($ = e.value) === null || $ === void 0 || $.addEventListener("touchstart", y, {
      passive: !1
    }), (O = e.value) === null || O === void 0 || O.addEventListener("wheel", w, {
      passive: !1
    });
  }), et(() => {
    document.removeEventListener("touchmove", S), document.removeEventListener("touchend", C);
  });
}
function CC(e, t) {
  const n = Y(e);
  function o(r) {
    const l = typeof r == "function" ? r(n.value) : r;
    l !== n.value && t(l, n.value), n.value = l;
  }
  return [n, o];
}
const X0 = () => {
  const e = Y(/* @__PURE__ */ new Map()), t = (n) => (o) => {
    e.value.set(n, o);
  };
  return eh(() => {
    e.value = /* @__PURE__ */ new Map();
  }), [t, e];
}, $C = {
  width: 0,
  height: 0,
  left: 0,
  top: 0,
  right: 0
}, Yj = () => ({
  id: {
    type: String
  },
  tabPosition: {
    type: String
  },
  activeKey: {
    type: [String, Number]
  },
  rtl: {
    type: Boolean
  },
  animated: Re(),
  editable: Re(),
  moreIcon: V.any,
  moreTransitionName: {
    type: String
  },
  mobile: {
    type: Boolean
  },
  tabBarGutter: {
    type: Number
  },
  renderTabBar: {
    type: Function
  },
  locale: Re(),
  popupClassName: String,
  getPopupContainer: le(),
  onTabClick: {
    type: Function
  },
  onTabScroll: {
    type: Function
  }
}), qj = (e, t) => {
  const {
    offsetWidth: n,
    offsetHeight: o,
    offsetTop: r,
    offsetLeft: l
  } = e, {
    width: a,
    height: i,
    x: s,
    y: c
  } = e.getBoundingClientRect();
  return Math.abs(a - n) < 1 ? [a, i, s - t.x, c - t.y] : [n, o, l, r];
}, wC = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TabNavList",
  inheritAttrs: !1,
  props: Yj(),
  slots: Object,
  emits: ["tabClick", "tabScroll"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      tabs: r,
      prefixCls: l
    } = V3(), a = Q(), i = Q(), s = Q(), c = Q(), [u, d] = X0(), p = P(() => e.tabPosition === "top" || e.tabPosition === "bottom"), [v, h] = CC(0, (ue, de) => {
      p.value && e.onTabScroll && e.onTabScroll({
        direction: ue > de ? "left" : "right"
      });
    }), [g, b] = CC(0, (ue, de) => {
      !p.value && e.onTabScroll && e.onTabScroll({
        direction: ue > de ? "top" : "bottom"
      });
    }), [y, S] = Pt(0), [C, w] = Pt(0), [$, O] = Pt(null), [x, I] = Pt(null), [E, _] = Pt(0), [M, R] = Pt(0), [A, z] = jj(/* @__PURE__ */ new Map()), T = Wj(r, A), N = P(() => `${l.value}-nav-operations-hidden`), k = Q(0), B = Q(0);
    Le(() => {
      p.value ? e.rtl ? (k.value = 0, B.value = Math.max(0, y.value - $.value)) : (k.value = Math.min(0, $.value - y.value), B.value = 0) : (k.value = Math.min(0, x.value - C.value), B.value = 0);
    });
    const F = (ue) => ue < k.value ? k.value : ue > B.value ? B.value : ue, L = Q(), [j, H] = Pt(), K = () => {
      H(Date.now());
    }, X = () => {
      clearTimeout(L.value);
    }, W = (ue, de) => {
      ue((Se) => F(Se + de));
    };
    Uj(a, (ue, de) => {
      if (p.value) {
        if ($.value >= y.value)
          return !1;
        W(h, ue);
      } else {
        if (x.value >= C.value)
          return !1;
        W(b, de);
      }
      return X(), K(), !0;
    }), ie(j, () => {
      X(), j.value && (L.value = setTimeout(() => {
        H(0);
      }, 100));
    });
    const q = function() {
      let ue = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : e.activeKey;
      const de = T.value.get(ue) || {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0
      };
      if (p.value) {
        let Se = v.value;
        e.rtl ? de.right < v.value ? Se = de.right : de.right + de.width > v.value + $.value && (Se = de.right + de.width - $.value) : de.left < -v.value ? Se = -de.left : de.left + de.width > -v.value + $.value && (Se = -(de.left + de.width - $.value)), b(0), h(F(Se));
      } else {
        let Se = g.value;
        de.top < -g.value ? Se = -de.top : de.top + de.height > -g.value + x.value && (Se = -(de.top + de.height - x.value)), h(0), b(F(Se));
      }
    }, J = Q(0), ne = Q(0);
    Le(() => {
      let ue, de, Se, xe, he, we;
      const Me = T.value;
      ["top", "bottom"].includes(e.tabPosition) ? (ue = "width", xe = $.value, he = y.value, we = E.value, de = e.rtl ? "right" : "left", Se = Math.abs(v.value)) : (ue = "height", xe = x.value, he = y.value, we = M.value, de = "top", Se = -g.value);
      let ae = xe;
      he + we > xe && he < xe && (ae = xe - we);
      const oe = r.value;
      if (!oe.length)
        return [J.value, ne.value] = [0, 0];
      const pe = oe.length;
      let Pe = pe;
      for (let ze = 0; ze < pe; ze += 1) {
        const ge = Me.get(oe[ze].key) || $C;
        if (ge[de] + ge[ue] > Se + ae) {
          Pe = ze - 1;
          break;
        }
      }
      let Ee = 0;
      for (let ze = pe - 1; ze >= 0; ze -= 1)
        if ((Me.get(oe[ze].key) || $C)[de] < Se) {
          Ee = ze + 1;
          break;
        }
      return [J.value, ne.value] = [Ee, Pe];
    });
    const te = () => {
      z(() => {
        var ue;
        const de = /* @__PURE__ */ new Map(), Se = (ue = i.value) === null || ue === void 0 ? void 0 : ue.getBoundingClientRect();
        return r.value.forEach((xe) => {
          let {
            key: he
          } = xe;
          const we = d.value.get(he), Me = (we == null ? void 0 : we.$el) || we;
          if (Me) {
            const [ae, oe, pe, Pe] = qj(Me, Se);
            de.set(he, {
              width: ae,
              height: oe,
              left: pe,
              top: Pe
            });
          }
        }), de;
      });
    };
    ie(() => r.value.map((ue) => ue.key).join("%%"), () => {
      te();
    }, {
      flush: "post"
    });
    const G = () => {
      var ue, de, Se, xe, he;
      const we = ((ue = a.value) === null || ue === void 0 ? void 0 : ue.offsetWidth) || 0, Me = ((de = a.value) === null || de === void 0 ? void 0 : de.offsetHeight) || 0, ae = ((Se = c.value) === null || Se === void 0 ? void 0 : Se.$el) || {}, oe = ae.offsetWidth || 0, pe = ae.offsetHeight || 0;
      O(we), I(Me), _(oe), R(pe);
      const Pe = (((xe = i.value) === null || xe === void 0 ? void 0 : xe.offsetWidth) || 0) - oe, Ee = (((he = i.value) === null || he === void 0 ? void 0 : he.offsetHeight) || 0) - pe;
      S(Pe), w(Ee), te();
    }, U = P(() => [...r.value.slice(0, J.value), ...r.value.slice(ne.value + 1)]), [re, se] = Pt(), me = P(() => T.value.get(e.activeKey)), Ce = Q(), fe = () => {
      Ze.cancel(Ce.value);
    };
    ie([me, p, () => e.rtl], () => {
      const ue = {};
      me.value && (p.value ? (e.rtl ? ue.right = jl(me.value.right) : ue.left = jl(me.value.left), ue.width = jl(me.value.width)) : (ue.top = jl(me.value.top), ue.height = jl(me.value.height))), fe(), Ce.value = Ze(() => {
        se(ue);
      });
    }), ie([() => e.activeKey, me, T, p], () => {
      q();
    }, {
      flush: "post"
    }), ie([() => e.rtl, () => e.tabBarGutter, () => e.activeKey, () => r.value], () => {
      G();
    }, {
      flush: "post"
    });
    const be = (ue) => {
      let {
        position: de,
        prefixCls: Se,
        extra: xe
      } = ue;
      if (!xe)
        return null;
      const he = xe == null ? void 0 : xe({
        position: de
      });
      return he ? f("div", {
        class: `${Se}-extra-content`
      }, [he]) : null;
    };
    return et(() => {
      X(), fe();
    }), () => {
      const {
        id: ue,
        animated: de,
        activeKey: Se,
        rtl: xe,
        editable: he,
        locale: we,
        tabPosition: Me,
        tabBarGutter: ae,
        onTabClick: oe
      } = e, {
        class: pe,
        style: Pe
      } = n, Ee = l.value, ze = !!U.value.length, ge = `${Ee}-nav-wrap`;
      let ye, $e, Ae, Ve;
      p.value ? xe ? ($e = v.value > 0, ye = v.value + $.value < y.value) : (ye = v.value < 0, $e = -v.value + $.value < y.value) : (Ae = g.value < 0, Ve = -g.value + x.value < C.value);
      const De = {};
      Me === "top" || Me === "bottom" ? De[xe ? "marginRight" : "marginLeft"] = typeof ae == "number" ? `${ae}px` : ae : De.marginTop = typeof ae == "number" ? `${ae}px` : ae;
      const We = r.value.map((at, gt) => {
        const {
          key: ut
        } = at;
        return f(Vj, {
          id: ue,
          prefixCls: Ee,
          key: ut,
          tab: at,
          style: gt === 0 ? void 0 : De,
          closable: at.closable,
          editable: he,
          active: ut === Se,
          removeAriaLabel: we == null ? void 0 : we.removeAriaLabel,
          ref: u(ut),
          onClick: (St) => {
            oe(ut, St);
          },
          onFocus: () => {
            q(ut), K(), a.value && (xe || (a.value.scrollLeft = 0), a.value.scrollTop = 0);
          }
        }, o);
      });
      return f("div", {
        role: "tablist",
        class: ee(`${Ee}-nav`, pe),
        style: Pe,
        onKeydown: () => {
          K();
        }
      }, [f(be, {
        position: "left",
        prefixCls: Ee,
        extra: o.leftExtra
      }, null), f(Fo, {
        onResize: G
      }, {
        default: () => [f("div", {
          class: ee(ge, {
            [`${ge}-ping-left`]: ye,
            [`${ge}-ping-right`]: $e,
            [`${ge}-ping-top`]: Ae,
            [`${ge}-ping-bottom`]: Ve
          }),
          ref: a
        }, [f(Fo, {
          onResize: G
        }, {
          default: () => [f("div", {
            ref: i,
            class: `${Ee}-nav-list`,
            style: {
              transform: `translate(${v.value}px, ${g.value}px)`,
              transition: j.value ? "none" : void 0
            }
          }, [We, f(z3, {
            ref: c,
            prefixCls: Ee,
            locale: we,
            editable: he,
            style: m(m({}, We.length === 0 ? void 0 : De), {
              visibility: ze ? "hidden" : null
            })
          }, null), f("div", {
            class: ee(`${Ee}-ink-bar`, {
              [`${Ee}-ink-bar-animated`]: de.inkBar
            }),
            style: re.value
          }, null)])]
        })])]
      }), f(Gj, D(D({}, e), {}, {
        removeAriaLabel: we == null ? void 0 : we.removeAriaLabel,
        ref: s,
        prefixCls: Ee,
        tabs: U.value,
        class: !ze && N.value
      }), SO(o, ["moreIcon"])), f(be, {
        position: "right",
        prefixCls: Ee,
        extra: o.rightExtra
      }, null), f(be, {
        position: "right",
        prefixCls: Ee,
        extra: o.tabBarExtraContent
      }, null)]);
    };
  }
}), Zj = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TabPanelList",
  inheritAttrs: !1,
  props: {
    activeKey: {
      type: [String, Number]
    },
    id: {
      type: String
    },
    rtl: {
      type: Boolean
    },
    animated: {
      type: Object,
      default: void 0
    },
    tabPosition: {
      type: String
    },
    destroyInactiveTabPane: {
      type: Boolean
    }
  },
  setup(e) {
    const {
      tabs: t,
      prefixCls: n
    } = V3();
    return () => {
      const {
        id: o,
        activeKey: r,
        animated: l,
        tabPosition: a,
        rtl: i,
        destroyInactiveTabPane: s
      } = e, c = l.tabPane, u = n.value, d = t.value.findIndex((p) => p.key === r);
      return f("div", {
        class: `${u}-content-holder`
      }, [f("div", {
        class: [`${u}-content`, `${u}-content-${a}`, {
          [`${u}-content-animated`]: c
        }],
        style: d && c ? {
          [i ? "marginRight" : "marginLeft"]: `-${d}00%`
        } : null
      }, [t.value.map((p) => yt(p.node, {
        key: p.key,
        prefixCls: u,
        tabKey: p.key,
        id: o,
        animated: c,
        active: p.key === r,
        destroyInactiveTabPane: s
      }))])]);
    };
  }
});
var Qj = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M482 152h60q8 0 8 8v704q0 8-8 8h-60q-8 0-8-8V160q0-8 8-8z" } }, { tag: "path", attrs: { d: "M192 474h672q8 0 8 8v60q0 8-8 8H160q-8 0-8-8v-60q0-8 8-8z" } }] }, name: "plus", theme: "outlined" };
function xC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Jj(e, r, n[r]);
    });
  }
  return e;
}
function Jj(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var op = function(t, n) {
  var o = xC({}, t, n.attrs);
  return f(Ge, xC({}, o, {
    icon: Qj
  }), null);
};
op.displayName = "PlusOutlined";
op.inheritAttrs = !1;
const eV = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e;
  return [
    {
      [t]: {
        [`${t}-switch`]: {
          "&-appear, &-enter": {
            transition: "none",
            "&-start": {
              opacity: 0
            },
            "&-active": {
              opacity: 1,
              transition: `opacity ${n}`
            }
          },
          "&-leave": {
            position: "absolute",
            transition: "none",
            inset: 0,
            "&-start": {
              opacity: 1
            },
            "&-active": {
              opacity: 0,
              transition: `opacity ${n}`
            }
          }
        }
      }
    },
    // Follow code may reuse in other components
    [$r(e, "slide-up"), $r(e, "slide-down")]
  ];
}, tV = (e) => {
  const {
    componentCls: t,
    tabsCardHorizontalPadding: n,
    tabsCardHeadBackground: o,
    tabsCardGutter: r,
    colorSplit: l
  } = e;
  return {
    [`${t}-card`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-tab`]: {
          margin: 0,
          padding: n,
          background: o,
          border: `${e.lineWidth}px ${e.lineType} ${l}`,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`
        },
        [`${t}-tab-active`]: {
          color: e.colorPrimary,
          background: e.colorBgContainer
        },
        [`${t}-ink-bar`]: {
          visibility: "hidden"
        }
      },
      // ========================== Top & Bottom ==========================
      [`&${t}-top, &${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginLeft: {
              _skip_check_: !0,
              value: `${r}px`
            }
          }
        }
      },
      [`&${t}-top`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`
          },
          [`${t}-tab-active`]: {
            borderBottomColor: e.colorBgContainer
          }
        }
      },
      [`&${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`
          },
          [`${t}-tab-active`]: {
            borderTopColor: e.colorBgContainer
          }
        }
      },
      // ========================== Left & Right ==========================
      [`&${t}-left, &${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginTop: `${r}px`
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${e.borderRadiusLG}px 0 0 ${e.borderRadiusLG}px`
            }
          },
          [`${t}-tab-active`]: {
            borderRightColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px 0`
            }
          },
          [`${t}-tab-active`]: {
            borderLeftColor: {
              _skip_check_: !0,
              value: e.colorBgContainer
            }
          }
        }
      }
    }
  };
}, nV = (e) => {
  const {
    componentCls: t,
    tabsHoverColor: n,
    dropdownEdgeChildVerticalPadding: o
  } = e;
  return {
    [`${t}-dropdown`]: m(m({}, qe(e)), {
      position: "absolute",
      top: -9999,
      left: {
        _skip_check_: !0,
        value: -9999
      },
      zIndex: e.zIndexPopup,
      display: "block",
      "&-hidden": {
        display: "none"
      },
      [`${t}-dropdown-menu`]: {
        maxHeight: e.tabsDropdownHeight,
        margin: 0,
        padding: `${o}px 0`,
        overflowX: "hidden",
        overflowY: "auto",
        textAlign: {
          _skip_check_: !0,
          value: "left"
        },
        listStyleType: "none",
        backgroundColor: e.colorBgContainer,
        backgroundClip: "padding-box",
        borderRadius: e.borderRadiusLG,
        outline: "none",
        boxShadow: e.boxShadowSecondary,
        "&-item": m(m({}, tn), {
          display: "flex",
          alignItems: "center",
          minWidth: e.tabsDropdownWidth,
          margin: 0,
          padding: `${e.paddingXXS}px ${e.paddingSM}px`,
          color: e.colorText,
          fontWeight: "normal",
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          cursor: "pointer",
          transition: `all ${e.motionDurationSlow}`,
          "> span": {
            flex: 1,
            whiteSpace: "nowrap"
          },
          "&-remove": {
            flex: "none",
            marginLeft: {
              _skip_check_: !0,
              value: e.marginSM
            },
            color: e.colorTextDescription,
            fontSize: e.fontSizeSM,
            background: "transparent",
            border: 0,
            cursor: "pointer",
            "&:hover": {
              color: n
            }
          },
          "&:hover": {
            background: e.controlItemBgHover
          },
          "&-disabled": {
            "&, &:hover": {
              color: e.colorTextDisabled,
              background: "transparent",
              cursor: "not-allowed"
            }
          }
        })
      }
    })
  };
}, oV = (e) => {
  const {
    componentCls: t,
    margin: n,
    colorSplit: o
  } = e;
  return {
    // ========================== Top & Bottom ==========================
    [`${t}-top, ${t}-bottom`]: {
      flexDirection: "column",
      [`> ${t}-nav, > div > ${t}-nav`]: {
        margin: `0 0 ${n}px 0`,
        "&::before": {
          position: "absolute",
          right: {
            _skip_check_: !0,
            value: 0
          },
          left: {
            _skip_check_: !0,
            value: 0
          },
          borderBottom: `${e.lineWidth}px ${e.lineType} ${o}`,
          content: "''"
        },
        [`${t}-ink-bar`]: {
          height: e.lineWidthBold,
          "&-animated": {
            transition: `width ${e.motionDurationSlow}, left ${e.motionDurationSlow},
            right ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-wrap`]: {
          "&::before, &::after": {
            top: 0,
            bottom: 0,
            width: e.controlHeight
          },
          "&::before": {
            left: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowLeft
          },
          "&::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            boxShadow: e.boxShadowTabsOverflowRight
          },
          [`&${t}-nav-wrap-ping-left::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-right::after`]: {
            opacity: 1
          }
        }
      }
    },
    [`${t}-top`]: {
      [`> ${t}-nav,
        > div > ${t}-nav`]: {
        "&::before": {
          bottom: 0
        },
        [`${t}-ink-bar`]: {
          bottom: 0
        }
      }
    },
    [`${t}-bottom`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        marginTop: `${n}px`,
        marginBottom: 0,
        "&::before": {
          top: 0
        },
        [`${t}-ink-bar`]: {
          top: 0
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0
      }
    },
    // ========================== Left & Right ==========================
    [`${t}-left, ${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        flexDirection: "column",
        minWidth: e.controlHeight * 1.25,
        // >>>>>>>>>>> Tab
        [`${t}-tab`]: {
          padding: `${e.paddingXS}px ${e.paddingLG}px`,
          textAlign: "center"
        },
        [`${t}-tab + ${t}-tab`]: {
          margin: `${e.margin}px 0 0 0`
        },
        // >>>>>>>>>>> Nav
        [`${t}-nav-wrap`]: {
          flexDirection: "column",
          "&::before, &::after": {
            right: {
              _skip_check_: !0,
              value: 0
            },
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.controlHeight
          },
          "&::before": {
            top: 0,
            boxShadow: e.boxShadowTabsOverflowTop
          },
          "&::after": {
            bottom: 0,
            boxShadow: e.boxShadowTabsOverflowBottom
          },
          [`&${t}-nav-wrap-ping-top::before`]: {
            opacity: 1
          },
          [`&${t}-nav-wrap-ping-bottom::after`]: {
            opacity: 1
          }
        },
        // >>>>>>>>>>> Ink Bar
        [`${t}-ink-bar`]: {
          width: e.lineWidthBold,
          "&-animated": {
            transition: `height ${e.motionDurationSlow}, top ${e.motionDurationSlow}`
          }
        },
        [`${t}-nav-list, ${t}-nav-operations`]: {
          flex: "1 0 auto",
          flexDirection: "column"
        }
      }
    },
    [`${t}-left`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-ink-bar`]: {
          right: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        marginLeft: {
          _skip_check_: !0,
          value: `-${e.lineWidth}px`
        },
        borderLeft: {
          _skip_check_: !0,
          value: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingLeft: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    },
    [`${t}-right`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        order: 1,
        [`${t}-ink-bar`]: {
          left: {
            _skip_check_: !0,
            value: 0
          }
        }
      },
      [`> ${t}-content-holder, > div > ${t}-content-holder`]: {
        order: 0,
        marginRight: {
          _skip_check_: !0,
          value: -e.lineWidth
        },
        borderRight: {
          _skip_check_: !0,
          value: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`
        },
        [`> ${t}-content > ${t}-tabpane`]: {
          paddingRight: {
            _skip_check_: !0,
            value: e.paddingLG
          }
        }
      }
    }
  };
}, rV = (e) => {
  const {
    componentCls: t,
    padding: n
  } = e;
  return {
    [t]: {
      "&-small": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${e.paddingXS}px 0`,
            fontSize: e.fontSize
          }
        }
      },
      "&-large": {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${n}px 0`,
            fontSize: e.fontSizeLG
          }
        }
      }
    },
    [`${t}-card`]: {
      [`&${t}-small`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${e.paddingXXS * 1.5}px ${n}px`
          }
        },
        [`&${t}-bottom`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `0 0 ${e.borderRadius}px ${e.borderRadius}px`
          }
        },
        [`&${t}-top`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: `${e.borderRadius}px ${e.borderRadius}px 0 0`
          }
        },
        [`&${t}-right`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `0 ${e.borderRadius}px ${e.borderRadius}px 0`
            }
          }
        },
        [`&${t}-left`]: {
          [`> ${t}-nav ${t}-tab`]: {
            borderRadius: {
              _skip_check_: !0,
              value: `${e.borderRadius}px 0 0 ${e.borderRadius}px`
            }
          }
        }
      },
      [`&${t}-large`]: {
        [`> ${t}-nav`]: {
          [`${t}-tab`]: {
            padding: `${e.paddingXS}px ${n}px ${e.paddingXXS * 1.5}px`
          }
        }
      }
    }
  };
}, lV = (e) => {
  const {
    componentCls: t,
    tabsActiveColor: n,
    tabsHoverColor: o,
    iconCls: r,
    tabsHorizontalGutter: l
  } = e, a = `${t}-tab`;
  return {
    [a]: {
      position: "relative",
      display: "inline-flex",
      alignItems: "center",
      padding: `${e.paddingSM}px 0`,
      fontSize: `${e.fontSize}px`,
      background: "transparent",
      border: 0,
      outline: "none",
      cursor: "pointer",
      "&-btn, &-remove": m({
        "&:focus:not(:focus-visible), &:active": {
          color: n
        }
      }, Xr(e)),
      "&-btn": {
        outline: "none",
        transition: "all 0.3s"
      },
      "&-remove": {
        flex: "none",
        marginRight: {
          _skip_check_: !0,
          value: -e.marginXXS
        },
        marginLeft: {
          _skip_check_: !0,
          value: e.marginXS
        },
        color: e.colorTextDescription,
        fontSize: e.fontSizeSM,
        background: "transparent",
        border: "none",
        outline: "none",
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      "&:hover": {
        color: o
      },
      [`&${a}-active ${a}-btn`]: {
        color: e.colorPrimary,
        textShadow: e.tabsActiveTextShadow
      },
      [`&${a}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed"
      },
      [`&${a}-disabled ${a}-btn, &${a}-disabled ${t}-remove`]: {
        "&:focus, &:active": {
          color: e.colorTextDisabled
        }
      },
      [`& ${a}-remove ${r}`]: {
        margin: 0
      },
      [r]: {
        marginRight: {
          _skip_check_: !0,
          value: e.marginSM
        }
      }
    },
    [`${a} + ${a}`]: {
      margin: {
        _skip_check_: !0,
        value: `0 0 0 ${l}px`
      }
    }
  };
}, aV = (e) => {
  const {
    componentCls: t,
    tabsHorizontalGutter: n,
    iconCls: o,
    tabsCardGutter: r
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl",
      [`${t}-nav`]: {
        [`${t}-tab`]: {
          margin: {
            _skip_check_: !0,
            value: `0 0 0 ${n}px`
          },
          [`${t}-tab:last-of-type`]: {
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          },
          [o]: {
            marginRight: {
              _skip_check_: !0,
              value: 0
            },
            marginLeft: {
              _skip_check_: !0,
              value: `${e.marginSM}px`
            }
          },
          [`${t}-tab-remove`]: {
            marginRight: {
              _skip_check_: !0,
              value: `${e.marginXS}px`
            },
            marginLeft: {
              _skip_check_: !0,
              value: `-${e.marginXXS}px`
            },
            [o]: {
              margin: 0
            }
          }
        }
      },
      [`&${t}-left`]: {
        [`> ${t}-nav`]: {
          order: 1
        },
        [`> ${t}-content-holder`]: {
          order: 0
        }
      },
      [`&${t}-right`]: {
        [`> ${t}-nav`]: {
          order: 0
        },
        [`> ${t}-content-holder`]: {
          order: 1
        }
      },
      // ====================== Card ======================
      [`&${t}-card${t}-top, &${t}-card${t}-bottom`]: {
        [`> ${t}-nav, > div > ${t}-nav`]: {
          [`${t}-tab + ${t}-tab`]: {
            marginRight: {
              _skip_check_: !0,
              value: `${r}px`
            },
            marginLeft: {
              _skip_check_: !0,
              value: 0
            }
          }
        }
      }
    },
    [`${t}-dropdown-rtl`]: {
      direction: "rtl"
    },
    [`${t}-menu-item`]: {
      [`${t}-dropdown-rtl`]: {
        textAlign: {
          _skip_check_: !0,
          value: "right"
        }
      }
    }
  };
}, iV = (e) => {
  const {
    componentCls: t,
    tabsCardHorizontalPadding: n,
    tabsCardHeight: o,
    tabsCardGutter: r,
    tabsHoverColor: l,
    tabsActiveColor: a,
    colorSplit: i
  } = e;
  return {
    [t]: m(m(m(m({}, qe(e)), {
      display: "flex",
      // ========================== Navigation ==========================
      [`> ${t}-nav, > div > ${t}-nav`]: {
        position: "relative",
        display: "flex",
        flex: "none",
        alignItems: "center",
        [`${t}-nav-wrap`]: {
          position: "relative",
          display: "flex",
          flex: "auto",
          alignSelf: "stretch",
          overflow: "hidden",
          whiteSpace: "nowrap",
          transform: "translate(0)",
          // >>>>> Ping shadow
          "&::before, &::after": {
            position: "absolute",
            zIndex: 1,
            opacity: 0,
            transition: `opacity ${e.motionDurationSlow}`,
            content: "''",
            pointerEvents: "none"
          }
        },
        [`${t}-nav-list`]: {
          position: "relative",
          display: "flex",
          transition: `opacity ${e.motionDurationSlow}`
        },
        // >>>>>>>> Operations
        [`${t}-nav-operations`]: {
          display: "flex",
          alignSelf: "stretch"
        },
        [`${t}-nav-operations-hidden`]: {
          position: "absolute",
          visibility: "hidden",
          pointerEvents: "none"
        },
        [`${t}-nav-more`]: {
          position: "relative",
          padding: n,
          background: "transparent",
          border: 0,
          "&::after": {
            position: "absolute",
            right: {
              _skip_check_: !0,
              value: 0
            },
            bottom: 0,
            left: {
              _skip_check_: !0,
              value: 0
            },
            height: e.controlHeightLG / 8,
            transform: "translateY(100%)",
            content: "''"
          }
        },
        [`${t}-nav-add`]: m({
          minWidth: `${o}px`,
          marginLeft: {
            _skip_check_: !0,
            value: `${r}px`
          },
          padding: `0 ${e.paddingXS}px`,
          background: "transparent",
          border: `${e.lineWidth}px ${e.lineType} ${i}`,
          borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`,
          outline: "none",
          cursor: "pointer",
          color: e.colorText,
          transition: `all ${e.motionDurationSlow} ${e.motionEaseInOut}`,
          "&:hover": {
            color: l
          },
          "&:active, &:focus:not(:focus-visible)": {
            color: a
          }
        }, Xr(e))
      },
      [`${t}-extra-content`]: {
        flex: "none"
      },
      // ============================ InkBar ============================
      [`${t}-ink-bar`]: {
        position: "absolute",
        background: e.colorPrimary,
        pointerEvents: "none"
      }
    }), lV(e)), {
      // =========================== TabPanes ===========================
      [`${t}-content`]: {
        position: "relative",
        display: "flex",
        width: "100%",
        "&-animated": {
          transition: "margin 0.3s"
        }
      },
      [`${t}-content-holder`]: {
        flex: "auto",
        minWidth: 0,
        minHeight: 0
      },
      [`${t}-tabpane`]: {
        outline: "none",
        flex: "none",
        width: "100%"
      }
    }),
    [`${t}-centered`]: {
      [`> ${t}-nav, > div > ${t}-nav`]: {
        [`${t}-nav-wrap`]: {
          [`&:not([class*='${t}-nav-wrap-ping'])`]: {
            justifyContent: "center"
          }
        }
      }
    }
  };
}, sV = Xe("Tabs", (e) => {
  const t = e.controlHeightLG, n = He(e, {
    tabsHoverColor: e.colorPrimaryHover,
    tabsActiveColor: e.colorPrimaryActive,
    tabsCardHorizontalPadding: `${(t - Math.round(e.fontSize * e.lineHeight)) / 2 - e.lineWidth}px ${e.padding}px`,
    tabsCardHeight: t,
    tabsCardGutter: e.marginXXS / 2,
    tabsHorizontalGutter: 32,
    tabsCardHeadBackground: e.colorFillAlter,
    dropdownEdgeChildVerticalPadding: e.paddingXXS,
    tabsActiveTextShadow: "0 0 0.25px currentcolor",
    tabsDropdownHeight: 200,
    tabsDropdownWidth: 120
  });
  return [rV(n), aV(n), oV(n), nV(n), tV(n), iV(n), eV(n)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50
}));
let OC = 0;
const W3 = () => ({
  prefixCls: {
    type: String
  },
  id: {
    type: String
  },
  popupClassName: String,
  getPopupContainer: le(),
  activeKey: {
    type: [String, Number]
  },
  defaultActiveKey: {
    type: [String, Number]
  },
  direction: ke(),
  animated: je([Boolean, Object]),
  renderTabBar: le(),
  tabBarGutter: {
    type: Number
  },
  tabBarStyle: Re(),
  tabPosition: ke(),
  destroyInactiveTabPane: ve(),
  hideAdd: Boolean,
  type: ke(),
  size: ke(),
  centered: Boolean,
  onEdit: le(),
  onChange: le(),
  onTabClick: le(),
  onTabScroll: le(),
  "onUpdate:activeKey": le(),
  // Accessibility
  locale: Re(),
  onPrevClick: le(),
  onNextClick: le(),
  tabBarExtraContent: V.any
});
function cV(e) {
  return e.map((t) => {
    if (Gt(t)) {
      const n = m({}, t.props || {});
      for (const [p, v] of Object.entries(n))
        delete n[p], n[Oi(p)] = v;
      const o = t.children || {}, r = t.key !== void 0 ? t.key : void 0, {
        tab: l = o.tab,
        disabled: a,
        forceRender: i,
        closable: s,
        animated: c,
        active: u,
        destroyInactiveTabPane: d
      } = n;
      return m(m({
        key: r
      }, n), {
        node: t,
        closeIcon: o.closeIcon,
        tab: l,
        disabled: a === "" || a,
        forceRender: i === "" || i,
        closable: s === "" || s,
        animated: c === "" || c,
        active: u === "" || u,
        destroyInactiveTabPane: d === "" || d
      });
    }
    return null;
  }).filter((t) => t);
}
const uV = Z({
  compatConfig: {
    MODE: 3
  },
  name: "InternalTabs",
  inheritAttrs: !1,
  props: m(m({}, Qe(W3(), {
    tabPosition: "top",
    animated: {
      inkBar: !0,
      tabPane: !1
    }
  })), {
    tabs: vt()
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    nt(e.onPrevClick === void 0 && e.onNextClick === void 0, "Tabs", "`onPrevClick / @prevClick` and `onNextClick / @nextClick` has been removed. Please use `onTabScroll / @tabScroll` instead."), nt(e.tabBarExtraContent === void 0, "Tabs", "`tabBarExtraContent` prop has been removed. Please use `rightExtra` slot instead."), nt(o.tabBarExtraContent === void 0, "Tabs", "`tabBarExtraContent` slot is deprecated. Please use `rightExtra` slot instead.");
    const {
      prefixCls: r,
      direction: l,
      size: a,
      rootPrefixCls: i,
      getPopupContainer: s
    } = Ie("tabs", e), [c, u] = sV(r), d = P(() => l.value === "rtl"), p = P(() => {
      const {
        animated: x,
        tabPosition: I
      } = e;
      return x === !1 || ["left", "right"].includes(I) ? {
        inkBar: !1,
        tabPane: !1
      } : x === !0 ? {
        inkBar: !0,
        tabPane: !0
      } : m({
        inkBar: !0,
        tabPane: !1
      }, typeof x == "object" ? x : {});
    }), [v, h] = Pt(!1);
    Ke(() => {
      h(Bh());
    });
    const [g, b] = Rt(() => {
      var x;
      return (x = e.tabs[0]) === null || x === void 0 ? void 0 : x.key;
    }, {
      value: P(() => e.activeKey),
      defaultValue: e.defaultActiveKey
    }), [y, S] = Pt(() => e.tabs.findIndex((x) => x.key === g.value));
    Le(() => {
      var x;
      let I = e.tabs.findIndex((E) => E.key === g.value);
      I === -1 && (I = Math.max(0, Math.min(y.value, e.tabs.length - 1)), b((x = e.tabs[I]) === null || x === void 0 ? void 0 : x.key)), S(I);
    });
    const [C, w] = Rt(null, {
      value: P(() => e.id)
    }), $ = P(() => v.value && !["left", "right"].includes(e.tabPosition) ? "top" : e.tabPosition);
    Ke(() => {
      e.id || (w(`rc-tabs-${process.env.NODE_ENV === "test" ? "test" : OC}`), OC += 1);
    });
    const O = (x, I) => {
      var E, _;
      (E = e.onTabClick) === null || E === void 0 || E.call(e, x, I);
      const M = x !== g.value;
      b(x), M && ((_ = e.onChange) === null || _ === void 0 || _.call(e, x));
    };
    return j3({
      tabs: P(() => e.tabs),
      prefixCls: r
    }), () => {
      const {
        id: x,
        type: I,
        tabBarGutter: E,
        tabBarStyle: _,
        locale: M,
        destroyInactiveTabPane: R,
        renderTabBar: A = o.renderTabBar,
        onTabScroll: z,
        hideAdd: T,
        centered: N
      } = e, k = {
        id: C.value,
        activeKey: g.value,
        animated: p.value,
        tabPosition: $.value,
        rtl: d.value,
        mobile: v.value
      };
      let B;
      I === "editable-card" && (B = {
        onEdit: (H, K) => {
          let {
            key: X,
            event: W
          } = K;
          var q;
          (q = e.onEdit) === null || q === void 0 || q.call(e, H === "add" ? W : X, H);
        },
        removeIcon: () => f(Kn, null, null),
        addIcon: o.addIcon ? o.addIcon : () => f(op, null, null),
        showAdd: T !== !0
      });
      let F;
      const L = m(m({}, k), {
        moreTransitionName: `${i.value}-slide-up`,
        editable: B,
        locale: M,
        tabBarGutter: E,
        onTabClick: O,
        onTabScroll: z,
        style: _,
        getPopupContainer: s.value,
        popupClassName: ee(e.popupClassName, u.value)
      });
      A ? F = A(m(m({}, L), {
        DefaultTabBar: wC
      })) : F = f(wC, L, SO(o, ["moreIcon", "leftExtra", "rightExtra", "tabBarExtraContent"]));
      const j = r.value;
      return c(f("div", D(D({}, n), {}, {
        id: x,
        class: ee(j, `${j}-${$.value}`, {
          [u.value]: !0,
          [`${j}-${a.value}`]: a.value,
          [`${j}-card`]: ["card", "editable-card"].includes(I),
          [`${j}-editable-card`]: I === "editable-card",
          [`${j}-centered`]: N,
          [`${j}-mobile`]: v.value,
          [`${j}-editable`]: I === "editable-card",
          [`${j}-rtl`]: d.value
        }, n.class)
      }), [F, f(Zj, D(D({
        destroyInactiveTabPane: R
      }, k), {}, {
        animated: p.value
      }), null)]));
    };
  }
}), na = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATabs",
  inheritAttrs: !1,
  props: Qe(W3(), {
    tabPosition: "top",
    animated: {
      inkBar: !0,
      tabPane: !1
    }
  }),
  slots: Object,
  // emits: ['tabClick', 'tabScroll', 'change', 'update:activeKey'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r
    } = t;
    const l = (a) => {
      r("update:activeKey", a), r("change", a);
    };
    return () => {
      var a;
      const i = cV(It((a = o.default) === null || a === void 0 ? void 0 : a.call(o)));
      return f(uV, D(D(D({}, ot(e, ["onUpdate:activeKey"])), n), {}, {
        onChange: l,
        tabs: i
      }), o);
    };
  }
}), dV = () => ({
  tab: V.any,
  disabled: {
    type: Boolean
  },
  forceRender: {
    type: Boolean
  },
  closable: {
    type: Boolean
  },
  animated: {
    type: Boolean
  },
  active: {
    type: Boolean
  },
  destroyInactiveTabPane: {
    type: Boolean
  },
  // Pass by TabPaneList
  prefixCls: {
    type: String
  },
  tabKey: {
    type: [String, Number]
  },
  id: {
    type: String
  }
  // closeIcon: PropTypes.any,
}), Fd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATabPane",
  inheritAttrs: !1,
  __ANT_TAB_PANE: !0,
  props: dV(),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = Y(e.forceRender);
    ie([() => e.active, () => e.destroyInactiveTabPane], () => {
      e.active ? r.value = !0 : e.destroyInactiveTabPane && (r.value = !1);
    }, {
      immediate: !0
    });
    const l = P(() => e.active ? {} : e.animated ? {
      visibility: "hidden",
      height: 0,
      overflowY: "hidden"
    } : {
      display: "none"
    });
    return () => {
      var a;
      const {
        prefixCls: i,
        forceRender: s,
        id: c,
        active: u,
        tabKey: d
      } = e;
      return f("div", {
        id: c && `${c}-panel-${d}`,
        role: "tabpanel",
        tabindex: u ? 0 : -1,
        "aria-labelledby": c && `${c}-tab-${d}`,
        "aria-hidden": !u,
        style: [l.value, n.style],
        class: [`${i}-tabpane`, u && `${i}-tabpane-active`, n.class]
      }, [(u || r.value || s) && ((a = o.default) === null || a === void 0 ? void 0 : a.call(o))]);
    };
  }
});
na.TabPane = Fd;
na.install = function(e) {
  return e.component(na.name, na), e.component(Fd.name, Fd), e;
};
const fV = (e) => {
  const {
    antCls: t,
    componentCls: n,
    cardHeadHeight: o,
    cardPaddingBase: r,
    cardHeadTabsMarginBottom: l
  } = e;
  return m(m({
    display: "flex",
    justifyContent: "center",
    flexDirection: "column",
    minHeight: o,
    marginBottom: -1,
    padding: `0 ${r}px`,
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.fontSizeLG,
    background: "transparent",
    borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorBorderSecondary}`,
    borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`
  }, nr()), {
    "&-wrapper": {
      width: "100%",
      display: "flex",
      alignItems: "center"
    },
    "&-title": m(m({
      display: "inline-block",
      flex: 1
    }, tn), {
      [`
          > ${n}-typography,
          > ${n}-typography-edit-content
        `]: {
        insetInlineStart: 0,
        marginTop: 0,
        marginBottom: 0
      }
    }),
    [`${t}-tabs-top`]: {
      clear: "both",
      marginBottom: l,
      color: e.colorText,
      fontWeight: "normal",
      fontSize: e.fontSize,
      "&-bar": {
        borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorBorderSecondary}`
      }
    }
  });
}, pV = (e) => {
  const {
    cardPaddingBase: t,
    colorBorderSecondary: n,
    cardShadow: o,
    lineWidth: r
  } = e;
  return {
    width: "33.33%",
    padding: t,
    border: 0,
    borderRadius: 0,
    boxShadow: `
      ${r}px 0 0 0 ${n},
      0 ${r}px 0 0 ${n},
      ${r}px ${r}px 0 0 ${n},
      ${r}px 0 0 0 ${n} inset,
      0 ${r}px 0 0 ${n} inset;
    `,
    transition: `all ${e.motionDurationMid}`,
    "&-hoverable:hover": {
      position: "relative",
      zIndex: 1,
      boxShadow: o
    }
  };
}, vV = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    cardActionsLiMargin: o,
    cardActionsIconSize: r,
    colorBorderSecondary: l
  } = e;
  return m(m({
    margin: 0,
    padding: 0,
    listStyle: "none",
    background: e.colorBgContainer,
    borderTop: `${e.lineWidth}px ${e.lineType} ${l}`,
    display: "flex",
    borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px `
  }, nr()), {
    "& > li": {
      margin: o,
      color: e.colorTextDescription,
      textAlign: "center",
      "> span": {
        position: "relative",
        display: "block",
        minWidth: e.cardActionsIconSize * 2,
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        cursor: "pointer",
        "&:hover": {
          color: e.colorPrimary,
          transition: `color ${e.motionDurationMid}`
        },
        [`a:not(${t}-btn), > ${n}`]: {
          display: "inline-block",
          width: "100%",
          color: e.colorTextDescription,
          lineHeight: `${e.fontSize * e.lineHeight}px`,
          transition: `color ${e.motionDurationMid}`,
          "&:hover": {
            color: e.colorPrimary
          }
        },
        [`> ${n}`]: {
          fontSize: r,
          lineHeight: `${r * e.lineHeight}px`
        }
      },
      "&:not(:last-child)": {
        borderInlineEnd: `${e.lineWidth}px ${e.lineType} ${l}`
      }
    }
  });
}, gV = (e) => m(m({
  margin: `-${e.marginXXS}px 0`,
  display: "flex"
}, nr()), {
  "&-avatar": {
    paddingInlineEnd: e.padding
  },
  "&-detail": {
    overflow: "hidden",
    flex: 1,
    "> div:not(:last-child)": {
      marginBottom: e.marginXS
    }
  },
  "&-title": m({
    color: e.colorTextHeading,
    fontWeight: e.fontWeightStrong,
    fontSize: e.fontSizeLG
  }, tn),
  "&-description": {
    color: e.colorTextDescription
  }
}), mV = (e) => {
  const {
    componentCls: t,
    cardPaddingBase: n,
    colorFillAlter: o
  } = e;
  return {
    [`${t}-head`]: {
      padding: `0 ${n}px`,
      background: o,
      "&-title": {
        fontSize: e.fontSize
      }
    },
    [`${t}-body`]: {
      padding: `${e.padding}px ${n}px`
    }
  };
}, hV = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    overflow: "hidden",
    [`${t}-body`]: {
      userSelect: "none"
    }
  };
}, bV = (e) => {
  const {
    componentCls: t,
    cardShadow: n,
    cardHeadPadding: o,
    colorBorderSecondary: r,
    boxShadow: l,
    cardPaddingBase: a
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      position: "relative",
      background: e.colorBgContainer,
      borderRadius: e.borderRadiusLG,
      [`&:not(${t}-bordered)`]: {
        boxShadow: l
      },
      [`${t}-head`]: fV(e),
      [`${t}-extra`]: {
        // https://stackoverflow.com/a/22429853/3040605
        marginInlineStart: "auto",
        color: "",
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`${t}-body`]: m({
        padding: a,
        borderRadius: ` 0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`
      }, nr()),
      [`${t}-grid`]: pV(e),
      [`${t}-cover`]: {
        "> *": {
          display: "block",
          width: "100%"
        },
        img: {
          borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`
        }
      },
      [`${t}-actions`]: vV(e),
      [`${t}-meta`]: gV(e)
    }),
    [`${t}-bordered`]: {
      border: `${e.lineWidth}px ${e.lineType} ${r}`,
      [`${t}-cover`]: {
        marginTop: -1,
        marginInlineStart: -1,
        marginInlineEnd: -1
      }
    },
    [`${t}-hoverable`]: {
      cursor: "pointer",
      transition: `box-shadow ${e.motionDurationMid}, border-color ${e.motionDurationMid}`,
      "&:hover": {
        borderColor: "transparent",
        boxShadow: n
      }
    },
    [`${t}-contain-grid`]: {
      [`${t}-body`]: {
        display: "flex",
        flexWrap: "wrap"
      },
      [`&:not(${t}-loading) ${t}-body`]: {
        marginBlockStart: -e.lineWidth,
        marginInlineStart: -e.lineWidth,
        padding: 0
      }
    },
    [`${t}-contain-tabs`]: {
      [`> ${t}-head`]: {
        [`${t}-head-title, ${t}-extra`]: {
          paddingTop: o
        }
      }
    },
    [`${t}-type-inner`]: mV(e),
    [`${t}-loading`]: hV(e),
    [`${t}-rtl`]: {
      direction: "rtl"
    }
  };
}, yV = (e) => {
  const {
    componentCls: t,
    cardPaddingSM: n,
    cardHeadHeightSM: o
  } = e;
  return {
    [`${t}-small`]: {
      [`> ${t}-head`]: {
        minHeight: o,
        padding: `0 ${n}px`,
        fontSize: e.fontSize,
        [`> ${t}-head-wrapper`]: {
          [`> ${t}-extra`]: {
            fontSize: e.fontSize
          }
        }
      },
      [`> ${t}-body`]: {
        padding: n
      }
    },
    [`${t}-small${t}-contain-tabs`]: {
      [`> ${t}-head`]: {
        [`${t}-head-title, ${t}-extra`]: {
          minHeight: o,
          paddingTop: 0,
          display: "flex",
          alignItems: "center"
        }
      }
    }
  };
}, SV = Xe("Card", (e) => {
  const t = He(e, {
    cardShadow: e.boxShadowCard,
    cardHeadHeight: e.fontSizeLG * e.lineHeightLG + e.padding * 2,
    cardHeadHeightSM: e.fontSize * e.lineHeight + e.paddingXS * 2,
    cardHeadPadding: e.padding,
    cardPaddingBase: e.paddingLG,
    cardHeadTabsMarginBottom: -e.padding - e.lineWidth,
    cardActionsLiMargin: `${e.paddingSM}px 0`,
    cardActionsIconSize: e.fontSize,
    cardPaddingSM: 12
    // Fixed padding.
  });
  return [
    // Style
    bV(t),
    // Size
    yV(t)
  ];
}), CV = () => ({
  prefixCls: String,
  width: {
    type: [Number, String]
  }
}), rp = Z({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonTitle",
  props: CV(),
  setup(e) {
    return () => {
      const {
        prefixCls: t,
        width: n
      } = e, o = typeof n == "number" ? `${n}px` : n;
      return f("h3", {
        class: t,
        style: {
          width: o
        }
      }, null);
    };
  }
}), $V = () => ({
  prefixCls: String,
  width: {
    type: [Number, String, Array]
  },
  rows: Number
}), wV = Z({
  compatConfig: {
    MODE: 3
  },
  name: "SkeletonParagraph",
  props: $V(),
  setup(e) {
    const t = (n) => {
      const {
        width: o,
        rows: r = 2
      } = e;
      if (Array.isArray(o))
        return o[n];
      if (r - 1 === n)
        return o;
    };
    return () => {
      const {
        prefixCls: n,
        rows: o
      } = e, r = [...Array(o)].map((l, a) => {
        const i = t(a);
        return f("li", {
          key: a,
          style: {
            width: typeof i == "number" ? `${i}px` : i
          }
        }, null);
      });
      return f("ul", {
        class: n
      }, [r]);
    };
  }
}), lp = () => ({
  prefixCls: String,
  size: [String, Number],
  shape: String,
  active: {
    type: Boolean,
    default: void 0
  }
}), gc = (e) => {
  const {
    prefixCls: t,
    size: n,
    shape: o
  } = e, r = ee({
    [`${t}-lg`]: n === "large",
    [`${t}-sm`]: n === "small"
  }), l = ee({
    [`${t}-circle`]: o === "circle",
    [`${t}-square`]: o === "square",
    [`${t}-round`]: o === "round"
  }), a = typeof n == "number" ? {
    width: `${n}px`,
    height: `${n}px`,
    lineHeight: `${n}px`
  } : {};
  return f("span", {
    class: ee(t, r, l),
    style: a
  }, null);
};
gc.displayName = "SkeletonElement";
const xV = new lt("ant-skeleton-loading", {
  "0%": {
    transform: "translateX(-37.5%)"
  },
  "100%": {
    transform: "translateX(37.5%)"
  }
}), ap = (e) => ({
  height: e,
  lineHeight: `${e}px`
}), li = (e) => m({
  width: e
}, ap(e)), OV = (e) => ({
  position: "relative",
  // fix https://github.com/ant-design/ant-design/issues/36444
  // https://monshin.github.io/202109/css/safari-border-radius-overflow-hidden/
  /* stylelint-disable-next-line property-no-vendor-prefix,value-no-vendor-prefix */
  zIndex: 0,
  overflow: "hidden",
  background: "transparent",
  "&::after": {
    position: "absolute",
    top: 0,
    insetInlineEnd: "-150%",
    bottom: 0,
    insetInlineStart: "-150%",
    background: e.skeletonLoadingBackground,
    animationName: xV,
    animationDuration: e.skeletonLoadingMotionDuration,
    animationTimingFunction: "ease",
    animationIterationCount: "infinite",
    content: '""'
  }
}), hv = (e) => m({
  width: e * 5,
  minWidth: e * 5
}, ap(e)), PV = (e) => {
  const {
    skeletonAvatarCls: t,
    color: n,
    controlHeight: o,
    controlHeightLG: r,
    controlHeightSM: l
  } = e;
  return {
    [`${t}`]: m({
      display: "inline-block",
      verticalAlign: "top",
      background: n
    }, li(o)),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    },
    [`${t}${t}-lg`]: m({}, li(r)),
    [`${t}${t}-sm`]: m({}, li(l))
  };
}, IV = (e) => {
  const {
    controlHeight: t,
    borderRadiusSM: n,
    skeletonInputCls: o,
    controlHeightLG: r,
    controlHeightSM: l,
    color: a
  } = e;
  return {
    [`${o}`]: m({
      display: "inline-block",
      verticalAlign: "top",
      background: a,
      borderRadius: n
    }, hv(t)),
    [`${o}-lg`]: m({}, hv(r)),
    [`${o}-sm`]: m({}, hv(l))
  };
}, PC = (e) => m({
  width: e
}, ap(e)), EV = (e) => {
  const {
    skeletonImageCls: t,
    imageSizeBase: n,
    color: o,
    borderRadiusSM: r
  } = e;
  return {
    [`${t}`]: m(m({
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      verticalAlign: "top",
      background: o,
      borderRadius: r
    }, PC(n * 2)), {
      [`${t}-path`]: {
        fill: "#bfbfbf"
      },
      [`${t}-svg`]: m(m({}, PC(n)), {
        maxWidth: n * 4,
        maxHeight: n * 4
      }),
      [`${t}-svg${t}-svg-circle`]: {
        borderRadius: "50%"
      }
    }),
    [`${t}${t}-circle`]: {
      borderRadius: "50%"
    }
  };
}, bv = (e, t, n) => {
  const {
    skeletonButtonCls: o
  } = e;
  return {
    [`${n}${o}-circle`]: {
      width: t,
      minWidth: t,
      borderRadius: "50%"
    },
    [`${n}${o}-round`]: {
      borderRadius: t
    }
  };
}, yv = (e) => m({
  width: e * 2,
  minWidth: e * 2
}, ap(e)), TV = (e) => {
  const {
    borderRadiusSM: t,
    skeletonButtonCls: n,
    controlHeight: o,
    controlHeightLG: r,
    controlHeightSM: l,
    color: a
  } = e;
  return m(m(m(m(m({
    [`${n}`]: m({
      display: "inline-block",
      verticalAlign: "top",
      background: a,
      borderRadius: t,
      width: o * 2,
      minWidth: o * 2
    }, yv(o))
  }, bv(e, o, n)), {
    [`${n}-lg`]: m({}, yv(r))
  }), bv(e, r, `${n}-lg`)), {
    [`${n}-sm`]: m({}, yv(l))
  }), bv(e, l, `${n}-sm`));
}, MV = (e) => {
  const {
    componentCls: t,
    skeletonAvatarCls: n,
    skeletonTitleCls: o,
    skeletonParagraphCls: r,
    skeletonButtonCls: l,
    skeletonInputCls: a,
    skeletonImageCls: i,
    controlHeight: s,
    controlHeightLG: c,
    controlHeightSM: u,
    color: d,
    padding: p,
    marginSM: v,
    borderRadius: h,
    skeletonTitleHeight: g,
    skeletonBlockRadius: b,
    skeletonParagraphLineHeight: y,
    controlHeightXS: S,
    skeletonParagraphMarginTop: C
  } = e;
  return {
    [`${t}`]: {
      display: "table",
      width: "100%",
      [`${t}-header`]: {
        display: "table-cell",
        paddingInlineEnd: p,
        verticalAlign: "top",
        // Avatar
        [`${n}`]: m({
          display: "inline-block",
          verticalAlign: "top",
          background: d
        }, li(s)),
        [`${n}-circle`]: {
          borderRadius: "50%"
        },
        [`${n}-lg`]: m({}, li(c)),
        [`${n}-sm`]: m({}, li(u))
      },
      [`${t}-content`]: {
        display: "table-cell",
        width: "100%",
        verticalAlign: "top",
        // Title
        [`${o}`]: {
          width: "100%",
          height: g,
          background: d,
          borderRadius: b,
          [`+ ${r}`]: {
            marginBlockStart: u
          }
        },
        // paragraph
        [`${r}`]: {
          padding: 0,
          "> li": {
            width: "100%",
            height: y,
            listStyle: "none",
            background: d,
            borderRadius: b,
            "+ li": {
              marginBlockStart: S
            }
          }
        },
        [`${r}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
          width: "61%"
        }
      },
      [`&-round ${t}-content`]: {
        [`${o}, ${r} > li`]: {
          borderRadius: h
        }
      }
    },
    [`${t}-with-avatar ${t}-content`]: {
      // Title
      [`${o}`]: {
        marginBlockStart: v,
        [`+ ${r}`]: {
          marginBlockStart: C
        }
      }
    },
    // Skeleton element
    [`${t}${t}-element`]: m(m(m(m({
      display: "inline-block",
      width: "auto"
    }, TV(e)), PV(e)), IV(e)), EV(e)),
    // Skeleton Block Button, Input
    [`${t}${t}-block`]: {
      width: "100%",
      [`${l}`]: {
        width: "100%"
      },
      [`${a}`]: {
        width: "100%"
      }
    },
    // With active animation
    [`${t}${t}-active`]: {
      [`
        ${o},
        ${r} > li,
        ${n},
        ${l},
        ${a},
        ${i}
      `]: m({}, OV(e))
    }
  };
}, mc = Xe("Skeleton", (e) => {
  const {
    componentCls: t
  } = e, n = He(e, {
    skeletonAvatarCls: `${t}-avatar`,
    skeletonTitleCls: `${t}-title`,
    skeletonParagraphCls: `${t}-paragraph`,
    skeletonButtonCls: `${t}-button`,
    skeletonInputCls: `${t}-input`,
    skeletonImageCls: `${t}-image`,
    imageSizeBase: e.controlHeight * 1.5,
    skeletonTitleHeight: e.controlHeight / 2,
    skeletonBlockRadius: e.borderRadiusSM,
    skeletonParagraphLineHeight: e.controlHeight / 2,
    skeletonParagraphMarginTop: e.marginLG + e.marginXXS,
    borderRadius: 100,
    skeletonLoadingBackground: `linear-gradient(90deg, ${e.color} 25%, ${e.colorGradientEnd} 37%, ${e.color} 63%)`,
    skeletonLoadingMotionDuration: "1.4s"
  });
  return [MV(n)];
}, (e) => {
  const {
    colorFillContent: t,
    colorFill: n
  } = e;
  return {
    color: t,
    colorGradientEnd: n
  };
}), _V = () => ({
  active: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  avatar: {
    type: [Boolean, Object],
    default: void 0
  },
  title: {
    type: [Boolean, Object],
    default: void 0
  },
  paragraph: {
    type: [Boolean, Object],
    default: void 0
  },
  round: {
    type: Boolean,
    default: void 0
  }
});
function Sv(e) {
  return e && typeof e == "object" ? e : {};
}
function AV(e, t) {
  return e && !t ? {
    size: "large",
    shape: "square"
  } : {
    size: "large",
    shape: "circle"
  };
}
function DV(e, t) {
  return !e && t ? {
    width: "38%"
  } : e && t ? {
    width: "50%"
  } : {};
}
function NV(e, t) {
  const n = {};
  return (!e || !t) && (n.width = "61%"), !e && t ? n.rows = 3 : n.rows = 2, n;
}
const Nn = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeleton",
  props: Qe(_V(), {
    avatar: !1,
    title: !0,
    paragraph: !0
  }),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o,
      direction: r
    } = Ie("skeleton", e), [l, a] = mc(o);
    return () => {
      var i;
      const {
        loading: s,
        avatar: c,
        title: u,
        paragraph: d,
        active: p,
        round: v
      } = e, h = o.value;
      if (s || e.loading === void 0) {
        const g = !!c || c === "", b = !!u || u === "", y = !!d || d === "";
        let S;
        if (g) {
          const $ = m(m({
            prefixCls: `${h}-avatar`
          }, AV(b, y)), Sv(c));
          S = f("div", {
            class: `${h}-header`
          }, [f(gc, $, null)]);
        }
        let C;
        if (b || y) {
          let $;
          if (b) {
            const x = m(m({
              prefixCls: `${h}-title`
            }, DV(g, y)), Sv(u));
            $ = f(rp, x, null);
          }
          let O;
          if (y) {
            const x = m(m({
              prefixCls: `${h}-paragraph`
            }, NV(g, b)), Sv(d));
            O = f(wV, x, null);
          }
          C = f("div", {
            class: `${h}-content`
          }, [$, O]);
        }
        const w = ee(h, {
          [`${h}-with-avatar`]: g,
          [`${h}-active`]: p,
          [`${h}-rtl`]: r.value === "rtl",
          [`${h}-round`]: v,
          [a.value]: !0
        });
        return l(f("div", {
          class: w
        }, [S, C]));
      }
      return (i = n.default) === null || i === void 0 ? void 0 : i.call(n);
    };
  }
}), RV = () => m(m({}, lp()), {
  size: String,
  block: Boolean
}), U0 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonButton",
  props: Qe(RV(), {
    size: "default"
  }),
  setup(e) {
    const {
      prefixCls: t
    } = Ie("skeleton", e), [n, o] = mc(t), r = P(() => ee(t.value, `${t.value}-element`, {
      [`${t.value}-active`]: e.active,
      [`${t.value}-block`]: e.block
    }, o.value));
    return () => n(f("div", {
      class: r.value
    }, [f(gc, D(D({}, e), {}, {
      prefixCls: `${t.value}-button`
    }), null)]));
  }
}), Y0 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonInput",
  props: m(m({}, ot(lp(), ["shape"])), {
    size: String,
    block: Boolean
  }),
  setup(e) {
    const {
      prefixCls: t
    } = Ie("skeleton", e), [n, o] = mc(t), r = P(() => ee(t.value, `${t.value}-element`, {
      [`${t.value}-active`]: e.active,
      [`${t.value}-block`]: e.block
    }, o.value));
    return () => n(f("div", {
      class: r.value
    }, [f(gc, D(D({}, e), {}, {
      prefixCls: `${t.value}-input`
    }), null)]));
  }
}), kV = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z", q0 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonImage",
  props: ot(lp(), ["size", "shape", "active"]),
  setup(e) {
    const {
      prefixCls: t
    } = Ie("skeleton", e), [n, o] = mc(t), r = P(() => ee(t.value, `${t.value}-element`, o.value));
    return () => n(f("div", {
      class: r.value
    }, [f("div", {
      class: `${t.value}-image`
    }, [f("svg", {
      viewBox: "0 0 1098 1024",
      xmlns: "http://www.w3.org/2000/svg",
      class: `${t.value}-image-svg`
    }, [f("path", {
      d: kV,
      class: `${t.value}-image-path`
    }, null)])])]));
  }
}), BV = () => m(m({}, lp()), {
  shape: String
}), Z0 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASkeletonAvatar",
  props: Qe(BV(), {
    size: "default",
    shape: "circle"
  }),
  setup(e) {
    const {
      prefixCls: t
    } = Ie("skeleton", e), [n, o] = mc(t), r = P(() => ee(t.value, `${t.value}-element`, {
      [`${t.value}-active`]: e.active
    }, o.value));
    return () => n(f("div", {
      class: r.value
    }, [f(gc, D(D({}, e), {}, {
      prefixCls: `${t.value}-avatar`
    }), null)]));
  }
});
Nn.Button = U0;
Nn.Avatar = Z0;
Nn.Input = Y0;
Nn.Image = q0;
Nn.Title = rp;
Nn.install = function(e) {
  return e.component(Nn.name, Nn), e.component(Nn.Button.name, U0), e.component(Nn.Avatar.name, Z0), e.component(Nn.Input.name, Y0), e.component(Nn.Image.name, q0), e.component(Nn.Title.name, rp), e;
};
const {
  TabPane: FV
} = na, LV = () => ({
  prefixCls: String,
  title: V.any,
  extra: V.any,
  bordered: {
    type: Boolean,
    default: !0
  },
  bodyStyle: {
    type: Object,
    default: void 0
  },
  headStyle: {
    type: Object,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: !1
  },
  hoverable: {
    type: Boolean,
    default: !1
  },
  type: {
    type: String
  },
  size: {
    type: String
  },
  actions: V.any,
  tabList: {
    type: Array
  },
  tabBarExtraContent: V.any,
  activeTabKey: String,
  defaultActiveTabKey: String,
  cover: V.any,
  onTabChange: {
    type: Function
  }
}), ai = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACard",
  inheritAttrs: !1,
  props: LV(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l,
      size: a
    } = Ie("card", e), [i, s] = SV(r), c = (p) => p.map((h, g) => In(h) && !nc(h) || !In(h) ? f("li", {
      style: {
        width: `${100 / p.length}%`
      },
      key: `action-${g}`
    }, [f("span", null, [h])]) : null), u = (p) => {
      var v;
      (v = e.onTabChange) === null || v === void 0 || v.call(e, p);
    }, d = function() {
      let p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], v;
      return p.forEach((h) => {
        h && n0(h.type) && h.type.__ANT_CARD_GRID && (v = !0);
      }), v;
    };
    return () => {
      var p, v, h, g, b, y;
      const {
        headStyle: S = {},
        bodyStyle: C = {},
        loading: w,
        bordered: $ = !0,
        type: O,
        tabList: x,
        hoverable: I,
        activeTabKey: E,
        defaultActiveTabKey: _,
        tabBarExtraContent: M = Ki((p = n.tabBarExtraContent) === null || p === void 0 ? void 0 : p.call(n)),
        title: R = Ki((v = n.title) === null || v === void 0 ? void 0 : v.call(n)),
        extra: A = Ki((h = n.extra) === null || h === void 0 ? void 0 : h.call(n)),
        actions: z = Ki((g = n.actions) === null || g === void 0 ? void 0 : g.call(n)),
        cover: T = Ki((b = n.cover) === null || b === void 0 ? void 0 : b.call(n))
      } = e, N = It((y = n.default) === null || y === void 0 ? void 0 : y.call(n)), k = r.value, B = {
        [`${k}`]: !0,
        [s.value]: !0,
        [`${k}-loading`]: w,
        [`${k}-bordered`]: $,
        [`${k}-hoverable`]: !!I,
        [`${k}-contain-grid`]: d(N),
        [`${k}-contain-tabs`]: x && x.length,
        [`${k}-${a.value}`]: a.value,
        [`${k}-type-${O}`]: !!O,
        [`${k}-rtl`]: l.value === "rtl"
      }, F = f(Nn, {
        loading: !0,
        active: !0,
        paragraph: {
          rows: 4
        },
        title: !1
      }, {
        default: () => [N]
      }), L = E !== void 0, j = {
        size: "large",
        [L ? "activeKey" : "defaultActiveKey"]: L ? E : _,
        onChange: u,
        class: `${k}-head-tabs`
      };
      let H;
      const K = x && x.length ? f(na, j, {
        default: () => [x.map((J) => {
          const {
            tab: ne,
            slots: te
          } = J, G = te == null ? void 0 : te.tab;
          nt(!te, "Card", "tabList slots is deprecated, Please use `customTab` instead.");
          let U = ne !== void 0 ? ne : n[G] ? n[G](J) : null;
          return U = Pf(n, "customTab", J, () => [U]), f(FV, {
            tab: U,
            key: J.key,
            disabled: J.disabled
          }, null);
        })],
        rightExtra: M ? () => M : null
      }) : null;
      (R || A || K) && (H = f("div", {
        class: `${k}-head`,
        style: S
      }, [f("div", {
        class: `${k}-head-wrapper`
      }, [R && f("div", {
        class: `${k}-head-title`
      }, [R]), A && f("div", {
        class: `${k}-extra`
      }, [A])]), K]));
      const X = T ? f("div", {
        class: `${k}-cover`
      }, [T]) : null, W = f("div", {
        class: `${k}-body`,
        style: C
      }, [w ? F : N]), q = z && z.length ? f("ul", {
        class: `${k}-actions`
      }, [c(z)]) : null;
      return i(f("div", D(D({
        ref: "cardContainerRef"
      }, o), {}, {
        class: [B, o.class]
      }), [H, X, N && N.length ? W : null, q]));
    };
  }
}), zV = () => ({
  prefixCls: String,
  title: Rn(),
  description: Rn(),
  avatar: Rn()
}), Ld = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACardMeta",
  props: zV(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = Ie("card", e);
    return () => {
      const r = {
        [`${o.value}-meta`]: !0
      }, l = an(n, e, "avatar"), a = an(n, e, "title"), i = an(n, e, "description"), s = l ? f("div", {
        class: `${o.value}-meta-avatar`
      }, [l]) : null, c = a ? f("div", {
        class: `${o.value}-meta-title`
      }, [a]) : null, u = i ? f("div", {
        class: `${o.value}-meta-description`
      }, [i]) : null, d = c || u ? f("div", {
        class: `${o.value}-meta-detail`
      }, [c, u]) : null;
      return f("div", {
        class: r
      }, [s, d]);
    };
  }
}), HV = () => ({
  prefixCls: String,
  hoverable: {
    type: Boolean,
    default: !0
  }
}), zd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACardGrid",
  __ANT_CARD_GRID: !0,
  props: HV(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = Ie("card", e), r = P(() => ({
      [`${o.value}-grid`]: !0,
      [`${o.value}-grid-hoverable`]: e.hoverable
    }));
    return () => {
      var l;
      return f("div", {
        class: r.value
      }, [(l = n.default) === null || l === void 0 ? void 0 : l.call(n)]);
    };
  }
});
ai.Meta = Ld;
ai.Grid = zd;
ai.install = function(e) {
  return e.component(ai.name, ai), e.component(Ld.name, Ld), e.component(zd.name, zd), e;
};
const jV = () => ({
  prefixCls: String,
  activeKey: je([Array, Number, String]),
  defaultActiveKey: je([Array, Number, String]),
  accordion: ve(),
  destroyInactivePanel: ve(),
  bordered: ve(),
  expandIcon: le(),
  openAnimation: V.object,
  expandIconPosition: ke(),
  collapsible: ke(),
  ghost: ve(),
  onChange: le(),
  "onUpdate:activeKey": le()
}), K3 = () => ({
  openAnimation: V.object,
  prefixCls: String,
  header: V.any,
  headerClass: String,
  showArrow: ve(),
  isActive: ve(),
  destroyInactivePanel: ve(),
  /** @deprecated Use `collapsible="disabled"` instead */
  disabled: ve(),
  accordion: ve(),
  forceRender: ve(),
  expandIcon: le(),
  extra: V.any,
  panelKey: je(),
  collapsible: ke(),
  role: String,
  onItemClick: le()
}), VV = (e) => {
  const {
    componentCls: t,
    collapseContentBg: n,
    padding: o,
    collapseContentPaddingHorizontal: r,
    collapseHeaderBg: l,
    collapseHeaderPadding: a,
    collapsePanelBorderRadius: i,
    lineWidth: s,
    lineType: c,
    colorBorder: u,
    colorText: d,
    colorTextHeading: p,
    colorTextDisabled: v,
    fontSize: h,
    lineHeight: g,
    marginSM: b,
    paddingSM: y,
    motionDurationSlow: S,
    fontSizeIcon: C
  } = e, w = `${s}px ${c} ${u}`;
  return {
    [t]: m(m({}, qe(e)), {
      backgroundColor: l,
      border: w,
      borderBottom: 0,
      borderRadius: `${i}px`,
      "&-rtl": {
        direction: "rtl"
      },
      [`& > ${t}-item`]: {
        borderBottom: w,
        "&:last-child": {
          [`
            &,
            & > ${t}-header`]: {
            borderRadius: `0 0 ${i}px ${i}px`
          }
        },
        [`> ${t}-header`]: {
          position: "relative",
          display: "flex",
          flexWrap: "nowrap",
          alignItems: "flex-start",
          padding: a,
          color: p,
          lineHeight: g,
          cursor: "pointer",
          transition: `all ${S}, visibility 0s`,
          [`> ${t}-header-text`]: {
            flex: "auto"
          },
          "&:focus": {
            outline: "none"
          },
          // >>>>> Arrow
          [`${t}-expand-icon`]: {
            height: h * g,
            display: "flex",
            alignItems: "center",
            paddingInlineEnd: b
          },
          [`${t}-arrow`]: m(m({}, ha()), {
            fontSize: C,
            svg: {
              transition: `transform ${S}`
            }
          }),
          // >>>>> Text
          [`${t}-header-text`]: {
            marginInlineEnd: "auto"
          }
        },
        [`${t}-header-collapsible-only`]: {
          cursor: "default",
          [`${t}-header-text`]: {
            flex: "none",
            cursor: "pointer"
          },
          [`${t}-expand-icon`]: {
            cursor: "pointer"
          }
        },
        [`${t}-icon-collapsible-only`]: {
          cursor: "default",
          [`${t}-expand-icon`]: {
            cursor: "pointer"
          }
        },
        [`&${t}-no-arrow`]: {
          [`> ${t}-header`]: {
            paddingInlineStart: y
          }
        }
      },
      [`${t}-content`]: {
        color: d,
        backgroundColor: n,
        borderTop: w,
        [`& > ${t}-content-box`]: {
          padding: `${o}px ${r}px`
        },
        "&-hidden": {
          display: "none"
        }
      },
      [`${t}-item:last-child`]: {
        [`> ${t}-content`]: {
          borderRadius: `0 0 ${i}px ${i}px`
        }
      },
      [`& ${t}-item-disabled > ${t}-header`]: {
        "\n          &,\n          & > .arrow\n        ": {
          color: v,
          cursor: "not-allowed"
        }
      },
      // ========================== Icon Position ==========================
      [`&${t}-icon-position-end`]: {
        [`& > ${t}-item`]: {
          [`> ${t}-header`]: {
            [`${t}-expand-icon`]: {
              order: 1,
              paddingInlineEnd: 0,
              paddingInlineStart: b
            }
          }
        }
      }
    })
  };
}, WV = (e) => {
  const {
    componentCls: t
  } = e, n = `> ${t}-item > ${t}-header ${t}-arrow svg`;
  return {
    [`${t}-rtl`]: {
      [n]: {
        transform: "rotate(180deg)"
      }
    }
  };
}, KV = (e) => {
  const {
    componentCls: t,
    collapseHeaderBg: n,
    paddingXXS: o,
    colorBorder: r
  } = e;
  return {
    [`${t}-borderless`]: {
      backgroundColor: n,
      border: 0,
      [`> ${t}-item`]: {
        borderBottom: `1px solid ${r}`
      },
      [`
        > ${t}-item:last-child,
        > ${t}-item:last-child ${t}-header
      `]: {
        borderRadius: 0
      },
      [`> ${t}-item:last-child`]: {
        borderBottom: 0
      },
      [`> ${t}-item > ${t}-content`]: {
        backgroundColor: "transparent",
        borderTop: 0
      },
      [`> ${t}-item > ${t}-content > ${t}-content-box`]: {
        paddingTop: o
      }
    }
  };
}, GV = (e) => {
  const {
    componentCls: t,
    paddingSM: n
  } = e;
  return {
    [`${t}-ghost`]: {
      backgroundColor: "transparent",
      border: 0,
      [`> ${t}-item`]: {
        borderBottom: 0,
        [`> ${t}-content`]: {
          backgroundColor: "transparent",
          border: 0,
          [`> ${t}-content-box`]: {
            paddingBlock: n
          }
        }
      }
    }
  };
}, XV = Xe("Collapse", (e) => {
  const t = He(e, {
    collapseContentBg: e.colorBgContainer,
    collapseHeaderBg: e.colorFillAlter,
    collapseHeaderPadding: `${e.paddingSM}px ${e.padding}px`,
    collapsePanelBorderRadius: e.borderRadiusLG,
    collapseContentPaddingHorizontal: 16
    // Fixed value
  });
  return [VV(t), KV(t), GV(t), WV(t), cc(t)];
});
function IC(e) {
  let t = e;
  if (!Array.isArray(t)) {
    const n = typeof t;
    t = n === "number" || n === "string" ? [t] : [];
  }
  return t.map((n) => String(n));
}
const ys = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACollapse",
  inheritAttrs: !1,
  props: Qe(jV(), {
    accordion: !1,
    destroyInactivePanel: !1,
    bordered: !0,
    expandIconPosition: "start"
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r
    } = t;
    const l = Y(IC(xd([e.activeKey, e.defaultActiveKey])));
    ie(() => e.activeKey, () => {
      l.value = IC(e.activeKey);
    }, {
      deep: !0
    });
    const {
      prefixCls: a,
      direction: i,
      rootPrefixCls: s
    } = Ie("collapse", e), [c, u] = XV(a), d = P(() => {
      const {
        expandIconPosition: y
      } = e;
      return y !== void 0 ? y : i.value === "rtl" ? "end" : "start";
    }), p = (y) => {
      const {
        expandIcon: S = o.expandIcon
      } = e, C = S ? S(y) : f(Po, {
        rotate: y.isActive ? 90 : void 0
      }, null);
      return f("div", {
        class: [`${a.value}-expand-icon`, u.value],
        onClick: () => ["header", "icon"].includes(e.collapsible) && h(y.panelKey)
      }, [Gt(Array.isArray(S) ? C[0] : C) ? yt(C, {
        class: `${a.value}-arrow`
      }, !1) : C]);
    }, v = (y) => {
      e.activeKey === void 0 && (l.value = y);
      const S = e.accordion ? y[0] : y;
      r("update:activeKey", S), r("change", S);
    }, h = (y) => {
      let S = l.value;
      if (e.accordion)
        S = S[0] === y ? [] : [y];
      else {
        S = [...S];
        const C = S.indexOf(y);
        C > -1 ? S.splice(C, 1) : S.push(y);
      }
      v(S);
    }, g = (y, S) => {
      var C, w, $;
      if (nc(y))
        return;
      const O = l.value, {
        accordion: x,
        destroyInactivePanel: I,
        collapsible: E,
        openAnimation: _
      } = e, M = _ || dc(`${s.value}-motion-collapse`), R = String((C = y.key) !== null && C !== void 0 ? C : S), {
        header: A = ($ = (w = y.children) === null || w === void 0 ? void 0 : w.header) === null || $ === void 0 ? void 0 : $.call(w),
        headerClass: z,
        collapsible: T,
        disabled: N
      } = y.props || {};
      let k = !1;
      x ? k = O[0] === R : k = O.indexOf(R) > -1;
      let B = T ?? E;
      (N || N === "") && (B = "disabled");
      const F = {
        key: R,
        panelKey: R,
        header: A,
        headerClass: z,
        isActive: k,
        prefixCls: a.value,
        destroyInactivePanel: I,
        openAnimation: M,
        accordion: x,
        onItemClick: B === "disabled" ? null : h,
        expandIcon: p,
        collapsible: B
      };
      return yt(y, F);
    }, b = () => {
      var y;
      return It((y = o.default) === null || y === void 0 ? void 0 : y.call(o)).map(g);
    };
    return () => {
      const {
        accordion: y,
        bordered: S,
        ghost: C
      } = e, w = ee(a.value, {
        [`${a.value}-borderless`]: !S,
        [`${a.value}-icon-position-${d.value}`]: !0,
        [`${a.value}-rtl`]: i.value === "rtl",
        [`${a.value}-ghost`]: !!C,
        [n.class]: !!n.class
      }, u.value);
      return c(f("div", D(D({
        class: w
      }, ET(n)), {}, {
        style: n.style,
        role: y ? "tablist" : null
      }), [b()]));
    };
  }
}), UV = Z({
  compatConfig: {
    MODE: 3
  },
  name: "PanelContent",
  props: K3(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Q(!1);
    return Le(() => {
      (e.isActive || e.forceRender) && (o.value = !0);
    }), () => {
      var r;
      if (!o.value)
        return null;
      const {
        prefixCls: l,
        isActive: a,
        role: i
      } = e;
      return f("div", {
        class: ee(`${l}-content`, {
          [`${l}-content-active`]: a,
          [`${l}-content-inactive`]: !a
        }),
        role: i
      }, [f("div", {
        class: `${l}-content-box`
      }, [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)])]);
    };
  }
}), Hd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACollapsePanel",
  inheritAttrs: !1,
  props: Qe(K3(), {
    showArrow: !0,
    isActive: !1,
    onItemClick() {
    },
    headerClass: "",
    forceRender: !1
  }),
  slots: Object,
  // emits: ['itemClick'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    nt(e.disabled === void 0, "Collapse.Panel", '`disabled` is deprecated. Please use `collapsible="disabled"` instead.');
    const {
      prefixCls: l
    } = Ie("collapse", e), a = () => {
      o("itemClick", e.panelKey);
    }, i = (s) => {
      (s.key === "Enter" || s.keyCode === 13 || s.which === 13) && a();
    };
    return () => {
      var s, c;
      const {
        header: u = (s = n.header) === null || s === void 0 ? void 0 : s.call(n),
        headerClass: d,
        isActive: p,
        showArrow: v,
        destroyInactivePanel: h,
        accordion: g,
        forceRender: b,
        openAnimation: y,
        expandIcon: S = n.expandIcon,
        extra: C = (c = n.extra) === null || c === void 0 ? void 0 : c.call(n),
        collapsible: w
      } = e, $ = w === "disabled", O = l.value, x = ee(`${O}-header`, {
        [d]: d,
        [`${O}-header-collapsible-only`]: w === "header",
        [`${O}-icon-collapsible-only`]: w === "icon"
      }), I = ee({
        [`${O}-item`]: !0,
        [`${O}-item-active`]: p,
        [`${O}-item-disabled`]: $,
        [`${O}-no-arrow`]: !v,
        [`${r.class}`]: !!r.class
      });
      let E = f("i", {
        class: "arrow"
      }, null);
      v && typeof S == "function" && (E = S(e));
      const _ = Tn(f(UV, {
        prefixCls: O,
        isActive: p,
        forceRender: b,
        role: g ? "tabpanel" : null
      }, {
        default: n.default
      }), [[Hn, p]]), M = m({
        appear: !1,
        css: !1
      }, y);
      return f("div", D(D({}, r), {}, {
        class: I
      }), [f("div", {
        class: x,
        onClick: () => !["header", "icon"].includes(w) && a(),
        role: g ? "tab" : "button",
        tabindex: $ ? -1 : 0,
        "aria-expanded": p,
        onKeypress: i
      }, [v && E, f("span", {
        onClick: () => w === "header" && a(),
        class: `${O}-header-text`
      }, [u]), C && f("div", {
        class: `${O}-extra`
      }, [C])]), f(yn, M, {
        default: () => [!h || p ? _ : null]
      })]);
    };
  }
});
ys.Panel = Hd;
ys.install = function(e) {
  return e.component(ys.name, ys), e.component(Hd.name, Hd), e;
};
const YV = function(e) {
  return e.replace(/[A-Z]/g, function(t) {
    return "-" + t.toLowerCase();
  }).toLowerCase();
}, qV = function(e) {
  return /[height|width]$/.test(e);
}, EC = function(e) {
  let t = "";
  const n = Object.keys(e);
  return n.forEach(function(o, r) {
    let l = e[o];
    o = YV(o), qV(o) && typeof l == "number" && (l = l + "px"), l === !0 ? t += o : l === !1 ? t += "not " + o : t += "(" + o + ": " + l + ")", r < n.length - 1 && (t += " and ");
  }), t;
};
function Cv(e) {
  let t = "";
  return typeof e == "string" ? e : e instanceof Array ? (e.forEach(function(n, o) {
    t += EC(n), o < e.length - 1 && (t += ", ");
  }), t) : EC(e);
}
const G3 = {
  accessibility: {
    type: Boolean,
    default: !0
  },
  // 自定义高度
  adaptiveHeight: {
    type: Boolean,
    default: !1
  },
  afterChange: V.any.def(null),
  arrows: {
    type: Boolean,
    default: !0
  },
  autoplay: {
    type: Boolean,
    default: !1
  },
  autoplaySpeed: V.number.def(3e3),
  beforeChange: V.any.def(null),
  centerMode: {
    type: Boolean,
    default: !1
  },
  centerPadding: V.string.def("50px"),
  cssEase: V.string.def("ease"),
  dots: {
    type: Boolean,
    default: !1
  },
  dotsClass: V.string.def("slick-dots"),
  draggable: {
    type: Boolean,
    default: !0
  },
  unslick: {
    type: Boolean,
    default: !1
  },
  easing: V.string.def("linear"),
  edgeFriction: V.number.def(0.35),
  fade: {
    type: Boolean,
    default: !1
  },
  focusOnSelect: {
    type: Boolean,
    default: !1
  },
  infinite: {
    type: Boolean,
    default: !0
  },
  initialSlide: V.number.def(0),
  lazyLoad: V.any.def(null),
  verticalSwiping: {
    type: Boolean,
    default: !1
  },
  asNavFor: V.any.def(null),
  // 圆点hover是否暂停
  pauseOnDotsHover: {
    type: Boolean,
    default: !1
  },
  // focus是否暂停
  pauseOnFocus: {
    type: Boolean,
    default: !1
  },
  // hover是否暂停
  pauseOnHover: {
    type: Boolean,
    default: !0
  },
  responsive: V.array,
  rows: V.number.def(1),
  rtl: {
    type: Boolean,
    default: !1
  },
  slide: V.string.def("div"),
  slidesPerRow: V.number.def(1),
  slidesToScroll: V.number.def(1),
  slidesToShow: V.number.def(1),
  speed: V.number.def(500),
  swipe: {
    type: Boolean,
    default: !0
  },
  swipeEvent: V.any.def(null),
  swipeToSlide: {
    type: Boolean,
    default: !1
  },
  touchMove: {
    type: Boolean,
    default: !0
  },
  touchThreshold: V.number.def(5),
  useCSS: {
    type: Boolean,
    default: !0
  },
  useTransform: {
    type: Boolean,
    default: !0
  },
  variableWidth: {
    type: Boolean,
    default: !1
  },
  vertical: {
    type: Boolean,
    default: !1
  },
  waitForAnimate: {
    type: Boolean,
    default: !0
  },
  children: V.array,
  __propsSymbol__: V.any
}, ZV = {
  animating: !1,
  autoplaying: null,
  currentDirection: 0,
  currentLeft: null,
  currentSlide: 0,
  direction: 1,
  dragging: !1,
  edgeDragged: !1,
  initialized: !1,
  lazyLoadedList: [],
  listHeight: null,
  listWidth: null,
  scrolling: !1,
  slideCount: null,
  slideHeight: null,
  slideWidth: null,
  swipeLeft: null,
  swiped: !1,
  swiping: !1,
  touchObject: {
    startX: 0,
    startY: 0,
    curX: 0,
    curY: 0
  },
  trackStyle: {},
  trackWidth: 0,
  targetSlide: 0
};
function im(e, t, n) {
  return Math.max(t, Math.min(e, n));
}
const ii = (e) => {
  ["touchstart", "touchmove", "wheel"].includes(e.type) || e.preventDefault();
}, jd = (e) => {
  const t = [], n = X3(e), o = U3(e);
  for (let r = n; r < o; r++)
    e.lazyLoadedList.indexOf(r) < 0 && t.push(r);
  return t;
}, X3 = (e) => e.currentSlide - QV(e), U3 = (e) => e.currentSlide + JV(e), QV = (e) => e.centerMode ? Math.floor(e.slidesToShow / 2) + (parseInt(e.centerPadding) > 0 ? 1 : 0) : 0, JV = (e) => e.centerMode ? Math.floor((e.slidesToShow - 1) / 2) + 1 + (parseInt(e.centerPadding) > 0 ? 1 : 0) : e.slidesToShow, sm = (e) => e && e.offsetWidth || 0, Q0 = (e) => e && e.offsetHeight || 0, Y3 = function(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n;
  const o = e.startX - e.curX, r = e.startY - e.curY, l = Math.atan2(r, o);
  return n = Math.round(l * 180 / Math.PI), n < 0 && (n = 360 - Math.abs(n)), n <= 45 && n >= 0 || n <= 360 && n >= 315 ? "left" : n >= 135 && n <= 225 ? "right" : t === !0 ? n >= 35 && n <= 135 ? "up" : "down" : "vertical";
}, ip = (e) => {
  let t = !0;
  return e.infinite || (e.centerMode && e.currentSlide >= e.slideCount - 1 || e.slideCount <= e.slidesToShow || e.currentSlide >= e.slideCount - e.slidesToShow) && (t = !1), t;
}, $v = (e, t) => {
  const n = {};
  return t.forEach((o) => n[o] = e[o]), n;
}, eW = (e) => {
  const t = e.children.length, n = e.listRef, o = Math.ceil(sm(n)), r = e.trackRef, l = Math.ceil(sm(r));
  let a;
  if (e.vertical)
    a = o;
  else {
    let v = e.centerMode && parseInt(e.centerPadding) * 2;
    typeof e.centerPadding == "string" && e.centerPadding.slice(-1) === "%" && (v *= o / 100), a = Math.ceil((o - v) / e.slidesToShow);
  }
  const i = n && Q0(n.querySelector('[data-index="0"]')), s = i * e.slidesToShow;
  let c = e.currentSlide === void 0 ? e.initialSlide : e.currentSlide;
  e.rtl && e.currentSlide === void 0 && (c = t - 1 - e.initialSlide);
  let u = e.lazyLoadedList || [];
  const d = jd(m(m({}, e), {
    currentSlide: c,
    lazyLoadedList: u
  }));
  u = u.concat(d);
  const p = {
    slideCount: t,
    slideWidth: a,
    listWidth: o,
    trackWidth: l,
    currentSlide: c,
    slideHeight: i,
    listHeight: s,
    lazyLoadedList: u
  };
  return e.autoplaying === null && e.autoplay && (p.autoplaying = "playing"), p;
}, tW = (e) => {
  const {
    waitForAnimate: t,
    animating: n,
    fade: o,
    infinite: r,
    index: l,
    slideCount: a,
    lazyLoad: i,
    currentSlide: s,
    centerMode: c,
    slidesToScroll: u,
    slidesToShow: d,
    useCSS: p
  } = e;
  let {
    lazyLoadedList: v
  } = e;
  if (t && n)
    return {};
  let h = l, g, b, y, S = {}, C = {};
  const w = r ? l : im(l, 0, a - 1);
  if (o) {
    if (!r && (l < 0 || l >= a))
      return {};
    l < 0 ? h = l + a : l >= a && (h = l - a), i && v.indexOf(h) < 0 && (v = v.concat(h)), S = {
      animating: !0,
      currentSlide: h,
      lazyLoadedList: v,
      targetSlide: h
    }, C = {
      animating: !1,
      targetSlide: h
    };
  } else
    g = h, h < 0 ? (g = h + a, r ? a % u !== 0 && (g = a - a % u) : g = 0) : !ip(e) && h > s ? h = g = s : c && h >= a ? (h = r ? a : a - 1, g = r ? 0 : a - 1) : h >= a && (g = h - a, r ? a % u !== 0 && (g = 0) : g = a - d), !r && h + d >= a && (g = a - d), b = Zs(m(m({}, e), {
      slideIndex: h
    })), y = Zs(m(m({}, e), {
      slideIndex: g
    })), r || (b === y && (h = g), b = y), i && (v = v.concat(jd(m(m({}, e), {
      currentSlide: h
    })))), p ? (S = {
      animating: !0,
      currentSlide: g,
      trackStyle: q3(m(m({}, e), {
        left: b
      })),
      lazyLoadedList: v,
      targetSlide: w
    }, C = {
      animating: !1,
      currentSlide: g,
      trackStyle: qs(m(m({}, e), {
        left: y
      })),
      swipeLeft: null,
      targetSlide: w
    }) : S = {
      currentSlide: g,
      trackStyle: qs(m(m({}, e), {
        left: y
      })),
      lazyLoadedList: v,
      targetSlide: w
    };
  return {
    state: S,
    nextState: C
  };
}, nW = (e, t) => {
  let n, o, r;
  const {
    slidesToScroll: l,
    slidesToShow: a,
    slideCount: i,
    currentSlide: s,
    targetSlide: c,
    lazyLoad: u,
    infinite: d
  } = e, v = i % l !== 0 ? 0 : (i - s) % l;
  if (t.message === "previous")
    o = v === 0 ? l : a - v, r = s - o, u && !d && (n = s - o, r = n === -1 ? i - 1 : n), d || (r = c - l);
  else if (t.message === "next")
    o = v === 0 ? l : v, r = s + o, u && !d && (r = (s + l) % i + v), d || (r = c + l);
  else if (t.message === "dots")
    r = t.index * t.slidesToScroll;
  else if (t.message === "children") {
    if (r = t.index, d) {
      const h = cW(m(m({}, e), {
        targetSlide: r
      }));
      r > t.currentSlide && h === "left" ? r = r - i : r < t.currentSlide && h === "right" && (r = r + i);
    }
  } else
    t.message === "index" && (r = Number(t.index));
  return r;
}, oW = (e, t, n) => e.target.tagName.match("TEXTAREA|INPUT|SELECT") || !t ? "" : e.keyCode === 37 ? n ? "next" : "previous" : e.keyCode === 39 ? n ? "previous" : "next" : "", rW = (e, t, n) => (e.target.tagName === "IMG" && ii(e), !t || !n && e.type.indexOf("mouse") !== -1 ? "" : {
  dragging: !0,
  touchObject: {
    startX: e.touches ? e.touches[0].pageX : e.clientX,
    startY: e.touches ? e.touches[0].pageY : e.clientY,
    curX: e.touches ? e.touches[0].pageX : e.clientX,
    curY: e.touches ? e.touches[0].pageY : e.clientY
  }
}), lW = (e, t) => {
  const {
    scrolling: n,
    animating: o,
    vertical: r,
    swipeToSlide: l,
    verticalSwiping: a,
    rtl: i,
    currentSlide: s,
    edgeFriction: c,
    edgeDragged: u,
    onEdge: d,
    swiped: p,
    swiping: v,
    slideCount: h,
    slidesToScroll: g,
    infinite: b,
    touchObject: y,
    swipeEvent: S,
    listHeight: C,
    listWidth: w
  } = t;
  if (n)
    return;
  if (o)
    return ii(e);
  r && l && a && ii(e);
  let $, O = {};
  const x = Zs(t);
  y.curX = e.touches ? e.touches[0].pageX : e.clientX, y.curY = e.touches ? e.touches[0].pageY : e.clientY, y.swipeLength = Math.round(Math.sqrt(Math.pow(y.curX - y.startX, 2)));
  const I = Math.round(Math.sqrt(Math.pow(y.curY - y.startY, 2)));
  if (!a && !v && I > 10)
    return {
      scrolling: !0
    };
  a && (y.swipeLength = I);
  let E = (i ? -1 : 1) * (y.curX > y.startX ? 1 : -1);
  a && (E = y.curY > y.startY ? 1 : -1);
  const _ = Math.ceil(h / g), M = Y3(t.touchObject, a);
  let R = y.swipeLength;
  return b || (s === 0 && (M === "right" || M === "down") || s + 1 >= _ && (M === "left" || M === "up") || !ip(t) && (M === "left" || M === "up")) && (R = y.swipeLength * c, u === !1 && d && (d(M), O.edgeDragged = !0)), !p && S && (S(M), O.swiped = !0), r ? $ = x + R * (C / w) * E : i ? $ = x - R * E : $ = x + R * E, a && ($ = x + R * E), O = m(m({}, O), {
    touchObject: y,
    swipeLeft: $,
    trackStyle: qs(m(m({}, t), {
      left: $
    }))
  }), Math.abs(y.curX - y.startX) < Math.abs(y.curY - y.startY) * 0.8 || y.swipeLength > 10 && (O.swiping = !0, ii(e)), O;
}, aW = (e, t) => {
  const {
    dragging: n,
    swipe: o,
    touchObject: r,
    listWidth: l,
    touchThreshold: a,
    verticalSwiping: i,
    listHeight: s,
    swipeToSlide: c,
    scrolling: u,
    onSwipe: d,
    targetSlide: p,
    currentSlide: v,
    infinite: h
  } = t;
  if (!n)
    return o && ii(e), {};
  const g = i ? s / a : l / a, b = Y3(r, i), y = {
    dragging: !1,
    edgeDragged: !1,
    scrolling: !1,
    swiping: !1,
    swiped: !1,
    swipeLeft: null,
    touchObject: {}
  };
  if (u || !r.swipeLength)
    return y;
  if (r.swipeLength > g) {
    ii(e), d && d(b);
    let S, C;
    const w = h ? v : p;
    switch (b) {
      case "left":
      case "up":
        C = w + MC(t), S = c ? TC(t, C) : C, y.currentDirection = 0;
        break;
      case "right":
      case "down":
        C = w - MC(t), S = c ? TC(t, C) : C, y.currentDirection = 1;
        break;
      default:
        S = w;
    }
    y.triggerSlideHandler = S;
  } else {
    const S = Zs(t);
    y.trackStyle = q3(m(m({}, t), {
      left: S
    }));
  }
  return y;
}, iW = (e) => {
  const t = e.infinite ? e.slideCount * 2 : e.slideCount;
  let n = e.infinite ? e.slidesToShow * -1 : 0, o = e.infinite ? e.slidesToShow * -1 : 0;
  const r = [];
  for (; n < t; )
    r.push(n), n = o + e.slidesToScroll, o += Math.min(e.slidesToScroll, e.slidesToShow);
  return r;
}, TC = (e, t) => {
  const n = iW(e);
  let o = 0;
  if (t > n[n.length - 1])
    t = n[n.length - 1];
  else
    for (const r in n) {
      if (t < n[r]) {
        t = o;
        break;
      }
      o = n[r];
    }
  return t;
}, MC = (e) => {
  const t = e.centerMode ? e.slideWidth * Math.floor(e.slidesToShow / 2) : 0;
  if (e.swipeToSlide) {
    let n;
    const o = e.listRef, r = o.querySelectorAll && o.querySelectorAll(".slick-slide") || [];
    if (Array.from(r).every((i) => {
      if (e.vertical) {
        if (i.offsetTop + Q0(i) / 2 > e.swipeLeft * -1)
          return n = i, !1;
      } else if (i.offsetLeft - t + sm(i) / 2 > e.swipeLeft * -1)
        return n = i, !1;
      return !0;
    }), !n)
      return 0;
    const l = e.rtl === !0 ? e.slideCount - e.currentSlide : e.currentSlide;
    return Math.abs(n.dataset.index - l) || 1;
  } else
    return e.slidesToScroll;
}, J0 = (e, t) => t.reduce((n, o) => n && e.hasOwnProperty(o), !0) ? null : console.error("Keys Missing:", e), qs = (e) => {
  J0(e, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth"]);
  let t, n;
  const o = e.slideCount + 2 * e.slidesToShow;
  e.vertical ? n = o * e.slideHeight : t = sW(e) * e.slideWidth;
  let r = {
    opacity: 1,
    transition: "",
    WebkitTransition: ""
  };
  if (e.useTransform) {
    const l = e.vertical ? "translate3d(0px, " + e.left + "px, 0px)" : "translate3d(" + e.left + "px, 0px, 0px)", a = e.vertical ? "translate3d(0px, " + e.left + "px, 0px)" : "translate3d(" + e.left + "px, 0px, 0px)", i = e.vertical ? "translateY(" + e.left + "px)" : "translateX(" + e.left + "px)";
    r = m(m({}, r), {
      WebkitTransform: l,
      transform: a,
      msTransform: i
    });
  } else
    e.vertical ? r.top = e.left : r.left = e.left;
  return e.fade && (r = {
    opacity: 1
  }), t && (r.width = t + "px"), n && (r.height = n + "px"), window && !window.addEventListener && window.attachEvent && (e.vertical ? r.marginTop = e.left + "px" : r.marginLeft = e.left + "px"), r;
}, q3 = (e) => {
  J0(e, ["left", "variableWidth", "slideCount", "slidesToShow", "slideWidth", "speed", "cssEase"]);
  const t = qs(e);
  return e.useTransform ? (t.WebkitTransition = "-webkit-transform " + e.speed + "ms " + e.cssEase, t.transition = "transform " + e.speed + "ms " + e.cssEase) : e.vertical ? t.transition = "top " + e.speed + "ms " + e.cssEase : t.transition = "left " + e.speed + "ms " + e.cssEase, t;
}, Zs = (e) => {
  if (e.unslick)
    return 0;
  J0(e, ["slideIndex", "trackRef", "infinite", "centerMode", "slideCount", "slidesToShow", "slidesToScroll", "slideWidth", "listWidth", "variableWidth", "slideHeight"]);
  const {
    slideIndex: t,
    trackRef: n,
    infinite: o,
    centerMode: r,
    slideCount: l,
    slidesToShow: a,
    slidesToScroll: i,
    slideWidth: s,
    listWidth: c,
    variableWidth: u,
    slideHeight: d,
    fade: p,
    vertical: v
  } = e;
  let h = 0, g, b, y = 0;
  if (p || e.slideCount === 1)
    return 0;
  let S = 0;
  if (o ? (S = -jr(e), l % i !== 0 && t + i > l && (S = -(t > l ? a - (t - l) : l % i)), r && (S += parseInt(a / 2))) : (l % i !== 0 && t + i > l && (S = a - l % i), r && (S = parseInt(a / 2))), h = S * s, y = S * d, v ? g = t * d * -1 + y : g = t * s * -1 + h, u === !0) {
    let C;
    const w = n;
    if (C = t + jr(e), b = w && w.childNodes[C], g = b ? b.offsetLeft * -1 : 0, r === !0) {
      C = o ? t + jr(e) : t, b = w && w.children[C], g = 0;
      for (let $ = 0; $ < C; $++)
        g -= w && w.children[$] && w.children[$].offsetWidth;
      g -= parseInt(e.centerPadding), g += b && (c - b.offsetWidth) / 2;
    }
  }
  return g;
}, jr = (e) => e.unslick || !e.infinite ? 0 : e.variableWidth ? e.slideCount : e.slidesToShow + (e.centerMode ? 1 : 0), wu = (e) => e.unslick || !e.infinite ? 0 : e.slideCount, sW = (e) => e.slideCount === 1 ? 1 : jr(e) + e.slideCount + wu(e), cW = (e) => e.targetSlide > e.currentSlide ? e.targetSlide > e.currentSlide + uW(e) ? "left" : "right" : e.targetSlide < e.currentSlide - dW(e) ? "right" : "left", uW = (e) => {
  let {
    slidesToShow: t,
    centerMode: n,
    rtl: o,
    centerPadding: r
  } = e;
  if (n) {
    let l = (t - 1) / 2 + 1;
    return parseInt(r) > 0 && (l += 1), o && t % 2 === 0 && (l += 1), l;
  }
  return o ? 0 : t - 1;
}, dW = (e) => {
  let {
    slidesToShow: t,
    centerMode: n,
    rtl: o,
    centerPadding: r
  } = e;
  if (n) {
    let l = (t - 1) / 2 + 1;
    return parseInt(r) > 0 && (l += 1), !o && t % 2 === 0 && (l += 1), l;
  }
  return o ? t - 1 : 0;
}, _C = () => !!(typeof window < "u" && window.document && window.document.createElement), wv = (e) => {
  let t, n, o, r;
  e.rtl ? r = e.slideCount - 1 - e.index : r = e.index;
  const l = r < 0 || r >= e.slideCount;
  e.centerMode ? (o = Math.floor(e.slidesToShow / 2), n = (r - e.currentSlide) % e.slideCount === 0, r > e.currentSlide - o - 1 && r <= e.currentSlide + o && (t = !0)) : t = e.currentSlide <= r && r < e.currentSlide + e.slidesToShow;
  let a;
  return e.targetSlide < 0 ? a = e.targetSlide + e.slideCount : e.targetSlide >= e.slideCount ? a = e.targetSlide - e.slideCount : a = e.targetSlide, {
    "slick-slide": !0,
    "slick-active": t,
    "slick-center": n,
    "slick-cloned": l,
    "slick-current": r === a
    // dubious in case of RTL
  };
}, fW = function(e) {
  const t = {};
  return (e.variableWidth === void 0 || e.variableWidth === !1) && (t.width = e.slideWidth + (typeof e.slideWidth == "number" ? "px" : "")), e.fade && (t.position = "relative", e.vertical ? t.top = -e.index * parseInt(e.slideHeight) + "px" : t.left = -e.index * parseInt(e.slideWidth) + "px", t.opacity = e.currentSlide === e.index ? 1 : 0, e.useCSS && (t.transition = "opacity " + e.speed + "ms " + e.cssEase + ", visibility " + e.speed + "ms " + e.cssEase)), t;
}, xv = (e, t) => e.key + "-" + t, pW = function(e, t) {
  let n;
  const o = [], r = [], l = [], a = t.length, i = X3(e), s = U3(e);
  return t.forEach((c, u) => {
    let d;
    const p = {
      message: "children",
      index: u,
      slidesToScroll: e.slidesToScroll,
      currentSlide: e.currentSlide
    };
    !e.lazyLoad || e.lazyLoad && e.lazyLoadedList.indexOf(u) >= 0 ? d = c : d = f("div");
    const v = fW(m(m({}, e), {
      index: u
    })), h = d.props.class || "";
    let g = wv(m(m({}, e), {
      index: u
    }));
    if (o.push(ps(d, {
      key: "original" + xv(d, u),
      tabindex: "-1",
      "data-index": u,
      "aria-hidden": !g["slick-active"],
      class: ee(g, h),
      style: m(m({
        outline: "none"
      }, d.props.style || {}), v),
      onClick: () => {
        e.focusOnSelect && e.focusOnSelect(p);
      }
    })), e.infinite && e.fade === !1) {
      const b = a - u;
      b <= jr(e) && a !== e.slidesToShow && (n = -b, n >= i && (d = c), g = wv(m(m({}, e), {
        index: n
      })), r.push(ps(d, {
        key: "precloned" + xv(d, n),
        class: ee(g, h),
        tabindex: "-1",
        "data-index": n,
        "aria-hidden": !g["slick-active"],
        style: m(m({}, d.props.style || {}), v),
        onClick: () => {
          e.focusOnSelect && e.focusOnSelect(p);
        }
      }))), a !== e.slidesToShow && (n = a + u, n < s && (d = c), g = wv(m(m({}, e), {
        index: n
      })), l.push(ps(d, {
        key: "postcloned" + xv(d, n),
        tabindex: "-1",
        "data-index": n,
        "aria-hidden": !g["slick-active"],
        class: ee(g, h),
        style: m(m({}, d.props.style || {}), v),
        onClick: () => {
          e.focusOnSelect && e.focusOnSelect(p);
        }
      })));
    }
  }), e.rtl ? r.concat(o, l).reverse() : r.concat(o, l);
}, Z3 = (e, t) => {
  let {
    attrs: n,
    slots: o
  } = t;
  const r = pW(n, It(o == null ? void 0 : o.default())), {
    onMouseenter: l,
    onMouseover: a,
    onMouseleave: i
  } = n, s = {
    onMouseenter: l,
    onMouseover: a,
    onMouseleave: i
  }, c = m({
    class: "slick-track",
    style: n.trackStyle
  }, s);
  return f("div", c, [r]);
};
Z3.inheritAttrs = !1;
const vW = function(e) {
  let t;
  return e.infinite ? t = Math.ceil(e.slideCount / e.slidesToScroll) : t = Math.ceil((e.slideCount - e.slidesToShow) / e.slidesToScroll) + 1, t;
}, Q3 = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    slideCount: o,
    slidesToScroll: r,
    slidesToShow: l,
    infinite: a,
    currentSlide: i,
    appendDots: s,
    customPaging: c,
    clickHandler: u,
    dotsClass: d,
    onMouseenter: p,
    onMouseover: v,
    onMouseleave: h
  } = n, g = vW({
    slideCount: o,
    slidesToScroll: r,
    slidesToShow: l,
    infinite: a
  }), b = {
    onMouseenter: p,
    onMouseover: v,
    onMouseleave: h
  };
  let y = [];
  for (let S = 0; S < g; S++) {
    let E = function(_) {
      _ && _.preventDefault(), u(I);
    };
    const C = (S + 1) * r - 1, w = a ? C : im(C, 0, o - 1), $ = w - (r - 1), O = a ? $ : im($, 0, o - 1), x = ee({
      "slick-active": a ? i >= O && i <= w : i === O
    }), I = {
      message: "dots",
      index: S,
      slidesToScroll: r,
      currentSlide: i
    };
    y = y.concat(f("li", {
      key: S,
      class: x
    }, [yt(c({
      i: S
    }), {
      onClick: E
    })]));
  }
  return yt(s({
    dots: y
  }), m({
    class: d
  }, b));
};
Q3.inheritAttrs = !1;
function J3() {
}
function eP(e, t, n) {
  n && n.preventDefault(), t(e, n);
}
const tP = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    clickHandler: o,
    infinite: r,
    currentSlide: l,
    slideCount: a,
    slidesToShow: i
  } = n, s = {
    "slick-arrow": !0,
    "slick-prev": !0
  };
  let c = function(v) {
    eP({
      message: "previous"
    }, o, v);
  };
  !r && (l === 0 || a <= i) && (s["slick-disabled"] = !0, c = J3);
  const u = {
    key: "0",
    "data-role": "none",
    class: s,
    style: {
      display: "block"
    },
    onClick: c
  }, d = {
    currentSlide: l,
    slideCount: a
  };
  let p;
  return n.prevArrow ? p = yt(n.prevArrow(m(m({}, u), d)), {
    key: "0",
    class: s,
    style: {
      display: "block"
    },
    onClick: c
  }, !1) : p = f("button", D({
    key: "0",
    type: "button"
  }, u), [" ", Ot("Previous")]), p;
};
tP.inheritAttrs = !1;
const nP = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    clickHandler: o,
    currentSlide: r,
    slideCount: l
  } = n, a = {
    "slick-arrow": !0,
    "slick-next": !0
  };
  let i = function(d) {
    eP({
      message: "next"
    }, o, d);
  };
  ip(n) || (a["slick-disabled"] = !0, i = J3);
  const s = {
    key: "1",
    "data-role": "none",
    class: ee(a),
    style: {
      display: "block"
    },
    onClick: i
  }, c = {
    currentSlide: r,
    slideCount: l
  };
  let u;
  return n.nextArrow ? u = yt(n.nextArrow(m(m({}, s), c)), {
    key: "1",
    class: ee(a),
    style: {
      display: "block"
    },
    onClick: i
  }, !1) : u = f("button", D({
    key: "1",
    type: "button"
  }, s), [" ", Ot("Next")]), u;
};
nP.inheritAttrs = !1;
var gW = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function go() {
}
const mW = {
  name: "InnerSlider",
  mixins: [Ca],
  inheritAttrs: !1,
  props: m({}, G3),
  data() {
    this.preProps = m({}, this.$props), this.list = null, this.track = null, this.callbackTimers = [], this.clickable = !0, this.debouncedResize = null;
    const e = this.ssrInit();
    return m(m(m({}, ZV), {
      currentSlide: this.initialSlide,
      slideCount: this.children.length
    }), e);
  },
  watch: {
    autoplay(e, t) {
      !t && e ? this.handleAutoPlay("playing") : e ? this.handleAutoPlay("update") : this.pause("paused");
    },
    __propsSymbol__() {
      const e = this.$props, t = m(m({
        listRef: this.list,
        trackRef: this.track
      }, e), this.$data);
      let n = !1;
      for (const o of Object.keys(this.preProps)) {
        if (!e.hasOwnProperty(o)) {
          n = !0;
          break;
        }
        if (!(typeof e[o] == "object" || typeof e[o] == "function" || typeof e[o] == "symbol") && e[o] !== this.preProps[o]) {
          n = !0;
          break;
        }
      }
      this.updateState(t, n, () => {
        this.currentSlide >= e.children.length && this.changeSlide({
          message: "index",
          index: e.children.length - e.slidesToShow,
          currentSlide: this.currentSlide
        }), !this.preProps.autoplay && e.autoplay ? this.handleAutoPlay("playing") : e.autoplay ? this.handleAutoPlay("update") : this.pause("paused");
      }), this.preProps = m({}, e);
    }
  },
  mounted() {
    if (this.__emit("init"), this.lazyLoad) {
      const e = jd(m(m({}, this.$props), this.$data));
      e.length > 0 && (this.setState((t) => ({
        lazyLoadedList: t.lazyLoadedList.concat(e)
      })), this.__emit("lazyLoad", e));
    }
    this.$nextTick(() => {
      const e = m({
        listRef: this.list,
        trackRef: this.track,
        children: this.children
      }, this.$props);
      this.updateState(e, !0, () => {
        this.adaptHeight(), this.autoplay && this.handleAutoPlay("playing");
      }), this.lazyLoad === "progressive" && (this.lazyLoadTimer = setInterval(this.progressiveLazyLoad, 1e3)), this.ro = new oh(() => {
        this.animating ? (this.onWindowResized(!1), this.callbackTimers.push(setTimeout(() => this.onWindowResized(), this.speed))) : this.onWindowResized();
      }), this.ro.observe(this.list), document.querySelectorAll && Array.prototype.forEach.call(document.querySelectorAll(".slick-slide"), (t) => {
        t.onfocus = this.$props.pauseOnFocus ? this.onSlideFocus : null, t.onblur = this.$props.pauseOnFocus ? this.onSlideBlur : null;
      }), window.addEventListener ? window.addEventListener("resize", this.onWindowResized) : window.attachEvent("onresize", this.onWindowResized);
    });
  },
  beforeUnmount() {
    var e;
    this.animationEndCallback && clearTimeout(this.animationEndCallback), this.lazyLoadTimer && clearInterval(this.lazyLoadTimer), this.callbackTimers.length && (this.callbackTimers.forEach((t) => clearTimeout(t)), this.callbackTimers = []), window.addEventListener ? window.removeEventListener("resize", this.onWindowResized) : window.detachEvent("onresize", this.onWindowResized), this.autoplayTimer && clearInterval(this.autoplayTimer), (e = this.ro) === null || e === void 0 || e.disconnect();
  },
  updated() {
    if (this.checkImagesLoad(), this.__emit("reInit"), this.lazyLoad) {
      const e = jd(m(m({}, this.$props), this.$data));
      e.length > 0 && (this.setState((t) => ({
        lazyLoadedList: t.lazyLoadedList.concat(e)
      })), this.__emit("lazyLoad"));
    }
    this.adaptHeight();
  },
  methods: {
    listRefHandler(e) {
      this.list = e;
    },
    trackRefHandler(e) {
      this.track = e;
    },
    adaptHeight() {
      if (this.adaptiveHeight && this.list) {
        const e = this.list.querySelector(`[data-index="${this.currentSlide}"]`);
        this.list.style.height = Q0(e) + "px";
      }
    },
    onWindowResized(e) {
      this.debouncedResize && this.debouncedResize.cancel(), this.debouncedResize = Hf(() => this.resizeWindow(e), 50), this.debouncedResize();
    },
    resizeWindow() {
      let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      if (!!!this.track)
        return;
      const n = m(m({
        listRef: this.list,
        trackRef: this.track,
        children: this.children
      }, this.$props), this.$data);
      this.updateState(n, e, () => {
        this.autoplay ? this.handleAutoPlay("update") : this.pause("paused");
      }), this.setState({
        animating: !1
      }), clearTimeout(this.animationEndCallback), delete this.animationEndCallback;
    },
    updateState(e, t, n) {
      const o = eW(e);
      e = m(m(m({}, e), o), {
        slideIndex: o.currentSlide
      });
      const r = Zs(e);
      e = m(m({}, e), {
        left: r
      });
      const l = qs(e);
      (t || this.children.length !== e.children.length) && (o.trackStyle = l), this.setState(o, n);
    },
    ssrInit() {
      const e = this.children;
      if (this.variableWidth) {
        let s = 0, c = 0;
        const u = [], d = jr(m(m(m({}, this.$props), this.$data), {
          slideCount: e.length
        })), p = wu(m(m(m({}, this.$props), this.$data), {
          slideCount: e.length
        }));
        e.forEach((h) => {
          var g, b;
          const y = ((b = (g = h.props.style) === null || g === void 0 ? void 0 : g.width) === null || b === void 0 ? void 0 : b.split("px")[0]) || 0;
          u.push(y), s += y;
        });
        for (let h = 0; h < d; h++)
          c += u[u.length - 1 - h], s += u[u.length - 1 - h];
        for (let h = 0; h < p; h++)
          s += u[h];
        for (let h = 0; h < this.currentSlide; h++)
          c += u[h];
        const v = {
          width: s + "px",
          left: -c + "px"
        };
        if (this.centerMode) {
          const h = `${u[this.currentSlide]}px`;
          v.left = `calc(${v.left} + (100% - ${h}) / 2 ) `;
        }
        return {
          trackStyle: v
        };
      }
      const t = e.length, n = m(m(m({}, this.$props), this.$data), {
        slideCount: t
      }), o = jr(n) + wu(n) + t, r = 100 / this.slidesToShow * o, l = 100 / o;
      let a = -l * (jr(n) + this.currentSlide) * r / 100;
      this.centerMode && (a += (100 - l * r / 100) / 2);
      const i = {
        width: r + "%",
        left: a + "%"
      };
      return {
        slideWidth: l + "%",
        trackStyle: i
      };
    },
    checkImagesLoad() {
      const e = this.list && this.list.querySelectorAll && this.list.querySelectorAll(".slick-slide img") || [], t = e.length;
      let n = 0;
      Array.prototype.forEach.call(e, (o) => {
        const r = () => ++n && n >= t && this.onWindowResized();
        if (!o.onclick)
          o.onclick = () => o.parentNode.focus();
        else {
          const l = o.onclick;
          o.onclick = () => {
            l(), o.parentNode.focus();
          };
        }
        o.onload || (this.$props.lazyLoad ? o.onload = () => {
          this.adaptHeight(), this.callbackTimers.push(setTimeout(this.onWindowResized, this.speed));
        } : (o.onload = r, o.onerror = () => {
          r(), this.__emit("lazyLoadError");
        }));
      });
    },
    progressiveLazyLoad() {
      const e = [], t = m(m({}, this.$props), this.$data);
      for (let n = this.currentSlide; n < this.slideCount + wu(t); n++)
        if (this.lazyLoadedList.indexOf(n) < 0) {
          e.push(n);
          break;
        }
      for (let n = this.currentSlide - 1; n >= -jr(t); n--)
        if (this.lazyLoadedList.indexOf(n) < 0) {
          e.push(n);
          break;
        }
      e.length > 0 ? (this.setState((n) => ({
        lazyLoadedList: n.lazyLoadedList.concat(e)
      })), this.__emit("lazyLoad", e)) : this.lazyLoadTimer && (clearInterval(this.lazyLoadTimer), delete this.lazyLoadTimer);
    },
    slideHandler(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      const {
        asNavFor: n,
        beforeChange: o,
        speed: r,
        afterChange: l
      } = this.$props, {
        state: a,
        nextState: i
      } = tW(m(m(m({
        index: e
      }, this.$props), this.$data), {
        trackRef: this.track,
        useCSS: this.useCSS && !t
      }));
      if (!a)
        return;
      o && o(this.currentSlide, a.currentSlide);
      const s = a.lazyLoadedList.filter((c) => this.lazyLoadedList.indexOf(c) < 0);
      this.$attrs.onLazyLoad && s.length > 0 && this.__emit("lazyLoad", s), !this.$props.waitForAnimate && this.animationEndCallback && (clearTimeout(this.animationEndCallback), l && l(this.currentSlide), delete this.animationEndCallback), this.setState(a, () => {
        n && this.asNavForIndex !== e && (this.asNavForIndex = e, n.innerSlider.slideHandler(e)), i && (this.animationEndCallback = setTimeout(() => {
          const {
            animating: c
          } = i, u = gW(i, ["animating"]);
          this.setState(u, () => {
            this.callbackTimers.push(setTimeout(() => this.setState({
              animating: c
            }), 10)), l && l(a.currentSlide), delete this.animationEndCallback;
          });
        }, r));
      });
    },
    changeSlide(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      const n = m(m({}, this.$props), this.$data), o = nW(n, e);
      if (!(o !== 0 && !o) && (t === !0 ? this.slideHandler(o, t) : this.slideHandler(o), this.$props.autoplay && this.handleAutoPlay("update"), this.$props.focusOnSelect)) {
        const r = this.list.querySelectorAll(".slick-current");
        r[0] && r[0].focus();
      }
    },
    clickHandler(e) {
      this.clickable === !1 && (e.stopPropagation(), e.preventDefault()), this.clickable = !0;
    },
    keyHandler(e) {
      const t = oW(e, this.accessibility, this.rtl);
      t !== "" && this.changeSlide({
        message: t
      });
    },
    selectHandler(e) {
      this.changeSlide(e);
    },
    disableBodyScroll() {
      const e = (t) => {
        t = t || window.event, t.preventDefault && t.preventDefault(), t.returnValue = !1;
      };
      window.ontouchmove = e;
    },
    enableBodyScroll() {
      window.ontouchmove = null;
    },
    swipeStart(e) {
      this.verticalSwiping && this.disableBodyScroll();
      const t = rW(e, this.swipe, this.draggable);
      t !== "" && this.setState(t);
    },
    swipeMove(e) {
      const t = lW(e, m(m(m({}, this.$props), this.$data), {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));
      t && (t.swiping && (this.clickable = !1), this.setState(t));
    },
    swipeEnd(e) {
      const t = aW(e, m(m(m({}, this.$props), this.$data), {
        trackRef: this.track,
        listRef: this.list,
        slideIndex: this.currentSlide
      }));
      if (!t)
        return;
      const n = t.triggerSlideHandler;
      delete t.triggerSlideHandler, this.setState(t), n !== void 0 && (this.slideHandler(n), this.$props.verticalSwiping && this.enableBodyScroll());
    },
    touchEnd(e) {
      this.swipeEnd(e), this.clickable = !0;
    },
    slickPrev() {
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "previous"
      }), 0));
    },
    slickNext() {
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "next"
      }), 0));
    },
    slickGoTo(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      if (e = Number(e), isNaN(e))
        return "";
      this.callbackTimers.push(setTimeout(() => this.changeSlide({
        message: "index",
        index: e,
        currentSlide: this.currentSlide
      }, t), 0));
    },
    play() {
      let e;
      if (this.rtl)
        e = this.currentSlide - this.slidesToScroll;
      else if (ip(m(m({}, this.$props), this.$data)))
        e = this.currentSlide + this.slidesToScroll;
      else
        return !1;
      this.slideHandler(e);
    },
    handleAutoPlay(e) {
      this.autoplayTimer && clearInterval(this.autoplayTimer);
      const t = this.autoplaying;
      if (e === "update") {
        if (t === "hovered" || t === "focused" || t === "paused")
          return;
      } else if (e === "leave") {
        if (t === "paused" || t === "focused")
          return;
      } else if (e === "blur" && (t === "paused" || t === "hovered"))
        return;
      this.autoplayTimer = setInterval(this.play, this.autoplaySpeed + 50), this.setState({
        autoplaying: "playing"
      });
    },
    pause(e) {
      this.autoplayTimer && (clearInterval(this.autoplayTimer), this.autoplayTimer = null);
      const t = this.autoplaying;
      e === "paused" ? this.setState({
        autoplaying: "paused"
      }) : e === "focused" ? (t === "hovered" || t === "playing") && this.setState({
        autoplaying: "focused"
      }) : t === "playing" && this.setState({
        autoplaying: "hovered"
      });
    },
    onDotsOver() {
      this.autoplay && this.pause("hovered");
    },
    onDotsLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
    },
    onTrackOver() {
      this.autoplay && this.pause("hovered");
    },
    onTrackLeave() {
      this.autoplay && this.autoplaying === "hovered" && this.handleAutoPlay("leave");
    },
    onSlideFocus() {
      this.autoplay && this.pause("focused");
    },
    onSlideBlur() {
      this.autoplay && this.autoplaying === "focused" && this.handleAutoPlay("blur");
    },
    customPaging(e) {
      let {
        i: t
      } = e;
      return f("button", null, [t + 1]);
    },
    appendDots(e) {
      let {
        dots: t
      } = e;
      return f("ul", {
        style: {
          display: "block"
        }
      }, [t]);
    }
  },
  render() {
    const e = ee("slick-slider", this.$attrs.class, {
      "slick-vertical": this.vertical,
      "slick-initialized": !0
    }), t = m(m({}, this.$props), this.$data);
    let n = $v(t, ["fade", "cssEase", "speed", "infinite", "centerMode", "focusOnSelect", "currentSlide", "lazyLoad", "lazyLoadedList", "rtl", "slideWidth", "slideHeight", "listHeight", "vertical", "slidesToShow", "slidesToScroll", "slideCount", "trackStyle", "variableWidth", "unslick", "centerPadding", "targetSlide", "useCSS"]);
    const {
      pauseOnHover: o
    } = this.$props;
    n = m(m({}, n), {
      focusOnSelect: this.focusOnSelect && this.clickable ? this.selectHandler : null,
      ref: this.trackRefHandler,
      onMouseleave: o ? this.onTrackLeave : go,
      onMouseover: o ? this.onTrackOver : go
    });
    let r;
    if (this.dots === !0 && this.slideCount >= this.slidesToShow) {
      let b = $v(t, ["dotsClass", "slideCount", "slidesToShow", "currentSlide", "slidesToScroll", "clickHandler", "children", "infinite", "appendDots"]);
      b.customPaging = this.customPaging, b.appendDots = this.appendDots;
      const {
        customPaging: y,
        appendDots: S
      } = this.$slots;
      y && (b.customPaging = y), S && (b.appendDots = S);
      const {
        pauseOnDotsHover: C
      } = this.$props;
      b = m(m({}, b), {
        clickHandler: this.changeSlide,
        onMouseover: C ? this.onDotsOver : go,
        onMouseleave: C ? this.onDotsLeave : go
      }), r = f(Q3, b, null);
    }
    let l, a;
    const i = $v(t, ["infinite", "centerMode", "currentSlide", "slideCount", "slidesToShow"]);
    i.clickHandler = this.changeSlide;
    const {
      prevArrow: s,
      nextArrow: c
    } = this.$slots;
    s && (i.prevArrow = s), c && (i.nextArrow = c), this.arrows && (l = f(tP, i, null), a = f(nP, i, null));
    let u = null;
    this.vertical && (u = {
      height: typeof this.listHeight == "number" ? `${this.listHeight}px` : this.listHeight
    });
    let d = null;
    this.vertical === !1 ? this.centerMode === !0 && (d = {
      padding: "0px " + this.centerPadding
    }) : this.centerMode === !0 && (d = {
      padding: this.centerPadding + " 0px"
    });
    const p = m(m({}, u), d), v = this.touchMove;
    let h = {
      ref: this.listRefHandler,
      class: "slick-list",
      style: p,
      onClick: this.clickHandler,
      onMousedown: v ? this.swipeStart : go,
      onMousemove: this.dragging && v ? this.swipeMove : go,
      onMouseup: v ? this.swipeEnd : go,
      onMouseleave: this.dragging && v ? this.swipeEnd : go,
      [on ? "onTouchstartPassive" : "onTouchstart"]: v ? this.swipeStart : go,
      [on ? "onTouchmovePassive" : "onTouchmove"]: this.dragging && v ? this.swipeMove : go,
      onTouchend: v ? this.touchEnd : go,
      onTouchcancel: this.dragging && v ? this.swipeEnd : go,
      onKeydown: this.accessibility ? this.keyHandler : go
    }, g = {
      class: e,
      dir: "ltr",
      style: this.$attrs.style
    };
    return this.unslick && (h = {
      class: "slick-list",
      ref: this.listRefHandler
    }, g = {
      class: e
    }), f("div", g, [this.unslick ? "" : l, f("div", h, [f(Z3, n, {
      default: () => [this.children]
    })]), this.unslick ? "" : a, this.unslick ? "" : r]);
  }
}, hW = Z({
  name: "Slider",
  mixins: [Ca],
  inheritAttrs: !1,
  props: m({}, G3),
  data() {
    return this._responsiveMediaHandlers = [], {
      breakpoint: null
    };
  },
  // handles responsive breakpoints
  mounted() {
    if (this.responsive) {
      const e = this.responsive.map((n) => n.breakpoint);
      e.sort((n, o) => n - o), e.forEach((n, o) => {
        let r;
        o === 0 ? r = Cv({
          minWidth: 0,
          maxWidth: n
        }) : r = Cv({
          minWidth: e[o - 1] + 1,
          maxWidth: n
        }), _C() && this.media(r, () => {
          this.setState({
            breakpoint: n
          });
        });
      });
      const t = Cv({
        minWidth: e.slice(-1)[0]
      });
      _C() && this.media(t, () => {
        this.setState({
          breakpoint: null
        });
      });
    }
  },
  beforeUnmount() {
    this._responsiveMediaHandlers.forEach(function(e) {
      e.mql.removeListener(e.listener);
    });
  },
  methods: {
    innerSliderRefHandler(e) {
      this.innerSlider = e;
    },
    media(e, t) {
      const n = window.matchMedia(e), o = (r) => {
        let {
          matches: l
        } = r;
        l && t();
      };
      n.addListener(o), o(n), this._responsiveMediaHandlers.push({
        mql: n,
        query: e,
        listener: o
      });
    },
    slickPrev() {
      var e;
      (e = this.innerSlider) === null || e === void 0 || e.slickPrev();
    },
    slickNext() {
      var e;
      (e = this.innerSlider) === null || e === void 0 || e.slickNext();
    },
    slickGoTo(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      var n;
      (n = this.innerSlider) === null || n === void 0 || n.slickGoTo(e, t);
    },
    slickPause() {
      var e;
      (e = this.innerSlider) === null || e === void 0 || e.pause("paused");
    },
    slickPlay() {
      var e;
      (e = this.innerSlider) === null || e === void 0 || e.handleAutoPlay("play");
    }
  },
  render() {
    var e;
    let t, n;
    this.breakpoint ? (n = this.responsive.filter((i) => i.breakpoint === this.breakpoint), t = n[0].settings === "unslick" ? "unslick" : m(m({}, this.$props), n[0].settings)) : t = m({}, this.$props), t.centerMode && (t.slidesToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn(`slidesToScroll should be equal to 1 in centerMode, you are using ${t.slidesToScroll}`), t.slidesToScroll = 1), t.fade && (t.slidesToShow > 1 && process.env.NODE_ENV !== "production" && console.warn(`slidesToShow should be equal to 1 when fade is true, you're using ${t.slidesToShow}`), t.slidesToScroll > 1 && process.env.NODE_ENV !== "production" && console.warn(`slidesToScroll should be equal to 1 when fade is true, you're using ${t.slidesToScroll}`), t.slidesToShow = 1, t.slidesToScroll = 1);
    let o = hf(this) || [];
    o = o.filter((i) => typeof i == "string" ? !!i.trim() : !!i), t.variableWidth && (t.rows > 1 || t.slidesPerRow > 1) && (console.warn("variableWidth is not supported in case of rows > 1 or slidesPerRow > 1"), t.variableWidth = !1);
    const r = [];
    let l = null;
    for (let i = 0; i < o.length; i += t.rows * t.slidesPerRow) {
      const s = [];
      for (let c = i; c < i + t.rows * t.slidesPerRow; c += t.slidesPerRow) {
        const u = [];
        for (let d = c; d < c + t.slidesPerRow && (t.variableWidth && (!((e = o[d].props) === null || e === void 0) && e.style) && (l = o[d].props.style.width), !(d >= o.length)); d += 1)
          u.push(yt(o[d], {
            key: 100 * i + 10 * c + d,
            tabindex: -1,
            style: {
              width: `${100 / t.slidesPerRow}%`,
              display: "inline-block"
            }
          }));
        s.push(f("div", {
          key: 10 * i + c
        }, [u]));
      }
      t.variableWidth ? r.push(f("div", {
        key: i,
        style: {
          width: l
        }
      }, [s])) : r.push(f("div", {
        key: i
      }, [s]));
    }
    if (t === "unslick") {
      const i = "regular slider " + (this.className || "");
      return f("div", {
        class: i
      }, [o]);
    } else
      r.length <= t.slidesToShow && (t.unslick = !0);
    const a = m(m(m({}, this.$attrs), t), {
      children: r,
      ref: this.innerSliderRefHandler
    });
    return f(mW, D(D({}, a), {}, {
      __propsSymbol__: []
    }), this.$slots);
  }
}), bW = (e) => {
  const {
    componentCls: t,
    antCls: n,
    carouselArrowSize: o,
    carouselDotOffset: r,
    marginXXS: l
  } = e, a = -o * 1.25, i = l;
  return {
    [t]: m(m({}, qe(e)), {
      ".slick-slider": {
        position: "relative",
        display: "block",
        boxSizing: "border-box",
        touchAction: "pan-y",
        WebkitTouchCallout: "none",
        WebkitTapHighlightColor: "transparent",
        ".slick-track, .slick-list": {
          transform: "translate3d(0, 0, 0)",
          touchAction: "pan-y"
        }
      },
      ".slick-list": {
        position: "relative",
        display: "block",
        margin: 0,
        padding: 0,
        overflow: "hidden",
        "&:focus": {
          outline: "none"
        },
        "&.dragging": {
          cursor: "pointer"
        },
        ".slick-slide": {
          pointerEvents: "none",
          // https://github.com/ant-design/ant-design/issues/23294
          [`input${n}-radio-input, input${n}-checkbox-input`]: {
            visibility: "hidden"
          },
          "&.slick-active": {
            pointerEvents: "auto",
            [`input${n}-radio-input, input${n}-checkbox-input`]: {
              visibility: "visible"
            }
          },
          // fix Carousel content height not match parent node
          // when children is empty node
          // https://github.com/ant-design/ant-design/issues/25878
          "> div > div": {
            verticalAlign: "bottom"
          }
        }
      },
      ".slick-track": {
        position: "relative",
        top: 0,
        insetInlineStart: 0,
        display: "block",
        "&::before, &::after": {
          display: "table",
          content: '""'
        },
        "&::after": {
          clear: "both"
        }
      },
      ".slick-slide": {
        display: "none",
        float: "left",
        height: "100%",
        minHeight: 1,
        img: {
          display: "block"
        },
        "&.dragging img": {
          pointerEvents: "none"
        }
      },
      ".slick-initialized .slick-slide": {
        display: "block"
      },
      ".slick-vertical .slick-slide": {
        display: "block",
        height: "auto"
      },
      ".slick-arrow.slick-hidden": {
        display: "none"
      },
      // Arrows
      ".slick-prev, .slick-next": {
        position: "absolute",
        top: "50%",
        display: "block",
        width: o,
        height: o,
        marginTop: -o / 2,
        padding: 0,
        color: "transparent",
        fontSize: 0,
        lineHeight: 0,
        background: "transparent",
        border: 0,
        outline: "none",
        cursor: "pointer",
        "&:hover, &:focus": {
          color: "transparent",
          background: "transparent",
          outline: "none",
          "&::before": {
            opacity: 1
          }
        },
        "&.slick-disabled::before": {
          opacity: 0.25
        }
      },
      ".slick-prev": {
        insetInlineStart: a,
        "&::before": {
          content: '"←"'
        }
      },
      ".slick-next": {
        insetInlineEnd: a,
        "&::before": {
          content: '"→"'
        }
      },
      // Dots
      ".slick-dots": {
        position: "absolute",
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: 15,
        display: "flex !important",
        justifyContent: "center",
        paddingInlineStart: 0,
        listStyle: "none",
        "&-bottom": {
          bottom: r
        },
        "&-top": {
          top: r,
          bottom: "auto"
        },
        li: {
          position: "relative",
          display: "inline-block",
          flex: "0 1 auto",
          boxSizing: "content-box",
          width: e.dotWidth,
          height: e.dotHeight,
          marginInline: i,
          padding: 0,
          textAlign: "center",
          textIndent: -999,
          verticalAlign: "top",
          transition: `all ${e.motionDurationSlow}`,
          button: {
            position: "relative",
            display: "block",
            width: "100%",
            height: e.dotHeight,
            padding: 0,
            color: "transparent",
            fontSize: 0,
            background: e.colorBgContainer,
            border: 0,
            borderRadius: 1,
            outline: "none",
            cursor: "pointer",
            opacity: 0.3,
            transition: `all ${e.motionDurationSlow}`,
            "&: hover, &:focus": {
              opacity: 0.75
            },
            "&::after": {
              position: "absolute",
              inset: -i,
              content: '""'
            }
          },
          "&.slick-active": {
            width: e.dotWidthActive,
            "& button": {
              background: e.colorBgContainer,
              opacity: 1
            },
            "&: hover, &:focus": {
              opacity: 1
            }
          }
        }
      }
    })
  };
}, yW = (e) => {
  const {
    componentCls: t,
    carouselDotOffset: n,
    marginXXS: o
  } = e, r = {
    width: e.dotHeight,
    height: e.dotWidth
  };
  return {
    [`${t}-vertical`]: {
      ".slick-dots": {
        top: "50%",
        bottom: "auto",
        flexDirection: "column",
        width: e.dotHeight,
        height: "auto",
        margin: 0,
        transform: "translateY(-50%)",
        "&-left": {
          insetInlineEnd: "auto",
          insetInlineStart: n
        },
        "&-right": {
          insetInlineEnd: n,
          insetInlineStart: "auto"
        },
        li: m(m({}, r), {
          margin: `${o}px 0`,
          verticalAlign: "baseline",
          button: r,
          "&.slick-active": m(m({}, r), {
            button: r
          })
        })
      }
    }
  };
}, SW = (e) => {
  const {
    componentCls: t
  } = e;
  return [{
    [`${t}-rtl`]: {
      direction: "rtl",
      // Dots
      ".slick-dots": {
        [`${t}-rtl&`]: {
          flexDirection: "row-reverse"
        }
      }
    }
  }, {
    [`${t}-vertical`]: {
      ".slick-dots": {
        [`${t}-rtl&`]: {
          flexDirection: "column"
        }
      }
    }
  }];
}, CW = Xe("Carousel", (e) => {
  const {
    controlHeightLG: t,
    controlHeightSM: n
  } = e, o = He(e, {
    carouselArrowSize: t / 2,
    carouselDotOffset: n / 2
  });
  return [bW(o), yW(o), SW(o)];
}, {
  dotWidth: 16,
  dotHeight: 3,
  dotWidthActive: 24
});
var $W = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const wW = () => ({
  effect: ke(),
  dots: ve(!0),
  vertical: ve(),
  autoplay: ve(),
  easing: String,
  beforeChange: le(),
  afterChange: le(),
  // style: PropTypes.React.CSSProperties,
  prefixCls: String,
  accessibility: ve(),
  nextArrow: V.any,
  prevArrow: V.any,
  pauseOnHover: ve(),
  // className: String,
  adaptiveHeight: ve(),
  arrows: ve(!1),
  autoplaySpeed: Number,
  centerMode: ve(),
  centerPadding: String,
  cssEase: String,
  dotsClass: String,
  draggable: ve(!1),
  fade: ve(),
  focusOnSelect: ve(),
  infinite: ve(),
  initialSlide: Number,
  lazyLoad: ke(),
  rtl: ve(),
  slide: String,
  slidesToShow: Number,
  slidesToScroll: Number,
  speed: Number,
  swipe: ve(),
  swipeToSlide: ve(),
  swipeEvent: le(),
  touchMove: ve(),
  touchThreshold: Number,
  variableWidth: ve(),
  useCSS: ve(),
  slickGoTo: Number,
  responsive: Array,
  dotPosition: ke(),
  verticalSwiping: ve(!1)
}), xW = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACarousel",
  inheritAttrs: !1,
  props: wW(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const l = Y();
    r({
      goTo: function(h) {
        let g = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
        var b;
        (b = l.value) === null || b === void 0 || b.slickGoTo(h, g);
      },
      autoplay: (h) => {
        var g, b;
        (b = (g = l.value) === null || g === void 0 ? void 0 : g.innerSlider) === null || b === void 0 || b.handleAutoPlay(h);
      },
      prev: () => {
        var h;
        (h = l.value) === null || h === void 0 || h.slickPrev();
      },
      next: () => {
        var h;
        (h = l.value) === null || h === void 0 || h.slickNext();
      },
      innerSlider: P(() => {
        var h;
        return (h = l.value) === null || h === void 0 ? void 0 : h.innerSlider;
      })
    }), Le(() => {
      Mt(e.vertical === void 0, "Carousel", "`vertical` is deprecated, please use `dotPosition` instead.");
    });
    const {
      prefixCls: i,
      direction: s
    } = Ie("carousel", e), [c, u] = CW(i), d = P(() => e.dotPosition ? e.dotPosition : e.vertical !== void 0 && e.vertical ? "right" : "bottom"), p = P(() => d.value === "left" || d.value === "right"), v = P(() => {
      const h = "slick-dots";
      return ee({
        [h]: !0,
        [`${h}-${d.value}`]: !0,
        [`${e.dotsClass}`]: !!e.dotsClass
      });
    });
    return () => {
      const {
        dots: h,
        arrows: g,
        draggable: b,
        effect: y
      } = e, {
        class: S,
        style: C
      } = o, w = $W(o, ["class", "style"]), $ = y === "fade" ? !0 : e.fade, O = ee(i.value, {
        [`${i.value}-rtl`]: s.value === "rtl",
        [`${i.value}-vertical`]: p.value,
        [`${S}`]: !!S
      }, u.value);
      return c(f("div", {
        class: O,
        style: C
      }, [f(hW, D(D(D({
        ref: l
      }, e), w), {}, {
        dots: !!h,
        dotsClass: v.value,
        arrows: g,
        draggable: b,
        fade: $,
        vertical: p.value
      }), n)]));
    };
  }
}), OW = kt(xW), eb = "__RC_CASCADER_SPLIT__", oP = "SHOW_PARENT", rP = "SHOW_CHILD";
function ml(e) {
  return e.join(eb);
}
function Ya(e) {
  return e.map(ml);
}
function PW(e) {
  return e.split(eb);
}
function IW(e) {
  const {
    label: t,
    value: n,
    children: o
  } = e || {}, r = n || "value";
  return {
    label: t || "label",
    value: r,
    key: r,
    children: o || "children"
  };
}
function os(e, t) {
  var n, o;
  return (n = e.isLeaf) !== null && n !== void 0 ? n : !(!((o = e[t.children]) === null || o === void 0) && o.length);
}
function EW(e) {
  const t = e.parentElement;
  if (!t)
    return;
  const n = e.offsetTop - t.offsetTop;
  n - t.scrollTop < 0 ? t.scrollTo({
    top: n
  }) : n + e.offsetHeight - t.scrollTop > t.offsetHeight && t.scrollTo({
    top: n + e.offsetHeight - t.offsetHeight
  });
}
const lP = Symbol("TreeContextKey"), TW = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TreeContext",
  props: {
    value: {
      type: Object
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    return Je(lP, P(() => e.value)), () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), tb = () => tt(lP, P(() => ({}))), aP = Symbol("KeysStateKey"), MW = (e) => {
  Je(aP, e);
}, iP = () => tt(aP, {
  expandedKeys: Q([]),
  selectedKeys: Q([]),
  loadedKeys: Q([]),
  loadingKeys: Q([]),
  checkedKeys: Q([]),
  halfCheckedKeys: Q([]),
  expandedKeysSet: P(() => /* @__PURE__ */ new Set()),
  selectedKeysSet: P(() => /* @__PURE__ */ new Set()),
  loadedKeysSet: P(() => /* @__PURE__ */ new Set()),
  loadingKeysSet: P(() => /* @__PURE__ */ new Set()),
  checkedKeysSet: P(() => /* @__PURE__ */ new Set()),
  halfCheckedKeysSet: P(() => /* @__PURE__ */ new Set()),
  flattenNodes: Q([])
}), _W = (e) => {
  let {
    prefixCls: t,
    level: n,
    isStart: o,
    isEnd: r
  } = e;
  const l = `${t}-indent-unit`, a = [];
  for (let i = 0; i < n; i += 1)
    a.push(f("span", {
      key: i,
      class: {
        [l]: !0,
        [`${l}-start`]: o[i],
        [`${l}-end`]: r[i]
      }
    }, null));
  return f("span", {
    "aria-hidden": "true",
    class: `${t}-indent`
  }, [a]);
}, sP = {
  eventKey: [String, Number],
  prefixCls: String,
  // By parent
  // expanded: { type: Boolean, default: undefined },
  // selected: { type: Boolean, default: undefined },
  // checked: { type: Boolean, default: undefined },
  // loaded: { type: Boolean, default: undefined },
  // loading: { type: Boolean, default: undefined },
  // halfChecked: { type: Boolean, default: undefined },
  // dragOver: { type: Boolean, default: undefined },
  // dragOverGapTop: { type: Boolean, default: undefined },
  // dragOverGapBottom: { type: Boolean, default: undefined },
  // pos: String,
  title: V.any,
  /** New added in Tree for easy data access */
  data: {
    type: Object,
    default: void 0
  },
  parent: {
    type: Object,
    default: void 0
  },
  isStart: {
    type: Array
  },
  isEnd: {
    type: Array
  },
  active: {
    type: Boolean,
    default: void 0
  },
  onMousemove: {
    type: Function
  },
  // By user
  isLeaf: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  selectable: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  disableCheckbox: {
    type: Boolean,
    default: void 0
  },
  icon: V.any,
  switcherIcon: V.any,
  domRef: {
    type: Function
  }
}, AW = {
  prefixCls: {
    type: String
  },
  // data: { type: Array as PropType<FlattenNode[]> },
  motion: {
    type: Object
  },
  focusable: {
    type: Boolean
  },
  activeItem: {
    type: Object
  },
  focused: {
    type: Boolean
  },
  tabindex: {
    type: Number
  },
  checkable: {
    type: Boolean
  },
  selectable: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  // expandedKeys: { type: Array as PropType<Key[]> },
  // selectedKeys: { type: Array as PropType<Key[]> },
  // checkedKeys: { type: Array as PropType<Key[]> },
  // loadedKeys: { type: Array as PropType<Key[]> },
  // loadingKeys: { type: Array as PropType<Key[]> },
  // halfCheckedKeys: { type: Array as PropType<Key[]> },
  // keyEntities: { type: Object as PropType<Record<Key, DataEntity<DataNode>>> },
  // dragging: { type: Boolean as PropType<boolean> },
  // dragOverNodeKey: { type: [String, Number] as PropType<Key> },
  // dropPosition: { type: Number as PropType<number> },
  // Virtual list
  height: {
    type: Number
  },
  itemHeight: {
    type: Number
  },
  virtual: {
    type: Boolean
  },
  onScroll: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onActiveChange: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onListChangeStart: {
    type: Function
  },
  onListChangeEnd: {
    type: Function
  }
}, cP = () => ({
  prefixCls: String,
  focusable: {
    type: Boolean,
    default: void 0
  },
  activeKey: [Number, String],
  tabindex: Number,
  children: V.any,
  treeData: {
    type: Array
  },
  fieldNames: {
    type: Object
  },
  showLine: {
    type: [Boolean, Object],
    default: void 0
  },
  showIcon: {
    type: Boolean,
    default: void 0
  },
  icon: V.any,
  selectable: {
    type: Boolean,
    default: void 0
  },
  expandAction: [String, Boolean],
  disabled: {
    type: Boolean,
    default: void 0
  },
  multiple: {
    type: Boolean,
    default: void 0
  },
  checkable: {
    type: Boolean,
    default: void 0
  },
  checkStrictly: {
    type: Boolean,
    default: void 0
  },
  draggable: {
    type: [Function, Boolean]
  },
  defaultExpandParent: {
    type: Boolean,
    default: void 0
  },
  autoExpandParent: {
    type: Boolean,
    default: void 0
  },
  defaultExpandAll: {
    type: Boolean,
    default: void 0
  },
  defaultExpandedKeys: {
    type: Array
  },
  expandedKeys: {
    type: Array
  },
  defaultCheckedKeys: {
    type: Array
  },
  checkedKeys: {
    type: [Object, Array]
  },
  defaultSelectedKeys: {
    type: Array
  },
  selectedKeys: {
    type: Array
  },
  allowDrop: {
    type: Function
  },
  dropIndicatorRender: {
    type: Function
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onContextmenu: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onDblclick: {
    type: Function
  },
  onScroll: {
    type: Function
  },
  onExpand: {
    type: Function
  },
  onCheck: {
    type: Function
  },
  onSelect: {
    type: Function
  },
  onLoad: {
    type: Function
  },
  loadData: {
    type: Function
  },
  loadedKeys: {
    type: Array
  },
  onMouseenter: {
    type: Function
  },
  onMouseleave: {
    type: Function
  },
  onRightClick: {
    type: Function
  },
  onDragstart: {
    type: Function
  },
  onDragenter: {
    type: Function
  },
  onDragover: {
    type: Function
  },
  onDragleave: {
    type: Function
  },
  onDragend: {
    type: Function
  },
  onDrop: {
    type: Function
  },
  /**
   * Used for `rc-tree-select` only.
   * Do not use in your production code directly since this will be refactor.
   */
  onActiveChange: {
    type: Function
  },
  filterTreeNode: {
    type: Function
  },
  motion: V.any,
  switcherIcon: V.any,
  // Virtual List
  height: Number,
  itemHeight: Number,
  virtual: {
    type: Boolean,
    default: void 0
  },
  // direction for drag logic
  direction: {
    type: String
  },
  rootClassName: String,
  rootStyle: Object
});
var DW = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const AC = "open", DC = "close", NW = "---", cm = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATreeNode",
  inheritAttrs: !1,
  props: sP,
  isTreeNode: 1,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r
    } = t;
    ct(!("slots" in e.data), `treeData slots is deprecated, please use ${Object.keys(e.data.slots || {}).map((ae) => "`v-slot:" + ae + "` ")}instead`);
    const l = Q(!1), a = tb(), {
      expandedKeysSet: i,
      selectedKeysSet: s,
      loadedKeysSet: c,
      loadingKeysSet: u,
      checkedKeysSet: d,
      halfCheckedKeysSet: p
    } = iP(), {
      dragOverNodeKey: v,
      dropPosition: h,
      keyEntities: g
    } = a.value, b = P(() => xu(e.eventKey, {
      expandedKeysSet: i.value,
      selectedKeysSet: s.value,
      loadedKeysSet: c.value,
      loadingKeysSet: u.value,
      checkedKeysSet: d.value,
      halfCheckedKeysSet: p.value,
      dragOverNodeKey: v,
      dropPosition: h,
      keyEntities: g
    })), y = So(() => b.value.expanded), S = So(() => b.value.selected), C = So(() => b.value.checked), w = So(() => b.value.loaded), $ = So(() => b.value.loading), O = So(() => b.value.halfChecked), x = So(() => b.value.dragOver), I = So(() => b.value.dragOverGapTop), E = So(() => b.value.dragOverGapBottom), _ = So(() => b.value.pos), M = Q(), R = P(() => {
      const {
        eventKey: ae
      } = e, {
        keyEntities: oe
      } = a.value, {
        children: pe
      } = oe[ae] || {};
      return !!(pe || []).length;
    }), A = P(() => {
      const {
        isLeaf: ae
      } = e, {
        loadData: oe
      } = a.value, pe = R.value;
      return ae === !1 ? !1 : ae || !oe && !pe || oe && w.value && !pe;
    }), z = P(() => A.value ? null : y.value ? AC : DC), T = P(() => {
      const {
        disabled: ae
      } = e, {
        disabled: oe
      } = a.value;
      return !!(oe || ae);
    }), N = P(() => {
      const {
        checkable: ae
      } = e, {
        checkable: oe
      } = a.value;
      return !oe || ae === !1 ? !1 : oe;
    }), k = P(() => {
      const {
        selectable: ae
      } = e, {
        selectable: oe
      } = a.value;
      return typeof ae == "boolean" ? ae : oe;
    }), B = P(() => {
      const {
        data: ae,
        active: oe,
        checkable: pe,
        disableCheckbox: Pe,
        disabled: Ee,
        selectable: ze
      } = e;
      return m(m({
        active: oe,
        checkable: pe,
        disableCheckbox: Pe,
        disabled: Ee,
        selectable: ze
      }, ae), {
        dataRef: ae,
        data: ae,
        isLeaf: A.value,
        checked: C.value,
        expanded: y.value,
        loading: $.value,
        selected: S.value,
        halfChecked: O.value
      });
    }), F = Wn(), L = P(() => {
      const {
        eventKey: ae
      } = e, {
        keyEntities: oe
      } = a.value, {
        parent: pe
      } = oe[ae] || {};
      return m(m({}, Ou(m({}, e, b.value))), {
        parent: pe
      });
    }), j = xt({
      eventData: L,
      eventKey: P(() => e.eventKey),
      selectHandle: M,
      pos: _,
      key: F.vnode.key
    });
    r(j);
    const H = (ae) => {
      const {
        onNodeDoubleClick: oe
      } = a.value;
      oe(ae, L.value);
    }, K = (ae) => {
      if (T.value)
        return;
      const {
        onNodeSelect: oe
      } = a.value;
      ae.preventDefault(), oe(ae, L.value);
    }, X = (ae) => {
      if (T.value)
        return;
      const {
        disableCheckbox: oe
      } = e, {
        onNodeCheck: pe
      } = a.value;
      if (!N.value || oe)
        return;
      ae.preventDefault();
      const Pe = !C.value;
      pe(ae, L.value, Pe);
    }, W = (ae) => {
      const {
        onNodeClick: oe
      } = a.value;
      oe(ae, L.value), k.value ? K(ae) : X(ae);
    }, q = (ae) => {
      const {
        onNodeMouseEnter: oe
      } = a.value;
      oe(ae, L.value);
    }, J = (ae) => {
      const {
        onNodeMouseLeave: oe
      } = a.value;
      oe(ae, L.value);
    }, ne = (ae) => {
      const {
        onNodeContextMenu: oe
      } = a.value;
      oe(ae, L.value);
    }, te = (ae) => {
      const {
        onNodeDragStart: oe
      } = a.value;
      ae.stopPropagation(), l.value = !0, oe(ae, j);
      try {
        ae.dataTransfer.setData("text/plain", "");
      } catch {
      }
    }, G = (ae) => {
      const {
        onNodeDragEnter: oe
      } = a.value;
      ae.preventDefault(), ae.stopPropagation(), oe(ae, j);
    }, U = (ae) => {
      const {
        onNodeDragOver: oe
      } = a.value;
      ae.preventDefault(), ae.stopPropagation(), oe(ae, j);
    }, re = (ae) => {
      const {
        onNodeDragLeave: oe
      } = a.value;
      ae.stopPropagation(), oe(ae, j);
    }, se = (ae) => {
      const {
        onNodeDragEnd: oe
      } = a.value;
      ae.stopPropagation(), l.value = !1, oe(ae, j);
    }, me = (ae) => {
      const {
        onNodeDrop: oe
      } = a.value;
      ae.preventDefault(), ae.stopPropagation(), l.value = !1, oe(ae, j);
    }, Ce = (ae) => {
      const {
        onNodeExpand: oe
      } = a.value;
      $.value || oe(ae, L.value);
    }, fe = () => {
      const {
        data: ae
      } = e, {
        draggable: oe
      } = a.value;
      return !!(oe && (!oe.nodeDraggable || oe.nodeDraggable(ae)));
    }, be = () => {
      const {
        draggable: ae,
        prefixCls: oe
      } = a.value;
      return ae && (ae != null && ae.icon) ? f("span", {
        class: `${oe}-draggable-icon`
      }, [ae.icon]) : null;
    }, ue = () => {
      var ae, oe, pe;
      const {
        switcherIcon: Pe = o.switcherIcon || ((ae = a.value.slots) === null || ae === void 0 ? void 0 : ae[(pe = (oe = e.data) === null || oe === void 0 ? void 0 : oe.slots) === null || pe === void 0 ? void 0 : pe.switcherIcon])
      } = e, {
        switcherIcon: Ee
      } = a.value, ze = Pe || Ee;
      return typeof ze == "function" ? ze(B.value) : ze;
    }, de = () => {
      const {
        loadData: ae,
        onNodeLoad: oe
      } = a.value;
      $.value || ae && y.value && !A.value && !R.value && !w.value && oe(L.value);
    };
    Ke(() => {
      de();
    }), co(() => {
      de();
    });
    const Se = () => {
      const {
        prefixCls: ae
      } = a.value, oe = ue();
      if (A.value)
        return oe !== !1 ? f("span", {
          class: ee(`${ae}-switcher`, `${ae}-switcher-noop`)
        }, [oe]) : null;
      const pe = ee(`${ae}-switcher`, `${ae}-switcher_${y.value ? AC : DC}`);
      return oe !== !1 ? f("span", {
        onClick: Ce,
        class: pe
      }, [oe]) : null;
    }, xe = () => {
      var ae, oe;
      const {
        disableCheckbox: pe
      } = e, {
        prefixCls: Pe
      } = a.value, Ee = T.value;
      return N.value ? f("span", {
        class: ee(`${Pe}-checkbox`, C.value && `${Pe}-checkbox-checked`, !C.value && O.value && `${Pe}-checkbox-indeterminate`, (Ee || pe) && `${Pe}-checkbox-disabled`),
        onClick: X
      }, [(oe = (ae = a.value).customCheckable) === null || oe === void 0 ? void 0 : oe.call(ae)]) : null;
    }, he = () => {
      const {
        prefixCls: ae
      } = a.value;
      return f("span", {
        class: ee(`${ae}-iconEle`, `${ae}-icon__${z.value || "docu"}`, $.value && `${ae}-icon_loading`)
      }, null);
    }, we = () => {
      const {
        disabled: ae,
        eventKey: oe
      } = e, {
        draggable: pe,
        dropLevelOffset: Pe,
        dropPosition: Ee,
        prefixCls: ze,
        indent: ge,
        dropIndicatorRender: ye,
        dragOverNodeKey: $e,
        direction: Ae
      } = a.value;
      return !ae && pe !== !1 && $e === oe ? ye({
        dropPosition: Ee,
        dropLevelOffset: Pe,
        indent: ge,
        prefixCls: ze,
        direction: Ae
      }) : null;
    }, Me = () => {
      var ae, oe, pe, Pe, Ee, ze;
      const {
        // title = slots.title ||
        //   context.value.slots?.[props.data?.slots?.title] ||
        //   context.value.slots?.title,
        // selected,
        icon: ge = o.icon,
        // loading,
        data: ye
      } = e, $e = o.title || ((ae = a.value.slots) === null || ae === void 0 ? void 0 : ae[(pe = (oe = e.data) === null || oe === void 0 ? void 0 : oe.slots) === null || pe === void 0 ? void 0 : pe.title]) || ((Pe = a.value.slots) === null || Pe === void 0 ? void 0 : Pe.title) || e.title, {
        prefixCls: Ae,
        showIcon: Ve,
        icon: De,
        loadData: We
        // slots: contextSlots,
      } = a.value, at = T.value, gt = `${Ae}-node-content-wrapper`;
      let ut;
      if (Ve) {
        const Xt = ge || ((Ee = a.value.slots) === null || Ee === void 0 ? void 0 : Ee[(ze = ye == null ? void 0 : ye.slots) === null || ze === void 0 ? void 0 : ze.icon]) || De;
        ut = Xt ? f("span", {
          class: ee(`${Ae}-iconEle`, `${Ae}-icon__customize`)
        }, [typeof Xt == "function" ? Xt(B.value) : Xt]) : he();
      } else
        We && $.value && (ut = he());
      let St;
      typeof $e == "function" ? St = $e(B.value) : St = $e, St = St === void 0 ? NW : St;
      const wt = f("span", {
        class: `${Ae}-title`
      }, [St]);
      return f("span", {
        ref: M,
        title: typeof $e == "string" ? $e : "",
        class: ee(`${gt}`, `${gt}-${z.value || "normal"}`, !at && (S.value || l.value) && `${Ae}-node-selected`),
        onMouseenter: q,
        onMouseleave: J,
        onContextmenu: ne,
        onClick: W,
        onDblclick: H
      }, [ut, wt, we()]);
    };
    return () => {
      const ae = m(m({}, e), n), {
        eventKey: oe,
        isLeaf: pe,
        isStart: Pe,
        isEnd: Ee,
        domRef: ze,
        active: ge,
        data: ye,
        onMousemove: $e,
        selectable: Ae
      } = ae, Ve = DW(ae, ["eventKey", "isLeaf", "isStart", "isEnd", "domRef", "active", "data", "onMousemove", "selectable"]), {
        prefixCls: De,
        filterTreeNode: We,
        keyEntities: at,
        dropContainerKey: gt,
        dropTargetKey: ut,
        draggingNodeKey: St
      } = a.value, wt = T.value, Xt = wl(Ve, {
        aria: !0,
        data: !0
      }), {
        level: qt
      } = at[oe] || {}, gn = Ee[Ee.length - 1], Zt = fe(), An = !wt && Zt, Jn = St === oe, Io = Ae !== void 0 ? {
        "aria-selected": !!Ae
      } : void 0;
      return f("div", D(D({
        ref: ze,
        class: ee(n.class, `${De}-treenode`, {
          [`${De}-treenode-disabled`]: wt,
          [`${De}-treenode-switcher-${y.value ? "open" : "close"}`]: !pe,
          [`${De}-treenode-checkbox-checked`]: C.value,
          [`${De}-treenode-checkbox-indeterminate`]: O.value,
          [`${De}-treenode-selected`]: S.value,
          [`${De}-treenode-loading`]: $.value,
          [`${De}-treenode-active`]: ge,
          [`${De}-treenode-leaf-last`]: gn,
          [`${De}-treenode-draggable`]: An,
          dragging: Jn,
          "drop-target": ut === oe,
          "drop-container": gt === oe,
          "drag-over": !wt && x.value,
          "drag-over-gap-top": !wt && I.value,
          "drag-over-gap-bottom": !wt && E.value,
          "filter-node": We && We(L.value)
        }),
        style: n.style,
        draggable: An,
        "aria-grabbed": Jn,
        onDragstart: An ? te : void 0,
        onDragenter: Zt ? G : void 0,
        onDragover: Zt ? U : void 0,
        onDragleave: Zt ? re : void 0,
        onDrop: Zt ? me : void 0,
        onDragend: Zt ? se : void 0,
        onMousemove: $e
      }, Io), Xt), [f(_W, {
        prefixCls: De,
        level: qt,
        isStart: Pe,
        isEnd: Ee
      }, null), be(), Se(), xe(), Me()]);
    };
  }
});
function dr(e, t) {
  if (!e)
    return [];
  const n = e.slice(), o = n.indexOf(t);
  return o >= 0 && n.splice(o, 1), n;
}
function _r(e, t) {
  const n = (e || []).slice();
  return n.indexOf(t) === -1 && n.push(t), n;
}
function nb(e) {
  return e.split("-");
}
function uP(e, t) {
  return `${e}-${t}`;
}
function RW(e) {
  return e && e.type && e.type.isTreeNode;
}
function kW(e, t) {
  const n = [], o = t[e];
  function r() {
    (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : []).forEach((a) => {
      let {
        key: i,
        children: s
      } = a;
      n.push(i), r(s);
    });
  }
  return r(o.children), n;
}
function BW(e) {
  if (e.parent) {
    const t = nb(e.pos);
    return Number(t[t.length - 1]) === e.parent.children.length - 1;
  }
  return !1;
}
function FW(e) {
  const t = nb(e.pos);
  return Number(t[t.length - 1]) === 0;
}
function NC(e, t, n, o, r, l, a, i, s, c) {
  var u;
  const {
    clientX: d,
    clientY: p
  } = e, {
    top: v,
    height: h
  } = e.target.getBoundingClientRect(), b = ((c === "rtl" ? -1 : 1) * (((r == null ? void 0 : r.x) || 0) - d) - 12) / o;
  let y = i[n.eventKey];
  if (p < v + h / 2) {
    const _ = a.findIndex((A) => A.key === y.key), M = _ <= 0 ? 0 : _ - 1, R = a[M].key;
    y = i[R];
  }
  const S = y.key, C = y, w = y.key;
  let $ = 0, O = 0;
  if (!s.has(S))
    for (let _ = 0; _ < b && BW(y); _ += 1)
      y = y.parent, O += 1;
  const x = t.eventData, I = y.node;
  let E = !0;
  return FW(y) && y.level === 0 && p < v + h / 2 && l({
    dragNode: x,
    dropNode: I,
    dropPosition: -1
  }) && y.key === n.eventKey ? $ = -1 : (C.children || []).length && s.has(w) ? l({
    dragNode: x,
    dropNode: I,
    dropPosition: 0
  }) ? $ = 0 : E = !1 : O === 0 ? b > -1.5 ? l({
    dragNode: x,
    dropNode: I,
    dropPosition: 1
  }) ? $ = 1 : E = !1 : l({
    dragNode: x,
    dropNode: I,
    dropPosition: 0
  }) ? $ = 0 : l({
    dragNode: x,
    dropNode: I,
    dropPosition: 1
  }) ? $ = 1 : E = !1 : l({
    dragNode: x,
    dropNode: I,
    dropPosition: 1
  }) ? $ = 1 : E = !1, {
    dropPosition: $,
    dropLevelOffset: O,
    dropTargetKey: y.key,
    dropTargetPos: y.pos,
    dragOverNodeKey: w,
    dropContainerKey: $ === 0 ? null : ((u = y.parent) === null || u === void 0 ? void 0 : u.key) || null,
    dropAllowed: E
  };
}
function RC(e, t) {
  if (!e)
    return;
  const {
    multiple: n
  } = t;
  return n ? e.slice() : e.length ? [e[0]] : e;
}
function Ov(e) {
  if (!e)
    return null;
  let t;
  if (Array.isArray(e))
    t = {
      checkedKeys: e,
      halfCheckedKeys: void 0
    };
  else if (typeof e == "object")
    t = {
      checkedKeys: e.checked || void 0,
      halfCheckedKeys: e.halfChecked || void 0
    };
  else
    return ct(!1, "`checkedKeys` is not an array or an object"), null;
  return t;
}
function um(e, t) {
  const n = /* @__PURE__ */ new Set();
  function o(r) {
    if (n.has(r))
      return;
    const l = t[r];
    if (!l)
      return;
    n.add(r);
    const {
      parent: a,
      node: i
    } = l;
    i.disabled || a && o(a.key);
  }
  return (e || []).forEach((r) => {
    o(r);
  }), [...n];
}
var LW = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function hc(e, t) {
  return e ?? t;
}
function sp(e) {
  const {
    title: t,
    _title: n,
    key: o,
    children: r
  } = e || {}, l = t || "title";
  return {
    title: l,
    _title: n || [l],
    key: o || "key",
    children: r || "children"
  };
}
function dm(e) {
  function t() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return Lt(n).map((r) => {
      var l, a, i, s;
      if (!RW(r))
        return ct(!r, "Tree/TreeNode can only accept TreeNode as children."), null;
      const c = r.children || {}, u = r.key, d = {};
      for (const [_, M] of Object.entries(r.props))
        d[Oi(_)] = M;
      const {
        isLeaf: p,
        checkable: v,
        selectable: h,
        disabled: g,
        disableCheckbox: b
      } = d, y = {
        isLeaf: p || p === "" || void 0,
        checkable: v || v === "" || void 0,
        selectable: h || h === "" || void 0,
        disabled: g || g === "" || void 0,
        disableCheckbox: b || b === "" || void 0
      }, S = m(m({}, d), y), {
        title: C = (l = c.title) === null || l === void 0 ? void 0 : l.call(c, S),
        icon: w = (a = c.icon) === null || a === void 0 ? void 0 : a.call(c, S),
        switcherIcon: $ = (i = c.switcherIcon) === null || i === void 0 ? void 0 : i.call(c, S)
      } = d, O = LW(d, ["title", "icon", "switcherIcon"]), x = (s = c.default) === null || s === void 0 ? void 0 : s.call(c), I = m(m(m({}, O), {
        title: C,
        icon: w,
        switcherIcon: $,
        key: u,
        isLeaf: p
      }), y), E = t(x);
      return E.length && (I.children = E), I;
    });
  }
  return t(e);
}
function zW(e, t, n) {
  const {
    _title: o,
    key: r,
    children: l
  } = sp(n), a = new Set(t === !0 ? [] : t), i = [];
  function s(c) {
    let u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    return c.map((d, p) => {
      const v = uP(u ? u.pos : "0", p), h = hc(d[r], v);
      let g;
      for (let y = 0; y < o.length; y += 1) {
        const S = o[y];
        if (d[S] !== void 0) {
          g = d[S];
          break;
        }
      }
      const b = m(m({}, ot(d, [...o, r, l])), {
        title: g,
        key: h,
        parent: u,
        pos: v,
        children: null,
        data: d,
        isStart: [...u ? u.isStart : [], p === 0],
        isEnd: [...u ? u.isEnd : [], p === c.length - 1]
      });
      return i.push(b), t === !0 || a.has(h) ? b.children = s(d[l] || [], b) : b.children = [], b;
    });
  }
  return s(e), i;
}
function HW(e, t, n) {
  let o = {};
  typeof n == "object" ? o = n : o = {
    externalGetKey: n
  }, o = o || {};
  const {
    childrenPropName: r,
    externalGetKey: l,
    fieldNames: a
  } = o, {
    key: i,
    children: s
  } = sp(a), c = r || s;
  let u;
  l ? typeof l == "string" ? u = (p) => p[l] : typeof l == "function" && (u = (p) => l(p)) : u = (p, v) => hc(p[i], v);
  function d(p, v, h, g) {
    const b = p ? p[c] : e, y = p ? uP(h.pos, v) : "0", S = p ? [...g, p] : [];
    if (p) {
      const C = u(p, y), w = {
        node: p,
        index: v,
        pos: y,
        key: C,
        parentPos: h.node ? h.pos : null,
        level: h.level + 1,
        nodes: S
      };
      t(w);
    }
    b && b.forEach((C, w) => {
      d(C, w, {
        node: p,
        pos: y,
        level: h ? h.level + 1 : -1
      }, S);
    });
  }
  d(null);
}
function bc(e) {
  let {
    initWrapper: t,
    processEntity: n,
    onProcessFinished: o,
    externalGetKey: r,
    childrenPropName: l,
    fieldNames: a
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i = arguments.length > 2 ? arguments[2] : void 0;
  const s = r || i, c = {}, u = {};
  let d = {
    posEntities: c,
    keyEntities: u
  };
  return t && (d = t(d) || d), HW(e, (p) => {
    const {
      node: v,
      index: h,
      pos: g,
      key: b,
      parentPos: y,
      level: S,
      nodes: C
    } = p, w = {
      node: v,
      nodes: C,
      index: h,
      key: b,
      pos: g,
      level: S
    }, $ = hc(b, g);
    c[g] = w, u[$] = w, w.parent = c[y], w.parent && (w.parent.children = w.parent.children || [], w.parent.children.push(w)), n && n(w, d);
  }, {
    externalGetKey: s,
    childrenPropName: l,
    fieldNames: a
  }), o && o(d), d;
}
function xu(e, t) {
  let {
    expandedKeysSet: n,
    selectedKeysSet: o,
    loadedKeysSet: r,
    loadingKeysSet: l,
    checkedKeysSet: a,
    halfCheckedKeysSet: i,
    dragOverNodeKey: s,
    dropPosition: c,
    keyEntities: u
  } = t;
  const d = u[e];
  return {
    eventKey: e,
    expanded: n.has(e),
    selected: o.has(e),
    loaded: r.has(e),
    loading: l.has(e),
    checked: a.has(e),
    halfChecked: i.has(e),
    pos: String(d ? d.pos : ""),
    parent: d.parent,
    // [Legacy] Drag props
    // Since the interaction of drag is changed, the semantic of the props are
    // not accuracy, I think it should be finally removed
    dragOver: s === e && c === 0,
    dragOverGapTop: s === e && c === -1,
    dragOverGapBottom: s === e && c === 1
  };
}
function Ou(e) {
  const {
    data: t,
    expanded: n,
    selected: o,
    checked: r,
    loaded: l,
    loading: a,
    halfChecked: i,
    dragOver: s,
    dragOverGapTop: c,
    dragOverGapBottom: u,
    pos: d,
    active: p,
    eventKey: v
  } = e, h = m(m({
    dataRef: t
  }, t), {
    expanded: n,
    selected: o,
    checked: r,
    loaded: l,
    loading: a,
    halfChecked: i,
    dragOver: s,
    dragOverGapTop: c,
    dragOverGapBottom: u,
    pos: d,
    active: p,
    eventKey: v,
    key: v
  });
  return "props" in h || Object.defineProperty(h, "props", {
    get() {
      return ct(!1, "Second param return from event is node data instead of TreeNode instance. Please read value directly instead of reading from `props`."), e;
    }
  }), h;
}
const jW = (e, t) => P(() => bc(e.value, {
  fieldNames: t.value,
  initWrapper: (o) => m(m({}, o), {
    pathKeyEntities: {}
  }),
  processEntity: (o, r) => {
    const l = o.nodes.map((a) => a[t.value.value]).join(eb);
    r.pathKeyEntities[l] = o, o.key = l;
  }
}).pathKeyEntities);
function VW(e) {
  const t = Q(!1), n = Y({});
  return Le(() => {
    if (!e.value) {
      t.value = !1, n.value = {};
      return;
    }
    let o = {
      matchInputWidth: !0,
      limit: 50
    };
    e.value && typeof e.value == "object" && (o = m(m({}, o), e.value)), o.limit <= 0 && (delete o.limit, process.env.NODE_ENV !== "production" && ct(!1, "'limit' of showSearch should be positive number or false.")), t.value = !0, n.value = o;
  }), {
    showSearch: t,
    searchConfig: n
  };
}
const Ss = "__rc_cascader_search_mark__", WW = (e, t, n) => {
  let {
    label: o
  } = n;
  return t.some((r) => String(r[o]).toLowerCase().includes(e.toLowerCase()));
}, KW = (e) => {
  let {
    path: t,
    fieldNames: n
  } = e;
  return t.map((o) => o[n.label]).join(" / ");
}, GW = (e, t, n, o, r, l) => P(() => {
  const {
    filter: a = WW,
    render: i = KW,
    limit: s = 50,
    sort: c
  } = r.value, u = [];
  if (!e.value)
    return [];
  function d(p, v) {
    p.forEach((h) => {
      if (!c && s > 0 && u.length >= s)
        return;
      const g = [...v, h], b = h[n.value.children];
      // If is leaf option
      (!b || b.length === 0 || // If is changeOnSelect
      l.value) && a(e.value, g, {
        label: n.value.label
      }) && u.push(m(m({}, h), {
        [n.value.label]: i({
          inputValue: e.value,
          path: g,
          prefixCls: o.value,
          fieldNames: n.value
        }),
        [Ss]: g
      })), b && d(h[n.value.children], g);
    });
  }
  return d(t.value, []), c && u.sort((p, v) => c(p[Ss], v[Ss], e.value, n.value)), s > 0 ? u.slice(0, s) : u;
});
function kC(e, t, n) {
  const o = new Set(e);
  return e.filter((r) => {
    const l = t[r], a = l ? l.parent : null, i = l ? l.children : null;
    return n === rP ? !(i && i.some((s) => s.key && o.has(s.key))) : !(a && !a.node.disabled && o.has(a.key));
  });
}
function Qs(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  var r;
  let l = t;
  const a = [];
  for (let i = 0; i < e.length; i += 1) {
    const s = e[i], c = l == null ? void 0 : l.findIndex((d) => {
      const p = d[n.value];
      return o ? String(p) === String(s) : p === s;
    }), u = c !== -1 ? l == null ? void 0 : l[c] : null;
    a.push({
      value: (r = u == null ? void 0 : u[n.value]) !== null && r !== void 0 ? r : s,
      index: c,
      option: u
    }), l = u == null ? void 0 : u[n.children];
  }
  return a;
}
const XW = (e, t, n) => P(() => {
  const o = [], r = [];
  return n.value.forEach((l) => {
    Qs(l, e.value, t.value).every((i) => i.option) ? r.push(l) : o.push(l);
  }), [r, o];
});
function dP(e, t) {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((o) => {
    t.has(o) || n.add(o);
  }), n;
}
function UW(e) {
  const {
    disabled: t,
    disableCheckbox: n,
    checkable: o
  } = e || {};
  return !!(t || n) || o === !1;
}
function YW(e, t, n, o) {
  const r = new Set(e), l = /* @__PURE__ */ new Set();
  for (let i = 0; i <= n; i += 1)
    (t.get(i) || /* @__PURE__ */ new Set()).forEach((c) => {
      const {
        key: u,
        node: d,
        children: p = []
      } = c;
      r.has(u) && !o(d) && p.filter((v) => !o(v.node)).forEach((v) => {
        r.add(v.key);
      });
    });
  const a = /* @__PURE__ */ new Set();
  for (let i = n; i >= 0; i -= 1)
    (t.get(i) || /* @__PURE__ */ new Set()).forEach((c) => {
      const {
        parent: u,
        node: d
      } = c;
      if (o(d) || !c.parent || a.has(c.parent.key))
        return;
      if (o(c.parent.node)) {
        a.add(u.key);
        return;
      }
      let p = !0, v = !1;
      (u.children || []).filter((h) => !o(h.node)).forEach((h) => {
        let {
          key: g
        } = h;
        const b = r.has(g);
        p && !b && (p = !1), !v && (b || l.has(g)) && (v = !0);
      }), p && r.add(u.key), v && l.add(u.key), a.add(u.key);
    });
  return {
    checkedKeys: Array.from(r),
    halfCheckedKeys: Array.from(dP(l, r))
  };
}
function qW(e, t, n, o, r) {
  const l = new Set(e);
  let a = new Set(t);
  for (let s = 0; s <= o; s += 1)
    (n.get(s) || /* @__PURE__ */ new Set()).forEach((u) => {
      const {
        key: d,
        node: p,
        children: v = []
      } = u;
      !l.has(d) && !a.has(d) && !r(p) && v.filter((h) => !r(h.node)).forEach((h) => {
        l.delete(h.key);
      });
    });
  a = /* @__PURE__ */ new Set();
  const i = /* @__PURE__ */ new Set();
  for (let s = o; s >= 0; s -= 1)
    (n.get(s) || /* @__PURE__ */ new Set()).forEach((u) => {
      const {
        parent: d,
        node: p
      } = u;
      if (r(p) || !u.parent || i.has(u.parent.key))
        return;
      if (r(u.parent.node)) {
        i.add(d.key);
        return;
      }
      let v = !0, h = !1;
      (d.children || []).filter((g) => !r(g.node)).forEach((g) => {
        let {
          key: b
        } = g;
        const y = l.has(b);
        v && !y && (v = !1), !h && (y || a.has(b)) && (h = !0);
      }), v || l.delete(d.key), h && a.add(d.key), i.add(d.key);
    });
  return {
    checkedKeys: Array.from(l),
    halfCheckedKeys: Array.from(dP(a, l))
  };
}
function Bo(e, t, n, o, r, l) {
  const a = [];
  let i;
  l ? i = l : i = UW;
  const s = new Set(e.filter((u) => {
    const d = !!n[u];
    return d || a.push(u), d;
  }));
  f2(!a.length, `Tree missing follow keys: ${a.slice(0, 100).map((u) => `'${u}'`).join(", ")}`);
  let c;
  return t === !0 ? c = YW(s, r, o, i) : c = qW(s, t.halfCheckedKeys, r, o, i), c;
}
const ZW = (e, t, n, o, r) => P(() => {
  const l = r.value || // Default displayRender
  ((a) => {
    let {
      labels: i
    } = a;
    const s = o.value ? i.slice(-1) : i, c = " / ";
    return s.every((u) => ["string", "number"].includes(typeof u)) ? s.join(c) : s.reduce((u, d, p) => {
      const v = Gt(d) ? yt(d, {
        key: p
      }) : d;
      return p === 0 ? [v] : [...u, c, v];
    }, []);
  });
  return e.value.map((a) => {
    const i = Qs(a, t.value, n.value), s = l({
      labels: i.map((u) => {
        let {
          option: d,
          value: p
        } = u;
        var v;
        return (v = d == null ? void 0 : d[n.value.label]) !== null && v !== void 0 ? v : p;
      }),
      selectedOptions: i.map((u) => {
        let {
          option: d
        } = u;
        return d;
      })
    }), c = ml(a);
    return {
      label: s,
      value: c,
      key: c,
      valueCells: a
    };
  });
}), fP = Symbol("CascaderContextKey"), QW = (e) => {
  Je(fP, e);
}, cp = () => tt(fP), JW = () => {
  const e = ac(), {
    values: t
  } = cp(), [n, o] = Pt([]);
  return ie(() => e.open, () => {
    if (e.open && !e.multiple) {
      const r = t.value[0];
      o(r || []);
    }
  }, {
    immediate: !0
  }), [n, o];
}, eK = (e, t, n, o, r, l) => {
  const a = ac(), i = P(() => a.direction === "rtl"), [s, c, u] = [Y([]), Y(), Y([])];
  Le(() => {
    let g = -1, b = t.value;
    const y = [], S = [], C = o.value.length;
    for (let $ = 0; $ < C && b; $ += 1) {
      const O = b.findIndex((x) => x[n.value.value] === o.value[$]);
      if (O === -1)
        break;
      g = O, y.push(g), S.push(o.value[$]), b = b[g][n.value.children];
    }
    let w = t.value;
    for (let $ = 0; $ < y.length - 1; $ += 1)
      w = w[y[$]][n.value.children];
    [s.value, c.value, u.value] = [S, g, w];
  });
  const d = (g) => {
    r(g);
  }, p = (g) => {
    const b = u.value.length;
    let y = c.value;
    y === -1 && g < 0 && (y = b);
    for (let S = 0; S < b; S += 1) {
      y = (y + g + b) % b;
      const C = u.value[y];
      if (C && !C.disabled) {
        const w = C[n.value.value], $ = s.value.slice(0, -1).concat(w);
        d($);
        return;
      }
    }
  }, v = () => {
    if (s.value.length > 1) {
      const g = s.value.slice(0, -1);
      d(g);
    } else
      a.toggleOpen(!1);
  }, h = () => {
    var g;
    const y = (((g = u.value[c.value]) === null || g === void 0 ? void 0 : g[n.value.children]) || []).find((S) => !S.disabled);
    if (y) {
      const S = [...s.value, y[n.value.value]];
      d(S);
    }
  };
  e.expose({
    // scrollTo: treeRef.current?.scrollTo,
    onKeydown: (g) => {
      const {
        which: b
      } = g;
      switch (b) {
        case ce.UP:
        case ce.DOWN: {
          let y = 0;
          b === ce.UP ? y = -1 : b === ce.DOWN && (y = 1), y !== 0 && p(y);
          break;
        }
        case ce.LEFT: {
          i.value ? h() : v();
          break;
        }
        case ce.RIGHT: {
          i.value ? v() : h();
          break;
        }
        case ce.BACKSPACE: {
          a.searchValue || v();
          break;
        }
        case ce.ENTER: {
          if (s.value.length) {
            const y = u.value[c.value], S = (y == null ? void 0 : y[Ss]) || [];
            S.length ? l(S.map((C) => C[n.value.value]), S[S.length - 1]) : l(s.value, y);
          }
          break;
        }
        case ce.ESC:
          a.toggleOpen(!1), open && g.stopPropagation();
      }
    },
    onKeyup: () => {
    }
  });
};
function up(e) {
  let {
    prefixCls: t,
    checked: n,
    halfChecked: o,
    disabled: r,
    onClick: l
  } = e;
  const {
    customSlots: a,
    checkable: i
  } = cp(), s = i.value !== !1 ? a.value.checkable : i.value, c = typeof s == "function" ? s() : typeof s == "boolean" ? null : s;
  return f("span", {
    class: {
      [t]: !0,
      [`${t}-checked`]: n,
      [`${t}-indeterminate`]: !n && o,
      [`${t}-disabled`]: r
    },
    onClick: l
  }, [c]);
}
up.props = ["prefixCls", "checked", "halfChecked", "disabled", "onClick"];
up.displayName = "Checkbox";
up.inheritAttrs = !1;
const pP = "__cascader_fix_label__";
function dp(e) {
  let {
    prefixCls: t,
    multiple: n,
    options: o,
    activeValue: r,
    prevValuePath: l,
    onToggleOpen: a,
    onSelect: i,
    onActive: s,
    checkedSet: c,
    halfCheckedSet: u,
    loadingKeys: d,
    isSelectable: p
  } = e;
  var v, h, g, b, y, S;
  const C = `${t}-menu`, w = `${t}-menu-item`, {
    fieldNames: $,
    changeOnSelect: O,
    expandTrigger: x,
    expandIcon: I,
    loadingIcon: E,
    dropdownMenuColumnStyle: _,
    customSlots: M
  } = cp(), R = (v = I.value) !== null && v !== void 0 ? v : (g = (h = M.value).expandIcon) === null || g === void 0 ? void 0 : g.call(h), A = (b = E.value) !== null && b !== void 0 ? b : (S = (y = M.value).loadingIcon) === null || S === void 0 ? void 0 : S.call(y), z = x.value === "hover";
  return f("ul", {
    class: C,
    role: "menu"
  }, [o.map((T) => {
    var N;
    const {
      disabled: k
    } = T, B = T[Ss], F = (N = T[pP]) !== null && N !== void 0 ? N : T[$.value.label], L = T[$.value.value], j = os(T, $.value), H = B ? B.map((G) => G[$.value.value]) : [...l, L], K = ml(H), X = d.includes(K), W = c.has(K), q = u.has(K), J = () => {
      !k && (!z || !j) && s(H);
    }, ne = () => {
      p(T) && i(H, j);
    };
    let te;
    return typeof T.title == "string" ? te = T.title : typeof F == "string" && (te = F), f("li", {
      key: K,
      class: [w, {
        [`${w}-expand`]: !j,
        [`${w}-active`]: r === L,
        [`${w}-disabled`]: k,
        [`${w}-loading`]: X
      }],
      style: _.value,
      role: "menuitemcheckbox",
      title: te,
      "aria-checked": W,
      "data-path-key": K,
      onClick: () => {
        J(), (!n || j) && ne();
      },
      onDblclick: () => {
        O.value && a(!1);
      },
      onMouseenter: () => {
        z && J();
      },
      onMousedown: (G) => {
        G.preventDefault();
      }
    }, [n && f(up, {
      prefixCls: `${t}-checkbox`,
      checked: W,
      halfChecked: q,
      disabled: k,
      onClick: (G) => {
        G.stopPropagation(), ne();
      }
    }, null), f("div", {
      class: `${w}-content`
    }, [F]), !X && R && !j && f("div", {
      class: `${w}-expand-icon`
    }, [yt(R)]), X && A && f("div", {
      class: `${w}-loading-icon`
    }, [yt(A)])]);
  })]);
}
dp.props = ["prefixCls", "multiple", "options", "activeValue", "prevValuePath", "onToggleOpen", "onSelect", "onActive", "checkedSet", "halfCheckedSet", "loadingKeys", "isSelectable"];
dp.displayName = "Column";
dp.inheritAttrs = !1;
const tK = Z({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  setup(e, t) {
    const {
      attrs: n,
      slots: o
    } = t, r = ac(), l = Y(), a = P(() => r.direction === "rtl"), {
      options: i,
      values: s,
      halfValues: c,
      fieldNames: u,
      changeOnSelect: d,
      onSelect: p,
      searchOptions: v,
      dropdownPrefixCls: h,
      loadData: g,
      expandTrigger: b,
      customSlots: y
    } = cp(), S = P(() => h.value || r.prefixCls), C = Q([]), w = (N) => {
      if (!g.value || r.searchValue)
        return;
      const B = Qs(N, i.value, u.value).map((L) => {
        let {
          option: j
        } = L;
        return j;
      }), F = B[B.length - 1];
      if (F && !os(F, u.value)) {
        const L = ml(N);
        C.value = [...C.value, L], g.value(B);
      }
    };
    Le(() => {
      C.value.length && C.value.forEach((N) => {
        const k = PW(N), B = Qs(k, i.value, u.value, !0).map((L) => {
          let {
            option: j
          } = L;
          return j;
        }), F = B[B.length - 1];
        (!F || F[u.value.children] || os(F, u.value)) && (C.value = C.value.filter((L) => L !== N));
      });
    });
    const $ = P(() => new Set(Ya(s.value))), O = P(() => new Set(Ya(c.value))), [x, I] = JW(), E = (N) => {
      I(N), w(N);
    }, _ = (N) => {
      const {
        disabled: k
      } = N, B = os(N, u.value);
      return !k && (B || d.value || r.multiple);
    }, M = function(N, k) {
      let B = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      p(N), !r.multiple && (k || d.value && (b.value === "hover" || B)) && r.toggleOpen(!1);
    }, R = P(() => r.searchValue ? v.value : i.value), A = P(() => {
      const N = [{
        options: R.value
      }];
      let k = R.value;
      for (let B = 0; B < x.value.length; B += 1) {
        const F = x.value[B], L = k.find((H) => H[u.value.value] === F), j = L == null ? void 0 : L[u.value.children];
        if (!(j != null && j.length))
          break;
        k = j, N.push({
          options: j
        });
      }
      return N;
    });
    eK(t, R, u, x, E, (N, k) => {
      _(k) && M(N, os(k, u.value), !0);
    });
    const T = (N) => {
      N.preventDefault();
    };
    return Ke(() => {
      ie(x, (N) => {
        var k;
        for (let B = 0; B < N.length; B += 1) {
          const F = N.slice(0, B + 1), L = ml(F), j = (k = l.value) === null || k === void 0 ? void 0 : k.querySelector(`li[data-path-key="${L.replace(/\\{0,2}"/g, '\\"')}"]`);
          j && EW(j);
        }
      }, {
        flush: "post",
        immediate: !0
      });
    }), () => {
      var N, k, B, F, L;
      const {
        notFoundContent: j = ((N = o.notFoundContent) === null || N === void 0 ? void 0 : N.call(o)) || ((B = (k = y.value).notFoundContent) === null || B === void 0 ? void 0 : B.call(k)),
        multiple: H,
        toggleOpen: K
      } = r, X = !(!((L = (F = A.value[0]) === null || F === void 0 ? void 0 : F.options) === null || L === void 0) && L.length), W = [{
        [u.value.value]: "__EMPTY__",
        [pP]: j,
        disabled: !0
      }], q = m(m({}, n), {
        multiple: !X && H,
        onSelect: M,
        onActive: E,
        onToggleOpen: K,
        checkedSet: $.value,
        halfCheckedSet: O.value,
        loadingKeys: C.value,
        isSelectable: _
      }), ne = (X ? [{
        options: W
      }] : A.value).map((te, G) => {
        const U = x.value.slice(0, G), re = x.value[G];
        return f(dp, D(D({
          key: G
        }, q), {}, {
          prefixCls: S.value,
          options: te.options,
          prevValuePath: U,
          activeValue: re
        }), null);
      });
      return f("div", {
        class: [`${S.value}-menus`, {
          [`${S.value}-menu-empty`]: X,
          [`${S.value}-rtl`]: a.value
        }],
        onMousedown: T,
        ref: l
      }, [ne]);
    };
  }
});
function fp(e) {
  const t = Y(0), n = Q();
  return Le(() => {
    const o = /* @__PURE__ */ new Map();
    let r = 0;
    const l = e.value || {};
    for (const a in l)
      if (Object.prototype.hasOwnProperty.call(l, a)) {
        const i = l[a], {
          level: s
        } = i;
        let c = o.get(s);
        c || (c = /* @__PURE__ */ new Set(), o.set(s, c)), c.add(i), r = Math.max(r, s);
      }
    t.value = r, n.value = o;
  }), {
    maxLevel: t,
    levelEntities: n
  };
}
function nK() {
  return m(m({}, ot(kf(), ["tokenSeparators", "mode", "showSearch"])), {
    // MISC
    id: String,
    prefixCls: String,
    fieldNames: Re(),
    children: Array,
    // Value
    value: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array]
    },
    changeOnSelect: {
      type: Boolean,
      default: void 0
    },
    displayRender: Function,
    checkable: {
      type: Boolean,
      default: void 0
    },
    showCheckedStrategy: {
      type: String,
      default: oP
    },
    // Search
    showSearch: {
      type: [Boolean, Object],
      default: void 0
    },
    searchValue: String,
    onSearch: Function,
    // Trigger
    expandTrigger: String,
    // Options
    options: Array,
    /** @private Internal usage. Do not use in your production. */
    dropdownPrefixCls: String,
    loadData: Function,
    // Open
    /** @deprecated Use `open` instead */
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    dropdownClassName: String,
    dropdownMenuColumnStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `dropdownStyle` instead */
    popupStyle: {
      type: Object,
      default: void 0
    },
    dropdownStyle: {
      type: Object,
      default: void 0
    },
    /** @deprecated Use `placement` instead */
    popupPlacement: String,
    placement: String,
    /** @deprecated Use `onDropdownVisibleChange` instead */
    onPopupVisibleChange: Function,
    onDropdownVisibleChange: Function,
    // Icon
    expandIcon: V.any,
    loadingIcon: V.any
  });
}
function vP() {
  return m(m({}, nK()), {
    onChange: Function,
    customSlots: Object
  });
}
function oK(e) {
  return Array.isArray(e) && Array.isArray(e[0]);
}
function BC(e) {
  return e ? oK(e) ? e : (e.length === 0 ? [] : [e]).map((t) => Array.isArray(t) ? t : [t]) : [];
}
const rK = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Cascader",
  inheritAttrs: !1,
  props: Qe(vP(), {}),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: r
    } = t;
    const l = jh(Te(e, "id")), a = P(() => !!e.checkable), [i, s] = Rt(e.defaultValue, {
      value: P(() => e.value),
      postState: BC
    }), c = P(() => IW(e.fieldNames)), u = P(() => e.options || []), d = jW(u, c), p = (G) => {
      const U = d.value;
      return G.map((re) => {
        const {
          nodes: se
        } = U[re];
        return se.map((me) => me[c.value.value]);
      });
    }, [v, h] = Rt("", {
      value: P(() => e.searchValue),
      postState: (G) => G || ""
    }), g = (G, U) => {
      h(G), U.source !== "blur" && e.onSearch && e.onSearch(G);
    }, {
      showSearch: b,
      searchConfig: y
    } = VW(Te(e, "showSearch")), S = GW(v, u, c, P(() => e.dropdownPrefixCls || e.prefixCls), y, Te(e, "changeOnSelect")), C = XW(u, c, i), [w, $, O] = [Y([]), Y([]), Y([])], {
      maxLevel: x,
      levelEntities: I
    } = fp(d);
    Le(() => {
      const [G, U] = C.value;
      if (!a.value || !i.value.length) {
        [w.value, $.value, O.value] = [G, [], U];
        return;
      }
      const re = Ya(G), se = d.value, {
        checkedKeys: me,
        halfCheckedKeys: Ce
      } = Bo(re, !0, se, x.value, I.value);
      [w.value, $.value, O.value] = [p(me), p(Ce), U];
    });
    const E = P(() => {
      const G = Ya(w.value), U = kC(G, d.value, e.showCheckedStrategy);
      return [...O.value, ...p(U)];
    }), _ = ZW(E, u, c, a, Te(e, "displayRender")), M = (G) => {
      if (s(G), e.onChange) {
        const U = BC(G), re = U.map((Ce) => Qs(Ce, u.value, c.value).map((fe) => fe.option)), se = a.value ? U : U[0], me = a.value ? re : re[0];
        e.onChange(se, me);
      }
    }, R = (G) => {
      if (h(""), !a.value)
        M(G);
      else {
        const U = ml(G), re = Ya(w.value), se = Ya($.value), me = re.includes(U), Ce = O.value.some((ue) => ml(ue) === U);
        let fe = w.value, be = O.value;
        if (Ce && !me)
          be = O.value.filter((ue) => ml(ue) !== U);
        else {
          const ue = me ? re.filter((xe) => xe !== U) : [...re, U];
          let de;
          me ? {
            checkedKeys: de
          } = Bo(ue, {
            checked: !1,
            halfCheckedKeys: se
          }, d.value, x.value, I.value) : {
            checkedKeys: de
          } = Bo(ue, !0, d.value, x.value, I.value);
          const Se = kC(de, d.value, e.showCheckedStrategy);
          fe = p(Se);
        }
        M([...be, ...fe]);
      }
    }, A = (G, U) => {
      if (U.type === "clear") {
        M([]);
        return;
      }
      const {
        valueCells: re
      } = U.values[0];
      R(re);
    };
    process.env.NODE_ENV !== "production" && Le(() => {
      nt(!e.onPopupVisibleChange, "Cascader", "`popupVisibleChange` is deprecated. Please use `dropdownVisibleChange` instead."), nt(e.popupVisible === void 0, "Cascader", "`popupVisible` is deprecated. Please use `open` instead."), nt(e.popupPlacement === void 0, "Cascader", "`popupPlacement` is deprecated. Please use `placement` instead."), nt(e.popupStyle === void 0, "Cascader", "`popupStyle` is deprecated. Please use `dropdownStyle` instead.");
    });
    const z = P(() => e.open !== void 0 ? e.open : e.popupVisible), T = P(() => e.dropdownStyle || e.popupStyle || {}), N = P(() => e.placement || e.popupPlacement), k = (G) => {
      var U, re;
      (U = e.onDropdownVisibleChange) === null || U === void 0 || U.call(e, G), (re = e.onPopupVisibleChange) === null || re === void 0 || re.call(e, G);
    }, {
      changeOnSelect: B,
      checkable: F,
      dropdownPrefixCls: L,
      loadData: j,
      expandTrigger: H,
      expandIcon: K,
      loadingIcon: X,
      dropdownMenuColumnStyle: W,
      customSlots: q,
      dropdownClassName: J
    } = Qo(e);
    QW({
      options: u,
      fieldNames: c,
      values: w,
      halfValues: $,
      changeOnSelect: B,
      onSelect: R,
      checkable: F,
      searchOptions: S,
      dropdownPrefixCls: L,
      loadData: j,
      expandTrigger: H,
      expandIcon: K,
      loadingIcon: X,
      dropdownMenuColumnStyle: W,
      customSlots: q
    });
    const ne = Y();
    o({
      focus() {
        var G;
        (G = ne.value) === null || G === void 0 || G.focus();
      },
      blur() {
        var G;
        (G = ne.value) === null || G === void 0 || G.blur();
      },
      scrollTo(G) {
        var U;
        (U = ne.value) === null || U === void 0 || U.scrollTo(G);
      }
    });
    const te = P(() => ot(e, [
      "id",
      "prefixCls",
      "fieldNames",
      // Value
      "defaultValue",
      "value",
      "changeOnSelect",
      "onChange",
      "displayRender",
      "checkable",
      // Search
      "searchValue",
      "onSearch",
      "showSearch",
      // Trigger
      "expandTrigger",
      // Options
      "options",
      "dropdownPrefixCls",
      "loadData",
      // Open
      "popupVisible",
      "open",
      "dropdownClassName",
      "dropdownMenuColumnStyle",
      "popupPlacement",
      "placement",
      "onDropdownVisibleChange",
      "onPopupVisibleChange",
      // Icon
      "expandIcon",
      "loadingIcon",
      "customSlots",
      "showCheckedStrategy",
      // Children
      "children"
    ]));
    return () => {
      const G = !(v.value ? S.value : u.value).length, {
        dropdownMatchSelectWidth: U = !1
      } = e, re = (
        // Search to match width
        v.value && y.value.matchInputWidth || // Empty keep the width
        G ? {} : {
          minWidth: "auto"
        }
      );
      return f(Lh, D(D(D({}, te.value), n), {}, {
        ref: ne,
        id: l,
        prefixCls: e.prefixCls,
        dropdownMatchSelectWidth: U,
        dropdownStyle: m(m({}, T.value), re),
        displayValues: _.value,
        onDisplayValuesChange: A,
        mode: a.value ? "multiple" : void 0,
        searchValue: v.value,
        onSearch: g,
        showSearch: b.value,
        OptionList: tK,
        emptyOptions: G,
        open: z.value,
        dropdownClassName: J.value,
        placement: N.value,
        onDropdownVisibleChange: k,
        getRawInputElement: () => {
          var se;
          return (se = r.default) === null || se === void 0 ? void 0 : se.call(r);
        }
      }), r);
    };
  }
});
var lK = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 000 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z" } }] }, name: "left", theme: "outlined" };
function FC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      aK(e, r, n[r]);
    });
  }
  return e;
}
function aK(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var wr = function(t, n) {
  var o = FC({}, t, n.attrs);
  return f(Ge, FC({}, o, {
    icon: lK
  }), null);
};
wr.displayName = "LeftOutlined";
wr.inheritAttrs = !1;
const gP = () => jn() && window.document.documentElement, mP = (e) => {
  if (jn() && window.document.documentElement) {
    const t = Array.isArray(e) ? e : [e], {
      documentElement: n
    } = window.document;
    return t.some((o) => o in n.style);
  }
  return !1;
}, iK = (e, t) => {
  if (!mP(e))
    return !1;
  const n = document.createElement("div"), o = n.style[e];
  return n.style[e] = t, n.style[e] !== o;
};
function ob(e, t) {
  return !Array.isArray(e) && t !== void 0 ? iK(e, t) : mP(e);
}
let Qc;
const sK = () => {
  if (!gP())
    return !1;
  if (Qc !== void 0)
    return Qc;
  const e = document.createElement("div");
  return e.style.display = "flex", e.style.flexDirection = "column", e.style.rowGap = "1px", e.appendChild(document.createElement("div")), e.appendChild(document.createElement("div")), document.body.appendChild(e), Qc = e.scrollHeight === 1, document.body.removeChild(e), Qc;
}, hP = () => {
  const e = Q(!1);
  return Ke(() => {
    e.value = sK();
  }), e;
}, bP = Symbol("rowContextKey"), cK = (e) => {
  Je(bP, e);
}, uK = () => tt(bP, {
  gutter: P(() => {
  }),
  wrap: P(() => {
  }),
  supportFlexGap: P(() => {
  })
}), dK = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // Grid system
    [t]: {
      display: "flex",
      flexFlow: "row wrap",
      minWidth: 0,
      "&::before, &::after": {
        display: "flex"
      },
      "&-no-wrap": {
        flexWrap: "nowrap"
      },
      // The origin of the X-axis
      "&-start": {
        justifyContent: "flex-start"
      },
      // The center of the X-axis
      "&-center": {
        justifyContent: "center"
      },
      // The opposite of the X-axis
      "&-end": {
        justifyContent: "flex-end"
      },
      "&-space-between": {
        justifyContent: "space-between"
      },
      "&-space-around ": {
        justifyContent: "space-around"
      },
      "&-space-evenly ": {
        justifyContent: "space-evenly"
      },
      // Align at the top
      "&-top": {
        alignItems: "flex-start"
      },
      // Align at the center
      "&-middle": {
        alignItems: "center"
      },
      "&-bottom": {
        alignItems: "flex-end"
      }
    }
  };
}, fK = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // Grid system
    [t]: {
      position: "relative",
      maxWidth: "100%",
      // Prevent columns from collapsing when empty
      minHeight: 1
    }
  };
}, pK = (e, t) => {
  const {
    componentCls: n,
    gridColumns: o
  } = e, r = {};
  for (let l = o; l >= 0; l--)
    l === 0 ? (r[`${n}${t}-${l}`] = {
      display: "none"
    }, r[`${n}-push-${l}`] = {
      insetInlineStart: "auto"
    }, r[`${n}-pull-${l}`] = {
      insetInlineEnd: "auto"
    }, r[`${n}${t}-push-${l}`] = {
      insetInlineStart: "auto"
    }, r[`${n}${t}-pull-${l}`] = {
      insetInlineEnd: "auto"
    }, r[`${n}${t}-offset-${l}`] = {
      marginInlineEnd: 0
    }, r[`${n}${t}-order-${l}`] = {
      order: 0
    }) : (r[`${n}${t}-${l}`] = {
      display: "block",
      flex: `0 0 ${l / o * 100}%`,
      maxWidth: `${l / o * 100}%`
    }, r[`${n}${t}-push-${l}`] = {
      insetInlineStart: `${l / o * 100}%`
    }, r[`${n}${t}-pull-${l}`] = {
      insetInlineEnd: `${l / o * 100}%`
    }, r[`${n}${t}-offset-${l}`] = {
      marginInlineStart: `${l / o * 100}%`
    }, r[`${n}${t}-order-${l}`] = {
      order: l
    });
  return r;
}, fm = (e, t) => pK(e, t), vK = (e, t, n) => ({
  [`@media (min-width: ${t}px)`]: m({}, fm(e, n))
}), gK = Xe("Grid", (e) => [dK(e)]), mK = Xe("Grid", (e) => {
  const t = He(e, {
    gridColumns: 24
    // Row is divided into 24 parts in Grid
  }), n = {
    "-sm": t.screenSMMin,
    "-md": t.screenMDMin,
    "-lg": t.screenLGMin,
    "-xl": t.screenXLMin,
    "-xxl": t.screenXXLMin
  };
  return [fK(t), fm(t, ""), fm(t, "-xs"), Object.keys(n).map((o) => vK(t, n[o], o)).reduce((o, r) => m(m({}, o), r), {})];
}), hK = () => ({
  align: je([String, Object]),
  justify: je([String, Object]),
  prefixCls: String,
  gutter: je([Number, Array, Object], 0),
  wrap: {
    type: Boolean,
    default: void 0
  }
}), rb = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ARow",
  inheritAttrs: !1,
  props: hK(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("row", e), [a, i] = gK(r);
    let s;
    const c = s0(), u = Y({
      xs: !0,
      sm: !0,
      md: !0,
      lg: !0,
      xl: !0,
      xxl: !0
    }), d = Y({
      xs: !1,
      sm: !1,
      md: !1,
      lg: !1,
      xl: !1,
      xxl: !1
    }), p = (C) => P(() => {
      if (typeof e[C] == "string")
        return e[C];
      if (typeof e[C] != "object")
        return "";
      for (let w = 0; w < Lr.length; w++) {
        const $ = Lr[w];
        if (!d.value[$])
          continue;
        const O = e[C][$];
        if (O !== void 0)
          return O;
      }
      return "";
    }), v = p("align"), h = p("justify"), g = hP();
    Ke(() => {
      s = c.value.subscribe((C) => {
        d.value = C;
        const w = e.gutter || 0;
        (!Array.isArray(w) && typeof w == "object" || Array.isArray(w) && (typeof w[0] == "object" || typeof w[1] == "object")) && (u.value = C);
      });
    }), et(() => {
      c.value.unsubscribe(s);
    });
    const b = P(() => {
      const C = [void 0, void 0], {
        gutter: w = 0
      } = e;
      return (Array.isArray(w) ? w : [w, void 0]).forEach((O, x) => {
        if (typeof O == "object")
          for (let I = 0; I < Lr.length; I++) {
            const E = Lr[I];
            if (u.value[E] && O[E] !== void 0) {
              C[x] = O[E];
              break;
            }
          }
        else
          C[x] = O;
      }), C;
    });
    cK({
      gutter: b,
      supportFlexGap: g,
      wrap: P(() => e.wrap)
    });
    const y = P(() => ee(r.value, {
      [`${r.value}-no-wrap`]: e.wrap === !1,
      [`${r.value}-${h.value}`]: h.value,
      [`${r.value}-${v.value}`]: v.value,
      [`${r.value}-rtl`]: l.value === "rtl"
    }, o.class, i.value)), S = P(() => {
      const C = b.value, w = {}, $ = C[0] != null && C[0] > 0 ? `${C[0] / -2}px` : void 0, O = C[1] != null && C[1] > 0 ? `${C[1] / -2}px` : void 0;
      return $ && (w.marginLeft = $, w.marginRight = $), g.value ? w.rowGap = `${C[1]}px` : O && (w.marginTop = O, w.marginBottom = O), w;
    });
    return () => {
      var C;
      return a(f("div", D(D({}, o), {}, {
        class: y.value,
        style: m(m({}, S.value), o.style)
      }), [(C = n.default) === null || C === void 0 ? void 0 : C.call(n)]));
    };
  }
});
function Yl() {
  return Yl = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Yl.apply(this, arguments);
}
function bK(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, Js(e, t);
}
function pm(e) {
  return pm = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(n) {
    return n.__proto__ || Object.getPrototypeOf(n);
  }, pm(e);
}
function Js(e, t) {
  return Js = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(o, r) {
    return o.__proto__ = r, o;
  }, Js(e, t);
}
function yK() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function Pu(e, t, n) {
  return yK() ? Pu = Reflect.construct.bind() : Pu = function(r, l, a) {
    var i = [null];
    i.push.apply(i, l);
    var s = Function.bind.apply(r, i), c = new s();
    return a && Js(c, a.prototype), c;
  }, Pu.apply(null, arguments);
}
function SK(e) {
  return Function.toString.call(e).indexOf("[native code]") !== -1;
}
function vm(e) {
  var t = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return vm = function(o) {
    if (o === null || !SK(o))
      return o;
    if (typeof o != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof t < "u") {
      if (t.has(o))
        return t.get(o);
      t.set(o, r);
    }
    function r() {
      return Pu(o, arguments, pm(this).constructor);
    }
    return r.prototype = Object.create(o.prototype, {
      constructor: {
        value: r,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), Js(r, o);
  }, vm(e);
}
var CK = /%[sdj%]/g, yP = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (yP = function(t, n) {
  typeof console < "u" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING > "u" && n.every(function(o) {
    return typeof o == "string";
  }) && console.warn(t, n);
});
function gm(e) {
  if (!e || !e.length)
    return null;
  var t = {};
  return e.forEach(function(n) {
    var o = n.field;
    t[o] = t[o] || [], t[o].push(n);
  }), t;
}
function wo(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  var r = 0, l = n.length;
  if (typeof e == "function")
    return e.apply(null, n);
  if (typeof e == "string") {
    var a = e.replace(CK, function(i) {
      if (i === "%%")
        return "%";
      if (r >= l)
        return i;
      switch (i) {
        case "%s":
          return String(n[r++]);
        case "%d":
          return Number(n[r++]);
        case "%j":
          try {
            return JSON.stringify(n[r++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return i;
      }
    });
    return a;
  }
  return e;
}
function $K(e) {
  return e === "string" || e === "url" || e === "hex" || e === "email" || e === "date" || e === "pattern";
}
function Cn(e, t) {
  return !!(e == null || t === "array" && Array.isArray(e) && !e.length || $K(t) && typeof e == "string" && !e);
}
function wK(e, t, n) {
  var o = [], r = 0, l = e.length;
  function a(i) {
    o.push.apply(o, i || []), r++, r === l && n(o);
  }
  e.forEach(function(i) {
    t(i, a);
  });
}
function LC(e, t, n) {
  var o = 0, r = e.length;
  function l(a) {
    if (a && a.length) {
      n(a);
      return;
    }
    var i = o;
    o = o + 1, i < r ? t(e[i], l) : n([]);
  }
  l([]);
}
function xK(e) {
  var t = [];
  return Object.keys(e).forEach(function(n) {
    t.push.apply(t, e[n] || []);
  }), t;
}
var zC = /* @__PURE__ */ function(e) {
  bK(t, e);
  function t(n, o) {
    var r;
    return r = e.call(this, "Async Validation Error") || this, r.errors = n, r.fields = o, r;
  }
  return t;
}(/* @__PURE__ */ vm(Error));
function OK(e, t, n, o, r) {
  if (t.first) {
    var l = new Promise(function(p, v) {
      var h = function(y) {
        return o(y), y.length ? v(new zC(y, gm(y))) : p(r);
      }, g = xK(e);
      LC(g, n, h);
    });
    return l.catch(function(p) {
      return p;
    }), l;
  }
  var a = t.firstFields === !0 ? Object.keys(e) : t.firstFields || [], i = Object.keys(e), s = i.length, c = 0, u = [], d = new Promise(function(p, v) {
    var h = function(b) {
      if (u.push.apply(u, b), c++, c === s)
        return o(u), u.length ? v(new zC(u, gm(u))) : p(r);
    };
    i.length || (o(u), p(r)), i.forEach(function(g) {
      var b = e[g];
      a.indexOf(g) !== -1 ? LC(b, n, h) : wK(b, n, h);
    });
  });
  return d.catch(function(p) {
    return p;
  }), d;
}
function PK(e) {
  return !!(e && e.message !== void 0);
}
function IK(e, t) {
  for (var n = e, o = 0; o < t.length; o++) {
    if (n == null)
      return n;
    n = n[t[o]];
  }
  return n;
}
function HC(e, t) {
  return function(n) {
    var o;
    return e.fullFields ? o = IK(t, e.fullFields) : o = t[n.field || e.fullField], PK(n) ? (n.field = n.field || e.fullField, n.fieldValue = o, n) : {
      message: typeof n == "function" ? n() : n,
      fieldValue: o,
      field: n.field || e.fullField
    };
  };
}
function jC(e, t) {
  if (t) {
    for (var n in t)
      if (t.hasOwnProperty(n)) {
        var o = t[n];
        typeof o == "object" && typeof e[n] == "object" ? e[n] = Yl({}, e[n], o) : e[n] = o;
      }
  }
  return e;
}
var SP = function(t, n, o, r, l, a) {
  t.required && (!o.hasOwnProperty(t.field) || Cn(n, a || t.type)) && r.push(wo(l.messages.required, t.fullField));
}, EK = function(t, n, o, r, l) {
  (/^\s+$/.test(n) || n === "") && r.push(wo(l.messages.whitespace, t.fullField));
}, Jc, TK = function() {
  if (Jc)
    return Jc;
  var e = "[a-fA-F\\d:]", t = function(w) {
    return w && w.includeBoundaries ? "(?:(?<=\\s|^)(?=" + e + ")|(?<=" + e + ")(?=\\s|$))" : "";
  }, n = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}", o = "[a-fA-F\\d]{1,4}", r = (`
(?:
(?:` + o + ":){7}(?:" + o + `|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:` + o + ":){6}(?:" + n + "|:" + o + `|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:` + o + ":){5}(?::" + n + "|(?::" + o + `){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:` + o + ":){4}(?:(?::" + o + "){0,1}:" + n + "|(?::" + o + `){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:` + o + ":){3}(?:(?::" + o + "){0,2}:" + n + "|(?::" + o + `){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:` + o + ":){2}(?:(?::" + o + "){0,3}:" + n + "|(?::" + o + `){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:` + o + ":){1}(?:(?::" + o + "){0,4}:" + n + "|(?::" + o + `){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::` + o + "){0,5}:" + n + "|(?::" + o + `){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`).replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim(), l = new RegExp("(?:^" + n + "$)|(?:^" + r + "$)"), a = new RegExp("^" + n + "$"), i = new RegExp("^" + r + "$"), s = function(w) {
    return w && w.exact ? l : new RegExp("(?:" + t(w) + n + t(w) + ")|(?:" + t(w) + r + t(w) + ")", "g");
  };
  s.v4 = function(C) {
    return C && C.exact ? a : new RegExp("" + t(C) + n + t(C), "g");
  }, s.v6 = function(C) {
    return C && C.exact ? i : new RegExp("" + t(C) + r + t(C), "g");
  };
  var c = "(?:(?:[a-z]+:)?//)", u = "(?:\\S+(?::\\S*)?@)?", d = s.v4().source, p = s.v6().source, v = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)", h = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*", g = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))", b = "(?::\\d{2,5})?", y = '(?:[/?#][^\\s"]*)?', S = "(?:" + c + "|www\\.)" + u + "(?:localhost|" + d + "|" + p + "|" + v + h + g + ")" + b + y;
  return Jc = new RegExp("(?:^" + S + "$)", "i"), Jc;
}, VC = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
  // url: new RegExp(
  //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
  //   'i',
  // ),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, rs = {
  integer: function(t) {
    return rs.number(t) && parseInt(t, 10) === t;
  },
  float: function(t) {
    return rs.number(t) && !rs.integer(t);
  },
  array: function(t) {
    return Array.isArray(t);
  },
  regexp: function(t) {
    if (t instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(t);
    } catch {
      return !1;
    }
  },
  date: function(t) {
    return typeof t.getTime == "function" && typeof t.getMonth == "function" && typeof t.getYear == "function" && !isNaN(t.getTime());
  },
  number: function(t) {
    return isNaN(t) ? !1 : typeof t == "number";
  },
  object: function(t) {
    return typeof t == "object" && !rs.array(t);
  },
  method: function(t) {
    return typeof t == "function";
  },
  email: function(t) {
    return typeof t == "string" && t.length <= 320 && !!t.match(VC.email);
  },
  url: function(t) {
    return typeof t == "string" && t.length <= 2048 && !!t.match(TK());
  },
  hex: function(t) {
    return typeof t == "string" && !!t.match(VC.hex);
  }
}, MK = function(t, n, o, r, l) {
  if (t.required && n === void 0) {
    SP(t, n, o, r, l);
    return;
  }
  var a = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], i = t.type;
  a.indexOf(i) > -1 ? rs[i](n) || r.push(wo(l.messages.types[i], t.fullField, t.type)) : i && typeof n !== t.type && r.push(wo(l.messages.types[i], t.fullField, t.type));
}, _K = function(t, n, o, r, l) {
  var a = typeof t.len == "number", i = typeof t.min == "number", s = typeof t.max == "number", c = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, u = n, d = null, p = typeof n == "number", v = typeof n == "string", h = Array.isArray(n);
  if (p ? d = "number" : v ? d = "string" : h && (d = "array"), !d)
    return !1;
  h && (u = n.length), v && (u = n.replace(c, "_").length), a ? u !== t.len && r.push(wo(l.messages[d].len, t.fullField, t.len)) : i && !s && u < t.min ? r.push(wo(l.messages[d].min, t.fullField, t.min)) : s && !i && u > t.max ? r.push(wo(l.messages[d].max, t.fullField, t.max)) : i && s && (u < t.min || u > t.max) && r.push(wo(l.messages[d].range, t.fullField, t.min, t.max));
}, Da = "enum", AK = function(t, n, o, r, l) {
  t[Da] = Array.isArray(t[Da]) ? t[Da] : [], t[Da].indexOf(n) === -1 && r.push(wo(l.messages[Da], t.fullField, t[Da].join(", ")));
}, DK = function(t, n, o, r, l) {
  if (t.pattern) {
    if (t.pattern instanceof RegExp)
      t.pattern.lastIndex = 0, t.pattern.test(n) || r.push(wo(l.messages.pattern.mismatch, t.fullField, n, t.pattern));
    else if (typeof t.pattern == "string") {
      var a = new RegExp(t.pattern);
      a.test(n) || r.push(wo(l.messages.pattern.mismatch, t.fullField, n, t.pattern));
    }
  }
}, Tt = {
  required: SP,
  whitespace: EK,
  type: MK,
  range: _K,
  enum: AK,
  pattern: DK
}, NK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n, "string") && !t.required)
      return o();
    Tt.required(t, n, r, a, l, "string"), Cn(n, "string") || (Tt.type(t, n, r, a, l), Tt.range(t, n, r, a, l), Tt.pattern(t, n, r, a, l), t.whitespace === !0 && Tt.whitespace(t, n, r, a, l));
  }
  o(a);
}, RK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n) && !t.required)
      return o();
    Tt.required(t, n, r, a, l), n !== void 0 && Tt.type(t, n, r, a, l);
  }
  o(a);
}, kK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (n === "" && (n = void 0), Cn(n) && !t.required)
      return o();
    Tt.required(t, n, r, a, l), n !== void 0 && (Tt.type(t, n, r, a, l), Tt.range(t, n, r, a, l));
  }
  o(a);
}, BK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n) && !t.required)
      return o();
    Tt.required(t, n, r, a, l), n !== void 0 && Tt.type(t, n, r, a, l);
  }
  o(a);
}, FK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n) && !t.required)
      return o();
    Tt.required(t, n, r, a, l), Cn(n) || Tt.type(t, n, r, a, l);
  }
  o(a);
}, LK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n) && !t.required)
      return o();
    Tt.required(t, n, r, a, l), n !== void 0 && (Tt.type(t, n, r, a, l), Tt.range(t, n, r, a, l));
  }
  o(a);
}, zK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n) && !t.required)
      return o();
    Tt.required(t, n, r, a, l), n !== void 0 && (Tt.type(t, n, r, a, l), Tt.range(t, n, r, a, l));
  }
  o(a);
}, HK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (n == null && !t.required)
      return o();
    Tt.required(t, n, r, a, l, "array"), n != null && (Tt.type(t, n, r, a, l), Tt.range(t, n, r, a, l));
  }
  o(a);
}, jK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n) && !t.required)
      return o();
    Tt.required(t, n, r, a, l), n !== void 0 && Tt.type(t, n, r, a, l);
  }
  o(a);
}, VK = "enum", WK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n) && !t.required)
      return o();
    Tt.required(t, n, r, a, l), n !== void 0 && Tt[VK](t, n, r, a, l);
  }
  o(a);
}, KK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n, "string") && !t.required)
      return o();
    Tt.required(t, n, r, a, l), Cn(n, "string") || Tt.pattern(t, n, r, a, l);
  }
  o(a);
}, GK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n, "date") && !t.required)
      return o();
    if (Tt.required(t, n, r, a, l), !Cn(n, "date")) {
      var s;
      n instanceof Date ? s = n : s = new Date(n), Tt.type(t, s, r, a, l), s && Tt.range(t, s.getTime(), r, a, l);
    }
  }
  o(a);
}, XK = function(t, n, o, r, l) {
  var a = [], i = Array.isArray(n) ? "array" : typeof n;
  Tt.required(t, n, r, a, l, i), o(a);
}, Pv = function(t, n, o, r, l) {
  var a = t.type, i = [], s = t.required || !t.required && r.hasOwnProperty(t.field);
  if (s) {
    if (Cn(n, a) && !t.required)
      return o();
    Tt.required(t, n, r, i, l, a), Cn(n, a) || Tt.type(t, n, r, i, l);
  }
  o(i);
}, UK = function(t, n, o, r, l) {
  var a = [], i = t.required || !t.required && r.hasOwnProperty(t.field);
  if (i) {
    if (Cn(n) && !t.required)
      return o();
    Tt.required(t, n, r, a, l);
  }
  o(a);
}, Cs = {
  string: NK,
  method: RK,
  number: kK,
  boolean: BK,
  regexp: FK,
  integer: LK,
  float: zK,
  array: HK,
  object: jK,
  enum: WK,
  pattern: KK,
  date: GK,
  url: Pv,
  hex: Pv,
  email: Pv,
  required: XK,
  any: UK
};
function mm() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var t = JSON.parse(JSON.stringify(this));
      return t.clone = this.clone, t;
    }
  };
}
var hm = mm(), yc = /* @__PURE__ */ function() {
  function e(n) {
    this.rules = null, this._messages = hm, this.define(n);
  }
  var t = e.prototype;
  return t.define = function(o) {
    var r = this;
    if (!o)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof o != "object" || Array.isArray(o))
      throw new Error("Rules must be an object");
    this.rules = {}, Object.keys(o).forEach(function(l) {
      var a = o[l];
      r.rules[l] = Array.isArray(a) ? a : [a];
    });
  }, t.messages = function(o) {
    return o && (this._messages = jC(mm(), o)), this._messages;
  }, t.validate = function(o, r, l) {
    var a = this;
    r === void 0 && (r = {}), l === void 0 && (l = function() {
    });
    var i = o, s = r, c = l;
    if (typeof s == "function" && (c = s, s = {}), !this.rules || Object.keys(this.rules).length === 0)
      return c && c(null, i), Promise.resolve(i);
    function u(g) {
      var b = [], y = {};
      function S(w) {
        if (Array.isArray(w)) {
          var $;
          b = ($ = b).concat.apply($, w);
        } else
          b.push(w);
      }
      for (var C = 0; C < g.length; C++)
        S(g[C]);
      b.length ? (y = gm(b), c(b, y)) : c(null, i);
    }
    if (s.messages) {
      var d = this.messages();
      d === hm && (d = mm()), jC(d, s.messages), s.messages = d;
    } else
      s.messages = this.messages();
    var p = {}, v = s.keys || Object.keys(this.rules);
    v.forEach(function(g) {
      var b = a.rules[g], y = i[g];
      b.forEach(function(S) {
        var C = S;
        typeof C.transform == "function" && (i === o && (i = Yl({}, i)), y = i[g] = C.transform(y)), typeof C == "function" ? C = {
          validator: C
        } : C = Yl({}, C), C.validator = a.getValidationMethod(C), C.validator && (C.field = g, C.fullField = C.fullField || g, C.type = a.getType(C), p[g] = p[g] || [], p[g].push({
          rule: C,
          value: y,
          source: i,
          field: g
        }));
      });
    });
    var h = {};
    return OK(p, s, function(g, b) {
      var y = g.rule, S = (y.type === "object" || y.type === "array") && (typeof y.fields == "object" || typeof y.defaultField == "object");
      S = S && (y.required || !y.required && g.value), y.field = g.field;
      function C(O, x) {
        return Yl({}, x, {
          fullField: y.fullField + "." + O,
          fullFields: y.fullFields ? [].concat(y.fullFields, [O]) : [O]
        });
      }
      function w(O) {
        O === void 0 && (O = []);
        var x = Array.isArray(O) ? O : [O];
        !s.suppressWarning && x.length && e.warning("async-validator:", x), x.length && y.message !== void 0 && (x = [].concat(y.message));
        var I = x.map(HC(y, i));
        if (s.first && I.length)
          return h[y.field] = 1, b(I);
        if (!S)
          b(I);
        else {
          if (y.required && !g.value)
            return y.message !== void 0 ? I = [].concat(y.message).map(HC(y, i)) : s.error && (I = [s.error(y, wo(s.messages.required, y.field))]), b(I);
          var E = {};
          y.defaultField && Object.keys(g.value).map(function(R) {
            E[R] = y.defaultField;
          }), E = Yl({}, E, g.rule.fields);
          var _ = {};
          Object.keys(E).forEach(function(R) {
            var A = E[R], z = Array.isArray(A) ? A : [A];
            _[R] = z.map(C.bind(null, R));
          });
          var M = new e(_);
          M.messages(s.messages), g.rule.options && (g.rule.options.messages = s.messages, g.rule.options.error = s.error), M.validate(g.value, g.rule.options || s, function(R) {
            var A = [];
            I && I.length && A.push.apply(A, I), R && R.length && A.push.apply(A, R), b(A.length ? A : null);
          });
        }
      }
      var $;
      if (y.asyncValidator)
        $ = y.asyncValidator(y, g.value, w, g.source, s);
      else if (y.validator) {
        try {
          $ = y.validator(y, g.value, w, g.source, s);
        } catch (O) {
          console.error == null || console.error(O), s.suppressValidatorError || setTimeout(function() {
            throw O;
          }, 0), w(O.message);
        }
        $ === !0 ? w() : $ === !1 ? w(typeof y.message == "function" ? y.message(y.fullField || y.field) : y.message || (y.fullField || y.field) + " fails") : $ instanceof Array ? w($) : $ instanceof Error && w($.message);
      }
      $ && $.then && $.then(function() {
        return w();
      }, function(O) {
        return w(O);
      });
    }, function(g) {
      u(g);
    }, i);
  }, t.getType = function(o) {
    if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !Cs.hasOwnProperty(o.type))
      throw new Error(wo("Unknown rule type %s", o.type));
    return o.type || "string";
  }, t.getValidationMethod = function(o) {
    if (typeof o.validator == "function")
      return o.validator;
    var r = Object.keys(o), l = r.indexOf("message");
    return l !== -1 && r.splice(l, 1), r.length === 1 && r[0] === "required" ? Cs.required : Cs[this.getType(o)] || void 0;
  }, e;
}();
yc.register = function(t, n) {
  if (typeof n != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  Cs[t] = n;
};
yc.warning = yP;
yc.messages = hm;
yc.validators = Cs;
function hl(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function CP(e, t) {
  let n = e;
  for (let o = 0; o < t.length; o += 1) {
    if (n == null)
      return;
    n = n[t[o]];
  }
  return n;
}
function $P(e, t, n, o) {
  if (!t.length)
    return n;
  const [r, ...l] = t;
  let a;
  return !e && typeof r == "number" ? a = [] : Array.isArray(e) ? a = [...e] : a = m({}, e), o && n === void 0 && l.length === 1 ? delete a[r][l[0]] : a[r] = $P(a[r], l, n, o), a;
}
function YK(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return t.length && o && n === void 0 && !CP(e, t.slice(0, -1)) ? e : $P(e, t, n, o);
}
function bm(e) {
  return hl(e);
}
function qK(e, t) {
  return CP(e, t);
}
function ZK(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  return YK(e, t, n, o);
}
function QK(e, t) {
  return e && e.some((n) => eG(n, t));
}
function WC(e) {
  return typeof e == "object" && e !== null && Object.getPrototypeOf(e) === Object.prototype;
}
function wP(e, t) {
  const n = Array.isArray(e) ? [...e] : m({}, e);
  return t && Object.keys(t).forEach((o) => {
    const r = n[o], l = t[o], a = WC(r) && WC(l);
    n[o] = a ? wP(r, l || {}) : l;
  }), n;
}
function JK(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  return n.reduce((r, l) => wP(r, l), e);
}
function KC(e, t) {
  let n = {};
  return t.forEach((o) => {
    const r = qK(e, o);
    n = ZK(n, o, r);
  }), n;
}
function eG(e, t) {
  return !e || !t || e.length !== t.length ? !1 : e.every((n, o) => t[o] === n);
}
const mo = "'${name}' is not a valid ${type}", pp = {
  default: "Validation error on field '${name}'",
  required: "'${name}' is required",
  enum: "'${name}' must be one of [${enum}]",
  whitespace: "'${name}' cannot be empty",
  date: {
    format: "'${name}' is invalid for format date",
    parse: "'${name}' could not be parsed as date",
    invalid: "'${name}' is invalid date"
  },
  types: {
    string: mo,
    method: mo,
    array: mo,
    object: mo,
    number: mo,
    date: mo,
    boolean: mo,
    integer: mo,
    float: mo,
    regexp: mo,
    email: mo,
    url: mo,
    hex: mo
  },
  string: {
    len: "'${name}' must be exactly ${len} characters",
    min: "'${name}' must be at least ${min} characters",
    max: "'${name}' cannot be longer than ${max} characters",
    range: "'${name}' must be between ${min} and ${max} characters"
  },
  number: {
    len: "'${name}' must equal ${len}",
    min: "'${name}' cannot be less than ${min}",
    max: "'${name}' cannot be greater than ${max}",
    range: "'${name}' must be between ${min} and ${max}"
  },
  array: {
    len: "'${name}' must be exactly ${len} in length",
    min: "'${name}' cannot be less than ${min} in length",
    max: "'${name}' cannot be greater than ${max} in length",
    range: "'${name}' must be between ${min} and ${max} in length"
  },
  pattern: {
    mismatch: "'${name}' does not match pattern ${pattern}"
  }
};
var vp = function(e, t, n, o) {
  function r(l) {
    return l instanceof n ? l : new n(function(a) {
      a(l);
    });
  }
  return new (n || (n = Promise))(function(l, a) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (d) {
        a(d);
      }
    }
    function s(u) {
      try {
        c(o.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? l(u.value) : r(u.value).then(i, s);
    }
    c((o = o.apply(e, t || [])).next());
  });
};
const tG = yc;
function nG(e, t) {
  return e.replace(/\$\{\w+\}/g, (n) => {
    const o = n.slice(2, -1);
    return t[o];
  });
}
function ym(e, t, n, o, r) {
  return vp(this, void 0, void 0, function* () {
    const l = m({}, n);
    delete l.ruleIndex, delete l.trigger;
    let a = null;
    l && l.type === "array" && l.defaultField && (a = l.defaultField, delete l.defaultField);
    const i = new tG({
      [e]: [l]
    }), s = JK({}, pp, o.validateMessages);
    i.messages(s);
    let c = [];
    try {
      yield Promise.resolve(i.validate({
        [e]: t
      }, m({}, o)));
    } catch (p) {
      p.errors ? c = p.errors.map((v, h) => {
        let {
          message: g
        } = v;
        return (
          // Wrap VueNode with `key`
          Gt(g) ? tr(g, {
            key: `error_${h}`
          }) : g
        );
      }) : (console.error(p), c = [s.default()]);
    }
    if (!c.length && a)
      return (yield Promise.all(t.map((v, h) => ym(`${e}.${h}`, v, a, o, r)))).reduce((v, h) => [...v, ...h], []);
    const u = m(m(m({}, n), {
      name: e,
      enum: (n.enum || []).join(", ")
    }), r);
    return c.map((p) => typeof p == "string" ? nG(p, u) : p);
  });
}
function xP(e, t, n, o, r, l) {
  const a = e.join("."), i = n.map((c, u) => {
    const d = c.validator, p = m(m({}, c), {
      ruleIndex: u
    });
    return d && (p.validator = (v, h, g) => {
      let b = !1;
      const S = d(v, h, function() {
        for (var C = arguments.length, w = new Array(C), $ = 0; $ < C; $++)
          w[$] = arguments[$];
        Promise.resolve().then(() => {
          ct(!b, "Your validator function has already return a promise. `callback` will be ignored."), b || g(...w);
        });
      });
      b = S && typeof S.then == "function" && typeof S.catch == "function", ct(b, "`callback` is deprecated. Please return a promise instead."), b && S.then(() => {
        g();
      }).catch((C) => {
        g(C || " ");
      });
    }), p;
  }).sort((c, u) => {
    let {
      warningOnly: d,
      ruleIndex: p
    } = c, {
      warningOnly: v,
      ruleIndex: h
    } = u;
    return !!d == !!v ? p - h : d ? 1 : -1;
  });
  let s;
  if (r === !0)
    s = new Promise((c, u) => vp(this, void 0, void 0, function* () {
      for (let d = 0; d < i.length; d += 1) {
        const p = i[d], v = yield ym(a, t, p, o, l);
        if (v.length) {
          u([{
            errors: v,
            rule: p
          }]);
          return;
        }
      }
      c([]);
    }));
  else {
    const c = i.map((u) => ym(a, t, u, o, l).then((d) => ({
      errors: d,
      rule: u
    })));
    s = (r ? rG(c) : oG(c)).then((u) => Promise.reject(u));
  }
  return s.catch((c) => c), s;
}
function oG(e) {
  return vp(this, void 0, void 0, function* () {
    return Promise.all(e).then((t) => [].concat(...t));
  });
}
function rG(e) {
  return vp(this, void 0, void 0, function* () {
    let t = 0;
    return new Promise((n) => {
      e.forEach((o) => {
        o.then((r) => {
          r.errors.length && n([r]), t += 1, t === e.length && n([]);
        });
      });
    });
  });
}
const OP = Symbol("formContextKey"), PP = (e) => {
  Je(OP, e);
}, lb = () => tt(OP, {
  name: P(() => {
  }),
  labelAlign: P(() => "right"),
  vertical: P(() => !1),
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  addField: (e, t) => {
  },
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  removeField: (e) => {
  },
  model: P(() => {
  }),
  rules: P(() => {
  }),
  colon: P(() => {
  }),
  labelWrap: P(() => {
  }),
  labelCol: P(() => {
  }),
  requiredMark: P(() => !1),
  validateTrigger: P(() => {
  }),
  onValidate: () => {
  },
  validateMessages: P(() => pp)
}), IP = Symbol("formItemPrefixContextKey"), lG = (e) => {
  Je(IP, e);
}, aG = () => tt(IP, {
  prefixCls: P(() => "")
});
function iG(e) {
  return typeof e == "number" ? `${e} ${e} auto` : /^\d+(\.\d+)?(px|em|rem|%)$/.test(e) ? `0 0 ${e}` : e;
}
const sG = () => ({
  span: [String, Number],
  order: [String, Number],
  offset: [String, Number],
  push: [String, Number],
  pull: [String, Number],
  xs: {
    type: [String, Number, Object],
    default: void 0
  },
  sm: {
    type: [String, Number, Object],
    default: void 0
  },
  md: {
    type: [String, Number, Object],
    default: void 0
  },
  lg: {
    type: [String, Number, Object],
    default: void 0
  },
  xl: {
    type: [String, Number, Object],
    default: void 0
  },
  xxl: {
    type: [String, Number, Object],
    default: void 0
  },
  prefixCls: String,
  flex: [String, Number]
}), cG = ["xs", "sm", "md", "lg", "xl", "xxl"], gp = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACol",
  inheritAttrs: !1,
  props: sG(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      gutter: r,
      supportFlexGap: l,
      wrap: a
    } = uK(), {
      prefixCls: i,
      direction: s
    } = Ie("col", e), [c, u] = mK(i), d = P(() => {
      const {
        span: v,
        order: h,
        offset: g,
        push: b,
        pull: y
      } = e, S = i.value;
      let C = {};
      return cG.forEach((w) => {
        let $ = {};
        const O = e[w];
        typeof O == "number" ? $.span = O : typeof O == "object" && ($ = O || {}), C = m(m({}, C), {
          [`${S}-${w}-${$.span}`]: $.span !== void 0,
          [`${S}-${w}-order-${$.order}`]: $.order || $.order === 0,
          [`${S}-${w}-offset-${$.offset}`]: $.offset || $.offset === 0,
          [`${S}-${w}-push-${$.push}`]: $.push || $.push === 0,
          [`${S}-${w}-pull-${$.pull}`]: $.pull || $.pull === 0,
          [`${S}-rtl`]: s.value === "rtl"
        });
      }), ee(S, {
        [`${S}-${v}`]: v !== void 0,
        [`${S}-order-${h}`]: h,
        [`${S}-offset-${g}`]: g,
        [`${S}-push-${b}`]: b,
        [`${S}-pull-${y}`]: y
      }, C, o.class, u.value);
    }), p = P(() => {
      const {
        flex: v
      } = e, h = r.value, g = {};
      if (h && h[0] > 0) {
        const b = `${h[0] / 2}px`;
        g.paddingLeft = b, g.paddingRight = b;
      }
      if (h && h[1] > 0 && !l.value) {
        const b = `${h[1] / 2}px`;
        g.paddingTop = b, g.paddingBottom = b;
      }
      return v && (g.flex = iG(v), a.value === !1 && !g.minWidth && (g.minWidth = 0)), g;
    });
    return () => {
      var v;
      return c(f("div", D(D({}, o), {}, {
        class: d.value,
        style: [p.value, o.style]
      }), [(v = n.default) === null || v === void 0 ? void 0 : v.call(n)]));
    };
  }
});
var uG = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M623.6 316.7C593.6 290.4 554 276 512 276s-81.6 14.5-111.6 40.7C369.2 344 352 380.7 352 420v7.6c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V420c0-44.1 43.1-80 96-80s96 35.9 96 80c0 31.1-22 59.6-56.1 72.7-21.2 8.1-39.2 22.3-52.1 40.9-13.1 19-19.9 41.8-19.9 64.9V620c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8v-22.7a48.3 48.3 0 0130.9-44.8c59-22.7 97.1-74.7 97.1-132.5.1-39.3-17.1-76-48.3-103.3zM472 732a40 40 0 1080 0 40 40 0 10-80 0z" } }] }, name: "question-circle", theme: "outlined" };
function GC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      dG(e, r, n[r]);
    });
  }
  return e;
}
function dG(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ab = function(t, n) {
  var o = GC({}, t, n.attrs);
  return f(Ge, GC({}, o, {
    icon: uG
  }), null);
};
ab.displayName = "QuestionCircleOutlined";
ab.inheritAttrs = !1;
const ib = (e, t) => {
  let {
    slots: n,
    emit: o,
    attrs: r
  } = t;
  var l, a, i, s, c;
  const {
    prefixCls: u,
    htmlFor: d,
    labelCol: p,
    labelAlign: v,
    colon: h,
    required: g,
    requiredMark: b
  } = m(m({}, e), r), [y] = jo("Form"), S = (l = e.label) !== null && l !== void 0 ? l : (a = n.label) === null || a === void 0 ? void 0 : a.call(n);
  if (!S)
    return null;
  const {
    vertical: C,
    labelAlign: w,
    labelCol: $,
    labelWrap: O,
    colon: x
  } = lb(), I = p || ($ == null ? void 0 : $.value) || {}, E = v || (w == null ? void 0 : w.value), _ = `${u}-item-label`, M = ee(_, E === "left" && `${_}-left`, I.class, {
    [`${_}-wrap`]: !!O.value
  });
  let R = S;
  const A = h === !0 || (x == null ? void 0 : x.value) !== !1 && h !== !1;
  if (A && !C.value && typeof S == "string" && S.trim() !== "" && (R = S.replace(/[:|：]\s*$/, "")), e.tooltip || n.tooltip) {
    const N = f("span", {
      class: `${u}-item-tooltip`
    }, [f(Ln, {
      title: e.tooltip
    }, {
      default: () => [f(ab, null, null)]
    })]);
    R = f(Fe, null, [R, n.tooltip ? (i = n.tooltip) === null || i === void 0 ? void 0 : i.call(n, {
      class: `${u}-item-tooltip`
    }) : N]);
  }
  b === "optional" && !g && (R = f(Fe, null, [R, f("span", {
    class: `${u}-item-optional`
  }, [((s = y.value) === null || s === void 0 ? void 0 : s.optional) || ((c = Zn.Form) === null || c === void 0 ? void 0 : c.optional)])]));
  const T = ee({
    [`${u}-item-required`]: g,
    [`${u}-item-required-mark-optional`]: b === "optional",
    [`${u}-item-no-colon`]: !A
  });
  return f(gp, D(D({}, I), {}, {
    class: M
  }), {
    default: () => [f("label", {
      for: d,
      class: T,
      title: typeof S == "string" ? S : "",
      onClick: (N) => o("click", N)
    }, [R])]
  });
};
ib.displayName = "FormItemLabel";
ib.inheritAttrs = !1;
const fG = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-show-help`, o = `${t}-show-help-item`;
  return {
    [n]: {
      // Explain holder
      transition: `opacity ${e.motionDurationSlow} ${e.motionEaseInOut}`,
      "&-appear, &-enter": {
        opacity: 0,
        "&-active": {
          opacity: 1
        }
      },
      "&-leave": {
        opacity: 1,
        "&-active": {
          opacity: 0
        }
      },
      // Explain
      [o]: {
        overflow: "hidden",
        transition: `height ${e.motionDurationSlow} ${e.motionEaseInOut},
                     opacity ${e.motionDurationSlow} ${e.motionEaseInOut},
                     transform ${e.motionDurationSlow} ${e.motionEaseInOut} !important`,
        [`&${o}-appear, &${o}-enter`]: {
          transform: "translateY(-5px)",
          opacity: 0,
          "&-active": {
            transform: "translateY(0)",
            opacity: 1
          }
        },
        [`&${o}-leave-active`]: {
          transform: "translateY(-5px)"
        }
      }
    }
  };
}, pG = (e) => ({
  legend: {
    display: "block",
    width: "100%",
    marginBottom: e.marginLG,
    padding: 0,
    color: e.colorTextDescription,
    fontSize: e.fontSizeLG,
    lineHeight: "inherit",
    border: 0,
    borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`
  },
  label: {
    fontSize: e.fontSize
  },
  'input[type="search"]': {
    boxSizing: "border-box"
  },
  // Position radios and checkboxes better
  'input[type="radio"], input[type="checkbox"]': {
    lineHeight: "normal"
  },
  'input[type="file"]': {
    display: "block"
  },
  // Make range inputs behave like textual form controls
  'input[type="range"]': {
    display: "block",
    width: "100%"
  },
  // Make multiple select elements height not fixed
  "select[multiple], select[size]": {
    height: "auto"
  },
  // Focus for file, radio, and checkbox
  "input[type='file']:focus,\n  input[type='radio']:focus,\n  input[type='checkbox']:focus": {
    outline: 0,
    boxShadow: `0 0 0 ${e.controlOutlineWidth}px ${e.controlOutline}`
  },
  // Adjust output element
  output: {
    display: "block",
    paddingTop: 15,
    color: e.colorText,
    fontSize: e.fontSize,
    lineHeight: e.lineHeight
  }
}), XC = (e, t) => {
  const {
    formItemCls: n
  } = e;
  return {
    [n]: {
      [`${n}-label > label`]: {
        height: t
      },
      [`${n}-control-input`]: {
        minHeight: t
      }
    }
  };
}, vG = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [e.componentCls]: m(m(m({}, qe(e)), pG(e)), {
      [`${t}-text`]: {
        display: "inline-block",
        paddingInlineEnd: e.paddingSM
      },
      // ================================================================
      // =                             Size                             =
      // ================================================================
      "&-small": m({}, XC(e, e.controlHeightSM)),
      "&-large": m({}, XC(e, e.controlHeightLG))
    })
  };
}, gG = (e) => {
  const {
    formItemCls: t,
    iconCls: n,
    componentCls: o,
    rootPrefixCls: r
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      marginBottom: e.marginLG,
      verticalAlign: "top",
      "&-with-help": {
        transition: "none"
      },
      [`&-hidden,
        &-hidden.${r}-row`]: {
        // https://github.com/ant-design/ant-design/issues/26141
        display: "none"
      },
      "&-has-warning": {
        [`${t}-split`]: {
          color: e.colorError
        }
      },
      "&-has-error": {
        [`${t}-split`]: {
          color: e.colorWarning
        }
      },
      // ==============================================================
      // =                            Label                           =
      // ==============================================================
      [`${t}-label`]: {
        display: "inline-block",
        flexGrow: 0,
        overflow: "hidden",
        whiteSpace: "nowrap",
        textAlign: "end",
        verticalAlign: "middle",
        "&-left": {
          textAlign: "start"
        },
        "&-wrap": {
          overflow: "unset",
          lineHeight: `${e.lineHeight} - 0.25em`,
          whiteSpace: "unset"
        },
        "> label": {
          position: "relative",
          display: "inline-flex",
          alignItems: "center",
          maxWidth: "100%",
          height: e.controlHeight,
          color: e.colorTextHeading,
          fontSize: e.fontSize,
          [`> ${n}`]: {
            fontSize: e.fontSize,
            verticalAlign: "top"
          },
          // Required mark
          [`&${t}-required:not(${t}-required-mark-optional)::before`]: {
            display: "inline-block",
            marginInlineEnd: e.marginXXS,
            color: e.colorError,
            fontSize: e.fontSize,
            fontFamily: "SimSun, sans-serif",
            lineHeight: 1,
            content: '"*"',
            [`${o}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${t}-optional`]: {
            display: "inline-block",
            marginInlineStart: e.marginXXS,
            color: e.colorTextDescription,
            [`${o}-hide-required-mark &`]: {
              display: "none"
            }
          },
          // Optional mark
          [`${t}-tooltip`]: {
            color: e.colorTextDescription,
            cursor: "help",
            writingMode: "horizontal-tb",
            marginInlineStart: e.marginXXS
          },
          "&::after": {
            content: '":"',
            position: "relative",
            marginBlock: 0,
            marginInlineStart: e.marginXXS / 2,
            marginInlineEnd: e.marginXS
          },
          [`&${t}-no-colon::after`]: {
            content: '" "'
          }
        }
      },
      // ==============================================================
      // =                            Input                           =
      // ==============================================================
      [`${t}-control`]: {
        display: "flex",
        flexDirection: "column",
        flexGrow: 1,
        [`&:first-child:not([class^="'${r}-col-'"]):not([class*="' ${r}-col-'"])`]: {
          width: "100%"
        },
        "&-input": {
          position: "relative",
          display: "flex",
          alignItems: "center",
          minHeight: e.controlHeight,
          "&-content": {
            flex: "auto",
            maxWidth: "100%"
          }
        }
      },
      // ==============================================================
      // =                           Explain                          =
      // ==============================================================
      [t]: {
        "&-explain, &-extra": {
          clear: "both",
          color: e.colorTextDescription,
          fontSize: e.fontSize,
          lineHeight: e.lineHeight
        },
        "&-explain-connected": {
          width: "100%"
        },
        "&-extra": {
          minHeight: e.controlHeightSM,
          transition: `color ${e.motionDurationMid} ${e.motionEaseOut}`
          // sync input color transition
        },
        "&-explain": {
          "&-error": {
            color: e.colorError
          },
          "&-warning": {
            color: e.colorWarning
          }
        }
      },
      [`&-with-help ${t}-explain`]: {
        height: "auto",
        opacity: 1
      },
      // ==============================================================
      // =                        Feedback Icon                       =
      // ==============================================================
      [`${t}-feedback-icon`]: {
        fontSize: e.fontSize,
        textAlign: "center",
        visibility: "visible",
        animationName: a0,
        animationDuration: e.motionDurationMid,
        animationTimingFunction: e.motionEaseOutBack,
        pointerEvents: "none",
        "&-success": {
          color: e.colorSuccess
        },
        "&-error": {
          color: e.colorError
        },
        "&-warning": {
          color: e.colorWarning
        },
        "&-validating": {
          color: e.colorPrimary
        }
      }
    })
  };
}, mG = (e) => {
  const {
    componentCls: t,
    formItemCls: n,
    rootPrefixCls: o
  } = e;
  return {
    [`${t}-horizontal`]: {
      [`${n}-label`]: {
        flexGrow: 0
      },
      [`${n}-control`]: {
        flex: "1 1 0",
        // https://github.com/ant-design/ant-design/issues/32777
        // https://github.com/ant-design/ant-design/issues/33773
        minWidth: 0
      },
      // https://github.com/ant-design/ant-design/issues/32980
      [`${n}-label.${o}-col-24 + ${n}-control`]: {
        minWidth: "unset"
      }
    }
  };
}, hG = (e) => {
  const {
    componentCls: t,
    formItemCls: n
  } = e;
  return {
    [`${t}-inline`]: {
      display: "flex",
      flexWrap: "wrap",
      [n]: {
        flex: "none",
        flexWrap: "nowrap",
        marginInlineEnd: e.margin,
        marginBottom: 0,
        "&-with-help": {
          marginBottom: e.marginLG
        },
        [`> ${n}-label,
        > ${n}-control`]: {
          display: "inline-block",
          verticalAlign: "top"
        },
        [`> ${n}-label`]: {
          flex: "none"
        },
        [`${t}-text`]: {
          display: "inline-block"
        },
        [`${n}-has-feedback`]: {
          display: "inline-block"
        }
      }
    }
  };
}, ja = (e) => ({
  margin: 0,
  padding: `0 0 ${e.paddingXS}px`,
  whiteSpace: "initial",
  textAlign: "start",
  "> label": {
    margin: 0,
    "&::after": {
      display: "none"
    }
  }
}), bG = (e) => {
  const {
    componentCls: t,
    formItemCls: n
  } = e;
  return {
    [`${n} ${n}-label`]: ja(e),
    [t]: {
      [n]: {
        flexWrap: "wrap",
        [`${n}-label,
          ${n}-control`]: {
          flex: "0 0 100%",
          maxWidth: "100%"
        }
      }
    }
  };
}, yG = (e) => {
  const {
    componentCls: t,
    formItemCls: n,
    rootPrefixCls: o
  } = e;
  return {
    [`${t}-vertical`]: {
      [n]: {
        "&-row": {
          flexDirection: "column"
        },
        "&-label > label": {
          height: "auto"
        },
        [`${t}-item-control`]: {
          width: "100%"
        }
      }
    },
    [`${t}-vertical ${n}-label,
      .${o}-col-24${n}-label,
      .${o}-col-xl-24${n}-label`]: ja(e),
    [`@media (max-width: ${e.screenXSMax}px)`]: [bG(e), {
      [t]: {
        [`.${o}-col-xs-24${n}-label`]: ja(e)
      }
    }],
    [`@media (max-width: ${e.screenSMMax}px)`]: {
      [t]: {
        [`.${o}-col-sm-24${n}-label`]: ja(e)
      }
    },
    [`@media (max-width: ${e.screenMDMax}px)`]: {
      [t]: {
        [`.${o}-col-md-24${n}-label`]: ja(e)
      }
    },
    [`@media (max-width: ${e.screenLGMax}px)`]: {
      [t]: {
        [`.${o}-col-lg-24${n}-label`]: ja(e)
      }
    }
  };
}, sb = Xe("Form", (e, t) => {
  let {
    rootPrefixCls: n
  } = t;
  const o = He(e, {
    formItemCls: `${e.componentCls}-item`,
    rootPrefixCls: n
  });
  return [vG(o), gG(o), fG(o), mG(o), hG(o), yG(o), cc(o), a0];
}), SG = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ErrorList",
  inheritAttrs: !1,
  props: ["errors", "help", "onErrorVisibleChanged", "helpStatus", "warnings"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const {
      prefixCls: o,
      status: r
    } = aG(), l = P(() => `${o.value}-item-explain`), a = P(() => !!(e.errors && e.errors.length)), i = Y(r.value), [, s] = sb(o);
    return ie([a, r], () => {
      a.value && (i.value = r.value);
    }), () => {
      var c, u;
      const d = dc(`${o.value}-show-help-item`), p = Nf(`${o.value}-show-help-item`, d);
      return p.role = "alert", p.class = [s.value, l.value, n.class, `${o.value}-show-help`], f(yn, D(D({}, Ho(`${o.value}-show-help`)), {}, {
        onAfterEnter: () => e.onErrorVisibleChanged(!0),
        onAfterLeave: () => e.onErrorVisibleChanged(!1)
      }), {
        default: () => [Tn(f(gf, D(D({}, p), {}, {
          tag: "div"
        }), {
          default: () => [(u = e.errors) === null || u === void 0 ? void 0 : u.map((v, h) => f("div", {
            key: h,
            class: i.value ? `${l.value}-${i.value}` : ""
          }, [v]))]
        }), [[Hn, !!(!((c = e.errors) === null || c === void 0) && c.length)]])]
      });
    };
  }
}), CG = Z({
  compatConfig: {
    MODE: 3
  },
  slots: Object,
  inheritAttrs: !1,
  props: ["prefixCls", "errors", "hasFeedback", "onDomErrorVisibleChange", "wrapperCol", "help", "extra", "status", "marginBottom", "onErrorVisibleChanged"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = lb(), {
      wrapperCol: r
    } = o, l = m({}, o);
    return delete l.labelCol, delete l.wrapperCol, PP(l), lG({
      prefixCls: P(() => e.prefixCls),
      status: P(() => e.status)
    }), () => {
      var a, i, s;
      const {
        prefixCls: c,
        wrapperCol: u,
        marginBottom: d,
        onErrorVisibleChanged: p,
        help: v = (a = n.help) === null || a === void 0 ? void 0 : a.call(n),
        errors: h = Lt((i = n.errors) === null || i === void 0 ? void 0 : i.call(n)),
        // hasFeedback,
        // status,
        extra: g = (s = n.extra) === null || s === void 0 ? void 0 : s.call(n)
      } = e, b = `${c}-item`, y = u || (r == null ? void 0 : r.value) || {}, S = ee(`${b}-control`, y.class);
      return f(gp, D(D({}, y), {}, {
        class: S
      }), {
        default: () => {
          var C;
          return f(Fe, null, [f("div", {
            class: `${b}-control-input`
          }, [f("div", {
            class: `${b}-control-input-content`
          }, [(C = n.default) === null || C === void 0 ? void 0 : C.call(n)])]), d !== null || h.length ? f("div", {
            style: {
              display: "flex",
              flexWrap: "nowrap"
            }
          }, [f(SG, {
            errors: h,
            help: v,
            class: `${b}-explain-connected`,
            onErrorVisibleChanged: p
          }, null), !!d && f("div", {
            style: {
              width: 0,
              height: `${d}px`
            }
          }, null)]) : null, g ? f("div", {
            class: `${b}-extra`
          }, [g]) : null]);
        }
      });
    };
  }
});
function $G(e) {
  const t = Q(e.value.slice());
  let n = null;
  return Le(() => {
    clearTimeout(n), n = setTimeout(() => {
      t.value = e.value;
    }, e.value.length ? 0 : 10);
  }), t;
}
Mn("success", "warning", "error", "validating", "");
const wG = {
  success: ir,
  warning: sr,
  error: Gn,
  validating: Qn
};
function Iv(e, t, n) {
  let o = e;
  const r = t;
  let l = 0;
  try {
    for (let a = r.length; l < a - 1 && !(!o && !n); ++l) {
      const i = r[l];
      if (i in o)
        o = o[i];
      else {
        if (n)
          throw Error("please transfer a valid name path to form item!");
        break;
      }
    }
    if (n && !o)
      throw Error("please transfer a valid name path to form item!");
  } catch {
    console.error("please transfer a valid name path to form item!");
  }
  return {
    o,
    k: r[l],
    v: o ? o[r[l]] : void 0
  };
}
const xG = () => ({
  htmlFor: String,
  prefixCls: String,
  label: V.any,
  help: V.any,
  extra: V.any,
  labelCol: {
    type: Object
  },
  wrapperCol: {
    type: Object
  },
  hasFeedback: {
    type: Boolean,
    default: !1
  },
  colon: {
    type: Boolean,
    default: void 0
  },
  labelAlign: String,
  prop: {
    type: [String, Number, Array]
  },
  name: {
    type: [String, Number, Array]
  },
  rules: [Array, Object],
  autoLink: {
    type: Boolean,
    default: !0
  },
  required: {
    type: Boolean,
    default: void 0
  },
  validateFirst: {
    type: Boolean,
    default: void 0
  },
  validateStatus: V.oneOf(Mn("", "success", "warning", "error", "validating")),
  validateTrigger: {
    type: [String, Array]
  },
  messageVariables: {
    type: Object
  },
  hidden: Boolean,
  noStyle: Boolean,
  tooltip: String
});
let OG = 0;
const PG = "form_item", EP = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AFormItem",
  inheritAttrs: !1,
  __ANT_NEW_FORM_ITEM: !0,
  props: xG(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    ct(e.prop === void 0, "`prop` is deprecated. Please use `name` instead.");
    const l = `form-item-${++OG}`, {
      prefixCls: a
    } = Ie("form", e), [i, s] = sb(a), c = Q(), u = lb(), d = P(() => e.name || e.prop), p = Q([]), v = Q(!1), h = Q(), g = P(() => {
      const W = d.value;
      return bm(W);
    }), b = P(() => {
      if (g.value.length) {
        const W = u.name.value, q = g.value.join("_");
        return W ? `${W}_${q}` : `${PG}_${q}`;
      } else
        return;
    }), y = () => {
      const W = u.model.value;
      if (!(!W || !d.value))
        return Iv(W, g.value, !0).v;
    }, S = P(() => y()), C = Q(_e(S.value)), w = P(() => {
      let W = e.validateTrigger !== void 0 ? e.validateTrigger : u.validateTrigger.value;
      return W = W === void 0 ? "change" : W, hl(W);
    }), $ = P(() => {
      let W = u.rules.value;
      const q = e.rules, J = e.required !== void 0 ? {
        required: !!e.required,
        trigger: w.value
      } : [], ne = Iv(W, g.value);
      W = W ? ne.o[ne.k] || ne.v : [];
      const te = [].concat(q || W || []);
      return hB(te, (G) => G.required) ? te : te.concat(J);
    }), O = P(() => {
      const W = $.value;
      let q = !1;
      return W && W.length && W.every((J) => J.required ? (q = !0, !1) : !0), q || e.required;
    }), x = Q();
    Le(() => {
      x.value = e.validateStatus;
    });
    const I = P(() => {
      let W = {};
      return typeof e.label == "string" ? W.label = e.label : e.name && (W.label = String(e.name)), e.messageVariables && (W = m(m({}, W), e.messageVariables)), W;
    }), E = (W) => {
      if (g.value.length === 0)
        return;
      const {
        validateFirst: q = !1
      } = e, {
        triggerName: J
      } = W || {};
      let ne = $.value;
      if (J && (ne = ne.filter((G) => {
        const {
          trigger: U
        } = G;
        return !U && !w.value.length ? !0 : hl(U || w.value).includes(J);
      })), !ne.length)
        return Promise.resolve();
      const te = xP(g.value, S.value, ne, m({
        validateMessages: u.validateMessages.value
      }, W), q, I.value);
      return x.value = "validating", p.value = [], te.catch((G) => G).then(function() {
        let G = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
        if (x.value === "validating") {
          const U = G.filter((re) => re && re.errors.length);
          x.value = U.length ? "error" : "success", p.value = U.map((re) => re.errors), u.onValidate(d.value, !p.value.length, p.value.length ? Yt(p.value[0]) : null);
        }
      }), te;
    }, _ = () => {
      E({
        triggerName: "blur"
      });
    }, M = () => {
      if (v.value) {
        v.value = !1;
        return;
      }
      E({
        triggerName: "change"
      });
    }, R = () => {
      x.value = e.validateStatus, v.value = !1, p.value = [];
    }, A = () => {
      var W;
      x.value = e.validateStatus, v.value = !0, p.value = [];
      const q = u.model.value || {}, J = S.value, ne = Iv(q, g.value, !0);
      Array.isArray(J) ? ne.o[ne.k] = [].concat((W = C.value) !== null && W !== void 0 ? W : []) : ne.o[ne.k] = C.value, rt(() => {
        v.value = !1;
      });
    }, z = P(() => e.htmlFor === void 0 ? b.value : e.htmlFor), T = () => {
      const W = z.value;
      if (!W || !h.value)
        return;
      const q = h.value.$el.querySelector(`[id="${W}"]`);
      q && q.focus && q.focus();
    };
    r({
      onFieldBlur: _,
      onFieldChange: M,
      clearValidate: R,
      resetField: A
    }), eR({
      id: b,
      onFieldBlur: () => {
        e.autoLink && _();
      },
      onFieldChange: () => {
        e.autoLink && M();
      },
      clearValidate: R
    }, P(() => !!(e.autoLink && u.model.value && d.value)));
    let N = !1;
    ie(d, (W) => {
      W ? N || (N = !0, u.addField(l, {
        fieldValue: S,
        fieldId: b,
        fieldName: d,
        resetField: A,
        clearValidate: R,
        namePath: g,
        validateRules: E,
        rules: $
      })) : (N = !1, u.removeField(l));
    }, {
      immediate: !0
    }), et(() => {
      u.removeField(l);
    });
    const k = $G(p), B = P(() => e.validateStatus !== void 0 ? e.validateStatus : k.value.length ? "error" : x.value), F = P(() => ({
      [`${a.value}-item`]: !0,
      [s.value]: !0,
      // Status
      [`${a.value}-item-has-feedback`]: B.value && e.hasFeedback,
      [`${a.value}-item-has-success`]: B.value === "success",
      [`${a.value}-item-has-warning`]: B.value === "warning",
      [`${a.value}-item-has-error`]: B.value === "error",
      [`${a.value}-item-is-validating`]: B.value === "validating",
      [`${a.value}-item-hidden`]: e.hidden
    })), L = xt({});
    Sn.useProvide(L), Le(() => {
      let W;
      if (e.hasFeedback) {
        const q = B.value && wG[B.value];
        W = q ? f("span", {
          class: ee(`${a.value}-item-feedback-icon`, `${a.value}-item-feedback-icon-${B.value}`)
        }, [f(q, null, null)]) : null;
      }
      m(L, {
        status: B.value,
        hasFeedback: e.hasFeedback,
        feedbackIcon: W,
        isFormItemInput: !0
      });
    });
    const j = Q(null), H = Q(!1), K = () => {
      if (c.value) {
        const W = getComputedStyle(c.value);
        j.value = parseInt(W.marginBottom, 10);
      }
    };
    Ke(() => {
      ie(H, () => {
        H.value && K();
      }, {
        flush: "post",
        immediate: !0
      });
    });
    const X = (W) => {
      W || (j.value = null);
    };
    return () => {
      var W, q;
      if (e.noStyle)
        return (W = n.default) === null || W === void 0 ? void 0 : W.call(n);
      const J = (q = e.help) !== null && q !== void 0 ? q : n.help ? Lt(n.help()) : null, ne = !!(J != null && Array.isArray(J) && J.length || k.value.length);
      return H.value = ne, i(f("div", {
        class: [F.value, ne ? `${a.value}-item-with-help` : "", o.class],
        ref: c
      }, [f(rb, D(D({}, o), {}, {
        class: `${a.value}-item-row`,
        key: "row"
      }), {
        default: () => {
          var te, G;
          return f(Fe, null, [f(ib, D(D({}, e), {}, {
            htmlFor: z.value,
            required: O.value,
            requiredMark: u.requiredMark.value,
            prefixCls: a.value,
            onClick: T,
            label: e.label
          }), {
            label: n.label,
            tooltip: n.tooltip
          }), f(CG, D(D({}, e), {}, {
            errors: J != null ? hl(J) : k.value,
            marginBottom: j.value,
            prefixCls: a.value,
            status: B.value,
            ref: h,
            help: J,
            extra: (te = e.extra) !== null && te !== void 0 ? te : (G = n.extra) === null || G === void 0 ? void 0 : G.call(n),
            onErrorVisibleChanged: X
          }), {
            default: n.default
          })]);
        }
      }), !!j.value && f("div", {
        class: `${a.value}-margin-offset`,
        style: {
          marginBottom: `-${j.value}px`
        }
      }, null)]));
    };
  }
});
function TP(e) {
  let t = !1, n = e.length;
  const o = [];
  return e.length ? new Promise((r, l) => {
    e.forEach((a, i) => {
      a.catch((s) => (t = !0, s)).then((s) => {
        n -= 1, o[i] = s, !(n > 0) && (t && l(o), r(o));
      });
    });
  }) : Promise.resolve([]);
}
function UC(e) {
  let t = !1;
  return e && e.length && e.every((n) => n.required ? (t = !0, !1) : !0), t;
}
function YC(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function Ev(e, t, n) {
  let o = e;
  t = t.replace(/\[(\w+)\]/g, ".$1"), t = t.replace(/^\./, "");
  const r = t.split(".");
  let l = 0;
  for (let a = r.length; l < a - 1 && !(!o && !n); ++l) {
    const i = r[l];
    if (i in o)
      o = o[i];
    else {
      if (n)
        throw new Error("please transfer a valid name path to validate!");
      break;
    }
  }
  return {
    o,
    k: r[l],
    v: o ? o[r[l]] : null,
    isValid: o && r[l] in o
  };
}
function IG(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Y({}), n = arguments.length > 2 ? arguments[2] : void 0;
  const o = _e(hn(e)), r = xt({}), l = Q([]), a = (C) => {
    m(hn(e), m(m({}, _e(o)), C)), rt(() => {
      Object.keys(r).forEach((w) => {
        r[w] = {
          autoLink: !1,
          required: UC(hn(t)[w])
        };
      });
    });
  }, i = function() {
    let C = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], w = arguments.length > 1 ? arguments[1] : void 0;
    return w.length ? C.filter(($) => {
      const O = YC($.trigger || "change");
      return $B(O, w).length;
    }) : C;
  };
  let s = null;
  const c = function(C) {
    let w = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, $ = arguments.length > 2 ? arguments[2] : void 0;
    const O = [], x = {};
    for (let _ = 0; _ < C.length; _++) {
      const M = C[_], R = Ev(hn(e), M, $);
      if (!R.isValid)
        continue;
      x[M] = R.v;
      const A = i(hn(t)[M], YC(w && w.trigger));
      A.length && O.push(u(M, R.v, A, w || {}).then(() => ({
        name: M,
        errors: [],
        warnings: []
      })).catch((z) => {
        const T = [], N = [];
        return z.forEach((k) => {
          let {
            rule: {
              warningOnly: B
            },
            errors: F
          } = k;
          B ? N.push(...F) : T.push(...F);
        }), T.length ? Promise.reject({
          name: M,
          errors: T,
          warnings: N
        }) : {
          name: M,
          errors: T,
          warnings: N
        };
      }));
    }
    const I = TP(O);
    s = I;
    const E = I.then(() => s === I ? Promise.resolve(x) : Promise.reject([])).catch((_) => {
      const M = _.filter((R) => R && R.errors.length);
      return M.length ? Promise.reject({
        values: x,
        errorFields: M,
        outOfDate: s !== I
      }) : Promise.resolve(x);
    });
    return E.catch((_) => _), E;
  }, u = function(C, w, $) {
    let O = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const x = xP([C], w, $, m({
      validateMessages: pp
    }, O), !!O.validateFirst);
    return r[C] ? (r[C].validateStatus = "validating", x.catch((I) => I).then(function() {
      let I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var E;
      if (r[C].validateStatus === "validating") {
        const _ = I.filter((M) => M && M.errors.length);
        r[C].validateStatus = _.length ? "error" : "success", r[C].help = _.length ? _.map((M) => M.errors) : null, (E = n == null ? void 0 : n.onValidate) === null || E === void 0 || E.call(n, C, !_.length, _.length ? Yt(r[C].help[0]) : null);
      }
    }), x) : x.catch((I) => I);
  }, d = (C, w) => {
    let $ = [], O = !0;
    C ? Array.isArray(C) ? $ = C : $ = [C] : (O = !1, $ = l.value);
    const x = c($, w || {}, O);
    return x.catch((I) => I), x;
  }, p = (C) => {
    let w = [];
    C ? Array.isArray(C) ? w = C : w = [C] : w = l.value, w.forEach(($) => {
      r[$] && m(r[$], {
        validateStatus: "",
        help: null
      });
    });
  }, v = (C) => {
    const w = {
      autoLink: !1
    }, $ = [], O = Array.isArray(C) ? C : [C];
    for (let x = 0; x < O.length; x++) {
      const I = O[x];
      (I == null ? void 0 : I.validateStatus) === "error" && (w.validateStatus = "error", I.help && $.push(I.help)), w.required = w.required || (I == null ? void 0 : I.required);
    }
    return w.help = $, w;
  };
  let h = o, g = !0;
  const b = (C) => {
    const w = [];
    l.value.forEach(($) => {
      const O = Ev(C, $, !1), x = Ev(h, $, !1);
      (g && (n == null ? void 0 : n.immediate) && O.isValid || !Dh(O.v, x.v)) && w.push($);
    }), d(w, {
      trigger: "change"
    }), g = !1, h = _e(Yt(C));
  }, y = n == null ? void 0 : n.debounce;
  let S = !0;
  return ie(t, () => {
    l.value = t ? Object.keys(hn(t)) : [], !S && n && n.validateOnRuleChange && d(), S = !1;
  }, {
    deep: !0,
    immediate: !0
  }), ie(l, () => {
    const C = {};
    l.value.forEach((w) => {
      C[w] = m({}, r[w], {
        autoLink: !1,
        required: UC(hn(t)[w])
      }), delete r[w];
    });
    for (const w in r)
      Object.prototype.hasOwnProperty.call(r, w) && delete r[w];
    m(r, C);
  }, {
    immediate: !0
  }), ie(e, y && y.wait ? Hf(b, y.wait, RB(y, ["wait"])) : b, {
    immediate: n && !!n.immediate,
    deep: !0
  }), {
    modelRef: e,
    rulesRef: t,
    initialModel: o,
    validateInfos: r,
    resetFields: a,
    validate: d,
    validateField: u,
    mergeValidateInfo: v,
    clearValidate: p
  };
}
const EG = () => ({
  layout: V.oneOf(Mn("horizontal", "inline", "vertical")),
  labelCol: Re(),
  wrapperCol: Re(),
  colon: ve(),
  labelAlign: ke(),
  labelWrap: ve(),
  prefixCls: String,
  requiredMark: je([String, Boolean]),
  /** @deprecated Will warning in future branch. Pls use `requiredMark` instead. */
  hideRequiredMark: ve(),
  model: V.object,
  rules: Re(),
  validateMessages: Re(),
  validateOnRuleChange: ve(),
  // 提交失败自动滚动到第一个错误字段
  scrollToFirstError: _t(),
  onSubmit: le(),
  name: String,
  validateTrigger: je([String, Array]),
  size: ke(),
  disabled: ve(),
  onValuesChange: le(),
  onFieldsChange: le(),
  onFinish: le(),
  onFinishFailed: le(),
  onValidate: le()
});
function TG(e, t) {
  return Dh(hl(e), hl(t));
}
const kr = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AForm",
  inheritAttrs: !1,
  props: Qe(EG(), {
    layout: "horizontal",
    hideRequiredMark: !1,
    colon: !0
  }),
  Item: EP,
  useForm: IG,
  // emits: ['finishFailed', 'submit', 'finish', 'validate'],
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      expose: r,
      attrs: l
    } = t;
    const {
      prefixCls: a,
      direction: i,
      form: s,
      size: c,
      disabled: u
    } = Ie("form", e), d = P(() => e.requiredMark === "" || e.requiredMark), p = P(() => {
      var k;
      return d.value !== void 0 ? d.value : s && ((k = s.value) === null || k === void 0 ? void 0 : k.requiredMark) !== void 0 ? s.value.requiredMark : !e.hideRequiredMark;
    });
    B2(c), t2(u);
    const v = P(() => {
      var k, B;
      return (k = e.colon) !== null && k !== void 0 ? k : (B = s.value) === null || B === void 0 ? void 0 : B.colon;
    }), {
      validateMessages: h
    } = e8(), g = P(() => m(m(m({}, pp), h.value), e.validateMessages)), [b, y] = sb(a), S = P(() => ee(a.value, {
      [`${a.value}-${e.layout}`]: !0,
      [`${a.value}-hide-required-mark`]: p.value === !1,
      [`${a.value}-rtl`]: i.value === "rtl",
      [`${a.value}-${c.value}`]: c.value
    }, y.value)), C = Y(), w = {}, $ = (k, B) => {
      w[k] = B;
    }, O = (k) => {
      delete w[k];
    }, x = (k) => {
      const B = !!k, F = B ? hl(k).map(bm) : [];
      return B ? Object.values(w).filter((L) => F.findIndex((j) => TG(j, L.fieldName.value)) > -1) : Object.values(w);
    }, I = (k) => {
      if (!e.model) {
        Mt(!1, "Form", "model is required for resetFields to work.");
        return;
      }
      x(k).forEach((B) => {
        B.resetField();
      });
    }, E = (k) => {
      x(k).forEach((B) => {
        B.clearValidate();
      });
    }, _ = (k) => {
      const {
        scrollToFirstError: B
      } = e;
      if (n("finishFailed", k), B && k.errorFields.length) {
        let F = {};
        typeof B == "object" && (F = B), R(k.errorFields[0].name, F);
      }
    }, M = function() {
      return T(...arguments);
    }, R = function(k) {
      let B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const F = x(k ? [k] : void 0);
      if (F.length) {
        const L = F[0].fieldId.value, j = L ? document.getElementById(L) : null;
        j && z2(j, m({
          scrollMode: "if-needed",
          block: "nearest"
        }, B));
      }
    }, A = function() {
      let k = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0;
      if (k === !0) {
        const B = [];
        return Object.values(w).forEach((F) => {
          let {
            namePath: L
          } = F;
          B.push(L.value);
        }), KC(e.model, B);
      } else
        return KC(e.model, k);
    }, z = (k, B) => {
      if (Mt(!(k instanceof Function), "Form", "validateFields/validateField/validate not support callback, please use promise instead"), !e.model)
        return Mt(!1, "Form", "model is required for validateFields to work."), Promise.reject("Form `model` is required for validateFields to work.");
      const F = !!k, L = F ? hl(k).map(bm) : [], j = [];
      Object.values(w).forEach((X) => {
        var W;
        if (F || L.push(X.namePath.value), !(!((W = X.rules) === null || W === void 0) && W.value.length))
          return;
        const q = X.namePath.value;
        if (!F || QK(L, q)) {
          const J = X.validateRules(m({
            validateMessages: g.value
          }, B));
          j.push(J.then(() => ({
            name: q,
            errors: [],
            warnings: []
          })).catch((ne) => {
            const te = [], G = [];
            return ne.forEach((U) => {
              let {
                rule: {
                  warningOnly: re
                },
                errors: se
              } = U;
              re ? G.push(...se) : te.push(...se);
            }), te.length ? Promise.reject({
              name: q,
              errors: te,
              warnings: G
            }) : {
              name: q,
              errors: te,
              warnings: G
            };
          }));
        }
      });
      const H = TP(j);
      C.value = H;
      const K = H.then(() => C.value === H ? Promise.resolve(A(L)) : Promise.reject([])).catch((X) => {
        const W = X.filter((q) => q && q.errors.length);
        return Promise.reject({
          values: A(L),
          errorFields: W,
          outOfDate: C.value !== H
        });
      });
      return K.catch((X) => X), K;
    }, T = function() {
      return z(...arguments);
    }, N = (k) => {
      k.preventDefault(), k.stopPropagation(), n("submit", k), e.model && z().then((F) => {
        n("finish", F);
      }).catch((F) => {
        _(F);
      });
    };
    return r({
      resetFields: I,
      clearValidate: E,
      validateFields: z,
      getFieldsValue: A,
      validate: M,
      scrollToField: R
    }), PP({
      model: P(() => e.model),
      name: P(() => e.name),
      labelAlign: P(() => e.labelAlign),
      labelCol: P(() => e.labelCol),
      labelWrap: P(() => e.labelWrap),
      wrapperCol: P(() => e.wrapperCol),
      vertical: P(() => e.layout === "vertical"),
      colon: v,
      requiredMark: p,
      validateTrigger: P(() => e.validateTrigger),
      rules: P(() => e.rules),
      addField: $,
      removeField: O,
      onValidate: (k, B, F) => {
        n("validate", k, B, F);
      },
      validateMessages: g
    }), ie(() => e.rules, () => {
      e.validateOnRuleChange && z();
    }), () => {
      var k;
      return b(f("form", D(D({}, l), {}, {
        onSubmit: N,
        class: [S.value, l.class]
      }), [(k = o.default) === null || k === void 0 ? void 0 : k.call(o)]));
    };
  }
});
kr.useInjectFormItemContext = sn;
kr.ItemRest = Si;
kr.install = function(e) {
  return e.component(kr.name, kr), e.component(kr.Item.name, kr.Item), e.component(Si.name, Si), e;
};
const MG = new lt("antCheckboxEffect", {
  "0%": {
    transform: "scale(1)",
    opacity: 0.5
  },
  "100%": {
    transform: "scale(1.6)",
    opacity: 0
  }
}), _G = (e) => {
  const {
    checkboxCls: t
  } = e, n = `${t}-wrapper`;
  return [
    // ===================== Basic =====================
    {
      // Group
      [`${t}-group`]: m(m({}, qe(e)), {
        display: "inline-flex",
        flexWrap: "wrap",
        columnGap: e.marginXS,
        // Group > Grid
        [`> ${e.antCls}-row`]: {
          flex: 1
        }
      }),
      // Wrapper
      [n]: m(m({}, qe(e)), {
        display: "inline-flex",
        alignItems: "baseline",
        cursor: "pointer",
        // Fix checkbox & radio in flex align #30260
        "&:after": {
          display: "inline-block",
          width: 0,
          overflow: "hidden",
          content: "'\\a0'"
        },
        // Checkbox near checkbox
        [`& + ${n}`]: {
          marginInlineStart: 0
        },
        [`&${n}-in-form-item`]: {
          'input[type="checkbox"]': {
            width: 14,
            height: 14
            // FIXME: magic
          }
        }
      }),
      // Wrapper > Checkbox
      [t]: m(m({}, qe(e)), {
        position: "relative",
        whiteSpace: "nowrap",
        lineHeight: 1,
        cursor: "pointer",
        // To make alignment right when `controlHeight` is changed
        // Ref: https://github.com/ant-design/ant-design/issues/41564
        alignSelf: "center",
        // Wrapper > Checkbox > input
        [`${t}-input`]: {
          position: "absolute",
          // Since baseline align will get additional space offset,
          // we need to move input to top to make it align with text.
          // Ref: https://github.com/ant-design/ant-design/issues/38926#issuecomment-1486137799
          inset: 0,
          zIndex: 1,
          cursor: "pointer",
          opacity: 0,
          margin: 0,
          [`&:focus-visible + ${t}-inner`]: m({}, Gr(e))
        },
        // Wrapper > Checkbox > inner
        [`${t}-inner`]: {
          boxSizing: "border-box",
          position: "relative",
          top: 0,
          insetInlineStart: 0,
          display: "block",
          width: e.checkboxSize,
          height: e.checkboxSize,
          direction: "ltr",
          backgroundColor: e.colorBgContainer,
          border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
          borderRadius: e.borderRadiusSM,
          borderCollapse: "separate",
          transition: `all ${e.motionDurationSlow}`,
          "&:after": {
            boxSizing: "border-box",
            position: "absolute",
            top: "50%",
            insetInlineStart: "21.5%",
            display: "table",
            width: e.checkboxSize / 14 * 5,
            height: e.checkboxSize / 14 * 8,
            border: `${e.lineWidthBold}px solid ${e.colorWhite}`,
            borderTop: 0,
            borderInlineStart: 0,
            transform: "rotate(45deg) scale(0) translate(-50%,-50%)",
            opacity: 0,
            content: '""',
            transition: `all ${e.motionDurationFast} ${e.motionEaseInBack}, opacity ${e.motionDurationFast}`
          }
        },
        // Wrapper > Checkbox + Text
        "& + span": {
          paddingInlineStart: e.paddingXS,
          paddingInlineEnd: e.paddingXS
        }
      })
    },
    // ================= Indeterminate =================
    {
      [t]: {
        "&-indeterminate": {
          // Wrapper > Checkbox > inner
          [`${t}-inner`]: {
            "&:after": {
              top: "50%",
              insetInlineStart: "50%",
              width: e.fontSizeLG / 2,
              height: e.fontSizeLG / 2,
              backgroundColor: e.colorPrimary,
              border: 0,
              transform: "translate(-50%, -50%) scale(1)",
              opacity: 1,
              content: '""'
            }
          }
        }
      }
    },
    // ===================== Hover =====================
    {
      // Wrapper
      [`${n}:hover ${t}:after`]: {
        visibility: "visible"
      },
      // Wrapper & Wrapper > Checkbox
      [`
        ${n}:not(${n}-disabled),
        ${t}:not(${t}-disabled)
      `]: {
        [`&:hover ${t}-inner`]: {
          borderColor: e.colorPrimary
        }
      },
      [`${n}:not(${n}-disabled)`]: {
        [`&:hover ${t}-checked:not(${t}-disabled) ${t}-inner`]: {
          backgroundColor: e.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${t}-checked:not(${t}-disabled):after`]: {
          borderColor: e.colorPrimaryHover
        }
      }
    },
    // ==================== Checked ====================
    {
      // Wrapper > Checkbox
      [`${t}-checked`]: {
        [`${t}-inner`]: {
          backgroundColor: e.colorPrimary,
          borderColor: e.colorPrimary,
          "&:after": {
            opacity: 1,
            transform: "rotate(45deg) scale(1) translate(-50%,-50%)",
            transition: `all ${e.motionDurationMid} ${e.motionEaseOutBack} ${e.motionDurationFast}`
          }
        },
        // Checked Effect
        "&:after": {
          position: "absolute",
          top: 0,
          insetInlineStart: 0,
          width: "100%",
          height: "100%",
          borderRadius: e.borderRadiusSM,
          visibility: "hidden",
          border: `${e.lineWidthBold}px solid ${e.colorPrimary}`,
          animationName: MG,
          animationDuration: e.motionDurationSlow,
          animationTimingFunction: "ease-in-out",
          animationFillMode: "backwards",
          content: '""',
          transition: `all ${e.motionDurationSlow}`
        }
      },
      [`
        ${n}-checked:not(${n}-disabled),
        ${t}-checked:not(${t}-disabled)
      `]: {
        [`&:hover ${t}-inner`]: {
          backgroundColor: e.colorPrimaryHover,
          borderColor: "transparent"
        },
        [`&:hover ${t}:after`]: {
          borderColor: e.colorPrimaryHover
        }
      }
    },
    // ==================== Disable ====================
    {
      // Wrapper
      [`${n}-disabled`]: {
        cursor: "not-allowed"
      },
      // Wrapper > Checkbox
      [`${t}-disabled`]: {
        // Wrapper > Checkbox > input
        [`&, ${t}-input`]: {
          cursor: "not-allowed",
          // Disabled for native input to enable Tooltip event handler
          // ref: https://github.com/ant-design/ant-design/issues/39822#issuecomment-1365075901
          pointerEvents: "none"
        },
        // Wrapper > Checkbox > inner
        [`${t}-inner`]: {
          background: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          "&:after": {
            borderColor: e.colorTextDisabled
          }
        },
        "&:after": {
          display: "none"
        },
        "& + span": {
          color: e.colorTextDisabled
        },
        [`&${t}-indeterminate ${t}-inner::after`]: {
          background: e.colorTextDisabled
        }
      }
    }
  ];
};
function mp(e, t) {
  const n = He(t, {
    checkboxCls: `.${e}`,
    checkboxSize: t.controlInteractiveSize
  });
  return [_G(n)];
}
const MP = Xe("Checkbox", (e, t) => {
  let {
    prefixCls: n
  } = t;
  return [mp(n, e)];
}), AG = (e) => {
  const {
    prefixCls: t,
    componentCls: n,
    antCls: o
  } = e, r = `${n}-menu-item`, l = `
    &${r}-expand ${r}-expand-icon,
    ${r}-loading-icon
  `, a = Math.round((e.controlHeight - e.fontSize * e.lineHeight) / 2);
  return [
    // =====================================================
    // ==                     Control                     ==
    // =====================================================
    {
      [n]: {
        width: e.controlWidth
      }
    },
    // =====================================================
    // ==                      Popup                      ==
    // =====================================================
    {
      [`${n}-dropdown`]: [
        // ==================== Checkbox ====================
        mp(`${t}-checkbox`, e),
        {
          [`&${o}-select-dropdown`]: {
            padding: 0
          }
        },
        {
          [n]: {
            // ================== Checkbox ==================
            "&-checkbox": {
              top: 0,
              marginInlineEnd: e.paddingXS
            },
            // ==================== Menu ====================
            // >>> Menus
            "&-menus": {
              display: "flex",
              flexWrap: "nowrap",
              alignItems: "flex-start",
              [`&${n}-menu-empty`]: {
                [`${n}-menu`]: {
                  width: "100%",
                  height: "auto",
                  [r]: {
                    color: e.colorTextDisabled
                  }
                }
              }
            },
            // >>> Menu
            "&-menu": {
              flexGrow: 1,
              minWidth: e.controlItemWidth,
              height: e.dropdownHeight,
              margin: 0,
              padding: e.paddingXXS,
              overflow: "auto",
              verticalAlign: "top",
              listStyle: "none",
              "-ms-overflow-style": "-ms-autohiding-scrollbar",
              "&:not(:last-child)": {
                borderInlineEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
              },
              "&-item": m(m({}, tn), {
                display: "flex",
                flexWrap: "nowrap",
                alignItems: "center",
                padding: `${a}px ${e.paddingSM}px`,
                lineHeight: e.lineHeight,
                cursor: "pointer",
                transition: `all ${e.motionDurationMid}`,
                borderRadius: e.borderRadiusSM,
                "&:hover": {
                  background: e.controlItemBgHover
                },
                "&-disabled": {
                  color: e.colorTextDisabled,
                  cursor: "not-allowed",
                  "&:hover": {
                    background: "transparent"
                  },
                  [l]: {
                    color: e.colorTextDisabled
                  }
                },
                [`&-active:not(${r}-disabled)`]: {
                  "&, &:hover": {
                    fontWeight: e.fontWeightStrong,
                    backgroundColor: e.controlItemBgActive
                  }
                },
                "&-content": {
                  flex: "auto"
                },
                [l]: {
                  marginInlineStart: e.paddingXXS,
                  color: e.colorTextDescription,
                  fontSize: e.fontSizeIcon
                },
                "&-keyword": {
                  color: e.colorHighlight
                }
              })
            }
          }
        }
      ]
    },
    // =====================================================
    // ==                       RTL                       ==
    // =====================================================
    {
      [`${n}-dropdown-rtl`]: {
        direction: "rtl"
      }
    },
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Ri(e)
  ];
}, DG = Xe("Cascader", (e) => [AG(e)], {
  controlWidth: 184,
  controlItemWidth: 111,
  dropdownHeight: 180
});
var NG = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function RG(e, t, n) {
  const o = e.toLowerCase().split(t).reduce((a, i, s) => s === 0 ? [i] : [...a, t, i], []), r = [];
  let l = 0;
  return o.forEach((a, i) => {
    const s = l + a.length;
    let c = e.slice(l, s);
    l = s, i % 2 === 1 && (c = f("span", {
      class: `${n}-menu-item-keyword`,
      key: "seperator"
    }, [c])), r.push(c);
  }), r;
}
const kG = (e) => {
  let {
    inputValue: t,
    path: n,
    prefixCls: o,
    fieldNames: r
  } = e;
  const l = [], a = t.toLowerCase();
  return n.forEach((i, s) => {
    s !== 0 && l.push(" / ");
    let c = i[r.label];
    const u = typeof c;
    (u === "string" || u === "number") && (c = RG(String(c), a, o)), l.push(c);
  }), l;
};
function BG() {
  return m(m({}, ot(vP(), ["customSlots", "checkable", "options"])), {
    multiple: {
      type: Boolean,
      default: void 0
    },
    size: String,
    bordered: {
      type: Boolean,
      default: void 0
    },
    placement: {
      type: String
    },
    suffixIcon: V.any,
    status: String,
    options: Array,
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    "onUpdate:value": Function
  });
}
const FG = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACascader",
  inheritAttrs: !1,
  props: Qe(BG(), {
    bordered: !0,
    choiceTransitionName: "",
    allowClear: !0
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: r,
      emit: l
    } = t;
    process.env.NODE_ENV !== "production" && nt(!e.dropdownClassName, "Cascader", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const a = sn(), i = Sn.useInject(), s = P(() => ar(i.status, e.status)), {
      prefixCls: c,
      rootPrefixCls: u,
      getPrefixCls: d,
      direction: p,
      getPopupContainer: v,
      renderEmpty: h,
      size: g,
      disabled: b
    } = Ie("cascader", e), y = P(() => d("select", e.prefixCls)), {
      compactSize: S,
      compactItemClassnames: C
    } = Ol(y, p), w = P(() => S.value || g.value), $ = so(), O = P(() => {
      var B;
      return (B = b.value) !== null && B !== void 0 ? B : $.value;
    }), [x, I] = i0(y), [E] = DG(c), _ = P(() => p.value === "rtl");
    process.env.NODE_ENV !== "production" && Le(() => {
      nt(!e.multiple || !e.displayRender || !r.displayRender, "Cascader", "`displayRender` not work on `multiple`. Please use `tagRender` instead.");
    });
    const M = P(() => {
      if (!e.showSearch)
        return e.showSearch;
      let B = {
        render: kG
      };
      return typeof e.showSearch == "object" && (B = m(m({}, B), e.showSearch)), B;
    }), R = P(() => ee(e.popupClassName || e.dropdownClassName, `${c.value}-dropdown`, {
      [`${c.value}-dropdown-rtl`]: _.value
    }, I.value)), A = Y();
    o({
      focus() {
        var B;
        (B = A.value) === null || B === void 0 || B.focus();
      },
      blur() {
        var B;
        (B = A.value) === null || B === void 0 || B.blur();
      }
    });
    const z = function() {
      for (var B = arguments.length, F = new Array(B), L = 0; L < B; L++)
        F[L] = arguments[L];
      l("update:value", F[0]), l("change", ...F), a.onFieldChange();
    }, T = function() {
      for (var B = arguments.length, F = new Array(B), L = 0; L < B; L++)
        F[L] = arguments[L];
      l("blur", ...F), a.onFieldBlur();
    }, N = P(() => e.showArrow !== void 0 ? e.showArrow : e.loading || !e.multiple), k = P(() => e.placement !== void 0 ? e.placement : p.value === "rtl" ? "bottomRight" : "bottomLeft");
    return () => {
      var B, F;
      const {
        notFoundContent: L = (B = r.notFoundContent) === null || B === void 0 ? void 0 : B.call(r),
        expandIcon: j = (F = r.expandIcon) === null || F === void 0 ? void 0 : F.call(r),
        multiple: H,
        bordered: K,
        allowClear: X,
        choiceTransitionName: W,
        transitionName: q,
        id: J = a.id.value
      } = e, ne = NG(e, ["notFoundContent", "expandIcon", "multiple", "bordered", "allowClear", "choiceTransitionName", "transitionName", "id"]), te = L || h("Cascader");
      let G = j;
      j || (G = _.value ? f(wr, null, null) : f(Po, null, null));
      const U = f("span", {
        class: `${y.value}-menu-item-loading-icon`
      }, [f(Qn, {
        spin: !0
      }, null)]), {
        suffixIcon: re,
        removeIcon: se,
        clearIcon: me
      } = Uh(m(m({}, e), {
        hasFeedback: i.hasFeedback,
        feedbackIcon: i.feedbackIcon,
        multiple: H,
        prefixCls: y.value,
        showArrow: N.value
      }), r);
      return E(x(f(rK, D(D(D({}, ne), n), {}, {
        id: J,
        prefixCls: y.value,
        class: [c.value, {
          [`${y.value}-lg`]: w.value === "large",
          [`${y.value}-sm`]: w.value === "small",
          [`${y.value}-rtl`]: _.value,
          [`${y.value}-borderless`]: !K,
          [`${y.value}-in-form-item`]: i.isFormItemInput
        }, Fn(y.value, s.value, i.hasFeedback), C.value, n.class, I.value],
        disabled: O.value,
        direction: p.value,
        placement: k.value,
        notFoundContent: te,
        allowClear: X,
        showSearch: M.value,
        expandIcon: G,
        inputIcon: re,
        removeIcon: se,
        clearIcon: me,
        loadingIcon: U,
        checkable: !!H,
        dropdownClassName: R.value,
        dropdownPrefixCls: c.value,
        choiceTransitionName: Vn(u.value, "", W),
        transitionName: Vn(u.value, Nh(k.value), q),
        getPopupContainer: v == null ? void 0 : v.value,
        customSlots: m(m({}, r), {
          checkable: () => f("span", {
            class: `${c.value}-checkbox-inner`
          }, null)
        }),
        tagRender: e.tagRender || r.tagRender,
        displayRender: e.displayRender || r.displayRender,
        maxTagPlaceholder: e.maxTagPlaceholder || r.maxTagPlaceholder,
        showArrow: i.hasFeedback || e.showArrow,
        onChange: z,
        onBlur: T,
        ref: A
      }), r)));
    };
  }
}), Vd = kt(m(FG, {
  SHOW_CHILD: rP,
  SHOW_PARENT: oP
})), LG = () => ({
  name: String,
  prefixCls: String,
  options: vt([]),
  disabled: Boolean,
  id: String
}), zG = () => m(m({}, LG()), {
  defaultValue: vt(),
  value: vt(),
  onChange: le(),
  "onUpdate:value": le()
}), HG = () => ({
  prefixCls: String,
  defaultChecked: ve(),
  checked: ve(),
  disabled: ve(),
  isGroup: ve(),
  value: V.any,
  name: String,
  id: String,
  indeterminate: ve(),
  type: ke("checkbox"),
  autofocus: ve(),
  onChange: le(),
  "onUpdate:checked": le(),
  onClick: le(),
  skipGroup: ve(!1)
}), jG = () => m(m({}, HG()), {
  indeterminate: ve(!1)
}), _P = Symbol("CheckboxGroupContext");
var qC = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const io = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckbox",
  inheritAttrs: !1,
  __ANT_CHECKBOX: !0,
  props: jG(),
  // emits: ['change', 'update:checked'],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      slots: r,
      expose: l
    } = t;
    const a = sn(), i = Sn.useInject(), {
      prefixCls: s,
      direction: c,
      disabled: u
    } = Ie("checkbox", e), d = so(), [p, v] = MP(s), h = tt(_P, void 0), g = Symbol("checkboxUniId"), b = P(() => (h == null ? void 0 : h.disabled.value) || u.value);
    Le(() => {
      !e.skipGroup && h && h.registerValue(g, e.value);
    }), et(() => {
      h && h.cancelValue(g);
    }), Ke(() => {
      Mt(!!(e.checked !== void 0 || h || e.value === void 0), "Checkbox", "`value` is not validate prop, do you mean `checked`?");
    });
    const y = ($) => {
      const O = $.target.checked;
      n("update:checked", O), n("change", $), a.onFieldChange();
    }, S = Y();
    return l({
      focus: () => {
        var $;
        ($ = S.value) === null || $ === void 0 || $.focus();
      },
      blur: () => {
        var $;
        ($ = S.value) === null || $ === void 0 || $.blur();
      }
    }), () => {
      var $;
      const O = It(($ = r.default) === null || $ === void 0 ? void 0 : $.call(r)), {
        indeterminate: x,
        skipGroup: I,
        id: E = a.id.value
      } = e, _ = qC(e, ["indeterminate", "skipGroup", "id"]), {
        onMouseenter: M,
        onMouseleave: R,
        onInput: A,
        class: z,
        style: T
      } = o, N = qC(o, ["onMouseenter", "onMouseleave", "onInput", "class", "style"]), k = m(m(m(m({}, _), {
        id: E,
        prefixCls: s.value
      }), N), {
        disabled: b.value
      });
      h && !I ? (k.onChange = function() {
        for (var j = arguments.length, H = new Array(j), K = 0; K < j; K++)
          H[K] = arguments[K];
        n("change", ...H), h.toggleOption({
          label: O,
          value: e.value
        });
      }, k.name = h.name.value, k.checked = h.mergedValue.value.includes(e.value), k.disabled = b.value || d.value, k.indeterminate = x) : k.onChange = y;
      const B = ee({
        [`${s.value}-wrapper`]: !0,
        [`${s.value}-rtl`]: c.value === "rtl",
        [`${s.value}-wrapper-checked`]: k.checked,
        [`${s.value}-wrapper-disabled`]: k.disabled,
        [`${s.value}-wrapper-in-form-item`]: i.isFormItemInput
      }, z, v.value), F = ee({
        [`${s.value}-indeterminate`]: x
      }, v.value);
      return p(f("label", {
        class: B,
        style: T,
        onMouseenter: M,
        onMouseleave: R
      }, [f(I3, D(D({
        "aria-checked": x ? "mixed" : void 0
      }, k), {}, {
        class: F,
        ref: S
      }), null), O.length ? f("span", null, [O]) : null]));
    };
  }
}), Wd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckboxGroup",
  inheritAttrs: !1,
  props: zG(),
  // emits: ['change', 'update:value'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r,
      expose: l
    } = t;
    const a = sn(), {
      prefixCls: i,
      direction: s
    } = Ie("checkbox", e), c = P(() => `${i.value}-group`), [u, d] = MP(c), p = Y((e.value === void 0 ? e.defaultValue : e.value) || []);
    ie(() => e.value, () => {
      p.value = e.value || [];
    });
    const v = P(() => e.options.map((w) => typeof w == "string" || typeof w == "number" ? {
      label: w,
      value: w
    } : w)), h = Y(Symbol()), g = Y(/* @__PURE__ */ new Map()), b = (w) => {
      g.value.delete(w), h.value = Symbol();
    }, y = (w, $) => {
      g.value.set(w, $), h.value = Symbol();
    }, S = Y(/* @__PURE__ */ new Map());
    return ie(h, () => {
      const w = /* @__PURE__ */ new Map();
      for (const $ of g.value.values())
        w.set($, !0);
      S.value = w;
    }), Je(_P, {
      cancelValue: b,
      registerValue: y,
      toggleOption: (w) => {
        const $ = p.value.indexOf(w.value), O = [...p.value];
        $ === -1 ? O.push(w.value) : O.splice($, 1), e.value === void 0 && (p.value = O);
        const x = O.filter((I) => S.value.has(I)).sort((I, E) => {
          const _ = v.value.findIndex((R) => R.value === I), M = v.value.findIndex((R) => R.value === E);
          return _ - M;
        });
        r("update:value", x), r("change", x), a.onFieldChange();
      },
      mergedValue: p,
      name: P(() => e.name),
      disabled: P(() => e.disabled)
    }), l({
      mergedValue: p
    }), () => {
      var w;
      const {
        id: $ = a.id.value
      } = e;
      let O = null;
      return v.value && v.value.length > 0 && (O = v.value.map((x) => {
        var I;
        return f(io, {
          prefixCls: i.value,
          key: x.value.toString(),
          disabled: "disabled" in x ? x.disabled : e.disabled,
          indeterminate: x.indeterminate,
          value: x.value,
          checked: p.value.indexOf(x.value) !== -1,
          onChange: x.onChange,
          class: `${c.value}-item`
        }, {
          default: () => [n.label !== void 0 ? (I = n.label) === null || I === void 0 ? void 0 : I.call(n, x) : x.label]
        });
      })), u(f("div", D(D({}, o), {}, {
        class: [c.value, {
          [`${c.value}-rtl`]: s.value === "rtl"
        }, o.class, d.value],
        id: $
      }), [O || ((w = n.default) === null || w === void 0 ? void 0 : w.call(n))]));
    };
  }
});
io.Group = Wd;
io.install = function(e) {
  return e.component(io.name, io), e.component(Wd.name, Wd), e;
};
const VG = {
  useBreakpoint: ki
}, WG = kt(gp), KG = (e) => {
  const {
    componentCls: t,
    commentBg: n,
    commentPaddingBase: o,
    commentNestIndent: r,
    commentFontSizeBase: l,
    commentFontSizeSm: a,
    commentAuthorNameColor: i,
    commentAuthorTimeColor: s,
    commentActionColor: c,
    commentActionHoverColor: u,
    commentActionsMarginBottom: d,
    commentActionsMarginTop: p,
    commentContentDetailPMarginBottom: v
  } = e;
  return {
    [t]: {
      position: "relative",
      backgroundColor: n,
      [`${t}-inner`]: {
        display: "flex",
        padding: o
      },
      [`${t}-avatar`]: {
        position: "relative",
        flexShrink: 0,
        marginRight: e.marginSM,
        cursor: "pointer",
        img: {
          width: "32px",
          height: "32px",
          borderRadius: "50%"
        }
      },
      [`${t}-content`]: {
        position: "relative",
        flex: "1 1 auto",
        minWidth: "1px",
        fontSize: l,
        wordWrap: "break-word",
        "&-author": {
          display: "flex",
          flexWrap: "wrap",
          justifyContent: "flex-start",
          marginBottom: e.marginXXS,
          fontSize: l,
          "& > a,& > span": {
            paddingRight: e.paddingXS,
            fontSize: a,
            lineHeight: "18px"
          },
          "&-name": {
            color: i,
            fontSize: l,
            transition: `color ${e.motionDurationSlow}`,
            "> *": {
              color: i,
              "&:hover": {
                color: i
              }
            }
          },
          "&-time": {
            color: s,
            whiteSpace: "nowrap",
            cursor: "auto"
          }
        },
        "&-detail p": {
          marginBottom: v,
          whiteSpace: "pre-wrap"
        }
      },
      [`${t}-actions`]: {
        marginTop: p,
        marginBottom: d,
        paddingLeft: 0,
        "> li": {
          display: "inline-block",
          color: c,
          "> span": {
            marginRight: "10px",
            color: c,
            fontSize: a,
            cursor: "pointer",
            transition: `color ${e.motionDurationSlow}`,
            userSelect: "none",
            "&:hover": {
              color: u
            }
          }
        }
      },
      [`${t}-nested`]: {
        marginLeft: r
      },
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
}, GG = Xe("Comment", (e) => {
  const t = He(e, {
    commentBg: "inherit",
    commentPaddingBase: `${e.paddingMD}px 0`,
    commentNestIndent: "44px",
    commentFontSizeBase: e.fontSize,
    commentFontSizeSm: e.fontSizeSM,
    commentAuthorNameColor: e.colorTextTertiary,
    commentAuthorTimeColor: e.colorTextPlaceholder,
    commentActionColor: e.colorTextTertiary,
    commentActionHoverColor: e.colorTextSecondary,
    commentActionsMarginBottom: "inherit",
    commentActionsMarginTop: e.marginSM,
    commentContentDetailPMarginBottom: "inherit"
  });
  return [KG(t)];
}), XG = () => ({
  actions: Array,
  /** The element to display as the comment author. */
  author: V.any,
  /** The element to display as the comment avatar - generally an antd Avatar */
  avatar: V.any,
  /** The main content of the comment */
  content: V.any,
  /** Comment prefix defaults to '.ant-comment' */
  prefixCls: String,
  /** A datetime element containing the time to be displayed */
  datetime: V.any
}), UG = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AComment",
  inheritAttrs: !1,
  props: XG(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("comment", e), [a, i] = GG(r), s = (u, d) => f("div", {
      class: `${u}-nested`
    }, [d]), c = (u) => !u || !u.length ? null : u.map((p, v) => f("li", {
      key: `action-${v}`
    }, [p]));
    return () => {
      var u, d, p, v, h, g, b, y, S, C, w;
      const $ = r.value, O = (u = e.actions) !== null && u !== void 0 ? u : (d = n.actions) === null || d === void 0 ? void 0 : d.call(n), x = (p = e.author) !== null && p !== void 0 ? p : (v = n.author) === null || v === void 0 ? void 0 : v.call(n), I = (h = e.avatar) !== null && h !== void 0 ? h : (g = n.avatar) === null || g === void 0 ? void 0 : g.call(n), E = (b = e.content) !== null && b !== void 0 ? b : (y = n.content) === null || y === void 0 ? void 0 : y.call(n), _ = (S = e.datetime) !== null && S !== void 0 ? S : (C = n.datetime) === null || C === void 0 ? void 0 : C.call(n), M = f("div", {
        class: `${$}-avatar`
      }, [typeof I == "string" ? f("img", {
        src: I,
        alt: "comment-avatar"
      }, null) : I]), R = O ? f("ul", {
        class: `${$}-actions`
      }, [c(Array.isArray(O) ? O : [O])]) : null, A = f("div", {
        class: `${$}-content-author`
      }, [x && f("span", {
        class: `${$}-content-author-name`
      }, [x]), _ && f("span", {
        class: `${$}-content-author-time`
      }, [_])]), z = f("div", {
        class: `${$}-content`
      }, [A, f("div", {
        class: `${$}-content-detail`
      }, [E]), R]), T = f("div", {
        class: `${$}-inner`
      }, [M, z]), N = It((w = n.default) === null || w === void 0 ? void 0 : w.call(n));
      return a(f("div", D(D({}, o), {}, {
        class: [$, {
          [`${$}-rtl`]: l.value === "rtl"
        }, o.class, i.value]
      }), [T, N && N.length ? s($, N) : null]));
    };
  }
}), YG = kt(UG);
let Iu = m({}, Zn.Modal);
function qG(e) {
  e ? Iu = m(m({}, Iu), e) : Iu = m({}, Zn.Modal);
}
function ZG() {
  return Iu;
}
const Sm = "internalMark", Eu = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ALocaleProvider",
  props: {
    locale: {
      type: Object
    },
    ANT_MARK__: String
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    Mt(e.ANT_MARK__ === Sm, "LocaleProvider", "`LocaleProvider` is deprecated. Please use `locale` with `ConfigProvider` instead");
    const o = xt({
      antLocale: m(m({}, e.locale), {
        exist: !0
      }),
      ANT_MARK__: Sm
    });
    return Je("localeData", o), ie(() => e.locale, (r) => {
      qG(r && r.Modal), o.antLocale = m(m({}, r), {
        exist: !0
      });
    }, {
      immediate: !0
    }), () => {
      var r;
      return (r = n.default) === null || r === void 0 ? void 0 : r.call(n);
    };
  }
});
Eu.install = function(e) {
  return e.component(Eu.name, Eu), e;
};
const AP = kt(Eu), hp = Z({
  name: "Notice",
  inheritAttrs: !1,
  props: ["prefixCls", "duration", "updateMark", "noticeKey", "closeIcon", "closable", "props", "onClick", "onClose", "holder", "visible"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t, r, l = !1;
    const a = P(() => e.duration === void 0 ? 4.5 : e.duration), i = () => {
      a.value && !l && (r = setTimeout(() => {
        c();
      }, a.value * 1e3));
    }, s = () => {
      r && (clearTimeout(r), r = null);
    }, c = (d) => {
      d && d.stopPropagation(), s();
      const {
        onClose: p,
        noticeKey: v
      } = e;
      p && p(v);
    }, u = () => {
      s(), i();
    };
    return Ke(() => {
      i();
    }), uo(() => {
      l = !0, s();
    }), ie([a, () => e.updateMark, () => e.visible], (d, p) => {
      let [v, h, g] = d, [b, y, S] = p;
      (v !== b || h !== y || g !== S && S) && u();
    }, {
      flush: "post"
    }), () => {
      var d, p;
      const {
        prefixCls: v,
        closable: h,
        closeIcon: g = (d = o.closeIcon) === null || d === void 0 ? void 0 : d.call(o),
        onClick: b,
        holder: y
      } = e, {
        class: S,
        style: C
      } = n, w = `${v}-notice`, $ = Object.keys(n).reduce((x, I) => ((I.startsWith("data-") || I.startsWith("aria-") || I === "role") && (x[I] = n[I]), x), {}), O = f("div", D({
        class: ee(w, S, {
          [`${w}-closable`]: h
        }),
        style: C,
        onMouseenter: s,
        onMouseleave: i,
        onClick: b
      }, $), [f("div", {
        class: `${w}-content`
      }, [(p = o.default) === null || p === void 0 ? void 0 : p.call(o)]), h ? f("a", {
        tabindex: 0,
        onClick: c,
        class: `${w}-close`
      }, [g || f("span", {
        class: `${w}-close-x`
      }, null)]) : null]);
      return y ? f(Jm, {
        to: y
      }, {
        default: () => O
      }) : O;
    };
  }
});
var QG = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
let ZC = 0;
const JG = Date.now();
function QC() {
  const e = ZC;
  return ZC += 1, `rcNotification_${JG}_${e}`;
}
const Kd = Z({
  name: "Notification",
  inheritAttrs: !1,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId"],
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: r
    } = t;
    const l = /* @__PURE__ */ new Map(), a = Y([]), i = P(() => {
      const {
        prefixCls: u,
        animation: d = "fade"
      } = e;
      let p = e.transitionName;
      return !p && d && (p = `${u}-${d}`), Nf(p);
    }), s = (u, d) => {
      const p = u.key || QC(), v = m(m({}, u), {
        key: p
      }), {
        maxCount: h
      } = e, g = a.value.map((y) => y.notice.key).indexOf(p), b = a.value.concat();
      g !== -1 ? b.splice(g, 1, {
        notice: v,
        holderCallback: d
      }) : (h && a.value.length >= h && (v.key = b[0].notice.key, v.updateMark = QC(), v.userPassKey = p, b.shift()), b.push({
        notice: v,
        holderCallback: d
      })), a.value = b;
    }, c = (u) => {
      a.value = Yt(a.value).filter((d) => {
        let {
          notice: {
            key: p,
            userPassKey: v
          }
        } = d;
        return (v || p) !== u;
      });
    };
    return o({
      add: s,
      remove: c,
      notices: a
    }), () => {
      var u;
      const {
        prefixCls: d,
        closeIcon: p = (u = r.closeIcon) === null || u === void 0 ? void 0 : u.call(r, {
          prefixCls: d
        })
      } = e, v = a.value.map((g, b) => {
        let {
          notice: y,
          holderCallback: S
        } = g;
        const C = b === a.value.length - 1 ? y.updateMark : void 0, {
          key: w,
          userPassKey: $
        } = y, {
          content: O
        } = y, x = m(m(m({
          prefixCls: d,
          closeIcon: typeof p == "function" ? p({
            prefixCls: d
          }) : p
        }, y), y.props), {
          key: w,
          noticeKey: $ || w,
          updateMark: C,
          onClose: (I) => {
            var E;
            c(I), (E = y.onClose) === null || E === void 0 || E.call(y);
          },
          onClick: y.onClick
        });
        return S ? f("div", {
          key: w,
          class: `${d}-hook-holder`,
          ref: (I) => {
            typeof w > "u" || (I ? (l.set(w, I), S(I, x)) : l.delete(w));
          }
        }, null) : f(hp, D(D({}, x), {}, {
          class: ee(x.class, e.hashId)
        }), {
          default: () => [typeof O == "function" ? O({
            prefixCls: d
          }) : O]
        });
      }), h = {
        [d]: 1,
        [n.class]: !!n.class,
        [e.hashId]: !0
      };
      return f("div", {
        class: h,
        style: n.style || {
          top: "65px",
          left: "50%"
        }
      }, [f(gf, D({
        tag: "div"
      }, i.value), {
        default: () => [v]
      })]);
    };
  }
});
Kd.newInstance = function(t, n) {
  const o = t || {}, {
    name: r = "notification",
    getContainer: l,
    appContext: a,
    prefixCls: i,
    rootPrefixCls: s,
    transitionName: c,
    hasTransitionName: u,
    useStyle: d
  } = o, p = QG(o, ["name", "getContainer", "appContext", "prefixCls", "rootPrefixCls", "transitionName", "hasTransitionName", "useStyle"]), v = document.createElement("div");
  l ? l().appendChild(v) : document.body.appendChild(v);
  const h = Z({
    compatConfig: {
      MODE: 3
    },
    name: "NotificationWrapper",
    setup(b, y) {
      let {
        attrs: S
      } = y;
      const C = Q(), w = P(() => On.getPrefixCls(r, i)), [, $] = d(w);
      return Ke(() => {
        n({
          notice(O) {
            var x;
            (x = C.value) === null || x === void 0 || x.add(O);
          },
          removeNotice(O) {
            var x;
            (x = C.value) === null || x === void 0 || x.remove(O);
          },
          destroy() {
            yl(null, v), v.parentNode && v.parentNode.removeChild(v);
          },
          component: C
        });
      }), () => {
        const O = On, x = O.getRootPrefixCls(s, w.value), I = u ? c : `${w.value}-${c}`;
        return f(oa, D(D({}, O), {}, {
          prefixCls: x
        }), {
          default: () => [f(Kd, D(D({
            ref: C
          }, S), {}, {
            prefixCls: w.value,
            transitionName: I,
            hashId: $.value
          }), null)]
        });
      };
    }
  }), g = f(h, p);
  g.appContext = a || g.appContext, yl(g, v);
};
let JC = 0;
const eX = Date.now();
function e$() {
  const e = JC;
  return JC += 1, `rcNotification_${eX}_${e}`;
}
const tX = Z({
  name: "HookNotification",
  inheritAttrs: !1,
  props: ["prefixCls", "transitionName", "animation", "maxCount", "closeIcon", "hashId", "remove", "notices", "getStyles", "getClassName", "onAllRemoved", "getContainer"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = /* @__PURE__ */ new Map(), l = P(() => e.notices), a = P(() => {
      let u = e.transitionName;
      if (!u && e.animation)
        switch (typeof e.animation) {
          case "string":
            u = e.animation;
            break;
          case "function":
            u = e.animation().name;
            break;
          case "object":
            u = e.animation.name;
            break;
          default:
            u = `${e.prefixCls}-fade`;
            break;
        }
      return Nf(u);
    }), i = (u) => e.remove(u), s = Y({});
    ie(l, () => {
      const u = {};
      Object.keys(s.value).forEach((d) => {
        u[d] = [];
      }), e.notices.forEach((d) => {
        const {
          placement: p = "topRight"
        } = d.notice;
        p && (u[p] = u[p] || [], u[p].push(d));
      }), s.value = u;
    });
    const c = P(() => Object.keys(s.value));
    return () => {
      var u;
      const {
        prefixCls: d,
        closeIcon: p = (u = o.closeIcon) === null || u === void 0 ? void 0 : u.call(o, {
          prefixCls: d
        })
      } = e, v = c.value.map((h) => {
        var g, b;
        const y = s.value[h], S = (g = e.getClassName) === null || g === void 0 ? void 0 : g.call(e, h), C = (b = e.getStyles) === null || b === void 0 ? void 0 : b.call(e, h), w = y.map((x, I) => {
          let {
            notice: E,
            holderCallback: _
          } = x;
          const M = I === l.value.length - 1 ? E.updateMark : void 0, {
            key: R,
            userPassKey: A
          } = E, {
            content: z
          } = E, T = m(m(m({
            prefixCls: d,
            closeIcon: typeof p == "function" ? p({
              prefixCls: d
            }) : p
          }, E), E.props), {
            key: R,
            noticeKey: A || R,
            updateMark: M,
            onClose: (N) => {
              var k;
              i(N), (k = E.onClose) === null || k === void 0 || k.call(E);
            },
            onClick: E.onClick
          });
          return _ ? f("div", {
            key: R,
            class: `${d}-hook-holder`,
            ref: (N) => {
              typeof R > "u" || (N ? (r.set(R, N), _(N, T)) : r.delete(R));
            }
          }, null) : f(hp, D(D({}, T), {}, {
            class: ee(T.class, e.hashId)
          }), {
            default: () => [typeof z == "function" ? z({
              prefixCls: d
            }) : z]
          });
        }), $ = {
          [d]: 1,
          [`${d}-${h}`]: 1,
          [n.class]: !!n.class,
          [e.hashId]: !0,
          [S]: !!S
        };
        function O() {
          var x;
          y.length > 0 || (Reflect.deleteProperty(s.value, h), (x = e.onAllRemoved) === null || x === void 0 || x.call(e));
        }
        return f("div", {
          key: h,
          class: $,
          style: n.style || C || {
            top: "65px",
            left: "50%"
          }
        }, [f(gf, D(D({
          tag: "div"
        }, a.value), {}, {
          onAfterLeave: O
        }), {
          default: () => [w]
        })]);
      });
      return f(x4, {
        getContainer: e.getContainer
      }, {
        default: () => [v]
      });
    };
  }
}), nX = tX;
var oX = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const rX = () => document.body;
let t$ = 0;
function lX() {
  const e = {};
  for (var t = arguments.length, n = new Array(t), o = 0; o < t; o++)
    n[o] = arguments[o];
  return n.forEach((r) => {
    r && Object.keys(r).forEach((l) => {
      const a = r[l];
      a !== void 0 && (e[l] = a);
    });
  }), e;
}
function DP() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    getContainer: t = rX,
    motion: n,
    prefixCls: o,
    maxCount: r,
    getClassName: l,
    getStyles: a,
    onAllRemoved: i
  } = e, s = oX(e, ["getContainer", "motion", "prefixCls", "maxCount", "getClassName", "getStyles", "onAllRemoved"]), c = Q([]), u = Q(), d = (y, S) => {
    const C = y.key || e$(), w = m(m({}, y), {
      key: C
    }), $ = c.value.map((x) => x.notice.key).indexOf(C), O = c.value.concat();
    $ !== -1 ? O.splice($, 1, {
      notice: w,
      holderCallback: S
    }) : (r && c.value.length >= r && (w.key = O[0].notice.key, w.updateMark = e$(), w.userPassKey = C, O.shift()), O.push({
      notice: w,
      holderCallback: S
    })), c.value = O;
  }, p = (y) => {
    c.value = c.value.filter((S) => {
      let {
        notice: {
          key: C,
          userPassKey: w
        }
      } = S;
      return (w || C) !== y;
    });
  }, v = () => {
    c.value = [];
  }, h = () => f(nX, {
    ref: u,
    prefixCls: o,
    maxCount: r,
    notices: c.value,
    remove: p,
    getClassName: l,
    getStyles: a,
    animation: n,
    hashId: e.hashId,
    onAllRemoved: i,
    getContainer: t
  }, null), g = Q([]), b = {
    open: (y) => {
      const S = lX(s, y);
      (S.key === null || S.key === void 0) && (S.key = `vc-notification-${t$}`, t$ += 1), g.value = [...g.value, {
        type: "open",
        config: S
      }];
    },
    close: (y) => {
      g.value = [...g.value, {
        type: "close",
        key: y
      }];
    },
    destroy: () => {
      g.value = [...g.value, {
        type: "destroy"
      }];
    }
  };
  return ie(g, () => {
    g.value.length && (g.value.forEach((y) => {
      switch (y.type) {
        case "open":
          d(y.config);
          break;
        case "close":
          p(y.key);
          break;
        case "destroy":
          v();
          break;
      }
    }), g.value = []);
  }), [b, h];
}
const aX = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    boxShadowSecondary: o,
    colorBgElevated: r,
    colorSuccess: l,
    colorError: a,
    colorWarning: i,
    colorInfo: s,
    fontSizeLG: c,
    motionEaseInOutCirc: u,
    motionDurationSlow: d,
    marginXS: p,
    paddingXS: v,
    borderRadiusLG: h,
    zIndexPopup: g,
    // Custom token
    messageNoticeContentPadding: b
  } = e, y = new lt("MessageMoveIn", {
    "0%": {
      padding: 0,
      transform: "translateY(-100%)",
      opacity: 0
    },
    "100%": {
      padding: v,
      transform: "translateY(0)",
      opacity: 1
    }
  }), S = new lt("MessageMoveOut", {
    "0%": {
      maxHeight: e.height,
      padding: v,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      padding: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [t]: m(m({}, qe(e)), {
        position: "fixed",
        top: p,
        left: "50%",
        transform: "translateX(-50%)",
        width: "100%",
        pointerEvents: "none",
        zIndex: g,
        [`${t}-move-up`]: {
          animationFillMode: "forwards"
        },
        [`
        ${t}-move-up-appear,
        ${t}-move-up-enter
      `]: {
          animationName: y,
          animationDuration: d,
          animationPlayState: "paused",
          animationTimingFunction: u
        },
        [`
        ${t}-move-up-appear${t}-move-up-appear-active,
        ${t}-move-up-enter${t}-move-up-enter-active
      `]: {
          animationPlayState: "running"
        },
        [`${t}-move-up-leave`]: {
          animationName: S,
          animationDuration: d,
          animationPlayState: "paused",
          animationTimingFunction: u
        },
        [`${t}-move-up-leave${t}-move-up-leave-active`]: {
          animationPlayState: "running"
        },
        "&-rtl": {
          direction: "rtl",
          span: {
            direction: "rtl"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [`${t}-notice`]: {
        padding: v,
        textAlign: "center",
        [n]: {
          verticalAlign: "text-bottom",
          marginInlineEnd: p,
          fontSize: c
        },
        [`${t}-notice-content`]: {
          display: "inline-block",
          padding: b,
          background: r,
          borderRadius: h,
          boxShadow: o,
          pointerEvents: "all"
        },
        [`${t}-success ${n}`]: {
          color: l
        },
        [`${t}-error ${n}`]: {
          color: a
        },
        [`${t}-warning ${n}`]: {
          color: i
        },
        [`
        ${t}-info ${n},
        ${t}-loading ${n}`]: {
          color: s
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${t}-notice-pure-panel`]: {
        padding: 0,
        textAlign: "start"
      }
    }
  ];
}, cb = Xe("Message", (e) => {
  const t = He(e, {
    messageNoticeContentPadding: `${(e.controlHeightLG - e.fontSize * e.lineHeight) / 2}px ${e.paddingSM}px`
  });
  return [aX(t)];
}, (e) => ({
  height: 150,
  zIndexPopup: e.zIndexPopupBase + 10
})), iX = {
  info: f(Pl, null, null),
  success: f(ir, null, null),
  error: f(Gn, null, null),
  warning: f(sr, null, null),
  loading: f(Qn, null, null)
}, NP = Z({
  name: "PureContent",
  inheritAttrs: !1,
  props: ["prefixCls", "type", "icon"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return f("div", {
        class: ee(`${e.prefixCls}-custom-content`, `${e.prefixCls}-${e.type}`)
      }, [e.icon || iX[e.type], f("span", null, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)])]);
    };
  }
});
Z({
  name: "PurePanel",
  inheritAttrs: !1,
  props: ["prefixCls", "class", "type", "icon", "content"],
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    var r;
    const {
      getPrefixCls: l
    } = oc(), a = P(() => e.prefixCls || l("message")), [, i] = cb(a);
    return f(hp, D(D({}, o), {}, {
      prefixCls: a.value,
      class: ee(i.value, `${a.value}-notice-pure-panel`),
      noticeKey: "pure",
      duration: null
    }), {
      default: () => [f(NP, {
        prefixCls: a.value,
        type: e.type,
        icon: e.icon
      }, {
        default: () => [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)]
      })]
    });
  }
});
var sX = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const cX = 8, uX = 3, dX = Z({
  name: "Holder",
  inheritAttrs: !1,
  props: ["top", "prefixCls", "getContainer", "maxCount", "duration", "rtl", "transitionName", "onAllRemoved", "animation", "staticGetContainer"],
  setup(e, t) {
    let {
      expose: n
    } = t;
    var o, r;
    const {
      getPrefixCls: l,
      getPopupContainer: a
    } = Ie("message", e), i = P(() => l("message", e.prefixCls)), [, s] = cb(i), c = () => {
      var g;
      const b = (g = e.top) !== null && g !== void 0 ? g : cX;
      return {
        left: "50%",
        transform: "translateX(-50%)",
        top: typeof b == "number" ? `${b}px` : b
      };
    }, u = () => ee(s.value, e.rtl ? `${i.value}-rtl` : ""), d = () => {
      var g;
      return Sh({
        prefixCls: i.value,
        animation: (g = e.animation) !== null && g !== void 0 ? g : "move-up",
        transitionName: e.transitionName
      });
    }, p = f("span", {
      class: `${i.value}-close-x`
    }, [f(Kn, {
      class: `${i.value}-close-icon`
    }, null)]), [v, h] = DP({
      //@ts-ignore
      getStyles: c,
      prefixCls: i.value,
      getClassName: u,
      motion: d,
      closable: !1,
      closeIcon: p,
      duration: (o = e.duration) !== null && o !== void 0 ? o : uX,
      getContainer: (r = e.staticGetContainer) !== null && r !== void 0 ? r : a.value,
      maxCount: e.maxCount,
      onAllRemoved: e.onAllRemoved
    });
    return n(m(m({}, v), {
      prefixCls: i,
      hashId: s
    })), h;
  }
});
let n$ = 0;
function fX(e) {
  const t = Q(null), n = Symbol("messageHolderKey"), o = (s) => {
    var c;
    (c = t.value) === null || c === void 0 || c.close(s);
  }, r = (s) => {
    if (!t.value) {
      const $ = () => {
      };
      return $.then = () => {
      }, $;
    }
    const {
      open: c,
      prefixCls: u,
      hashId: d
    } = t.value, p = `${u}-notice`, {
      content: v,
      icon: h,
      type: g,
      key: b,
      class: y,
      onClose: S
    } = s, C = sX(s, ["content", "icon", "type", "key", "class", "onClose"]);
    let w = b;
    return w == null && (n$ += 1, w = `antd-message-${n$}`), TT(($) => (c(m(m({}, C), {
      key: w,
      content: () => f(NP, {
        prefixCls: u,
        type: g,
        icon: typeof h == "function" ? h() : h
      }, {
        default: () => [typeof v == "function" ? v() : v]
      }),
      placement: "top",
      // @ts-ignore
      class: ee(g && `${p}-${g}`, d, y),
      onClose: () => {
        S == null || S(), $();
      }
    })), () => {
      o(w);
    }));
  }, a = {
    open: r,
    destroy: (s) => {
      var c;
      s !== void 0 ? o(s) : (c = t.value) === null || c === void 0 || c.destroy();
    }
  };
  return ["info", "success", "warning", "error", "loading"].forEach((s) => {
    const c = (u, d, p) => {
      let v;
      u && typeof u == "object" && "content" in u ? v = u : v = {
        content: u
      };
      let h, g;
      typeof d == "function" ? g = d : (h = d, g = p);
      const b = m(m({
        onClose: g,
        duration: h
      }, v), {
        type: s
      });
      return r(b);
    };
    a[s] = c;
  }), [a, () => f(dX, D(D({
    key: n
  }, e), {}, {
    ref: t
  }), null)];
}
function RP(e) {
  return fX(e);
}
let kP = 3, BP, Yn, pX = 1, FP = "", LP = "move-up", zP = !1, HP = () => document.body, jP, VP = !1;
function vX() {
  return pX++;
}
function gX(e) {
  e.top !== void 0 && (BP = e.top, Yn = null), e.duration !== void 0 && (kP = e.duration), e.prefixCls !== void 0 && (FP = e.prefixCls), e.getContainer !== void 0 && (HP = e.getContainer, Yn = null), e.transitionName !== void 0 && (LP = e.transitionName, Yn = null, zP = !0), e.maxCount !== void 0 && (jP = e.maxCount, Yn = null), e.rtl !== void 0 && (VP = e.rtl);
}
function mX(e, t) {
  if (Yn) {
    t(Yn);
    return;
  }
  Kd.newInstance({
    appContext: e.appContext,
    prefixCls: e.prefixCls || FP,
    rootPrefixCls: e.rootPrefixCls,
    transitionName: LP,
    hasTransitionName: zP,
    style: {
      top: BP
    },
    getContainer: HP || e.getPopupContainer,
    maxCount: jP,
    name: "message",
    useStyle: cb
  }, (n) => {
    if (Yn) {
      t(Yn);
      return;
    }
    Yn = n, t(n);
  });
}
const WP = {
  info: Pl,
  success: ir,
  error: Gn,
  warning: sr,
  loading: Qn
}, hX = Object.keys(WP);
function bX(e) {
  const t = e.duration !== void 0 ? e.duration : kP, n = e.key || vX(), o = new Promise((l) => {
    const a = () => (typeof e.onClose == "function" && e.onClose(), l(!0));
    mX(e, (i) => {
      i.notice({
        key: n,
        duration: t,
        style: e.style || {},
        class: e.class,
        content: (s) => {
          let {
            prefixCls: c
          } = s;
          const u = WP[e.type], d = u ? f(u, null, null) : "", p = ee(`${c}-custom-content`, {
            [`${c}-${e.type}`]: e.type,
            [`${c}-rtl`]: VP === !0
          });
          return f("div", {
            class: p
          }, [typeof e.icon == "function" ? e.icon() : e.icon || d, f("span", null, [typeof e.content == "function" ? e.content() : e.content])]);
        },
        onClose: a,
        onClick: e.onClick
      });
    });
  }), r = () => {
    Yn && Yn.removeNotice(n);
  };
  return r.then = (l, a) => o.then(l, a), r.promise = o, r;
}
function yX(e) {
  return Object.prototype.toString.call(e) === "[object Object]" && !!e.content;
}
const xn = {
  open: bX,
  config: gX,
  destroy(e) {
    if (Yn)
      if (e) {
        const {
          removeNotice: t
        } = Yn;
        t(e);
      } else {
        const {
          destroy: t
        } = Yn;
        t(), Yn = null;
      }
  }
};
function SX(e, t) {
  e[t] = (n, o, r) => yX(n) ? e.open(m(m({}, n), {
    type: t
  })) : (typeof o == "function" && (r = o, o = void 0), e.open({
    content: n,
    duration: o,
    type: t,
    onClose: r
  }));
}
hX.forEach((e) => SX(xn, e));
xn.warn = xn.warning;
xn.useMessage = RP;
const CX = (e) => {
  const {
    componentCls: t,
    width: n,
    notificationMarginEdge: o
  } = e, r = new lt("antNotificationTopFadeIn", {
    "0%": {
      marginTop: "-100%",
      opacity: 0
    },
    "100%": {
      marginTop: 0,
      opacity: 1
    }
  }), l = new lt("antNotificationBottomFadeIn", {
    "0%": {
      marginBottom: "-100%",
      opacity: 0
    },
    "100%": {
      marginBottom: 0,
      opacity: 1
    }
  }), a = new lt("antNotificationLeftFadeIn", {
    "0%": {
      right: {
        _skip_check_: !0,
        value: n
      },
      opacity: 0
    },
    "100%": {
      right: {
        _skip_check_: !0,
        value: 0
      },
      opacity: 1
    }
  });
  return {
    [`&${t}-top, &${t}-bottom`]: {
      marginInline: 0
    },
    [`&${t}-top`]: {
      [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
        animationName: r
      }
    },
    [`&${t}-bottom`]: {
      [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
        animationName: l
      }
    },
    [`&${t}-topLeft, &${t}-bottomLeft`]: {
      marginInlineEnd: 0,
      marginInlineStart: o,
      [`${t}-fade-enter${t}-fade-enter-active, ${t}-fade-appear${t}-fade-appear-active`]: {
        animationName: a
      }
    }
  };
}, $X = (e) => {
  const {
    iconCls: t,
    componentCls: n,
    // .ant-notification
    boxShadowSecondary: o,
    fontSizeLG: r,
    notificationMarginBottom: l,
    borderRadiusLG: a,
    colorSuccess: i,
    colorInfo: s,
    colorWarning: c,
    colorError: u,
    colorTextHeading: d,
    notificationBg: p,
    notificationPadding: v,
    notificationMarginEdge: h,
    motionDurationMid: g,
    motionEaseInOut: b,
    fontSize: y,
    lineHeight: S,
    width: C,
    notificationIconSize: w
  } = e, $ = `${n}-notice`, O = new lt("antNotificationFadeIn", {
    "0%": {
      left: {
        _skip_check_: !0,
        value: C
      },
      opacity: 0
    },
    "100%": {
      left: {
        _skip_check_: !0,
        value: 0
      },
      opacity: 1
    }
  }), x = new lt("antNotificationFadeOut", {
    "0%": {
      maxHeight: e.animationMaxHeight,
      marginBottom: l,
      opacity: 1
    },
    "100%": {
      maxHeight: 0,
      marginBottom: 0,
      paddingTop: 0,
      paddingBottom: 0,
      opacity: 0
    }
  });
  return [
    // ============================ Holder ============================
    {
      [n]: m(m(m(m({}, qe(e)), {
        position: "fixed",
        zIndex: e.zIndexPopup,
        marginInlineEnd: h,
        [`${n}-hook-holder`]: {
          position: "relative"
        },
        [`&${n}-top, &${n}-bottom`]: {
          [`${n}-notice`]: {
            marginInline: "auto auto"
          }
        },
        [`&${n}-topLeft, &${n}-bottomLeft`]: {
          [`${n}-notice`]: {
            marginInlineEnd: "auto",
            marginInlineStart: 0
          }
        },
        //  animation
        [`${n}-fade-enter, ${n}-fade-appear`]: {
          animationDuration: e.motionDurationMid,
          animationTimingFunction: b,
          animationFillMode: "both",
          opacity: 0,
          animationPlayState: "paused"
        },
        [`${n}-fade-leave`]: {
          animationTimingFunction: b,
          animationFillMode: "both",
          animationDuration: g,
          animationPlayState: "paused"
        },
        [`${n}-fade-enter${n}-fade-enter-active, ${n}-fade-appear${n}-fade-appear-active`]: {
          animationName: O,
          animationPlayState: "running"
        },
        [`${n}-fade-leave${n}-fade-leave-active`]: {
          animationName: x,
          animationPlayState: "running"
        }
      }), CX(e)), {
        // RTL
        "&-rtl": {
          direction: "rtl",
          [`${n}-notice-btn`]: {
            float: "left"
          }
        }
      })
    },
    // ============================ Notice ============================
    {
      [$]: {
        position: "relative",
        width: C,
        maxWidth: `calc(100vw - ${h * 2}px)`,
        marginBottom: l,
        marginInlineStart: "auto",
        padding: v,
        overflow: "hidden",
        lineHeight: S,
        wordWrap: "break-word",
        background: p,
        borderRadius: a,
        boxShadow: o,
        [`${n}-close-icon`]: {
          fontSize: y,
          cursor: "pointer"
        },
        [`${$}-message`]: {
          marginBottom: e.marginXS,
          color: d,
          fontSize: r,
          lineHeight: e.lineHeightLG
        },
        [`${$}-description`]: {
          fontSize: y
        },
        [`&${$}-closable ${$}-message`]: {
          paddingInlineEnd: e.paddingLG
        },
        [`${$}-with-icon ${$}-message`]: {
          marginBottom: e.marginXS,
          marginInlineStart: e.marginSM + w,
          fontSize: r
        },
        [`${$}-with-icon ${$}-description`]: {
          marginInlineStart: e.marginSM + w,
          fontSize: y
        },
        // Icon & color style in different selector level
        // https://github.com/ant-design/ant-design/issues/16503
        // https://github.com/ant-design/ant-design/issues/15512
        [`${$}-icon`]: {
          position: "absolute",
          fontSize: w,
          lineHeight: 0,
          // icon-font
          [`&-success${t}`]: {
            color: i
          },
          [`&-info${t}`]: {
            color: s
          },
          [`&-warning${t}`]: {
            color: c
          },
          [`&-error${t}`]: {
            color: u
          }
        },
        [`${$}-close`]: {
          position: "absolute",
          top: e.notificationPaddingVertical,
          insetInlineEnd: e.notificationPaddingHorizontal,
          color: e.colorIcon,
          outline: "none",
          width: e.notificationCloseButtonSize,
          height: e.notificationCloseButtonSize,
          borderRadius: e.borderRadiusSM,
          transition: `background-color ${e.motionDurationMid}, color ${e.motionDurationMid}`,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          "&:hover": {
            color: e.colorIconHover,
            backgroundColor: e.wireframe ? "transparent" : e.colorFillContent
          }
        },
        [`${$}-btn`]: {
          float: "right",
          marginTop: e.marginSM
        }
      }
    },
    // ============================= Pure =============================
    {
      [`${$}-pure-panel`]: {
        margin: 0
      }
    }
  ];
}, ub = Xe("Notification", (e) => {
  const t = e.paddingMD, n = e.paddingLG, o = He(e, {
    // default.less variables
    notificationBg: e.colorBgElevated,
    notificationPaddingVertical: t,
    notificationPaddingHorizontal: n,
    // index.less variables
    notificationPadding: `${e.paddingMD}px ${e.paddingContentHorizontalLG}px`,
    notificationMarginBottom: e.margin,
    notificationMarginEdge: e.marginLG,
    animationMaxHeight: 150,
    notificationIconSize: e.fontSizeLG * e.lineHeightLG,
    notificationCloseButtonSize: e.controlHeightLG * 0.55
  });
  return [$X(o)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 50,
  width: 384
}));
function KP(e, t) {
  return t || f("span", {
    class: `${e}-close-x`
  }, [f(Kn, {
    class: `${e}-close-icon`
  }, null)]);
}
f(Pl, null, null), f(ir, null, null), f(Gn, null, null), f(sr, null, null), f(Qn, null, null);
const wX = {
  success: ir,
  info: Pl,
  error: Gn,
  warning: sr
};
function GP(e) {
  let {
    prefixCls: t,
    icon: n,
    type: o,
    message: r,
    description: l,
    btn: a
  } = e, i = null;
  if (n)
    i = f("span", {
      class: `${t}-icon`
    }, [Ga(n)]);
  else if (o) {
    const s = wX[o];
    i = f(s, {
      class: `${t}-icon ${t}-icon-${o}`
    }, null);
  }
  return f("div", {
    class: ee({
      [`${t}-with-icon`]: i
    }),
    role: "alert"
  }, [i, f("div", {
    class: `${t}-message`
  }, [r]), f("div", {
    class: `${t}-description`
  }, [l]), a && f("div", {
    class: `${t}-btn`
  }, [a])]);
}
Z({
  name: "PurePanel",
  inheritAttrs: !1,
  props: ["prefixCls", "icon", "type", "message", "description", "btn", "closeIcon"],
  setup(e) {
    const {
      getPrefixCls: t
    } = Ie("notification", e), n = P(() => e.prefixCls || t("notification")), o = P(() => `${n.value}-notice`), [, r] = ub(n);
    return () => f(hp, D(D({}, e), {}, {
      prefixCls: n.value,
      class: ee(r.value, `${o.value}-pure-panel`),
      noticeKey: "pure",
      duration: null,
      closable: e.closable,
      closeIcon: KP(n.value, e.closeIcon)
    }), {
      default: () => [f(GP, {
        prefixCls: o.value,
        icon: e.icon,
        type: e.type,
        message: e.message,
        description: e.description,
        btn: e.btn
      }, null)]
    });
  }
});
function XP(e, t, n) {
  let o;
  switch (t = typeof t == "number" ? `${t}px` : t, n = typeof n == "number" ? `${n}px` : n, e) {
    case "top":
      o = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: t,
        bottom: "auto"
      };
      break;
    case "topLeft":
      o = {
        left: 0,
        top: t,
        bottom: "auto"
      };
      break;
    case "topRight":
      o = {
        right: 0,
        top: t,
        bottom: "auto"
      };
      break;
    case "bottom":
      o = {
        left: "50%",
        transform: "translateX(-50%)",
        right: "auto",
        top: "auto",
        bottom: n
      };
      break;
    case "bottomLeft":
      o = {
        left: 0,
        top: "auto",
        bottom: n
      };
      break;
    default:
      o = {
        right: 0,
        top: "auto",
        bottom: n
      };
      break;
  }
  return o;
}
function xX(e) {
  return {
    name: `${e}-fade`
  };
}
var OX = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const o$ = 24, PX = 4.5, IX = Z({
  name: "Holder",
  inheritAttrs: !1,
  props: ["prefixCls", "class", "type", "icon", "content", "onAllRemoved"],
  setup(e, t) {
    let {
      expose: n
    } = t;
    const {
      getPrefixCls: o,
      getPopupContainer: r
    } = Ie("notification", e), l = P(() => e.prefixCls || o("notification")), a = (p) => {
      var v, h;
      return XP(p, (v = e.top) !== null && v !== void 0 ? v : o$, (h = e.bottom) !== null && h !== void 0 ? h : o$);
    }, [, i] = ub(l), s = () => ee(i.value, {
      [`${l.value}-rtl`]: e.rtl
    }), c = () => xX(l.value), [u, d] = DP({
      prefixCls: l.value,
      getStyles: a,
      getClassName: s,
      motion: c,
      closable: !0,
      closeIcon: KP(l.value),
      duration: PX,
      getContainer: () => {
        var p, v;
        return ((p = e.getPopupContainer) === null || p === void 0 ? void 0 : p.call(e)) || ((v = r.value) === null || v === void 0 ? void 0 : v.call(r)) || document.body;
      },
      maxCount: e.maxCount,
      hashId: i.value,
      onAllRemoved: e.onAllRemoved
    });
    return n(m(m({}, u), {
      prefixCls: l.value,
      hashId: i
    })), d;
  }
});
function EX(e) {
  const t = Q(null), n = Symbol("notificationHolderKey"), o = (i) => {
    if (!t.value)
      return;
    const {
      open: s,
      prefixCls: c,
      hashId: u
    } = t.value, d = `${c}-notice`, {
      message: p,
      description: v,
      icon: h,
      type: g,
      btn: b,
      class: y
    } = i, S = OX(i, ["message", "description", "icon", "type", "btn", "class"]);
    return s(m(m({
      placement: "topRight"
    }, S), {
      content: () => f(GP, {
        prefixCls: d,
        icon: typeof h == "function" ? h() : h,
        type: g,
        message: typeof p == "function" ? p() : p,
        description: typeof v == "function" ? v() : v,
        btn: typeof b == "function" ? b() : b
      }, null),
      // @ts-ignore
      class: ee(g && `${d}-${g}`, u, y)
    }));
  }, l = {
    open: o,
    destroy: (i) => {
      var s, c;
      i !== void 0 ? (s = t.value) === null || s === void 0 || s.close(i) : (c = t.value) === null || c === void 0 || c.destroy();
    }
  };
  return ["success", "info", "warning", "error"].forEach((i) => {
    l[i] = (s) => o(m(m({}, s), {
      type: i
    }));
  }), [l, () => f(IX, D(D({
    key: n
  }, e), {}, {
    ref: t
  }), null)];
}
function UP(e) {
  return EX(e);
}
const Kl = {};
let YP = 4.5, qP = "24px", ZP = "24px", Cm = "", QP = "topRight", JP = () => document.body, eI = null, $m = !1, tI;
function TX(e) {
  const {
    duration: t,
    placement: n,
    bottom: o,
    top: r,
    getContainer: l,
    closeIcon: a,
    prefixCls: i
  } = e;
  i !== void 0 && (Cm = i), t !== void 0 && (YP = t), n !== void 0 && (QP = n), o !== void 0 && (ZP = typeof o == "number" ? `${o}px` : o), r !== void 0 && (qP = typeof r == "number" ? `${r}px` : r), l !== void 0 && (JP = l), a !== void 0 && (eI = a), e.rtl !== void 0 && ($m = e.rtl), e.maxCount !== void 0 && (tI = e.maxCount);
}
function MX(e, t) {
  let {
    prefixCls: n,
    placement: o = QP,
    getContainer: r = JP,
    top: l,
    bottom: a,
    closeIcon: i = eI,
    appContext: s
  } = e;
  const {
    getPrefixCls: c
  } = jX(), u = c("notification", n || Cm), d = `${u}-${o}-${$m}`, p = Kl[d];
  if (p) {
    Promise.resolve(p).then((h) => {
      t(h);
    });
    return;
  }
  const v = ee(`${u}-${o}`, {
    [`${u}-rtl`]: $m === !0
  });
  Kd.newInstance({
    name: "notification",
    prefixCls: n || Cm,
    useStyle: ub,
    class: v,
    style: XP(o, l ?? qP, a ?? ZP),
    appContext: s,
    getContainer: r,
    closeIcon: (h) => {
      let {
        prefixCls: g
      } = h;
      return f("span", {
        class: `${g}-close-x`
      }, [Ga(i, {}, f(Kn, {
        class: `${g}-close-icon`
      }, null))]);
    },
    maxCount: tI,
    hasTransitionName: !0
  }, (h) => {
    Kl[d] = h, t(h);
  });
}
const _X = {
  success: Uf,
  info: qf,
  error: Zf,
  warning: Yf
};
function AX(e) {
  const {
    icon: t,
    type: n,
    description: o,
    message: r,
    btn: l
  } = e, a = e.duration === void 0 ? YP : e.duration;
  MX(e, (i) => {
    i.notice({
      content: (s) => {
        let {
          prefixCls: c
        } = s;
        const u = `${c}-notice`;
        let d = null;
        if (t)
          d = () => f("span", {
            class: `${u}-icon`
          }, [Ga(t)]);
        else if (n) {
          const p = _X[n];
          d = () => f(p, {
            class: `${u}-icon ${u}-icon-${n}`
          }, null);
        }
        return f("div", {
          class: d ? `${u}-with-icon` : ""
        }, [d && d(), f("div", {
          class: `${u}-message`
        }, [!o && d ? f("span", {
          class: `${u}-message-single-line-auto-margin`
        }, null) : null, Ga(r)]), f("div", {
          class: `${u}-description`
        }, [Ga(o)]), l ? f("span", {
          class: `${u}-btn`
        }, [Ga(l)]) : null]);
      },
      duration: a,
      closable: !0,
      onClose: e.onClose,
      onClick: e.onClick,
      key: e.key,
      style: e.style || {},
      class: e.class
    });
  });
}
const pa = {
  open: AX,
  close(e) {
    Object.keys(Kl).forEach((t) => Promise.resolve(Kl[t]).then((n) => {
      n.removeNotice(e);
    }));
  },
  config: TX,
  destroy() {
    Object.keys(Kl).forEach((e) => {
      Promise.resolve(Kl[e]).then((t) => {
        t.destroy();
      }), delete Kl[e];
    });
  }
}, DX = ["success", "info", "warning", "error"];
DX.forEach((e) => {
  pa[e] = (t) => pa.open(m(m({}, t), {
    type: e
  }));
});
pa.warn = pa.warning;
pa.useNotification = UP;
const NX = `-ant-${Date.now()}-${Math.random()}`;
function RX(e, t) {
  const n = {}, o = (a, i) => {
    let s = a.clone();
    return s = (i == null ? void 0 : i(s)) || s, s.toRgbString();
  }, r = (a, i) => {
    const s = new Ct(a), c = sa(s.toRgbString());
    n[`${i}-color`] = o(s), n[`${i}-color-disabled`] = c[1], n[`${i}-color-hover`] = c[4], n[`${i}-color-active`] = c[6], n[`${i}-color-outline`] = s.clone().setAlpha(0.2).toRgbString(), n[`${i}-color-deprecated-bg`] = c[0], n[`${i}-color-deprecated-border`] = c[2];
  };
  if (t.primaryColor) {
    r(t.primaryColor, "primary");
    const a = new Ct(t.primaryColor), i = sa(a.toRgbString());
    i.forEach((c, u) => {
      n[`primary-${u + 1}`] = c;
    }), n["primary-color-deprecated-l-35"] = o(a, (c) => c.lighten(35)), n["primary-color-deprecated-l-20"] = o(a, (c) => c.lighten(20)), n["primary-color-deprecated-t-20"] = o(a, (c) => c.tint(20)), n["primary-color-deprecated-t-50"] = o(a, (c) => c.tint(50)), n["primary-color-deprecated-f-12"] = o(a, (c) => c.setAlpha(c.getAlpha() * 0.12));
    const s = new Ct(i[0]);
    n["primary-color-active-deprecated-f-30"] = o(s, (c) => c.setAlpha(c.getAlpha() * 0.3)), n["primary-color-active-deprecated-d-02"] = o(s, (c) => c.darken(2));
  }
  return t.successColor && r(t.successColor, "success"), t.warningColor && r(t.warningColor, "warning"), t.errorColor && r(t.errorColor, "error"), t.infoColor && r(t.infoColor, "info"), `
  :root {
    ${Object.keys(n).map((a) => `--${e}-${a}: ${n[a]};`).join(`
`)}
  }
  `.trim();
}
function kX(e, t) {
  const n = RX(e, t);
  jn() ? Rs(n, `${NX}-dynamic-theme`) : Mt(!1, "ConfigProvider", "SSR do not support dynamic theme with css variables.");
}
const BX = (e) => {
  const [t, n] = qr();
  return Ig(P(() => ({
    theme: t.value,
    token: n.value,
    hashId: "",
    path: ["ant-design-icons", e.value]
  })), () => [{
    [`.${e.value}`]: m(m({}, ha()), {
      [`.${e.value} .${e.value}-icon`]: {
        display: "block"
      }
    })
  }]);
};
function FX(e, t) {
  const n = P(() => (e == null ? void 0 : e.value) || {}), o = P(() => n.value.inherit === !1 || !(t != null && t.value) ? A2 : t.value);
  return P(() => {
    if (!(e != null && e.value))
      return t == null ? void 0 : t.value;
    const l = m({}, o.value.components);
    return Object.keys(e.value.components || {}).forEach((a) => {
      l[a] = m(m({}, l[a]), e.value.components[a]);
    }), m(m(m({}, o.value), n.value), {
      token: m(m({}, o.value.token), n.value.token),
      components: l
    });
  });
}
var LX = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const zX = "ant";
function si() {
  return On.prefixCls || zX;
}
function nI() {
  return On.iconPrefixCls || ah;
}
const db = xt({}), On = xt({});
Le(() => {
  m(On, db), On.prefixCls = si(), On.iconPrefixCls = nI(), On.getPrefixCls = (e, t) => t || (e ? `${On.prefixCls}-${e}` : On.prefixCls), On.getRootPrefixCls = () => On.prefixCls ? On.prefixCls : si();
});
let Tv;
const HX = (e) => {
  Tv && Tv(), Tv = Le(() => {
    m(db, xt(e)), m(On, xt(e));
  }), e.theme && kX(si(), e.theme);
}, jX = () => ({
  getPrefixCls: (e, t) => t || (e ? `${si()}-${e}` : si()),
  getIconPrefixCls: nI,
  getRootPrefixCls: () => On.prefixCls ? On.prefixCls : si()
}), oa = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AConfigProvider",
  inheritAttrs: !1,
  props: t8(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = oc(), r = (T, N) => {
      const {
        prefixCls: k = "ant"
      } = e;
      if (N)
        return N;
      const B = k || o.getPrefixCls("");
      return T ? `${B}-${T}` : B;
    }, l = P(() => e.iconPrefixCls || o.iconPrefixCls.value || ah), a = P(() => l.value !== o.iconPrefixCls.value), i = P(() => {
      var T;
      return e.csp || ((T = o.csp) === null || T === void 0 ? void 0 : T.value);
    }), s = BX(l), c = FX(P(() => e.theme), P(() => {
      var T;
      return (T = o.theme) === null || T === void 0 ? void 0 : T.value;
    })), u = (T) => (e.renderEmpty || n.renderEmpty || o.renderEmpty || W5)(T), d = P(() => {
      var T, N;
      return (T = e.autoInsertSpaceInButton) !== null && T !== void 0 ? T : (N = o.autoInsertSpaceInButton) === null || N === void 0 ? void 0 : N.value;
    }), p = P(() => {
      var T;
      return e.locale || ((T = o.locale) === null || T === void 0 ? void 0 : T.value);
    });
    ie(p, () => {
      db.locale = p.value;
    }, {
      immediate: !0
    });
    const v = P(() => {
      var T;
      return e.direction || ((T = o.direction) === null || T === void 0 ? void 0 : T.value);
    }), h = P(() => {
      var T, N;
      return (T = e.space) !== null && T !== void 0 ? T : (N = o.space) === null || N === void 0 ? void 0 : N.value;
    }), g = P(() => {
      var T, N;
      return (T = e.virtual) !== null && T !== void 0 ? T : (N = o.virtual) === null || N === void 0 ? void 0 : N.value;
    }), b = P(() => {
      var T, N;
      return (T = e.dropdownMatchSelectWidth) !== null && T !== void 0 ? T : (N = o.dropdownMatchSelectWidth) === null || N === void 0 ? void 0 : N.value;
    }), y = P(() => {
      var T;
      return e.getTargetContainer !== void 0 ? e.getTargetContainer : (T = o.getTargetContainer) === null || T === void 0 ? void 0 : T.value;
    }), S = P(() => {
      var T;
      return e.getPopupContainer !== void 0 ? e.getPopupContainer : (T = o.getPopupContainer) === null || T === void 0 ? void 0 : T.value;
    }), C = P(() => {
      var T;
      return e.pageHeader !== void 0 ? e.pageHeader : (T = o.pageHeader) === null || T === void 0 ? void 0 : T.value;
    }), w = P(() => {
      var T;
      return e.input !== void 0 ? e.input : (T = o.input) === null || T === void 0 ? void 0 : T.value;
    }), $ = P(() => {
      var T;
      return e.pagination !== void 0 ? e.pagination : (T = o.pagination) === null || T === void 0 ? void 0 : T.value;
    }), O = P(() => {
      var T;
      return e.form !== void 0 ? e.form : (T = o.form) === null || T === void 0 ? void 0 : T.value;
    }), x = P(() => {
      var T;
      return e.select !== void 0 ? e.select : (T = o.select) === null || T === void 0 ? void 0 : T.value;
    }), I = P(() => e.componentSize), E = P(() => e.componentDisabled), _ = P(() => {
      var T, N;
      return (T = e.wave) !== null && T !== void 0 ? T : (N = o.wave) === null || N === void 0 ? void 0 : N.value;
    }), M = {
      csp: i,
      autoInsertSpaceInButton: d,
      locale: p,
      direction: v,
      space: h,
      virtual: g,
      dropdownMatchSelectWidth: b,
      getPrefixCls: r,
      iconPrefixCls: l,
      theme: P(() => {
        var T, N;
        return (T = c.value) !== null && T !== void 0 ? T : (N = o.theme) === null || N === void 0 ? void 0 : N.value;
      }),
      renderEmpty: u,
      getTargetContainer: y,
      getPopupContainer: S,
      pageHeader: C,
      input: w,
      pagination: $,
      form: O,
      select: x,
      componentSize: I,
      componentDisabled: E,
      transformCellText: P(() => e.transformCellText),
      wave: _
    }, R = P(() => {
      const T = c.value || {}, {
        algorithm: N,
        token: k
      } = T, B = LX(T, ["algorithm", "token"]), F = N && (!Array.isArray(N) || N.length > 0) ? g2(N) : void 0;
      return m(m({}, B), {
        theme: F,
        token: m(m({}, $f), k)
      });
    }), A = P(() => {
      var T, N;
      let k = {};
      return p.value && (k = ((T = p.value.Form) === null || T === void 0 ? void 0 : T.defaultValidateMessages) || ((N = Zn.Form) === null || N === void 0 ? void 0 : N.defaultValidateMessages) || {}), e.form && e.form.validateMessages && (k = m(m({}, k), e.form.validateMessages)), k;
    });
    n8(M), JT({
      validateMessages: A
    }), B2(I), t2(E);
    const z = (T) => {
      var N, k;
      let B = a.value ? s((N = n.default) === null || N === void 0 ? void 0 : N.call(n)) : (k = n.default) === null || k === void 0 ? void 0 : k.call(n);
      if (e.theme) {
        const F = /* @__PURE__ */ function() {
          return B;
        }();
        B = f(L5, {
          value: R.value
        }, {
          default: () => [F]
        });
      }
      return f(AP, {
        locale: p.value || T,
        ANT_MARK__: Sm
      }, {
        default: () => [B]
      });
    };
    return Le(() => {
      v.value && (xn.config({
        rtl: v.value === "rtl"
      }), pa.config({
        rtl: v.value === "rtl"
      }));
    }), () => f(ma, {
      children: (T, N, k) => z(k)
    }, null);
  }
});
oa.config = HX;
oa.install = function(e) {
  e.component(oa.name, oa);
};
const VX = (e, t) => {
  let {
    attrs: n,
    slots: o
  } = t;
  return f(Kt, D(D({
    size: "small",
    type: "primary"
  }, e), n), o);
}, eu = (e, t, n) => {
  const o = OT(n);
  return {
    [`${e.componentCls}-${t}`]: {
      color: e[`color${n}`],
      background: e[`color${o}Bg`],
      borderColor: e[`color${o}Border`],
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}, WX = (e) => dd(e, (t, n) => {
  let {
    textColor: o,
    lightBorderColor: r,
    lightColor: l,
    darkColor: a
  } = n;
  return {
    [`${e.componentCls}-${t}`]: {
      color: o,
      background: l,
      borderColor: r,
      // Inverse color
      "&-inverse": {
        color: e.colorTextLightSolid,
        background: a,
        borderColor: a
      },
      [`&${e.componentCls}-borderless`]: {
        borderColor: "transparent"
      }
    }
  };
}), KX = (e) => {
  const {
    paddingXXS: t,
    lineWidth: n,
    tagPaddingHorizontal: o,
    componentCls: r
  } = e, l = o - n, a = t - n;
  return {
    // Result
    [r]: m(m({}, qe(e)), {
      display: "inline-block",
      height: "auto",
      marginInlineEnd: e.marginXS,
      paddingInline: l,
      fontSize: e.tagFontSize,
      lineHeight: `${e.tagLineHeight}px`,
      whiteSpace: "nowrap",
      background: e.tagDefaultBg,
      border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
      borderRadius: e.borderRadiusSM,
      opacity: 1,
      transition: `all ${e.motionDurationMid}`,
      textAlign: "start",
      // RTL
      [`&${r}-rtl`]: {
        direction: "rtl"
      },
      "&, a, a:hover": {
        color: e.tagDefaultColor
      },
      [`${r}-close-icon`]: {
        marginInlineStart: a,
        color: e.colorTextDescription,
        fontSize: e.tagIconSize,
        cursor: "pointer",
        transition: `all ${e.motionDurationMid}`,
        "&:hover": {
          color: e.colorTextHeading
        }
      },
      [`&${r}-has-color`]: {
        borderColor: "transparent",
        [`&, a, a:hover, ${e.iconCls}-close, ${e.iconCls}-close:hover`]: {
          color: e.colorTextLightSolid
        }
      },
      "&-checkable": {
        backgroundColor: "transparent",
        borderColor: "transparent",
        cursor: "pointer",
        [`&:not(${r}-checkable-checked):hover`]: {
          color: e.colorPrimary,
          backgroundColor: e.colorFillSecondary
        },
        "&:active, &-checked": {
          color: e.colorTextLightSolid
        },
        "&-checked": {
          backgroundColor: e.colorPrimary,
          "&:hover": {
            backgroundColor: e.colorPrimaryHover
          }
        },
        "&:active": {
          backgroundColor: e.colorPrimaryActive
        }
      },
      "&-hidden": {
        display: "none"
      },
      // To ensure that a space will be placed between character and `Icon`.
      [`> ${e.iconCls} + span, > span + ${e.iconCls}`]: {
        marginInlineStart: l
      }
    }),
    [`${r}-borderless`]: {
      borderColor: "transparent",
      background: e.tagBorderlessBg
    }
  };
}, oI = Xe("Tag", (e) => {
  const {
    fontSize: t,
    lineHeight: n,
    lineWidth: o,
    fontSizeIcon: r
  } = e, l = Math.round(t * n), a = e.fontSizeSM, i = l - o * 2, s = e.colorFillAlter, c = e.colorText, u = He(e, {
    tagFontSize: a,
    tagLineHeight: i,
    tagDefaultBg: s,
    tagDefaultColor: c,
    tagIconSize: r - 2 * o,
    tagPaddingHorizontal: 8,
    tagBorderlessBg: e.colorFillTertiary
  });
  return [KX(u), WX(u), eu(u, "success", "Success"), eu(u, "processing", "Info"), eu(u, "error", "Error"), eu(u, "warning", "Warning")];
}), GX = () => ({
  prefixCls: String,
  checked: {
    type: Boolean,
    default: void 0
  },
  onChange: {
    type: Function
  },
  onClick: {
    type: Function
  },
  "onUpdate:checked": Function
}), Gd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ACheckableTag",
  inheritAttrs: !1,
  props: GX(),
  // emits: ['update:checked', 'change', 'click'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const {
      prefixCls: l
    } = Ie("tag", e), [a, i] = oI(l), s = (u) => {
      const {
        checked: d
      } = e;
      o("update:checked", !d), o("change", !d), o("click", u);
    }, c = P(() => ee(l.value, i.value, {
      [`${l.value}-checkable`]: !0,
      [`${l.value}-checkable-checked`]: e.checked
    }));
    return () => {
      var u;
      return a(f("span", D(D({}, r), {}, {
        class: [c.value, r.class],
        onClick: s
      }), [(u = n.default) === null || u === void 0 ? void 0 : u.call(n)]));
    };
  }
}), XX = () => ({
  prefixCls: String,
  color: {
    type: String
  },
  closable: {
    type: Boolean,
    default: !1
  },
  closeIcon: V.any,
  /** @deprecated `visible` will be removed in next major version. */
  visible: {
    type: Boolean,
    default: void 0
  },
  onClose: {
    type: Function
  },
  onClick: ia(),
  "onUpdate:visible": Function,
  icon: V.any,
  bordered: {
    type: Boolean,
    default: !0
  }
}), ci = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATag",
  inheritAttrs: !1,
  props: XX(),
  // emits: ['update:visible', 'close'],
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const {
      prefixCls: l,
      direction: a
    } = Ie("tag", e), [i, s] = oI(l), c = Q(!0);
    process.env.NODE_ENV !== "production" && Mt(e.visible === void 0, "Tag", '`visible` is deprecated, please use `<Tag v-show="visible" />` instead.'), Le(() => {
      e.visible !== void 0 && (c.value = e.visible);
    });
    const u = (h) => {
      h.stopPropagation(), o("update:visible", !1), o("close", h), !h.defaultPrevented && e.visible === void 0 && (c.value = !1);
    }, d = P(() => Qf(e.color) || $L(e.color)), p = P(() => ee(l.value, s.value, {
      [`${l.value}-${e.color}`]: d.value,
      [`${l.value}-has-color`]: e.color && !d.value,
      [`${l.value}-hidden`]: !c.value,
      [`${l.value}-rtl`]: a.value === "rtl",
      [`${l.value}-borderless`]: !e.bordered
    })), v = (h) => {
      o("click", h);
    };
    return () => {
      var h, g, b;
      const {
        icon: y = (h = n.icon) === null || h === void 0 ? void 0 : h.call(n),
        color: S,
        closeIcon: C = (g = n.closeIcon) === null || g === void 0 ? void 0 : g.call(n),
        closable: w = !1
      } = e, $ = () => w ? C ? f("span", {
        class: `${l.value}-close-icon`,
        onClick: u
      }, [C]) : f(Kn, {
        class: `${l.value}-close-icon`,
        onClick: u
      }, null) : null, O = {
        backgroundColor: S && !d.value ? S : void 0
      }, x = y || null, I = (b = n.default) === null || b === void 0 ? void 0 : b.call(n), E = x ? f(Fe, null, [x, f("span", null, [I])]) : I, _ = e.onClick !== void 0, M = f("span", D(D({}, r), {}, {
        onClick: v,
        class: [p.value, r.class],
        style: [O, r.style]
      }), [E, $()]);
      return i(_ ? f(v0, null, {
        default: () => [M]
      }) : M);
    };
  }
});
ci.CheckableTag = Gd;
ci.install = function(e) {
  return e.component(ci.name, ci), e.component(Gd.name, Gd), e;
};
function UX(e, t) {
  let {
    slots: n,
    attrs: o
  } = t;
  return f(ci, D(D({
    color: "blue"
  }, e), o), n);
}
var YX = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 184H712v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H384v-64c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v64H144c-17.7 0-32 14.3-32 32v664c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V216c0-17.7-14.3-32-32-32zm-40 656H184V460h656v380zM184 392V256h128v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h256v48c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8v-48h128v136H184z" } }] }, name: "calendar", theme: "outlined" };
function r$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      qX(e, r, n[r]);
    });
  }
  return e;
}
function qX(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var bp = function(t, n) {
  var o = r$({}, t, n.attrs);
  return f(Ge, r$({}, o, {
    icon: YX
  }), null);
};
bp.displayName = "CalendarOutlined";
bp.inheritAttrs = !1;
var ZX = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 820c-205.4 0-372-166.6-372-372s166.6-372 372-372 372 166.6 372 372-166.6 372-372 372z" } }, { tag: "path", attrs: { d: "M686.7 638.6L544.1 535.5V288c0-4.4-3.6-8-8-8H488c-4.4 0-8 3.6-8 8v275.4c0 2.6 1.2 5 3.3 6.5l165.4 120.6c3.6 2.6 8.6 1.8 11.2-1.7l28.6-39c2.6-3.7 1.8-8.7-1.8-11.2z" } }] }, name: "clock-circle", theme: "outlined" };
function l$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      QX(e, r, n[r]);
    });
  }
  return e;
}
function QX(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var yp = function(t, n) {
  var o = l$({}, t, n.attrs);
  return f(Ge, l$({}, o, {
    icon: ZX
  }), null);
};
yp.displayName = "ClockCircleOutlined";
yp.inheritAttrs = !1;
function JX(e, t, n) {
  return n !== void 0 ? n : t === "year" && e.lang.yearPlaceholder ? e.lang.yearPlaceholder : t === "quarter" && e.lang.quarterPlaceholder ? e.lang.quarterPlaceholder : t === "month" && e.lang.monthPlaceholder ? e.lang.monthPlaceholder : t === "week" && e.lang.weekPlaceholder ? e.lang.weekPlaceholder : t === "time" && e.timePickerLocale.placeholder ? e.timePickerLocale.placeholder : e.lang.placeholder;
}
function eU(e, t, n) {
  return n !== void 0 ? n : t === "year" && e.lang.yearPlaceholder ? e.lang.rangeYearPlaceholder : t === "month" && e.lang.monthPlaceholder ? e.lang.rangeMonthPlaceholder : t === "week" && e.lang.weekPlaceholder ? e.lang.rangeWeekPlaceholder : t === "time" && e.timePickerLocale.placeholder ? e.timePickerLocale.rangePlaceholder : e.lang.rangePlaceholder;
}
function rI(e, t) {
  const n = {
    adjustX: 1,
    adjustY: 1
  };
  switch (t) {
    case "bottomLeft":
      return {
        points: ["tl", "bl"],
        offset: [0, 4],
        overflow: n
      };
    case "bottomRight":
      return {
        points: ["tr", "br"],
        offset: [0, 4],
        overflow: n
      };
    case "topLeft":
      return {
        points: ["bl", "tl"],
        offset: [0, -4],
        overflow: n
      };
    case "topRight":
      return {
        points: ["br", "tr"],
        offset: [0, -4],
        overflow: n
      };
    default:
      return {
        points: e === "rtl" ? ["tr", "br"] : ["tl", "bl"],
        offset: [0, 4],
        overflow: n
      };
  }
}
function Xd() {
  return {
    id: String,
    /**
     * @deprecated `dropdownClassName` is deprecated which will be removed in next major
     *   version.Please use `popupClassName` instead.
     */
    dropdownClassName: String,
    popupClassName: String,
    popupStyle: Re(),
    transitionName: String,
    placeholder: String,
    allowClear: ve(),
    autofocus: ve(),
    disabled: ve(),
    tabindex: Number,
    open: ve(),
    defaultOpen: ve(),
    /** Make input readOnly to avoid popup keyboard in mobile */
    inputReadOnly: ve(),
    format: je([String, Function, Array]),
    // Value
    // format:  string | CustomFormat<DateType> | (string | CustomFormat<DateType>)[];
    // Render
    // suffixIcon?: VueNode;
    // clearIcon?: VueNode;
    // prevIcon?: VueNode;
    // nextIcon?: VueNode;
    // superPrevIcon?: VueNode;
    // superNextIcon?: VueNode;
    getPopupContainer: le(),
    panelRender: le(),
    // // Events
    onChange: le(),
    "onUpdate:value": le(),
    onOk: le(),
    onOpenChange: le(),
    "onUpdate:open": le(),
    onFocus: le(),
    onBlur: le(),
    onMousedown: le(),
    onMouseup: le(),
    onMouseenter: le(),
    onMouseleave: le(),
    onClick: le(),
    onContextmenu: le(),
    onKeydown: le(),
    // WAI-ARIA
    role: String,
    name: String,
    autocomplete: String,
    direction: ke(),
    showToday: ve(),
    showTime: je([Boolean, Object]),
    locale: Re(),
    size: ke(),
    bordered: ve(),
    dateRender: le(),
    disabledDate: le(),
    mode: ke(),
    picker: ke(),
    valueFormat: String,
    placement: ke(),
    status: ke(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledHours: le(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledMinutes: le(),
    /** @deprecated Please use `disabledTime` instead. */
    disabledSeconds: le()
  };
}
function lI() {
  return {
    defaultPickerValue: je([Object, String]),
    defaultValue: je([Object, String]),
    value: je([Object, String]),
    presets: vt(),
    disabledTime: le(),
    renderExtraFooter: le(),
    showNow: ve(),
    monthCellRender: le(),
    // deprecated  Please use `monthCellRender"` instead.',
    monthCellContentRender: le()
  };
}
function aI() {
  return {
    allowEmpty: vt(),
    dateRender: le(),
    defaultPickerValue: vt(),
    defaultValue: vt(),
    value: vt(),
    presets: vt(),
    disabledTime: le(),
    disabled: je([Boolean, Array]),
    renderExtraFooter: le(),
    separator: {
      type: String
    },
    showTime: je([Boolean, Object]),
    ranges: Re(),
    placeholder: vt(),
    mode: vt(),
    onChange: le(),
    "onUpdate:value": le(),
    onCalendarChange: le(),
    onPanelChange: le(),
    onOk: le()
  };
}
var tU = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function nU(e, t) {
  function n(c, u) {
    const d = m(m(m({}, Xd()), lI()), t);
    return Z({
      compatConfig: {
        MODE: 3
      },
      name: u,
      inheritAttrs: !1,
      props: d,
      slots: Object,
      setup(p, v) {
        let {
          slots: h,
          expose: g,
          attrs: b,
          emit: y
        } = v;
        const S = p, C = sn(), w = Sn.useInject();
        process.env.NODE_ENV !== "production" && (nt(c !== "quarter", u || "DatePicker", `DatePicker.${u} is legacy usage. Please use DatePicker[picker='${c}'] directly.`), nt(!S.dropdownClassName, u || "DatePicker", "`dropdownClassName` is deprecated. Please use `popupClassName` instead."), nt(!(S.monthCellContentRender || h.monthCellContentRender), u || "DatePicker", '`monthCellContentRender` is deprecated. Please use `monthCellRender"` instead.'), nt(!b.getCalendarContainer, u || "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.'));
        const {
          prefixCls: $,
          direction: O,
          getPopupContainer: x,
          size: I,
          rootPrefixCls: E,
          disabled: _
        } = Ie("picker", S), {
          compactSize: M,
          compactItemClassnames: R
        } = Ol($, O), A = P(() => M.value || I.value), [z, T] = L3($), N = Y();
        g({
          focus: () => {
            var ne;
            (ne = N.value) === null || ne === void 0 || ne.focus();
          },
          blur: () => {
            var ne;
            (ne = N.value) === null || ne === void 0 || ne.blur();
          }
        });
        const k = (ne) => S.valueFormat ? e.toString(ne, S.valueFormat) : ne, B = (ne, te) => {
          const G = k(ne);
          y("update:value", G), y("change", G, te), C.onFieldChange();
        }, F = (ne) => {
          y("update:open", ne), y("openChange", ne);
        }, L = (ne) => {
          y("focus", ne);
        }, j = (ne) => {
          y("blur", ne), C.onFieldBlur();
        }, H = (ne, te) => {
          const G = k(ne);
          y("panelChange", G, te);
        }, K = (ne) => {
          const te = k(ne);
          y("ok", te);
        }, [X] = jo("DatePicker", Ds), W = P(() => S.value ? S.valueFormat ? e.toDate(S.value, S.valueFormat) : S.value : S.value === "" ? void 0 : S.value), q = P(() => S.defaultValue ? S.valueFormat ? e.toDate(S.defaultValue, S.valueFormat) : S.defaultValue : S.defaultValue === "" ? void 0 : S.defaultValue), J = P(() => S.defaultPickerValue ? S.valueFormat ? e.toDate(S.defaultPickerValue, S.valueFormat) : S.defaultPickerValue : S.defaultPickerValue === "" ? void 0 : S.defaultPickerValue);
        return () => {
          var ne, te, G, U, re, se;
          const me = m(m({}, X.value), S.locale), Ce = m(m({}, S), b), {
            bordered: fe = !0,
            placeholder: be,
            suffixIcon: ue = (ne = h.suffixIcon) === null || ne === void 0 ? void 0 : ne.call(h),
            showToday: de = !0,
            transitionName: Se,
            allowClear: xe = !0,
            dateRender: he = h.dateRender,
            renderExtraFooter: we = h.renderExtraFooter,
            monthCellRender: Me = h.monthCellRender || S.monthCellContentRender || h.monthCellContentRender,
            clearIcon: ae = (te = h.clearIcon) === null || te === void 0 ? void 0 : te.call(h),
            id: oe = C.id.value
          } = Ce, pe = tU(Ce, ["bordered", "placeholder", "suffixIcon", "showToday", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "monthCellRender", "clearIcon", "id"]), Pe = Ce.showTime === "" ? !0 : Ce.showTime, {
            format: Ee
          } = Ce;
          let ze = {};
          c && (ze.picker = c);
          const ge = c || Ce.picker || "date";
          ze = m(m(m({}, ze), Pe ? Ud(m({
            format: Ee,
            picker: ge
          }, typeof Pe == "object" ? Pe : {})) : {}), ge === "time" ? Ud(m(m({
            format: Ee
          }, pe), {
            picker: ge
          })) : {});
          const ye = $.value, $e = f(Fe, null, [ue || (c === "time" ? f(yp, null, null) : f(bp, null, null)), w.hasFeedback && w.feedbackIcon]);
          return z(f(tj, D(D(D({
            monthCellRender: Me,
            dateRender: he,
            renderExtraFooter: we,
            ref: N,
            placeholder: JX(me, ge, be),
            suffixIcon: $e,
            dropdownAlign: rI(O.value, S.placement),
            clearIcon: ae || f(Gn, null, null),
            allowClear: xe,
            transitionName: Se || `${E.value}-slide-up`
          }, pe), ze), {}, {
            id: oe,
            picker: ge,
            value: W.value,
            defaultValue: q.value,
            defaultPickerValue: J.value,
            showToday: de,
            locale: me.lang,
            class: ee({
              [`${ye}-${A.value}`]: A.value,
              [`${ye}-borderless`]: !fe
            }, Fn(ye, ar(w.status, S.status), w.hasFeedback), b.class, T.value, R.value),
            disabled: _.value,
            prefixCls: ye,
            getPopupContainer: b.getCalendarContainer || x.value,
            generateConfig: e,
            prevIcon: ((G = h.prevIcon) === null || G === void 0 ? void 0 : G.call(h)) || f("span", {
              class: `${ye}-prev-icon`
            }, null),
            nextIcon: ((U = h.nextIcon) === null || U === void 0 ? void 0 : U.call(h)) || f("span", {
              class: `${ye}-next-icon`
            }, null),
            superPrevIcon: ((re = h.superPrevIcon) === null || re === void 0 ? void 0 : re.call(h)) || f("span", {
              class: `${ye}-super-prev-icon`
            }, null),
            superNextIcon: ((se = h.superNextIcon) === null || se === void 0 ? void 0 : se.call(h)) || f("span", {
              class: `${ye}-super-next-icon`
            }, null),
            components: iI,
            direction: O.value,
            dropdownClassName: ee(T.value, S.popupClassName, S.dropdownClassName),
            onChange: B,
            onOpenChange: F,
            onFocus: L,
            onBlur: j,
            onPanelChange: H,
            onOk: K
          }), null));
        };
      }
    });
  }
  const o = n(void 0, "ADatePicker"), r = n("week", "AWeekPicker"), l = n("month", "AMonthPicker"), a = n("year", "AYearPicker"), i = n("time", "TimePicker"), s = n("quarter", "AQuarterPicker");
  return {
    DatePicker: o,
    WeekPicker: r,
    MonthPicker: l,
    YearPicker: a,
    TimePicker: i,
    QuarterPicker: s
  };
}
var oU = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M873.1 596.2l-164-208A32 32 0 00684 376h-64.8c-6.7 0-10.4 7.7-6.3 13l144.3 183H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h695.9c26.8 0 41.7-30.8 25.2-51.8z" } }] }, name: "swap-right", theme: "outlined" };
function a$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      rU(e, r, n[r]);
    });
  }
  return e;
}
function rU(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var fb = function(t, n) {
  var o = a$({}, t, n.attrs);
  return f(Ge, a$({}, o, {
    icon: oU
  }), null);
};
fb.displayName = "SwapRightOutlined";
fb.inheritAttrs = !1;
var lU = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function aU(e, t) {
  return Z({
    compatConfig: {
      MODE: 3
    },
    name: "ARangePicker",
    inheritAttrs: !1,
    props: m(m(m({}, Xd()), aI()), t),
    slots: Object,
    setup(o, r) {
      let {
        expose: l,
        slots: a,
        attrs: i,
        emit: s
      } = r;
      const c = o, u = sn(), d = Sn.useInject();
      process.env.NODE_ENV !== "production" && (nt(!c.dropdownClassName, "RangePicker", "`dropdownClassName` is deprecated. Please use `popupClassName` instead."), nt(!i.getCalendarContainer, "DatePicker", '`getCalendarContainer` is deprecated. Please use `getPopupContainer"` instead.'));
      const {
        prefixCls: p,
        direction: v,
        getPopupContainer: h,
        size: g,
        rootPrefixCls: b,
        disabled: y
      } = Ie("picker", c), {
        compactSize: S,
        compactItemClassnames: C
      } = Ol(p, v), w = P(() => S.value || g.value), [$, O] = L3(p), x = Y();
      l({
        focus: () => {
          var L;
          (L = x.value) === null || L === void 0 || L.focus();
        },
        blur: () => {
          var L;
          (L = x.value) === null || L === void 0 || L.blur();
        }
      });
      const I = (L) => c.valueFormat ? e.toString(L, c.valueFormat) : L, E = (L, j) => {
        const H = I(L);
        s("update:value", H), s("change", H, j), u.onFieldChange();
      }, _ = (L) => {
        s("update:open", L), s("openChange", L);
      }, M = (L) => {
        s("focus", L);
      }, R = (L) => {
        s("blur", L), u.onFieldBlur();
      }, A = (L, j) => {
        const H = I(L);
        s("panelChange", H, j);
      }, z = (L) => {
        const j = I(L);
        s("ok", j);
      }, T = (L, j, H) => {
        const K = I(L);
        s("calendarChange", K, j, H);
      }, [N] = jo("DatePicker", Ds), k = P(() => c.value && c.valueFormat ? e.toDate(c.value, c.valueFormat) : c.value), B = P(() => c.defaultValue && c.valueFormat ? e.toDate(c.defaultValue, c.valueFormat) : c.defaultValue), F = P(() => c.defaultPickerValue && c.valueFormat ? e.toDate(c.defaultPickerValue, c.valueFormat) : c.defaultPickerValue);
      return () => {
        var L, j, H, K, X, W, q;
        const J = m(m({}, N.value), c.locale), ne = m(m({}, c), i), {
          prefixCls: te,
          bordered: G = !0,
          placeholder: U,
          suffixIcon: re = (L = a.suffixIcon) === null || L === void 0 ? void 0 : L.call(a),
          picker: se = "date",
          transitionName: me,
          allowClear: Ce = !0,
          dateRender: fe = a.dateRender,
          renderExtraFooter: be = a.renderExtraFooter,
          separator: ue = (j = a.separator) === null || j === void 0 ? void 0 : j.call(a),
          clearIcon: de = (H = a.clearIcon) === null || H === void 0 ? void 0 : H.call(a),
          id: Se = u.id.value
        } = ne, xe = lU(ne, ["prefixCls", "bordered", "placeholder", "suffixIcon", "picker", "transitionName", "allowClear", "dateRender", "renderExtraFooter", "separator", "clearIcon", "id"]);
        delete xe["onUpdate:value"], delete xe["onUpdate:open"];
        const {
          format: he,
          showTime: we
        } = ne;
        let Me = {};
        Me = m(m(m({}, Me), we ? Ud(m({
          format: he,
          picker: se
        }, we)) : {}), se === "time" ? Ud(m(m({
          format: he
        }, ot(xe, ["disabledTime"])), {
          picker: se
        })) : {});
        const ae = p.value, oe = f(Fe, null, [re || (se === "time" ? f(yp, null, null) : f(bp, null, null)), d.hasFeedback && d.feedbackIcon]);
        return $(f(dj, D(D(D({
          dateRender: fe,
          renderExtraFooter: be,
          separator: ue || f("span", {
            "aria-label": "to",
            class: `${ae}-separator`
          }, [f(fb, null, null)]),
          ref: x,
          dropdownAlign: rI(v.value, c.placement),
          placeholder: eU(J, se, U),
          suffixIcon: oe,
          clearIcon: de || f(Gn, null, null),
          allowClear: Ce,
          transitionName: me || `${b.value}-slide-up`
        }, xe), Me), {}, {
          disabled: y.value,
          id: Se,
          value: k.value,
          defaultValue: B.value,
          defaultPickerValue: F.value,
          picker: se,
          class: ee({
            [`${ae}-${w.value}`]: w.value,
            [`${ae}-borderless`]: !G
          }, Fn(ae, ar(d.status, c.status), d.hasFeedback), i.class, O.value, C.value),
          locale: J.lang,
          prefixCls: ae,
          getPopupContainer: i.getCalendarContainer || h.value,
          generateConfig: e,
          prevIcon: ((K = a.prevIcon) === null || K === void 0 ? void 0 : K.call(a)) || f("span", {
            class: `${ae}-prev-icon`
          }, null),
          nextIcon: ((X = a.nextIcon) === null || X === void 0 ? void 0 : X.call(a)) || f("span", {
            class: `${ae}-next-icon`
          }, null),
          superPrevIcon: ((W = a.superPrevIcon) === null || W === void 0 ? void 0 : W.call(a)) || f("span", {
            class: `${ae}-super-prev-icon`
          }, null),
          superNextIcon: ((q = a.superNextIcon) === null || q === void 0 ? void 0 : q.call(a)) || f("span", {
            class: `${ae}-super-next-icon`
          }, null),
          components: iI,
          direction: v.value,
          dropdownClassName: ee(O.value, c.popupClassName, c.dropdownClassName),
          onChange: E,
          onOpenChange: _,
          onFocus: M,
          onBlur: R,
          onPanelChange: A,
          onOk: z,
          onCalendarChange: T
        }), null));
      };
    }
  });
}
const iI = {
  button: VX,
  rangeItem: UX
};
function iU(e) {
  return e ? Array.isArray(e) ? e : [e] : [];
}
function Ud(e) {
  const {
    format: t,
    picker: n,
    showHour: o,
    showMinute: r,
    showSecond: l,
    use12Hours: a
  } = e, i = iU(t)[0], s = m({}, e);
  return i && typeof i == "string" && (!i.includes("s") && l === void 0 && (s.showSecond = !1), !i.includes("m") && r === void 0 && (s.showMinute = !1), !i.includes("H") && !i.includes("h") && o === void 0 && (s.showHour = !1), (i.includes("a") || i.includes("A")) && a === void 0 && (s.use12Hours = !0)), n === "time" ? s : (typeof i == "function" && delete s.format, {
    showTime: s
  });
}
function sI(e, t) {
  const {
    DatePicker: n,
    WeekPicker: o,
    MonthPicker: r,
    YearPicker: l,
    TimePicker: a,
    QuarterPicker: i
  } = nU(e, t), s = aU(e, t);
  return {
    DatePicker: n,
    WeekPicker: o,
    MonthPicker: r,
    YearPicker: l,
    TimePicker: a,
    QuarterPicker: i,
    RangePicker: s
  };
}
const {
  DatePicker: Mv,
  WeekPicker: Tu,
  MonthPicker: Mu,
  YearPicker: sU,
  TimePicker: cU,
  QuarterPicker: _u,
  RangePicker: Au
} = sI(C0), uU = m(Mv, {
  WeekPicker: Tu,
  MonthPicker: Mu,
  YearPicker: sU,
  RangePicker: Au,
  TimePicker: cU,
  QuarterPicker: _u,
  install: (e) => (e.component(Mv.name, Mv), e.component(Au.name, Au), e.component(Mu.name, Mu), e.component(Tu.name, Tu), e.component(_u.name, _u), e)
});
function tu(e) {
  return e != null;
}
const _v = (e) => {
  const {
    itemPrefixCls: t,
    component: n,
    span: o,
    labelStyle: r,
    contentStyle: l,
    bordered: a,
    label: i,
    content: s,
    colon: c
  } = e, u = n;
  return a ? f(u, {
    class: [{
      [`${t}-item-label`]: tu(i),
      [`${t}-item-content`]: tu(s)
    }],
    colSpan: o
  }, {
    default: () => [tu(i) && f("span", {
      style: r
    }, [i]), tu(s) && f("span", {
      style: l
    }, [s])]
  }) : f(u, {
    class: [`${t}-item`],
    colSpan: o
  }, {
    default: () => [f("div", {
      class: `${t}-item-container`
    }, [(i || i === 0) && f("span", {
      class: [`${t}-item-label`, {
        [`${t}-item-no-colon`]: !c
      }],
      style: r
    }, [i]), (s || s === 0) && f("span", {
      class: `${t}-item-content`,
      style: l
    }, [s])])]
  });
}, dU = (e) => {
  const t = (c, u, d) => {
    let {
      colon: p,
      prefixCls: v,
      bordered: h
    } = u, {
      component: g,
      type: b,
      showLabel: y,
      showContent: S,
      labelStyle: C,
      contentStyle: w
    } = d;
    return c.map(($, O) => {
      var x, I;
      const E = $.props || {}, {
        prefixCls: _ = v,
        span: M = 1,
        labelStyle: R = E["label-style"],
        contentStyle: A = E["content-style"],
        label: z = (I = (x = $.children) === null || x === void 0 ? void 0 : x.label) === null || I === void 0 ? void 0 : I.call(x)
      } = E, T = hf($), N = UT($), k = Xx($), {
        key: B
      } = $;
      return typeof g == "string" ? f(_v, {
        key: `${b}-${String(B) || O}`,
        class: N,
        style: k,
        labelStyle: m(m({}, C), R),
        contentStyle: m(m({}, w), A),
        span: M,
        colon: p,
        component: g,
        itemPrefixCls: _,
        bordered: h,
        label: y ? z : null,
        content: S ? T : null
      }, null) : [f(_v, {
        key: `label-${String(B) || O}`,
        class: N,
        style: m(m(m({}, C), k), R),
        span: 1,
        colon: p,
        component: g[0],
        itemPrefixCls: _,
        bordered: h,
        label: z
      }, null), f(_v, {
        key: `content-${String(B) || O}`,
        class: N,
        style: m(m(m({}, w), k), A),
        span: M * 2 - 1,
        component: g[1],
        itemPrefixCls: _,
        bordered: h,
        content: T
      }, null)];
    });
  }, {
    prefixCls: n,
    vertical: o,
    row: r,
    index: l,
    bordered: a
  } = e, {
    labelStyle: i,
    contentStyle: s
  } = tt(dI, {
    labelStyle: Y({}),
    contentStyle: Y({})
  });
  return o ? f(Fe, null, [f("tr", {
    key: `label-${l}`,
    class: `${n}-row`
  }, [t(r, e, {
    component: "th",
    type: "label",
    showLabel: !0,
    labelStyle: i.value,
    contentStyle: s.value
  })]), f("tr", {
    key: `content-${l}`,
    class: `${n}-row`
  }, [t(r, e, {
    component: "td",
    type: "content",
    showContent: !0,
    labelStyle: i.value,
    contentStyle: s.value
  })])]) : f("tr", {
    key: l,
    class: `${n}-row`
  }, [t(r, e, {
    component: a ? ["th", "td"] : "td",
    type: "item",
    showLabel: !0,
    showContent: !0,
    labelStyle: i.value,
    contentStyle: s.value
  })]);
}, fU = (e) => {
  const {
    componentCls: t,
    descriptionsSmallPadding: n,
    descriptionsDefaultPadding: o,
    descriptionsMiddlePadding: r,
    descriptionsBg: l
  } = e;
  return {
    [`&${t}-bordered`]: {
      [`${t}-view`]: {
        border: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
        "> table": {
          tableLayout: "auto",
          borderCollapse: "collapse"
        }
      },
      [`${t}-item-label, ${t}-item-content`]: {
        padding: o,
        borderInlineEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
        "&:last-child": {
          borderInlineEnd: "none"
        }
      },
      [`${t}-item-label`]: {
        backgroundColor: l,
        "&::after": {
          display: "none"
        }
      },
      [`${t}-row`]: {
        borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
        "&:last-child": {
          borderBottom: "none"
        }
      },
      [`&${t}-middle`]: {
        [`${t}-item-label, ${t}-item-content`]: {
          padding: r
        }
      },
      [`&${t}-small`]: {
        [`${t}-item-label, ${t}-item-content`]: {
          padding: n
        }
      }
    }
  };
}, pU = (e) => {
  const {
    componentCls: t,
    descriptionsExtraColor: n,
    descriptionItemPaddingBottom: o,
    descriptionsItemLabelColonMarginRight: r,
    descriptionsItemLabelColonMarginLeft: l,
    descriptionsTitleMarginBottom: a
  } = e;
  return {
    [t]: m(m(m({}, qe(e)), fU(e)), {
      "&-rtl": {
        direction: "rtl"
      },
      [`${t}-header`]: {
        display: "flex",
        alignItems: "center",
        marginBottom: a
      },
      [`${t}-title`]: m(m({}, tn), {
        flex: "auto",
        color: e.colorText,
        fontWeight: e.fontWeightStrong,
        fontSize: e.fontSizeLG,
        lineHeight: e.lineHeightLG
      }),
      [`${t}-extra`]: {
        marginInlineStart: "auto",
        color: n,
        fontSize: e.fontSize
      },
      [`${t}-view`]: {
        width: "100%",
        borderRadius: e.borderRadiusLG,
        table: {
          width: "100%",
          tableLayout: "fixed"
        }
      },
      [`${t}-row`]: {
        "> th, > td": {
          paddingBottom: o
        },
        "&:last-child": {
          borderBottom: "none"
        }
      },
      [`${t}-item-label`]: {
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        textAlign: "start",
        "&::after": {
          content: '":"',
          position: "relative",
          top: -0.5,
          marginInline: `${l}px ${r}px`
        },
        [`&${t}-item-no-colon::after`]: {
          content: '""'
        }
      },
      [`${t}-item-no-label`]: {
        "&::after": {
          margin: 0,
          content: '""'
        }
      },
      [`${t}-item-content`]: {
        display: "table-cell",
        flex: 1,
        color: e.colorText,
        fontSize: e.fontSize,
        lineHeight: e.lineHeight,
        wordBreak: "break-word",
        overflowWrap: "break-word"
      },
      [`${t}-item`]: {
        paddingBottom: 0,
        verticalAlign: "top",
        "&-container": {
          display: "flex",
          [`${t}-item-label`]: {
            display: "inline-flex",
            alignItems: "baseline"
          },
          [`${t}-item-content`]: {
            display: "inline-flex",
            alignItems: "baseline"
          }
        }
      },
      "&-middle": {
        [`${t}-row`]: {
          "> th, > td": {
            paddingBottom: e.paddingSM
          }
        }
      },
      "&-small": {
        [`${t}-row`]: {
          "> th, > td": {
            paddingBottom: e.paddingXS
          }
        }
      }
    })
  };
}, vU = Xe("Descriptions", (e) => {
  const t = e.colorFillAlter, n = e.fontSizeSM * e.lineHeightSM, o = e.colorText, r = `${e.paddingXS}px ${e.padding}px`, l = `${e.padding}px ${e.paddingLG}px`, a = `${e.paddingSM}px ${e.paddingLG}px`, i = e.padding, s = e.marginXS, c = e.marginXXS / 2, u = He(e, {
    descriptionsBg: t,
    descriptionsTitleMarginBottom: n,
    descriptionsExtraColor: o,
    descriptionItemPaddingBottom: i,
    descriptionsSmallPadding: r,
    descriptionsDefaultPadding: l,
    descriptionsMiddlePadding: a,
    descriptionsItemLabelColonMarginRight: s,
    descriptionsItemLabelColonMarginLeft: c
  });
  return [pU(u)];
});
V.any;
const gU = () => ({
  prefixCls: String,
  label: V.any,
  labelStyle: {
    type: Object,
    default: void 0
  },
  contentStyle: {
    type: Object,
    default: void 0
  },
  span: {
    type: Number,
    default: 1
  }
}), cI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ADescriptionsItem",
  props: gU(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
    };
  }
}), uI = {
  xxxl: 3,
  xxl: 3,
  xl: 3,
  lg: 3,
  md: 3,
  sm: 2,
  xs: 1
};
function mU(e, t) {
  if (typeof e == "number")
    return e;
  if (typeof e == "object")
    for (let n = 0; n < Lr.length; n++) {
      const o = Lr[n];
      if (t[o] && e[o] !== void 0)
        return e[o] || uI[o];
    }
  return 3;
}
function i$(e, t, n) {
  let o = e;
  return (n === void 0 || n > t) && (o = yt(e, {
    span: t
  }), Mt(n === void 0, "Descriptions", "Sum of column `span` in a line not match `column` of Descriptions.")), o;
}
function hU(e, t) {
  const n = It(e), o = [];
  let r = [], l = t;
  return n.forEach((a, i) => {
    var s;
    const c = (s = a.props) === null || s === void 0 ? void 0 : s.span, u = c || 1;
    if (i === n.length - 1) {
      r.push(i$(a, l, c)), o.push(r);
      return;
    }
    u < l ? (l -= u, r.push(a)) : (r.push(i$(a, l, u)), o.push(r), l = t, r = []);
  }), o;
}
const bU = () => ({
  prefixCls: String,
  bordered: {
    type: Boolean,
    default: void 0
  },
  size: {
    type: String,
    default: "default"
  },
  title: V.any,
  extra: V.any,
  column: {
    type: [Number, Object],
    default: () => uI
  },
  layout: String,
  colon: {
    type: Boolean,
    default: void 0
  },
  labelStyle: {
    type: Object,
    default: void 0
  },
  contentStyle: {
    type: Object,
    default: void 0
  }
}), dI = Symbol("descriptionsContext"), Va = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ADescriptions",
  inheritAttrs: !1,
  props: bU(),
  slots: Object,
  Item: cI,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("descriptions", e);
    let a;
    const i = Y({}), [s, c] = vU(r), u = s0();
    vf(() => {
      a = u.value.subscribe((p) => {
        typeof e.column == "object" && (i.value = p);
      });
    }), et(() => {
      u.value.unsubscribe(a);
    }), Je(dI, {
      labelStyle: Te(e, "labelStyle"),
      contentStyle: Te(e, "contentStyle")
    });
    const d = P(() => mU(e.column, i.value));
    return () => {
      var p, v, h;
      const {
        size: g,
        bordered: b = !1,
        layout: y = "horizontal",
        colon: S = !0,
        title: C = (p = n.title) === null || p === void 0 ? void 0 : p.call(n),
        extra: w = (v = n.extra) === null || v === void 0 ? void 0 : v.call(n)
      } = e, $ = (h = n.default) === null || h === void 0 ? void 0 : h.call(n), O = hU($, d.value);
      return s(f("div", D(D({}, o), {}, {
        class: [r.value, {
          [`${r.value}-${g}`]: g !== "default",
          [`${r.value}-bordered`]: !!b,
          [`${r.value}-rtl`]: l.value === "rtl"
        }, o.class, c.value]
      }), [(C || w) && f("div", {
        class: `${r.value}-header`
      }, [C && f("div", {
        class: `${r.value}-title`
      }, [C]), w && f("div", {
        class: `${r.value}-extra`
      }, [w])]), f("div", {
        class: `${r.value}-view`
      }, [f("table", null, [f("tbody", null, [O.map((x, I) => f(dU, {
        key: I,
        index: I,
        colon: S,
        prefixCls: r.value,
        vertical: y === "vertical",
        bordered: b,
        row: x
      }, null))])])])]));
    };
  }
});
Va.install = function(e) {
  return e.component(Va.name, Va), e.component(Va.Item.name, Va.Item), e;
};
const yU = (e) => {
  const {
    componentCls: t,
    sizePaddingEdgeHorizontal: n,
    colorSplit: o,
    lineWidth: r
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      borderBlockStart: `${r}px solid ${o}`,
      // vertical
      "&-vertical": {
        position: "relative",
        top: "-0.06em",
        display: "inline-block",
        height: "0.9em",
        margin: `0 ${e.dividerVerticalGutterMargin}px`,
        verticalAlign: "middle",
        borderTop: 0,
        borderInlineStart: `${r}px solid ${o}`
      },
      "&-horizontal": {
        display: "flex",
        clear: "both",
        width: "100%",
        minWidth: "100%",
        margin: `${e.dividerHorizontalGutterMargin}px 0`
      },
      [`&-horizontal${t}-with-text`]: {
        display: "flex",
        alignItems: "center",
        margin: `${e.dividerHorizontalWithTextGutterMargin}px 0`,
        color: e.colorTextHeading,
        fontWeight: 500,
        fontSize: e.fontSizeLG,
        whiteSpace: "nowrap",
        textAlign: "center",
        borderBlockStart: `0 ${o}`,
        "&::before, &::after": {
          position: "relative",
          width: "50%",
          borderBlockStart: `${r}px solid transparent`,
          // Chrome not accept `inherit` in `border-top`
          borderBlockStartColor: "inherit",
          borderBlockEnd: 0,
          transform: "translateY(50%)",
          content: "''"
        }
      },
      [`&-horizontal${t}-with-text-left`]: {
        "&::before": {
          width: "5%"
        },
        "&::after": {
          width: "95%"
        }
      },
      [`&-horizontal${t}-with-text-right`]: {
        "&::before": {
          width: "95%"
        },
        "&::after": {
          width: "5%"
        }
      },
      [`${t}-inner-text`]: {
        display: "inline-block",
        padding: "0 1em"
      },
      "&-dashed": {
        background: "none",
        borderColor: o,
        borderStyle: "dashed",
        borderWidth: `${r}px 0 0`
      },
      [`&-horizontal${t}-with-text${t}-dashed`]: {
        "&::before, &::after": {
          borderStyle: "dashed none none"
        }
      },
      [`&-vertical${t}-dashed`]: {
        borderInlineStartWidth: r,
        borderInlineEnd: 0,
        borderBlockStart: 0,
        borderBlockEnd: 0
      },
      [`&-plain${t}-with-text`]: {
        color: e.colorText,
        fontWeight: "normal",
        fontSize: e.fontSize
      },
      [`&-horizontal${t}-with-text-left${t}-no-default-orientation-margin-left`]: {
        "&::before": {
          width: 0
        },
        "&::after": {
          width: "100%"
        },
        [`${t}-inner-text`]: {
          paddingInlineStart: n
        }
      },
      [`&-horizontal${t}-with-text-right${t}-no-default-orientation-margin-right`]: {
        "&::before": {
          width: "100%"
        },
        "&::after": {
          width: 0
        },
        [`${t}-inner-text`]: {
          paddingInlineEnd: n
        }
      }
    })
  };
}, SU = Xe("Divider", (e) => {
  const t = He(e, {
    dividerVerticalGutterMargin: e.marginXS,
    dividerHorizontalWithTextGutterMargin: e.margin,
    dividerHorizontalGutterMargin: e.marginLG
  });
  return [yU(t)];
}, {
  sizePaddingEdgeHorizontal: 0
}), CU = () => ({
  prefixCls: String,
  type: {
    type: String,
    default: "horizontal"
  },
  dashed: {
    type: Boolean,
    default: !1
  },
  orientation: {
    type: String,
    default: "center"
  },
  plain: {
    type: Boolean,
    default: !1
  },
  orientationMargin: [String, Number]
}), $U = Z({
  name: "ADivider",
  inheritAttrs: !1,
  compatConfig: {
    MODE: 3
  },
  props: CU(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("divider", e), [a, i] = SU(r), s = P(() => e.orientation === "left" && e.orientationMargin != null), c = P(() => e.orientation === "right" && e.orientationMargin != null), u = P(() => {
      const {
        type: v,
        dashed: h,
        plain: g
      } = e, b = r.value;
      return {
        [b]: !0,
        [i.value]: !!i.value,
        [`${b}-${v}`]: !0,
        [`${b}-dashed`]: !!h,
        [`${b}-plain`]: !!g,
        [`${b}-rtl`]: l.value === "rtl",
        [`${b}-no-default-orientation-margin-left`]: s.value,
        [`${b}-no-default-orientation-margin-right`]: c.value
      };
    }), d = P(() => {
      const v = typeof e.orientationMargin == "number" ? `${e.orientationMargin}px` : e.orientationMargin;
      return m(m({}, s.value && {
        marginLeft: v
      }), c.value && {
        marginRight: v
      });
    }), p = P(() => e.orientation.length > 0 ? "-" + e.orientation : e.orientation);
    return () => {
      var v;
      const h = It((v = n.default) === null || v === void 0 ? void 0 : v.call(n));
      return a(f("div", D(D({}, o), {}, {
        class: [u.value, h.length ? `${r.value}-with-text ${r.value}-with-text${p.value}` : "", o.class],
        role: "separator"
      }), [h.length ? f("span", {
        class: `${r.value}-inner-text`,
        style: d.value
      }, [h]) : null]));
    };
  }
}), wU = kt($U);
er.Button = Gs;
er.install = function(e) {
  return e.component(er.name, er), e.component(Gs.name, Gs), e;
};
const fI = () => ({
  prefixCls: String,
  width: V.oneOfType([V.string, V.number]),
  height: V.oneOfType([V.string, V.number]),
  style: {
    type: Object,
    default: void 0
  },
  class: String,
  rootClassName: String,
  rootStyle: Re(),
  placement: {
    type: String
  },
  wrapperClassName: String,
  level: {
    type: [String, Array]
  },
  levelMove: {
    type: [Number, Function, Array]
  },
  duration: String,
  ease: String,
  showMask: {
    type: Boolean,
    default: void 0
  },
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  maskStyle: {
    type: Object,
    default: void 0
  },
  afterVisibleChange: Function,
  keyboard: {
    type: Boolean,
    default: void 0
  },
  contentWrapperStyle: vt(),
  autofocus: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  // Motion
  motion: le(),
  maskMotion: Re()
}), xU = () => m(m({}, fI()), {
  forceRender: {
    type: Boolean,
    default: void 0
  },
  getContainer: V.oneOfType([V.string, V.func, V.object, V.looseBool])
}), OU = () => m(m({}, fI()), {
  getContainer: Function,
  getOpenCount: Function,
  scrollLocker: V.any,
  inline: Boolean
});
function PU(e) {
  return Array.isArray(e) ? e : [e];
}
const IU = {
  transition: "transitionend",
  WebkitTransition: "webkitTransitionEnd",
  MozTransition: "transitionend",
  OTransition: "oTransitionEnd otransitionend"
};
Object.keys(IU).filter((e) => {
  if (typeof document > "u")
    return !1;
  const t = document.getElementsByTagName("html")[0];
  return e in (t ? t.style : {});
})[0];
const EU = !(typeof window < "u" && window.document && window.document.createElement);
var TU = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const s$ = Z({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: OU(),
  emits: ["close", "handleClick", "change"],
  setup(e, t) {
    let {
      emit: n,
      slots: o
    } = t;
    const r = Q(), l = Q(), a = Q(), i = Q(), s = Q();
    let c = [];
    `${Number((Date.now() + Math.random()).toString().replace(".", Math.round(Math.random() * 9).toString())).toString(16)}`, Ke(() => {
      rt(() => {
        var y;
        const {
          open: S,
          getContainer: C,
          showMask: w,
          autofocus: $
        } = e, O = C == null ? void 0 : C();
        h(e), S && (O && (O.parentNode, document.body), rt(() => {
          $ && u();
        }), w && ((y = e.scrollLocker) === null || y === void 0 || y.lock()));
      });
    }), ie(() => e.level, () => {
      h(e);
    }, {
      flush: "post"
    }), ie(() => e.open, () => {
      const {
        open: y,
        getContainer: S,
        scrollLocker: C,
        showMask: w,
        autofocus: $
      } = e, O = S == null ? void 0 : S();
      O && (O.parentNode, document.body), y ? ($ && u(), w && (C == null || C.lock())) : C == null || C.unLock();
    }, {
      flush: "post"
    }), uo(() => {
      var y;
      const {
        open: S
      } = e;
      S && (document.body.style.touchAction = ""), (y = e.scrollLocker) === null || y === void 0 || y.unLock();
    }), ie(() => e.placement, (y) => {
      y && (s.value = null);
    });
    const u = () => {
      var y, S;
      (S = (y = l.value) === null || y === void 0 ? void 0 : y.focus) === null || S === void 0 || S.call(y);
    }, d = (y) => {
      n("close", y);
    }, p = (y) => {
      y.keyCode === ce.ESC && (y.stopPropagation(), d(y));
    }, v = () => {
      const {
        open: y,
        afterVisibleChange: S
      } = e;
      S && S(!!y);
    }, h = (y) => {
      let {
        level: S,
        getContainer: C
      } = y;
      if (EU)
        return;
      const w = C == null ? void 0 : C(), $ = w ? w.parentNode : null;
      c = [], S === "all" ? ($ ? Array.prototype.slice.call($.children) : []).forEach((x) => {
        x.nodeName !== "SCRIPT" && x.nodeName !== "STYLE" && x.nodeName !== "LINK" && x !== w && c.push(x);
      }) : S && PU(S).forEach((O) => {
        document.querySelectorAll(O).forEach((x) => {
          c.push(x);
        });
      });
    }, g = (y) => {
      n("handleClick", y);
    }, b = Q(!1);
    return ie(l, () => {
      rt(() => {
        b.value = !0;
      });
    }), () => {
      var y, S;
      const {
        width: C,
        height: w,
        open: $,
        prefixCls: O,
        placement: x,
        level: I,
        levelMove: E,
        ease: _,
        duration: M,
        getContainer: R,
        onChange: A,
        afterVisibleChange: z,
        showMask: T,
        maskClosable: N,
        maskStyle: k,
        keyboard: B,
        getOpenCount: F,
        scrollLocker: L,
        contentWrapperStyle: j,
        style: H,
        class: K,
        rootClassName: X,
        rootStyle: W,
        maskMotion: q,
        motion: J,
        inline: ne
      } = e, te = TU(e, ["width", "height", "open", "prefixCls", "placement", "level", "levelMove", "ease", "duration", "getContainer", "onChange", "afterVisibleChange", "showMask", "maskClosable", "maskStyle", "keyboard", "getOpenCount", "scrollLocker", "contentWrapperStyle", "style", "class", "rootClassName", "rootStyle", "maskMotion", "motion", "inline"]), G = $ && b.value, U = ee(O, {
        [`${O}-${x}`]: !0,
        [`${O}-open`]: G,
        [`${O}-inline`]: ne,
        "no-mask": !T,
        [X]: !0
      }), re = typeof J == "function" ? J(x) : J;
      return f("div", D(D({}, ot(te, ["autofocus"])), {}, {
        tabindex: -1,
        class: U,
        style: W,
        ref: l,
        onKeydown: G && B ? p : void 0
      }), [f(yn, q, {
        default: () => [T && Tn(f("div", {
          class: `${O}-mask`,
          onClick: N ? d : void 0,
          style: k,
          ref: a
        }, null), [[Hn, G]])]
      }), f(yn, D(D({}, re), {}, {
        onAfterEnter: v,
        onAfterLeave: v
      }), {
        default: () => [Tn(f("div", {
          class: `${O}-content-wrapper`,
          style: [j],
          ref: r
        }, [f("div", {
          class: [`${O}-content`, K],
          style: H,
          ref: s
        }, [(y = o.default) === null || y === void 0 ? void 0 : y.call(o)]), o.handler ? f("div", {
          onClick: g,
          ref: i
        }, [(S = o.handler) === null || S === void 0 ? void 0 : S.call(o)]) : null]), [[Hn, G]])]
      })]);
    };
  }
});
var c$ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const MU = Z({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: Qe(xU(), {
    prefixCls: "drawer",
    placement: "left",
    getContainer: "body",
    level: "all",
    duration: ".3s",
    ease: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    afterVisibleChange: () => {
    },
    showMask: !0,
    maskClosable: !0,
    maskStyle: {},
    wrapperClassName: "",
    keyboard: !0,
    forceRender: !1,
    autofocus: !0
  }),
  emits: ["handleClick", "close"],
  setup(e, t) {
    let {
      emit: n,
      slots: o
    } = t;
    const r = Y(null), l = (i) => {
      n("handleClick", i);
    }, a = (i) => {
      n("close", i);
    };
    return () => {
      const {
        getContainer: i,
        wrapperClassName: s,
        rootClassName: c,
        rootStyle: u,
        forceRender: d
      } = e, p = c$(e, ["getContainer", "wrapperClassName", "rootClassName", "rootStyle", "forceRender"]);
      let v = null;
      if (!i)
        return f(s$, D(D({}, p), {}, {
          rootClassName: c,
          rootStyle: u,
          open: e.open,
          onClose: a,
          onHandleClick: l,
          inline: !0
        }), o);
      const h = !!o.handler || d;
      return (h || e.open || r.value) && (v = f(lc, {
        autoLock: !0,
        visible: e.open,
        forceRender: h,
        getContainer: i,
        wrapperClassName: s
      }, {
        default: (g) => {
          var {
            visible: b,
            afterClose: y
          } = g, S = c$(g, ["visible", "afterClose"]);
          return f(s$, D(D(D({
            ref: r
          }, p), S), {}, {
            rootClassName: c,
            rootStyle: u,
            open: b !== void 0 ? b : e.open,
            afterVisibleChange: y !== void 0 ? y : e.afterVisibleChange,
            onClose: a,
            onHandleClick: l
          }), o);
        }
      })), v;
    };
  }
}), _U = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e, o = {
    "&-enter, &-appear, &-leave": {
      "&-start": {
        transition: "none"
      },
      "&-active": {
        transition: `all ${n}`
      }
    }
  };
  return {
    [t]: {
      // ======================== Mask ========================
      [`${t}-mask-motion`]: {
        "&-enter, &-appear, &-leave": {
          "&-active": {
            transition: `all ${n}`
          }
        },
        "&-enter, &-appear": {
          opacity: 0,
          "&-active": {
            opacity: 1
          }
        },
        "&-leave": {
          opacity: 1,
          "&-active": {
            opacity: 0
          }
        }
      },
      // ======================= Panel ========================
      [`${t}-panel-motion`]: {
        // Left
        "&-left": [o, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(-100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(-100%)"
            }
          }
        }],
        // Right
        "&-right": [o, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateX(100%) !important"
            },
            "&-active": {
              transform: "translateX(0)"
            }
          },
          "&-leave": {
            transform: "translateX(0)",
            "&-active": {
              transform: "translateX(100%)"
            }
          }
        }],
        // Top
        "&-top": [o, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(-100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(-100%)"
            }
          }
        }],
        // Bottom
        "&-bottom": [o, {
          "&-enter, &-appear": {
            "&-start": {
              transform: "translateY(100%) !important"
            },
            "&-active": {
              transform: "translateY(0)"
            }
          },
          "&-leave": {
            transform: "translateY(0)",
            "&-active": {
              transform: "translateY(100%)"
            }
          }
        }]
      }
    }
  };
}, AU = (e) => {
  const {
    componentCls: t,
    zIndexPopup: n,
    colorBgMask: o,
    colorBgElevated: r,
    motionDurationSlow: l,
    motionDurationMid: a,
    padding: i,
    paddingLG: s,
    fontSizeLG: c,
    lineHeightLG: u,
    lineWidth: d,
    lineType: p,
    colorSplit: v,
    marginSM: h,
    colorIcon: g,
    colorIconHover: b,
    colorText: y,
    fontWeightStrong: S,
    drawerFooterPaddingVertical: C,
    drawerFooterPaddingHorizontal: w
  } = e, $ = `${t}-content-wrapper`;
  return {
    [t]: {
      position: "fixed",
      inset: 0,
      zIndex: n,
      pointerEvents: "none",
      "&-pure": {
        position: "relative",
        background: r,
        [`&${t}-left`]: {
          boxShadow: e.boxShadowDrawerLeft
        },
        [`&${t}-right`]: {
          boxShadow: e.boxShadowDrawerRight
        },
        [`&${t}-top`]: {
          boxShadow: e.boxShadowDrawerUp
        },
        [`&${t}-bottom`]: {
          boxShadow: e.boxShadowDrawerDown
        }
      },
      "&-inline": {
        position: "absolute"
      },
      // ====================== Mask ======================
      [`${t}-mask`]: {
        position: "absolute",
        inset: 0,
        zIndex: n,
        background: o,
        pointerEvents: "auto"
      },
      // ==================== Content =====================
      [$]: {
        position: "absolute",
        zIndex: n,
        transition: `all ${l}`,
        "&-hidden": {
          display: "none"
        }
      },
      // Placement
      [`&-left > ${$}`]: {
        top: 0,
        bottom: 0,
        left: {
          _skip_check_: !0,
          value: 0
        },
        boxShadow: e.boxShadowDrawerLeft
      },
      [`&-right > ${$}`]: {
        top: 0,
        right: {
          _skip_check_: !0,
          value: 0
        },
        bottom: 0,
        boxShadow: e.boxShadowDrawerRight
      },
      [`&-top > ${$}`]: {
        top: 0,
        insetInline: 0,
        boxShadow: e.boxShadowDrawerUp
      },
      [`&-bottom > ${$}`]: {
        bottom: 0,
        insetInline: 0,
        boxShadow: e.boxShadowDrawerDown
      },
      [`${t}-content`]: {
        width: "100%",
        height: "100%",
        overflow: "auto",
        background: r,
        pointerEvents: "auto"
      },
      // ===================== Panel ======================
      [`${t}-wrapper-body`]: {
        display: "flex",
        flexDirection: "column",
        width: "100%",
        height: "100%"
      },
      // Header
      [`${t}-header`]: {
        display: "flex",
        flex: 0,
        alignItems: "center",
        padding: `${i}px ${s}px`,
        fontSize: c,
        lineHeight: u,
        borderBottom: `${d}px ${p} ${v}`,
        "&-title": {
          display: "flex",
          flex: 1,
          alignItems: "center",
          minWidth: 0,
          minHeight: 0
        }
      },
      [`${t}-extra`]: {
        flex: "none"
      },
      [`${t}-close`]: {
        display: "inline-block",
        marginInlineEnd: h,
        color: g,
        fontWeight: S,
        fontSize: c,
        fontStyle: "normal",
        lineHeight: 1,
        textAlign: "center",
        textTransform: "none",
        textDecoration: "none",
        background: "transparent",
        border: 0,
        outline: 0,
        cursor: "pointer",
        transition: `color ${a}`,
        textRendering: "auto",
        "&:focus, &:hover": {
          color: b,
          textDecoration: "none"
        }
      },
      [`${t}-title`]: {
        flex: 1,
        margin: 0,
        color: y,
        fontWeight: e.fontWeightStrong,
        fontSize: c,
        lineHeight: u
      },
      // Body
      [`${t}-body`]: {
        flex: 1,
        minWidth: 0,
        minHeight: 0,
        padding: s,
        overflow: "auto"
      },
      // Footer
      [`${t}-footer`]: {
        flexShrink: 0,
        padding: `${C}px ${w}px`,
        borderTop: `${d}px ${p} ${v}`
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl"
      }
    }
  };
}, DU = Xe("Drawer", (e) => {
  const t = He(e, {
    drawerFooterPaddingVertical: e.paddingXS,
    drawerFooterPaddingHorizontal: e.padding
  });
  return [AU(t), _U(t)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase
}));
var NU = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const RU = ["top", "right", "bottom", "left"], u$ = {
  distance: 180
}, kU = () => ({
  autofocus: {
    type: Boolean,
    default: void 0
  },
  closable: {
    type: Boolean,
    default: void 0
  },
  closeIcon: V.any,
  destroyOnClose: {
    type: Boolean,
    default: void 0
  },
  forceRender: {
    type: Boolean,
    default: void 0
  },
  getContainer: {
    type: [String, Function, Boolean, Object],
    default: void 0
  },
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  mask: {
    type: Boolean,
    default: void 0
  },
  maskStyle: Re(),
  rootClassName: String,
  rootStyle: Re(),
  size: {
    type: String
  },
  drawerStyle: Re(),
  headerStyle: Re(),
  bodyStyle: Re(),
  contentWrapperStyle: {
    type: Object,
    default: void 0
  },
  title: V.any,
  /** @deprecated Please use `open` instead */
  visible: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  width: V.oneOfType([V.string, V.number]),
  height: V.oneOfType([V.string, V.number]),
  zIndex: Number,
  prefixCls: String,
  push: V.oneOfType([V.looseBool, {
    type: Object
  }]),
  placement: V.oneOf(RU),
  keyboard: {
    type: Boolean,
    default: void 0
  },
  extra: V.any,
  footer: V.any,
  footerStyle: Re(),
  level: V.any,
  levelMove: {
    type: [Number, Array, Function]
  },
  handle: V.any,
  /** @deprecated Use `@afterVisibleChange` instead */
  afterVisibleChange: Function,
  /** @deprecated Please use `@afterOpenChange` instead */
  onAfterVisibleChange: Function,
  onAfterOpenChange: Function,
  /** @deprecated Please use `onUpdate:open` instead */
  "onUpdate:visible": Function,
  "onUpdate:open": Function,
  onClose: Function
}), BU = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ADrawer",
  inheritAttrs: !1,
  props: Qe(kU(), {
    closable: !0,
    placement: "right",
    maskClosable: !0,
    mask: !0,
    level: null,
    keyboard: !0,
    push: u$
  }),
  slots: Object,
  // emits: ['update:visible', 'close', 'afterVisibleChange'],
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: r
    } = t;
    const l = Q(!1), a = Q(!1), i = Q(null), s = Q(!1), c = Q(!1), u = P(() => {
      var F;
      return (F = e.open) !== null && F !== void 0 ? F : e.visible;
    });
    ie(u, () => {
      u.value ? s.value = !0 : c.value = !1;
    }, {
      immediate: !0
    }), ie([u, s], () => {
      u.value && s.value && (c.value = !0);
    }, {
      immediate: !0
    });
    const d = tt("parentDrawerOpts", null), {
      prefixCls: p,
      getPopupContainer: v,
      direction: h
    } = Ie("drawer", e), [g, b] = DU(p), y = P(() => (
      // 有可能为 false，所以不能直接判断
      e.getContainer === void 0 && (v != null && v.value) ? () => v.value(document.body) : e.getContainer
    ));
    nt(!e.afterVisibleChange, "Drawer", "`afterVisibleChange` prop is deprecated, please use `@afterVisibleChange` event instead"), process.env.NODE_ENV !== "production" && [["visible", "open"], ["onUpdate:visible", "onUpdate:open"], ["onAfterVisibleChange", "onAfterOpenChange"]].forEach((F) => {
      let [L, j] = F;
      nt(!e[L], "Drawer", `\`${L}\` is deprecated, please use \`${j}\` instead.`);
    }), Je("parentDrawerOpts", {
      setPush: () => {
        l.value = !0;
      },
      setPull: () => {
        l.value = !1, rt(() => {
          w();
        });
      }
    }), Ke(() => {
      u.value && d && d.setPush();
    }), uo(() => {
      d && d.setPull();
    }), ie(c, () => {
      d && (c.value ? d.setPush() : d.setPull());
    }, {
      flush: "post"
    });
    const w = () => {
      var F, L;
      (L = (F = i.value) === null || F === void 0 ? void 0 : F.domFocus) === null || L === void 0 || L.call(F);
    }, $ = (F) => {
      n("update:visible", !1), n("update:open", !1), n("close", F);
    }, O = (F) => {
      var L;
      F || (a.value === !1 && (a.value = !0), e.destroyOnClose && (s.value = !1)), (L = e.afterVisibleChange) === null || L === void 0 || L.call(e, F), n("afterVisibleChange", F), n("afterOpenChange", F);
    }, x = P(() => {
      const {
        push: F,
        placement: L
      } = e;
      let j;
      return typeof F == "boolean" ? j = F ? u$.distance : 0 : j = F.distance, j = parseFloat(String(j || 0)), L === "left" || L === "right" ? `translateX(${L === "left" ? j : -j}px)` : L === "top" || L === "bottom" ? `translateY(${L === "top" ? j : -j}px)` : null;
    }), I = P(() => {
      var F;
      return (F = e.width) !== null && F !== void 0 ? F : e.size === "large" ? 736 : 378;
    }), E = P(() => {
      var F;
      return (F = e.height) !== null && F !== void 0 ? F : e.size === "large" ? 736 : 378;
    }), _ = P(() => {
      const {
        mask: F,
        placement: L
      } = e;
      if (!c.value && !F)
        return {};
      const j = {};
      return L === "left" || L === "right" ? j.width = Id(I.value) ? `${I.value}px` : I.value : j.height = Id(E.value) ? `${E.value}px` : E.value, j;
    }), M = P(() => {
      const {
        zIndex: F,
        contentWrapperStyle: L
      } = e, j = _.value;
      return [{
        zIndex: F,
        transform: l.value ? x.value : void 0
      }, m({}, L), j];
    }), R = (F) => {
      const {
        closable: L,
        headerStyle: j
      } = e, H = an(o, e, "extra"), K = an(o, e, "title");
      return !K && !L ? null : f("div", {
        class: ee(`${F}-header`, {
          [`${F}-header-close-only`]: L && !K && !H
        }),
        style: j
      }, [f("div", {
        class: `${F}-header-title`
      }, [A(F), K && f("div", {
        class: `${F}-title`
      }, [K])]), H && f("div", {
        class: `${F}-extra`
      }, [H])]);
    }, A = (F) => {
      var L;
      const {
        closable: j
      } = e, H = o.closeIcon ? (L = o.closeIcon) === null || L === void 0 ? void 0 : L.call(o) : e.closeIcon;
      return j && f("button", {
        key: "closer",
        onClick: $,
        "aria-label": "Close",
        class: `${F}-close`
      }, [H === void 0 ? f(Kn, null, null) : H]);
    }, z = (F) => {
      var L;
      if (a.value && !e.forceRender && !s.value)
        return null;
      const {
        bodyStyle: j,
        drawerStyle: H
      } = e;
      return f("div", {
        class: `${F}-wrapper-body`,
        style: H
      }, [R(F), f("div", {
        key: "body",
        class: `${F}-body`,
        style: j
      }, [(L = o.default) === null || L === void 0 ? void 0 : L.call(o)]), T(F)]);
    }, T = (F) => {
      const L = an(o, e, "footer");
      if (!L)
        return null;
      const j = `${F}-footer`;
      return f("div", {
        class: j,
        style: e.footerStyle
      }, [L]);
    }, N = P(() => ee({
      "no-mask": !e.mask,
      [`${p.value}-rtl`]: h.value === "rtl"
    }, e.rootClassName, b.value)), k = P(() => Ho(Vn(p.value, "mask-motion"))), B = (F) => Ho(Vn(p.value, `panel-motion-${F}`));
    return () => {
      const {
        width: F,
        height: L,
        placement: j,
        mask: H,
        forceRender: K
      } = e, X = NU(e, ["width", "height", "placement", "mask", "forceRender"]), W = m(m(m({}, r), ot(X, ["size", "closeIcon", "closable", "destroyOnClose", "drawerStyle", "headerStyle", "bodyStyle", "title", "push", "onAfterVisibleChange", "onClose", "onUpdate:visible", "onUpdate:open", "visible"])), {
        forceRender: K,
        onClose: $,
        afterVisibleChange: O,
        handler: !1,
        prefixCls: p.value,
        open: c.value,
        showMask: H,
        placement: j,
        ref: i
      });
      return g(f(Ks, null, {
        default: () => [f(MU, D(D({}, W), {}, {
          maskMotion: k.value,
          motion: B,
          width: I.value,
          height: E.value,
          getContainer: y.value,
          rootClassName: N.value,
          rootStyle: e.rootStyle,
          contentWrapperStyle: M.value
        }), {
          handler: e.handle ? () => e.handle : o.handle,
          default: () => z(p.value)
        })]
      }));
    };
  }
}), pI = kt(BU);
var FU = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z" } }] }, name: "file-text", theme: "outlined" };
function d$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      LU(e, r, n[r]);
    });
  }
  return e;
}
function LU(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Sp = function(t, n) {
  var o = d$({}, t, n.attrs);
  return f(Ge, d$({}, o, {
    icon: FU
  }), null);
};
Sp.displayName = "FileTextOutlined";
Sp.inheritAttrs = !1;
const pb = () => ({
  prefixCls: String,
  description: V.any,
  type: ke("default"),
  shape: ke("circle"),
  tooltip: V.any,
  href: String,
  target: String,
  badge: Re(),
  onClick: le()
}), zU = () => ({
  prefixCls: ke()
}), HU = () => m(m({}, pb()), {
  // 包含的 Float Button
  // 触发方式 (有触发方式为菜单模式）
  trigger: ke(),
  // 受控展开
  open: ve(),
  // 展开收起的回调
  onOpenChange: le(),
  "onUpdate:open": le()
}), jU = () => m(m({}, pb()), {
  prefixCls: String,
  duration: Number,
  target: le(),
  visibilityHeight: Number,
  onClick: le()
}), VU = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AFloatButtonContent",
  inheritAttrs: !1,
  props: zU(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    return () => {
      var r;
      const {
        prefixCls: l
      } = e, a = Lt((r = o.description) === null || r === void 0 ? void 0 : r.call(o));
      return f("div", D(D({}, n), {}, {
        class: [n.class, `${l}-content`]
      }), [o.icon || a.length ? f(Fe, null, [o.icon && f("div", {
        class: `${l}-icon`
      }, [o.icon()]), a.length ? f("div", {
        class: `${l}-description`
      }, [a]) : null]) : f("div", {
        class: `${l}-icon`
      }, [f(Sp, null, null)])]);
    };
  }
}), vI = Symbol("floatButtonGroupContext"), WU = (e) => (Je(vI, e), e), gI = () => tt(vI, {
  shape: Y()
}), f$ = (e) => e === 0 ? 0 : e - Math.sqrt(Math.pow(e, 2) / 2), KU = (e) => {
  const {
    componentCls: t,
    floatButtonSize: n,
    motionDurationSlow: o,
    motionEaseInOutCirc: r
  } = e, l = `${t}-group`, a = new lt("antFloatButtonMoveDownIn", {
    "0%": {
      transform: `translate3d(0, ${n}px, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    },
    "100%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    }
  }), i = new lt("antFloatButtonMoveDownOut", {
    "0%": {
      transform: "translate3d(0, 0, 0)",
      transformOrigin: "0 0",
      opacity: 1
    },
    "100%": {
      transform: `translate3d(0, ${n}px, 0)`,
      transformOrigin: "0 0",
      opacity: 0
    }
  });
  return [{
    [`${l}-wrap`]: m({}, sc(`${l}-wrap`, a, i, o, !0))
  }, {
    [`${l}-wrap`]: {
      [`
          &${l}-wrap-enter,
          &${l}-wrap-appear
        `]: {
        opacity: 0,
        animationTimingFunction: r
      },
      [`&${l}-wrap-leave`]: {
        animationTimingFunction: r
      }
    }
  }];
}, GU = (e) => {
  const {
    antCls: t,
    componentCls: n,
    floatButtonSize: o,
    margin: r,
    borderRadiusLG: l,
    borderRadiusSM: a,
    badgeOffset: i,
    floatButtonBodyPadding: s
  } = e, c = `${n}-group`;
  return {
    [c]: m(m({}, qe(e)), {
      zIndex: 99,
      display: "block",
      border: "none",
      position: "fixed",
      width: o,
      height: "auto",
      boxShadow: "none",
      minHeight: o,
      insetInlineEnd: e.floatButtonInsetInlineEnd,
      insetBlockEnd: e.floatButtonInsetBlockEnd,
      borderRadius: l,
      [`${c}-wrap`]: {
        zIndex: -1,
        display: "block",
        position: "relative",
        marginBottom: r
      },
      [`&${c}-rtl`]: {
        direction: "rtl"
      },
      [n]: {
        position: "static"
      }
    }),
    [`${c}-circle`]: {
      [`${n}-circle:not(:last-child)`]: {
        marginBottom: e.margin,
        [`${n}-body`]: {
          width: o,
          height: o,
          borderRadius: "50%"
        }
      }
    },
    [`${c}-square`]: {
      [`${n}-square`]: {
        borderRadius: 0,
        padding: 0,
        "&:first-child": {
          borderStartStartRadius: l,
          borderStartEndRadius: l
        },
        "&:last-child": {
          borderEndStartRadius: l,
          borderEndEndRadius: l
        },
        "&:not(:last-child)": {
          borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
        },
        [`${t}-badge`]: {
          [`${t}-badge-count`]: {
            top: -(s + i),
            insetInlineEnd: -(s + i)
          }
        }
      },
      [`${c}-wrap`]: {
        display: "block",
        borderRadius: l,
        boxShadow: e.boxShadowSecondary,
        [`${n}-square`]: {
          boxShadow: "none",
          marginTop: 0,
          borderRadius: 0,
          padding: s,
          "&:first-child": {
            borderStartStartRadius: l,
            borderStartEndRadius: l
          },
          "&:last-child": {
            borderEndStartRadius: l,
            borderEndEndRadius: l
          },
          "&:not(:last-child)": {
            borderBottom: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
          },
          [`${n}-body`]: {
            width: e.floatButtonBodySize,
            height: e.floatButtonBodySize
          }
        }
      }
    },
    [`${c}-circle-shadow`]: {
      boxShadow: "none"
    },
    [`${c}-square-shadow`]: {
      boxShadow: e.boxShadowSecondary,
      [`${n}-square`]: {
        boxShadow: "none",
        padding: s,
        [`${n}-body`]: {
          width: e.floatButtonBodySize,
          height: e.floatButtonBodySize,
          borderRadius: a
        }
      }
    }
  };
}, XU = (e) => {
  const {
    antCls: t,
    componentCls: n,
    floatButtonBodyPadding: o,
    floatButtonIconSize: r,
    floatButtonSize: l,
    borderRadiusLG: a,
    badgeOffset: i,
    dotOffsetInSquare: s,
    dotOffsetInCircle: c
  } = e;
  return {
    [n]: m(m({}, qe(e)), {
      border: "none",
      position: "fixed",
      cursor: "pointer",
      zIndex: 99,
      display: "block",
      justifyContent: "center",
      alignItems: "center",
      width: l,
      height: l,
      insetInlineEnd: e.floatButtonInsetInlineEnd,
      insetBlockEnd: e.floatButtonInsetBlockEnd,
      boxShadow: e.boxShadowSecondary,
      // Pure Panel
      "&-pure": {
        position: "relative",
        inset: "auto"
      },
      "&:empty": {
        display: "none"
      },
      [`${t}-badge`]: {
        width: "100%",
        height: "100%",
        [`${t}-badge-count`]: {
          transform: "translate(0, 0)",
          transformOrigin: "center",
          top: -i,
          insetInlineEnd: -i
        }
      },
      [`${n}-body`]: {
        width: "100%",
        height: "100%",
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        transition: `all ${e.motionDurationMid}`,
        [`${n}-content`]: {
          overflow: "hidden",
          textAlign: "center",
          minHeight: l,
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          padding: `${o / 2}px ${o}px`,
          [`${n}-icon`]: {
            textAlign: "center",
            margin: "auto",
            width: r,
            fontSize: r,
            lineHeight: 1
          }
        }
      }
    }),
    [`${n}-rtl`]: {
      direction: "rtl"
    },
    [`${n}-circle`]: {
      height: l,
      borderRadius: "50%",
      [`${t}-badge`]: {
        [`${t}-badge-dot`]: {
          top: c,
          insetInlineEnd: c
        }
      },
      [`${n}-body`]: {
        borderRadius: "50%"
      }
    },
    [`${n}-square`]: {
      height: "auto",
      minHeight: l,
      borderRadius: a,
      [`${t}-badge`]: {
        [`${t}-badge-dot`]: {
          top: s,
          insetInlineEnd: s
        }
      },
      [`${n}-body`]: {
        height: "auto",
        borderRadius: a
      }
    },
    [`${n}-default`]: {
      backgroundColor: e.floatButtonBackgroundColor,
      transition: `background-color ${e.motionDurationMid}`,
      [`${n}-body`]: {
        backgroundColor: e.floatButtonBackgroundColor,
        transition: `background-color ${e.motionDurationMid}`,
        "&:hover": {
          backgroundColor: e.colorFillContent
        },
        [`${n}-content`]: {
          [`${n}-icon`]: {
            color: e.colorText
          },
          [`${n}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: `${e.fontSizeLG}px`,
            color: e.colorText,
            fontSize: e.fontSizeSM
          }
        }
      }
    },
    [`${n}-primary`]: {
      backgroundColor: e.colorPrimary,
      [`${n}-body`]: {
        backgroundColor: e.colorPrimary,
        transition: `background-color ${e.motionDurationMid}`,
        "&:hover": {
          backgroundColor: e.colorPrimaryHover
        },
        [`${n}-content`]: {
          [`${n}-icon`]: {
            color: e.colorTextLightSolid
          },
          [`${n}-description`]: {
            display: "flex",
            alignItems: "center",
            lineHeight: `${e.fontSizeLG}px`,
            color: e.colorTextLightSolid,
            fontSize: e.fontSizeSM
          }
        }
      }
    }
  };
}, vb = Xe("FloatButton", (e) => {
  const {
    colorTextLightSolid: t,
    colorBgElevated: n,
    controlHeightLG: o,
    marginXXL: r,
    marginLG: l,
    fontSize: a,
    fontSizeIcon: i,
    controlItemBgHover: s,
    paddingXXS: c,
    borderRadiusLG: u
  } = e, d = He(e, {
    floatButtonBackgroundColor: n,
    floatButtonColor: t,
    floatButtonHoverBackgroundColor: s,
    floatButtonFontSize: a,
    floatButtonIconSize: i * 1.5,
    floatButtonSize: o,
    floatButtonInsetBlockEnd: r,
    floatButtonInsetInlineEnd: l,
    floatButtonBodySize: o - c * 2,
    // 这里的 paddingXXS 是简写，完整逻辑是 (controlHeightLG - (controlHeightLG - paddingXXS * 2)) / 2,
    floatButtonBodyPadding: c,
    badgeOffset: c * 1.5,
    dotOffsetInCircle: f$(o / 2),
    dotOffsetInSquare: f$(u)
  });
  return [GU(d), XU(d), l0(e), KU(d)];
});
var UU = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const gb = "float-btn", bl = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AFloatButton",
  inheritAttrs: !1,
  props: Qe(pb(), {
    type: "default",
    shape: "circle"
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie(gb, e), [a, i] = vb(r), {
      shape: s
    } = gI(), c = Y(null), u = P(() => (s == null ? void 0 : s.value) || e.shape);
    return () => {
      var d;
      const {
        prefixCls: p,
        type: v = "default",
        shape: h = "circle",
        description: g = (d = o.description) === null || d === void 0 ? void 0 : d.call(o),
        tooltip: b,
        badge: y = {}
      } = e, S = UU(e, ["prefixCls", "type", "shape", "description", "tooltip", "badge"]), C = ee(r.value, `${r.value}-${v}`, `${r.value}-${u.value}`, {
        [`${r.value}-rtl`]: l.value === "rtl"
      }, n.class, i.value), w = f(Ln, {
        placement: "left"
      }, {
        title: o.tooltip || b ? () => o.tooltip && o.tooltip() || b : void 0,
        default: () => f(hs, y, {
          default: () => [f("div", {
            class: `${r.value}-body`
          }, [f(VU, {
            prefixCls: r.value
          }, {
            icon: o.icon,
            description: () => g
          })])]
        })
      });
      return process.env.NODE_ENV !== "production" && Mt(!(h === "circle" && g), "FloatButton", "supported only when `shape` is `square`. Due to narrow space for text, short sentence is recommended."), a(e.href ? f("a", D(D(D({
        ref: c
      }, n), S), {}, {
        class: C
      }), [w]) : f("button", D(D(D({
        ref: c
      }, n), S), {}, {
        class: C,
        type: "button"
      }), [w]));
    };
  }
}), Yd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AFloatButtonGroup",
  inheritAttrs: !1,
  props: Qe(HU(), {
    type: "default",
    shape: "circle"
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r
    } = t;
    const {
      prefixCls: l,
      direction: a
    } = Ie(gb, e), [i, s] = vb(l), [c, u] = Rt(!1, {
      value: P(() => e.open)
    }), d = Y(null), p = Y(null);
    WU({
      shape: P(() => e.shape)
    });
    const v = {
      onMouseenter() {
        var y;
        u(!0), r("update:open", !0), (y = e.onOpenChange) === null || y === void 0 || y.call(e, !0);
      },
      onMouseleave() {
        var y;
        u(!1), r("update:open", !1), (y = e.onOpenChange) === null || y === void 0 || y.call(e, !1);
      }
    }, h = P(() => e.trigger === "hover" ? v : {}), g = () => {
      var y;
      const S = !c.value;
      r("update:open", S), (y = e.onOpenChange) === null || y === void 0 || y.call(e, S), u(S);
    }, b = (y) => {
      var S, C, w;
      if (!((S = d.value) === null || S === void 0) && S.contains(y.target)) {
        !((C = qn(p.value)) === null || C === void 0) && C.contains(y.target) && g();
        return;
      }
      u(!1), r("update:open", !1), (w = e.onOpenChange) === null || w === void 0 || w.call(e, !1);
    };
    return ie(P(() => e.trigger), (y) => {
      jn() && (document.removeEventListener("click", b), y === "click" && document.addEventListener("click", b));
    }, {
      immediate: !0
    }), et(() => {
      document.removeEventListener("click", b);
    }), () => {
      var y;
      const {
        shape: S = "circle",
        type: C = "default",
        tooltip: w,
        description: $,
        trigger: O
      } = e, x = `${l.value}-group`, I = ee(x, s.value, n.class, {
        [`${x}-rtl`]: a.value === "rtl",
        [`${x}-${S}`]: S,
        [`${x}-${S}-shadow`]: !O
      }), E = ee(s.value, `${x}-wrap`), _ = Ho(`${x}-wrap`);
      return i(f("div", D(D({
        ref: d
      }, n), {}, {
        class: I
      }, h.value), [O && ["click", "hover"].includes(O) ? f(Fe, null, [f(yn, _, {
        default: () => [Tn(f("div", {
          class: E
        }, [o.default && o.default()]), [[Hn, c.value]])]
      }), f(bl, {
        ref: p,
        type: C,
        shape: S,
        tooltip: w,
        description: $
      }, {
        icon: () => {
          var M, R;
          return c.value ? ((M = o.closeIcon) === null || M === void 0 ? void 0 : M.call(o)) || f(Kn, null, null) : ((R = o.icon) === null || R === void 0 ? void 0 : R.call(o)) || f(Sp, null, null);
        },
        tooltip: o.tooltip,
        description: o.description
      })]) : (y = o.default) === null || y === void 0 ? void 0 : y.call(o)]));
    };
  }
});
var YU = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" } }] }, name: "vertical-align-top", theme: "outlined" };
function p$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      qU(e, r, n[r]);
    });
  }
  return e;
}
function qU(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var mb = function(t, n) {
  var o = p$({}, t, n.attrs);
  return f(Ge, p$({}, o, {
    icon: YU
  }), null);
};
mb.displayName = "VerticalAlignTopOutlined";
mb.inheritAttrs = !1;
const qd = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ABackTop",
  inheritAttrs: !1,
  props: Qe(jU(), {
    visibilityHeight: 400,
    target: () => window,
    duration: 450,
    type: "default",
    shape: "circle"
  }),
  // emits: ['click'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r
    } = t;
    const {
      prefixCls: l,
      direction: a
    } = Ie(gb, e), [i] = vb(l), s = Y(), c = xt({
      visible: e.visibilityHeight === 0,
      scrollEvent: null
    }), u = () => s.value && s.value.ownerDocument ? s.value.ownerDocument : window, d = (b) => {
      const {
        target: y = u,
        duration: S
      } = e;
      mh(0, {
        getContainer: y,
        duration: S
      }), r("click", b);
    }, p = hg((b) => {
      const {
        visibilityHeight: y
      } = e, S = gh(b.target);
      c.visible = S >= y;
    }), v = () => {
      const {
        target: b
      } = e, S = (b || u)();
      p({
        target: S
      }), S == null || S.addEventListener("scroll", p);
    }, h = () => {
      const {
        target: b
      } = e, S = (b || u)();
      p.cancel(), S == null || S.removeEventListener("scroll", p);
    };
    ie(() => e.target, () => {
      h(), rt(() => {
        v();
      });
    }), Ke(() => {
      rt(() => {
        v();
      });
    }), th(() => {
      rt(() => {
        v();
      });
    }), iT(() => {
      h();
    }), et(() => {
      h();
    });
    const g = gI();
    return () => {
      const {
        description: b,
        type: y,
        shape: S,
        tooltip: C,
        badge: w
      } = e, $ = m(m({}, o), {
        shape: (g == null ? void 0 : g.shape.value) || S,
        onClick: d,
        class: {
          [`${l.value}`]: !0,
          [`${o.class}`]: o.class,
          [`${l.value}-rtl`]: a.value === "rtl"
        },
        description: b,
        type: y,
        tooltip: C,
        badge: w
      }), O = Ho("fade");
      return i(f(yn, O, {
        default: () => [Tn(f(bl, D(D({}, $), {}, {
          ref: s
        }), {
          icon: () => {
            var x;
            return ((x = n.icon) === null || x === void 0 ? void 0 : x.call(n)) || f(mb, null, null);
          }
        }), [[Hn, c.visible]])]
      }));
    };
  }
});
bl.Group = Yd;
bl.BackTop = qd;
bl.install = function(e) {
  return e.component(bl.name, bl), e.component(Yd.name, Yd), e.component(qd.name, qd), e;
};
const $s = (e) => e != null && (Array.isArray(e) ? Lt(e).length : !0);
function hb(e) {
  return $s(e.prefix) || $s(e.suffix) || $s(e.allowClear);
}
function Du(e) {
  return $s(e.addonBefore) || $s(e.addonAfter);
}
function wm(e) {
  return typeof e > "u" || e === null ? "" : String(e);
}
function ws(e, t, n, o) {
  if (!n)
    return;
  const r = t;
  if (t.type === "click") {
    Object.defineProperty(r, "target", {
      writable: !0
    }), Object.defineProperty(r, "currentTarget", {
      writable: !0
    });
    const l = e.cloneNode(!0);
    r.target = l, r.currentTarget = l, l.value = "", n(r);
    return;
  }
  if (o !== void 0) {
    Object.defineProperty(r, "target", {
      writable: !0
    }), Object.defineProperty(r, "currentTarget", {
      writable: !0
    }), r.target = e, r.currentTarget = e, e.value = o, n(r);
    return;
  }
  n(r);
}
function mI(e, t) {
  if (!e)
    return;
  e.focus(t);
  const {
    cursor: n
  } = t || {};
  if (n) {
    const o = e.value.length;
    switch (n) {
      case "start":
        e.setSelectionRange(0, 0);
        break;
      case "end":
        e.setSelectionRange(o, o);
        break;
      default:
        e.setSelectionRange(0, o);
    }
  }
}
const ZU = () => ({
  addonBefore: V.any,
  addonAfter: V.any,
  prefix: V.any,
  suffix: V.any,
  clearIcon: V.any,
  affixWrapperClassName: String,
  groupClassName: String,
  wrapperClassName: String,
  inputClassName: String,
  allowClear: {
    type: Boolean,
    default: void 0
  }
}), hI = () => m(m({}, ZU()), {
  value: {
    type: [String, Number, Symbol],
    default: void 0
  },
  defaultValue: {
    type: [String, Number, Symbol],
    default: void 0
  },
  inputElement: V.any,
  prefixCls: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  focused: {
    type: Boolean,
    default: void 0
  },
  triggerFocus: Function,
  readonly: {
    type: Boolean,
    default: void 0
  },
  handleReset: Function,
  hidden: {
    type: Boolean,
    default: void 0
  }
}), bI = () => m(m({}, hI()), {
  id: String,
  placeholder: {
    type: [String, Number]
  },
  autocomplete: String,
  type: ke("text"),
  name: String,
  size: {
    type: String
  },
  autofocus: {
    type: Boolean,
    default: void 0
  },
  lazy: {
    type: Boolean,
    default: !0
  },
  maxlength: Number,
  loading: {
    type: Boolean,
    default: void 0
  },
  bordered: {
    type: Boolean,
    default: void 0
  },
  showCount: {
    type: [Boolean, Object]
  },
  htmlSize: Number,
  onPressEnter: Function,
  onKeydown: Function,
  onKeyup: Function,
  onFocus: Function,
  onBlur: Function,
  onChange: Function,
  onInput: Function,
  "onUpdate:value": Function,
  onCompositionstart: Function,
  onCompositionend: Function,
  valueModifiers: Object,
  hidden: {
    type: Boolean,
    default: void 0
  },
  status: String
}), QU = Z({
  name: "BaseInput",
  inheritAttrs: !1,
  props: hI(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = Y(), l = (i) => {
      var s;
      if (!((s = r.value) === null || s === void 0) && s.contains(i.target)) {
        const {
          triggerFocus: c
        } = e;
        c == null || c();
      }
    }, a = () => {
      var i;
      const {
        allowClear: s,
        value: c,
        disabled: u,
        readonly: d,
        handleReset: p,
        suffix: v = n.suffix,
        prefixCls: h
      } = e;
      if (!s)
        return null;
      const g = !u && !d && c, b = `${h}-clear-icon`, y = ((i = n.clearIcon) === null || i === void 0 ? void 0 : i.call(n)) || "*";
      return f("span", {
        onClick: p,
        onMousedown: (S) => S.preventDefault(),
        class: ee({
          [`${b}-hidden`]: !g,
          [`${b}-has-suffix`]: !!v
        }, b),
        role: "button",
        tabindex: -1
      }, [y]);
    };
    return () => {
      var i, s;
      const {
        focused: c,
        value: u,
        disabled: d,
        allowClear: p,
        readonly: v,
        hidden: h,
        prefixCls: g,
        prefix: b = (i = n.prefix) === null || i === void 0 ? void 0 : i.call(n),
        suffix: y = (s = n.suffix) === null || s === void 0 ? void 0 : s.call(n),
        addonAfter: S = n.addonAfter,
        addonBefore: C = n.addonBefore,
        inputElement: w,
        affixWrapperClassName: $,
        wrapperClassName: O,
        groupClassName: x
      } = e;
      let I = yt(w, {
        value: u,
        hidden: h
      });
      if (hb({
        prefix: b,
        suffix: y,
        allowClear: p
      })) {
        const E = `${g}-affix-wrapper`, _ = ee(E, {
          [`${E}-disabled`]: d,
          [`${E}-focused`]: c,
          [`${E}-readonly`]: v,
          [`${E}-input-with-clear-btn`]: y && p && u
        }, !Du({
          addonAfter: S,
          addonBefore: C
        }) && o.class, $), M = (y || p) && f("span", {
          class: `${g}-suffix`
        }, [a(), y]);
        I = f("span", {
          class: _,
          style: o.style,
          hidden: !Du({
            addonAfter: S,
            addonBefore: C
          }) && h,
          onMousedown: l,
          ref: r
        }, [b && f("span", {
          class: `${g}-prefix`
        }, [b]), yt(w, {
          style: null,
          value: u,
          hidden: null
        }), M]);
      }
      if (Du({
        addonAfter: S,
        addonBefore: C
      })) {
        const E = `${g}-group`, _ = `${E}-addon`, M = ee(`${g}-wrapper`, E, O), R = ee(`${g}-group-wrapper`, o.class, x);
        return f("span", {
          class: R,
          style: o.style,
          hidden: h
        }, [f("span", {
          class: M
        }, [C && f("span", {
          class: _
        }, [C]), yt(I, {
          style: null,
          hidden: null
        }), S && f("span", {
          class: _
        }, [S])])]);
      }
      return I;
    };
  }
});
var JU = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const eY = Z({
  name: "VCInput",
  inheritAttrs: !1,
  props: bI(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r,
      emit: l
    } = t;
    const a = Q(e.value === void 0 ? e.defaultValue : e.value), i = Q(!1), s = Q(), c = Q();
    ie(() => e.value, () => {
      a.value = e.value;
    }), ie(() => e.disabled, () => {
      e.disabled && (i.value = !1);
    });
    const u = (x) => {
      s.value && mI(s.value.input, x);
    }, d = () => {
      var x;
      (x = s.value.input) === null || x === void 0 || x.blur();
    }, p = (x, I, E) => {
      var _;
      (_ = s.value.input) === null || _ === void 0 || _.setSelectionRange(x, I, E);
    }, v = () => {
      var x;
      (x = s.value.input) === null || x === void 0 || x.select();
    };
    r({
      focus: u,
      blur: d,
      input: P(() => {
        var x;
        return (x = s.value.input) === null || x === void 0 ? void 0 : x.input;
      }),
      stateValue: a,
      setSelectionRange: p,
      select: v
    });
    const h = (x) => {
      l("change", x);
    }, g = (x, I) => {
      a.value !== x && (e.value === void 0 ? a.value = x : rt(() => {
        var E;
        s.value.input.value !== a.value && ((E = c.value) === null || E === void 0 || E.$forceUpdate());
      }), rt(() => {
        I && I();
      }));
    }, b = (x) => {
      const {
        value: I
      } = x.target;
      if (a.value === I)
        return;
      const E = x.target.value;
      ws(s.value.input, x, h), g(E);
    }, y = (x) => {
      x.keyCode === 13 && l("pressEnter", x), l("keydown", x);
    }, S = (x) => {
      i.value = !0, l("focus", x);
    }, C = (x) => {
      i.value = !1, l("blur", x);
    }, w = (x) => {
      ws(s.value.input, x, h), g("", () => {
        u();
      });
    }, $ = () => {
      var x, I;
      const {
        addonBefore: E = n.addonBefore,
        addonAfter: _ = n.addonAfter,
        disabled: M,
        valueModifiers: R = {},
        htmlSize: A,
        autocomplete: z,
        prefixCls: T,
        inputClassName: N,
        prefix: k = (x = n.prefix) === null || x === void 0 ? void 0 : x.call(n),
        suffix: B = (I = n.suffix) === null || I === void 0 ? void 0 : I.call(n),
        allowClear: F,
        type: L = "text"
      } = e, j = ot(e, [
        "prefixCls",
        "onPressEnter",
        "addonBefore",
        "addonAfter",
        "prefix",
        "suffix",
        "allowClear",
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        "defaultValue",
        "size",
        "bordered",
        "htmlSize",
        "lazy",
        "showCount",
        "valueModifiers",
        "showCount",
        "affixWrapperClassName",
        "groupClassName",
        "inputClassName",
        "wrapperClassName"
      ]), H = m(m(m({}, j), o), {
        autocomplete: z,
        onChange: b,
        onInput: b,
        onFocus: S,
        onBlur: C,
        onKeydown: y,
        class: ee(T, {
          [`${T}-disabled`]: M
        }, N, !Du({
          addonAfter: _,
          addonBefore: E
        }) && !hb({
          prefix: k,
          suffix: B,
          allowClear: F
        }) && o.class),
        ref: s,
        key: "ant-input",
        size: A,
        type: L,
        lazy: e.lazy
      });
      return R.lazy && delete H.onInput, H.autofocus || delete H.autofocus, f(Ti, ot(H, ["size"]), null);
    }, O = () => {
      var x;
      const {
        maxlength: I,
        suffix: E = (x = n.suffix) === null || x === void 0 ? void 0 : x.call(n),
        showCount: _,
        prefixCls: M
      } = e, R = Number(I) > 0;
      if (E || _) {
        const A = [...wm(a.value)].length, z = typeof _ == "object" ? _.formatter({
          count: A,
          maxlength: I
        }) : `${A}${R ? ` / ${I}` : ""}`;
        return f(Fe, null, [!!_ && f("span", {
          class: ee(`${M}-show-count-suffix`, {
            [`${M}-show-count-has-suffix`]: !!E
          })
        }, [z]), E]);
      }
      return null;
    };
    return Ke(() => {
      process.env.NODE_ENV === "test" && e.autofocus && u();
    }), () => {
      const {
        prefixCls: x,
        disabled: I
      } = e, E = JU(e, ["prefixCls", "disabled"]);
      return f(QU, D(D(D({}, E), o), {}, {
        ref: c,
        prefixCls: x,
        inputElement: $(),
        handleReset: w,
        value: wm(a.value),
        focused: i.value,
        triggerFocus: u,
        suffix: O(),
        disabled: I
      }), n);
    };
  }
}), Cp = () => ot(bI(), ["wrapperClassName", "groupClassName", "inputClassName", "affixWrapperClassName"]), yI = () => m(m({}, ot(Cp(), ["prefix", "addonBefore", "addonAfter", "suffix"])), {
  rows: Number,
  autosize: {
    type: [Boolean, Object],
    default: void 0
  },
  autoSize: {
    type: [Boolean, Object],
    default: void 0
  },
  onResize: {
    type: Function
  },
  onCompositionstart: ia(),
  onCompositionend: ia(),
  valueModifiers: Object
});
var tY = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const fn = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AInput",
  inheritAttrs: !1,
  props: Cp(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r,
      emit: l
    } = t;
    const a = Y(), i = sn(), s = Sn.useInject(), c = P(() => ar(s.status, e.status)), {
      direction: u,
      prefixCls: d,
      size: p,
      autocomplete: v
    } = Ie("input", e), {
      compactSize: h,
      compactItemClassnames: g
    } = Ol(d, u), b = P(() => h.value || p.value), [y, S] = G0(d), C = so();
    r({
      focus: (A) => {
        var z;
        (z = a.value) === null || z === void 0 || z.focus(A);
      },
      blur: () => {
        var A;
        (A = a.value) === null || A === void 0 || A.blur();
      },
      input: a,
      setSelectionRange: (A, z, T) => {
        var N;
        (N = a.value) === null || N === void 0 || N.setSelectionRange(A, z, T);
      },
      select: () => {
        var A;
        (A = a.value) === null || A === void 0 || A.select();
      }
    });
    const I = Y([]), E = () => {
      I.value.push(setTimeout(() => {
        var A, z, T, N;
        !((A = a.value) === null || A === void 0) && A.input && ((z = a.value) === null || z === void 0 ? void 0 : z.input.getAttribute("type")) === "password" && (!((T = a.value) === null || T === void 0) && T.input.hasAttribute("value")) && ((N = a.value) === null || N === void 0 || N.input.removeAttribute("value"));
      }));
    };
    Ke(() => {
      E();
    }), eh(() => {
      I.value.forEach((A) => clearTimeout(A));
    }), et(() => {
      I.value.forEach((A) => clearTimeout(A));
    });
    const _ = (A) => {
      E(), l("blur", A), i.onFieldBlur();
    }, M = (A) => {
      E(), l("focus", A);
    }, R = (A) => {
      l("update:value", A.target.value), l("change", A), l("input", A), i.onFieldChange();
    };
    return () => {
      var A, z, T, N, k, B;
      const {
        hasFeedback: F,
        feedbackIcon: L
      } = s, {
        allowClear: j,
        bordered: H = !0,
        prefix: K = (A = n.prefix) === null || A === void 0 ? void 0 : A.call(n),
        suffix: X = (z = n.suffix) === null || z === void 0 ? void 0 : z.call(n),
        addonAfter: W = (T = n.addonAfter) === null || T === void 0 ? void 0 : T.call(n),
        addonBefore: q = (N = n.addonBefore) === null || N === void 0 ? void 0 : N.call(n),
        id: J = (k = i.id) === null || k === void 0 ? void 0 : k.value
      } = e, ne = tY(e, ["allowClear", "bordered", "prefix", "suffix", "addonAfter", "addonBefore", "id"]), te = (F || X) && f(Fe, null, [X, F && L]), G = d.value, U = hb({
        prefix: K,
        suffix: X
      }) || !!F, re = n.clearIcon || (() => f(Gn, null, null));
      return y(f(eY, D(D(D({}, o), ot(ne, ["onUpdate:value", "onChange", "onInput"])), {}, {
        onChange: R,
        id: J,
        disabled: (B = e.disabled) !== null && B !== void 0 ? B : C.value,
        ref: a,
        prefixCls: G,
        autocomplete: v.value,
        onBlur: _,
        onFocus: M,
        prefix: K,
        suffix: te,
        allowClear: j,
        addonAfter: W && f(Ks, null, {
          default: () => [f(Cd, null, {
            default: () => [W]
          })]
        }),
        addonBefore: q && f(Ks, null, {
          default: () => [f(Cd, null, {
            default: () => [q]
          })]
        }),
        class: [o.class, g.value],
        inputClassName: ee({
          [`${G}-sm`]: b.value === "small",
          [`${G}-lg`]: b.value === "large",
          [`${G}-rtl`]: u.value === "rtl",
          [`${G}-borderless`]: !H
        }, !U && Fn(G, c.value), S.value),
        affixWrapperClassName: ee({
          [`${G}-affix-wrapper-sm`]: b.value === "small",
          [`${G}-affix-wrapper-lg`]: b.value === "large",
          [`${G}-affix-wrapper-rtl`]: u.value === "rtl",
          [`${G}-affix-wrapper-borderless`]: !H
        }, Fn(`${G}-affix-wrapper`, c.value, F), S.value),
        wrapperClassName: ee({
          [`${G}-group-rtl`]: u.value === "rtl"
        }, S.value),
        groupClassName: ee({
          [`${G}-group-wrapper-sm`]: b.value === "small",
          [`${G}-group-wrapper-lg`]: b.value === "large",
          [`${G}-group-wrapper-rtl`]: u.value === "rtl"
        }, Fn(`${G}-group-wrapper`, c.value, F), S.value)
      }), m(m({}, n), {
        clearIcon: re
      })));
    };
  }
}), SI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AInputGroup",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    size: {
      type: String
    },
    compact: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l,
      getPrefixCls: a
    } = Ie("input-group", e), i = Sn.useInject();
    Sn.useProvide(i, {
      isFormItemInput: !1
    });
    const s = P(() => a("input")), [c, u] = G0(s), d = P(() => {
      const p = r.value;
      return {
        [`${p}`]: !0,
        [u.value]: !0,
        [`${p}-lg`]: e.size === "large",
        [`${p}-sm`]: e.size === "small",
        [`${p}-compact`]: e.compact,
        [`${p}-rtl`]: l.value === "rtl"
      };
    });
    return () => {
      var p;
      return c(f("span", D(D({}, o), {}, {
        class: ee(d.value, o.class)
      }), [(p = n.default) === null || p === void 0 ? void 0 : p.call(n)]));
    };
  }
});
var nY = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const CI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AInputSearch",
  inheritAttrs: !1,
  props: m(m({}, Cp()), {
    inputPrefixCls: String,
    // 不能设置默认值 https://github.com/vueComponent/ant-design-vue/issues/1916
    enterButton: V.any,
    onSearch: {
      type: Function
    }
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r,
      emit: l
    } = t;
    const a = Q(), i = Q(!1);
    r({
      focus: () => {
        var $;
        ($ = a.value) === null || $ === void 0 || $.focus();
      },
      blur: () => {
        var $;
        ($ = a.value) === null || $ === void 0 || $.blur();
      }
    });
    const u = ($) => {
      l("update:value", $.target.value), $ && $.target && $.type === "click" && l("search", $.target.value, $), l("change", $);
    }, d = ($) => {
      var O;
      document.activeElement === ((O = a.value) === null || O === void 0 ? void 0 : O.input) && $.preventDefault();
    }, p = ($) => {
      var O, x;
      l("search", (x = (O = a.value) === null || O === void 0 ? void 0 : O.input) === null || x === void 0 ? void 0 : x.stateValue, $);
    }, v = ($) => {
      i.value || e.loading || p($);
    }, h = ($) => {
      i.value = !0, l("compositionstart", $);
    }, g = ($) => {
      i.value = !1, l("compositionend", $);
    }, {
      prefixCls: b,
      getPrefixCls: y,
      direction: S,
      size: C
    } = Ie("input-search", e), w = P(() => y("input", e.inputPrefixCls));
    return () => {
      var $, O, x, I;
      const {
        disabled: E,
        loading: _,
        addonAfter: M = ($ = n.addonAfter) === null || $ === void 0 ? void 0 : $.call(n),
        suffix: R = (O = n.suffix) === null || O === void 0 ? void 0 : O.call(n)
      } = e, A = nY(e, ["disabled", "loading", "addonAfter", "suffix"]);
      let {
        enterButton: z = (I = (x = n.enterButton) === null || x === void 0 ? void 0 : x.call(n)) !== null && I !== void 0 ? I : !1
      } = e;
      z = z || z === "";
      const T = typeof z == "boolean" ? f(_i, null, null) : null, N = `${b.value}-button`, k = Array.isArray(z) ? z[0] : z;
      let B;
      const F = k.type && n0(k.type) && k.type.__ANT_BUTTON;
      if (F || k.tagName === "button")
        B = yt(k, m({
          onMousedown: d,
          onClick: p,
          key: "enterButton"
        }, F ? {
          class: N,
          size: C.value
        } : {}), !1);
      else {
        const j = T && !z;
        B = f(Kt, {
          class: N,
          type: z ? "primary" : void 0,
          size: C.value,
          disabled: E,
          key: "enterButton",
          onMousedown: d,
          onClick: p,
          loading: _,
          icon: j ? T : null
        }, {
          default: () => [j ? null : T || z]
        });
      }
      M && (B = [B, M]);
      const L = ee(b.value, {
        [`${b.value}-rtl`]: S.value === "rtl",
        [`${b.value}-${C.value}`]: !!C.value,
        [`${b.value}-with-button`]: !!z
      }, o.class);
      return f(fn, D(D(D({
        ref: a
      }, ot(A, ["onUpdate:value", "onSearch", "enterButton"])), o), {}, {
        onPressEnter: v,
        onCompositionstart: h,
        onCompositionend: g,
        size: C.value,
        prefixCls: w.value,
        addonAfter: B,
        suffix: R,
        onChange: u,
        class: L,
        disabled: E
      }), n);
    };
  }
}), v$ = (e) => e != null && (Array.isArray(e) ? Lt(e).length : !0);
function oY(e) {
  return v$(e.addonBefore) || v$(e.addonAfter);
}
const rY = ["text", "input"], lY = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ClearableLabeledInput",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    inputType: V.oneOf(Mn("text", "input")),
    value: _t(),
    defaultValue: _t(),
    allowClear: {
      type: Boolean,
      default: void 0
    },
    element: _t(),
    handleReset: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    direction: {
      type: String
    },
    size: {
      type: String
    },
    suffix: _t(),
    prefix: _t(),
    addonBefore: _t(),
    addonAfter: _t(),
    readonly: {
      type: Boolean,
      default: void 0
    },
    focused: {
      type: Boolean,
      default: void 0
    },
    bordered: {
      type: Boolean,
      default: !0
    },
    triggerFocus: {
      type: Function
    },
    hidden: Boolean,
    status: String,
    hashId: String
  },
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = Sn.useInject(), l = (i) => {
      const {
        value: s,
        disabled: c,
        readonly: u,
        handleReset: d,
        suffix: p = n.suffix
      } = e, v = !c && !u && s, h = `${i}-clear-icon`;
      return f(Gn, {
        onClick: d,
        onMousedown: (g) => g.preventDefault(),
        class: ee({
          [`${h}-hidden`]: !v,
          [`${h}-has-suffix`]: !!p
        }, h),
        role: "button"
      }, null);
    }, a = (i, s) => {
      const {
        value: c,
        allowClear: u,
        direction: d,
        bordered: p,
        hidden: v,
        status: h,
        addonAfter: g = n.addonAfter,
        addonBefore: b = n.addonBefore,
        hashId: y
      } = e, {
        status: S,
        hasFeedback: C
      } = r;
      if (!u)
        return yt(s, {
          value: c,
          disabled: e.disabled
        });
      const w = ee(`${i}-affix-wrapper`, `${i}-affix-wrapper-textarea-with-clear-btn`, Fn(`${i}-affix-wrapper`, ar(S, h), C), {
        [`${i}-affix-wrapper-rtl`]: d === "rtl",
        [`${i}-affix-wrapper-borderless`]: !p,
        // className will go to addon wrapper
        [`${o.class}`]: !oY({
          addonAfter: g,
          addonBefore: b
        }) && o.class
      }, y);
      return f("span", {
        class: w,
        style: o.style,
        hidden: v
      }, [yt(s, {
        style: null,
        value: c,
        disabled: e.disabled
      }), l(i)]);
    };
    return () => {
      var i;
      const {
        prefixCls: s,
        inputType: c,
        element: u = (i = n.element) === null || i === void 0 ? void 0 : i.call(n)
      } = e;
      return c === rY[0] ? a(s, u) : null;
    };
  }
}), aY = `
  min-height:0 !important;
  max-height:none !important;
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important;
  pointer-events: none !important;
`, iY = ["letter-spacing", "line-height", "padding-top", "padding-bottom", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "padding-left", "padding-right", "border-width", "box-sizing", "word-break", "white-space"], Av = {};
let Ao;
function sY(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const n = e.getAttribute("id") || e.getAttribute("data-reactid") || e.getAttribute("name");
  if (t && Av[n])
    return Av[n];
  const o = window.getComputedStyle(e), r = o.getPropertyValue("box-sizing") || o.getPropertyValue("-moz-box-sizing") || o.getPropertyValue("-webkit-box-sizing"), l = parseFloat(o.getPropertyValue("padding-bottom")) + parseFloat(o.getPropertyValue("padding-top")), a = parseFloat(o.getPropertyValue("border-bottom-width")) + parseFloat(o.getPropertyValue("border-top-width")), s = {
    sizingStyle: iY.map((c) => `${c}:${o.getPropertyValue(c)}`).join(";"),
    paddingSize: l,
    borderSize: a,
    boxSizing: r
  };
  return t && n && (Av[n] = s), s;
}
function cY(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null, o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
  Ao || (Ao = document.createElement("textarea"), Ao.setAttribute("tab-index", "-1"), Ao.setAttribute("aria-hidden", "true"), document.body.appendChild(Ao)), e.getAttribute("wrap") ? Ao.setAttribute("wrap", e.getAttribute("wrap")) : Ao.removeAttribute("wrap");
  const {
    paddingSize: r,
    borderSize: l,
    boxSizing: a,
    sizingStyle: i
  } = sY(e, t);
  Ao.setAttribute("style", `${i};${aY}`), Ao.value = e.value || e.placeholder || "";
  let s, c, u, d = Ao.scrollHeight;
  if (a === "border-box" ? d += l : a === "content-box" && (d -= r), n !== null || o !== null) {
    Ao.value = " ";
    const v = Ao.scrollHeight - r;
    n !== null && (s = v * n, a === "border-box" && (s = s + r + l), d = Math.max(s, d)), o !== null && (c = v * o, a === "border-box" && (c = c + r + l), u = d > c ? "" : "hidden", d = Math.min(c, d));
  }
  const p = {
    height: `${d}px`,
    overflowY: u,
    resize: "none"
  };
  return s && (p.minHeight = `${s}px`), c && (p.maxHeight = `${c}px`), p;
}
const Dv = 0, Nv = 1, Rv = 2, uY = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ResizableTextArea",
  inheritAttrs: !1,
  props: yI(),
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      expose: r
    } = t, l, a;
    const i = Y(), s = Y({}), c = Y(Rv);
    et(() => {
      Ze.cancel(l), Ze.cancel(a);
    });
    const u = () => {
      try {
        if (i.value && document.activeElement === i.value.input) {
          const O = i.value.getSelectionStart(), x = i.value.getSelectionEnd(), I = i.value.getScrollTop();
          i.value.setSelectionRange(O, x), i.value.setScrollTop(I);
        }
      } catch {
      }
    }, d = Y(), p = Y();
    Le(() => {
      const O = e.autoSize || e.autosize;
      O ? (d.value = O.minRows, p.value = O.maxRows) : (d.value = void 0, p.value = void 0);
    });
    const v = P(() => !!(e.autoSize || e.autosize)), h = () => {
      c.value = Dv;
    };
    ie([() => e.value, d, p, v], () => {
      v.value && h();
    }, {
      immediate: !0
    });
    const g = Y();
    ie([c, i], () => {
      if (i.value)
        if (c.value === Dv)
          c.value = Nv;
        else if (c.value === Nv) {
          const O = cY(i.value.input, !1, d.value, p.value);
          c.value = Rv, g.value = O;
        } else
          u();
    }, {
      immediate: !0,
      flush: "post"
    });
    const b = Wn(), y = Y(), S = () => {
      Ze.cancel(y.value);
    }, C = (O) => {
      c.value === Rv && (o("resize", O), v.value && (S(), y.value = Ze(() => {
        h();
      })));
    };
    et(() => {
      S();
    }), r({
      resizeTextarea: () => {
        h();
      },
      textArea: P(() => {
        var O;
        return (O = i.value) === null || O === void 0 ? void 0 : O.input;
      }),
      instance: b
    }), Mt(e.autosize === void 0, "Input.TextArea", "autosize is deprecated, please use autoSize instead.");
    const $ = () => {
      const {
        prefixCls: O,
        disabled: x
      } = e, I = ot(e, ["prefixCls", "onPressEnter", "autoSize", "autosize", "defaultValue", "allowClear", "type", "maxlength", "valueModifiers"]), E = ee(O, n.class, {
        [`${O}-disabled`]: x
      }), _ = v.value ? g.value : null, M = [n.style, s.value, _], R = m(m(m({}, I), n), {
        style: M,
        class: E
      });
      return (c.value === Dv || c.value === Nv) && M.push({
        overflowX: "hidden",
        overflowY: "hidden"
      }), R.autofocus || delete R.autofocus, R.rows === 0 && delete R.rows, f(Fo, {
        onResize: C,
        disabled: !v.value
      }, {
        default: () => [f(Ti, D(D({}, R), {}, {
          ref: i,
          tag: "textarea"
        }), null)]
      });
    };
    return () => $();
  }
});
function $I(e, t) {
  return [...e || ""].slice(0, t).join("");
}
function g$(e, t, n, o) {
  let r = n;
  return e ? r = $I(n, o) : [...t || ""].length < n.length && [...n || ""].length > o && (r = t), r;
}
const bb = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATextarea",
  inheritAttrs: !1,
  props: yI(),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      emit: r
    } = t;
    var l;
    const a = sn(), i = Sn.useInject(), s = P(() => ar(i.status, e.status)), c = Q((l = e.value) !== null && l !== void 0 ? l : e.defaultValue), u = Q(), d = Q(""), {
      prefixCls: p,
      size: v,
      direction: h
    } = Ie("input", e), [g, b] = G0(p), y = so(), S = P(() => e.showCount === "" || e.showCount || !1), C = P(() => Number(e.maxlength) > 0), w = Q(!1), $ = Q(), O = Q(0), x = (F) => {
      w.value = !0, $.value = d.value, O.value = F.currentTarget.selectionStart, r("compositionstart", F);
    }, I = (F) => {
      var L;
      w.value = !1;
      let j = F.currentTarget.value;
      if (C.value) {
        const H = O.value >= e.maxlength + 1 || O.value === ((L = $.value) === null || L === void 0 ? void 0 : L.length);
        j = g$(H, $.value, j, e.maxlength);
      }
      j !== d.value && (R(j), ws(F.currentTarget, F, T, j)), r("compositionend", F);
    }, E = Wn();
    ie(() => e.value, () => {
      var F;
      "value" in E.vnode.props, c.value = (F = e.value) !== null && F !== void 0 ? F : "";
    });
    const _ = (F) => {
      var L;
      mI((L = u.value) === null || L === void 0 ? void 0 : L.textArea, F);
    }, M = () => {
      var F, L;
      (L = (F = u.value) === null || F === void 0 ? void 0 : F.textArea) === null || L === void 0 || L.blur();
    }, R = (F, L) => {
      c.value !== F && (e.value === void 0 ? c.value = F : rt(() => {
        var j, H, K;
        u.value.textArea.value !== d.value && ((K = (j = u.value) === null || j === void 0 ? void 0 : (H = j.instance).update) === null || K === void 0 || K.call(H));
      }), rt(() => {
        L && L();
      }));
    }, A = (F) => {
      F.keyCode === 13 && r("pressEnter", F), r("keydown", F);
    }, z = (F) => {
      const {
        onBlur: L
      } = e;
      L == null || L(F), a.onFieldBlur();
    }, T = (F) => {
      r("update:value", F.target.value), r("change", F), r("input", F), a.onFieldChange();
    }, N = (F) => {
      ws(u.value.textArea, F, T), R("", () => {
        _();
      });
    }, k = (F) => {
      let L = F.target.value;
      if (c.value !== L) {
        if (C.value) {
          const j = F.target, H = j.selectionStart >= e.maxlength + 1 || j.selectionStart === L.length || !j.selectionStart;
          L = g$(H, d.value, L, e.maxlength);
        }
        ws(F.currentTarget, F, T, L), R(L);
      }
    }, B = () => {
      var F, L;
      const {
        class: j
      } = n, {
        bordered: H = !0
      } = e, K = m(m(m({}, ot(e, ["allowClear"])), n), {
        class: [{
          [`${p.value}-borderless`]: !H,
          [`${j}`]: j && !S.value,
          [`${p.value}-sm`]: v.value === "small",
          [`${p.value}-lg`]: v.value === "large"
        }, Fn(p.value, s.value), b.value],
        disabled: y.value,
        showCount: null,
        prefixCls: p.value,
        onInput: k,
        onChange: k,
        onBlur: z,
        onKeydown: A,
        onCompositionstart: x,
        onCompositionend: I
      });
      return !((F = e.valueModifiers) === null || F === void 0) && F.lazy && delete K.onInput, f(uY, D(D({}, K), {}, {
        id: (L = K == null ? void 0 : K.id) !== null && L !== void 0 ? L : a.id.value,
        ref: u,
        maxlength: e.maxlength,
        lazy: e.lazy
      }), null);
    };
    return o({
      focus: _,
      blur: M,
      resizableTextArea: u
    }), Le(() => {
      let F = wm(c.value);
      !w.value && C.value && (e.value === null || e.value === void 0) && (F = $I(F, e.maxlength)), d.value = F;
    }), () => {
      var F;
      const {
        maxlength: L,
        bordered: j = !0,
        hidden: H
      } = e, {
        style: K,
        class: X
      } = n, W = m(m(m({}, e), n), {
        prefixCls: p.value,
        inputType: "text",
        handleReset: N,
        direction: h.value,
        bordered: j,
        style: S.value ? void 0 : K,
        hashId: b.value,
        disabled: (F = e.disabled) !== null && F !== void 0 ? F : y.value
      });
      let q = f(lY, D(D({}, W), {}, {
        value: d.value,
        status: e.status
      }), {
        element: B
      });
      if (S.value || i.hasFeedback) {
        const J = [...d.value].length;
        let ne = "";
        typeof S.value == "object" ? ne = S.value.formatter({
          value: d.value,
          count: J,
          maxlength: L
        }) : ne = `${J}${C.value ? ` / ${L}` : ""}`, q = f("div", {
          hidden: H,
          class: ee(`${p.value}-textarea`, {
            [`${p.value}-textarea-rtl`]: h.value === "rtl",
            [`${p.value}-textarea-show-count`]: S.value,
            [`${p.value}-textarea-in-form-item`]: i.isFormItemInput
          }, `${p.value}-textarea-show-count`, X, b.value),
          style: K,
          "data-count": typeof ne != "object" ? ne : void 0
        }, [q, i.hasFeedback && f("span", {
          class: `${p.value}-textarea-suffix`
        }, [i.feedbackIcon])]);
      }
      return g(q);
    };
  }
});
var dY = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, name: "eye", theme: "outlined" };
function m$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      fY(e, r, n[r]);
    });
  }
  return e;
}
function fY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Sc = function(t, n) {
  var o = m$({}, t, n.attrs);
  return f(Ge, m$({}, o, {
    icon: dY
  }), null);
};
Sc.displayName = "EyeOutlined";
Sc.inheritAttrs = !1;
var pY = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { tag: "path", attrs: { d: "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, name: "eye-invisible", theme: "outlined" };
function h$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      vY(e, r, n[r]);
    });
  }
  return e;
}
function vY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var yb = function(t, n) {
  var o = h$({}, t, n.attrs);
  return f(Ge, h$({}, o, {
    icon: pY
  }), null);
};
yb.displayName = "EyeInvisibleOutlined";
yb.inheritAttrs = !1;
var gY = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const mY = {
  click: "onClick",
  hover: "onMouseover"
}, hY = (e) => e ? f(Sc, null, null) : f(yb, null, null), wI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AInputPassword",
  inheritAttrs: !1,
  props: m(m({}, Cp()), {
    prefixCls: String,
    inputPrefixCls: String,
    action: {
      type: String,
      default: "click"
    },
    visibilityToggle: {
      type: Boolean,
      default: !0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    "onUpdate:visible": Function,
    iconRender: Function
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r,
      emit: l
    } = t;
    const a = Q(!1), i = () => {
      const {
        disabled: b
      } = e;
      b || (a.value = !a.value, l("update:visible", a.value));
    };
    Le(() => {
      e.visible !== void 0 && (a.value = !!e.visible);
    });
    const s = Q();
    r({
      focus: () => {
        var b;
        (b = s.value) === null || b === void 0 || b.focus();
      },
      blur: () => {
        var b;
        (b = s.value) === null || b === void 0 || b.blur();
      }
    });
    const d = (b) => {
      const {
        action: y,
        iconRender: S = n.iconRender || hY
      } = e, C = mY[y] || "", w = S(a.value), $ = {
        [C]: i,
        class: `${b}-icon`,
        key: "passwordIcon",
        onMousedown: (O) => {
          O.preventDefault();
        },
        onMouseup: (O) => {
          O.preventDefault();
        }
      };
      return yt(Gt(w) ? w : f("span", null, [w]), $);
    }, {
      prefixCls: p,
      getPrefixCls: v
    } = Ie("input-password", e), h = P(() => v("input", e.inputPrefixCls)), g = () => {
      const {
        size: b,
        visibilityToggle: y
      } = e, S = gY(e, ["size", "visibilityToggle"]), C = y && d(p.value), w = ee(p.value, o.class, {
        [`${p.value}-${b}`]: !!b
      }), $ = m(m(m({}, ot(S, ["suffix", "iconRender", "action"])), o), {
        type: a.value ? "text" : "password",
        class: w,
        prefixCls: h.value,
        suffix: C
      });
      return b && ($.size = b), f(fn, D({
        ref: s
      }, $), n);
    };
    return () => g();
  }
});
fn.Group = SI;
fn.Search = CI;
fn.TextArea = bb;
fn.Password = wI;
fn.install = function(e) {
  return e.component(fn.name, fn), e.component(fn.Group.name, fn.Group), e.component(fn.Search.name, fn.Search), e.component(fn.TextArea.name, fn.TextArea), e.component(fn.Password.name, fn.Password), e;
};
function $p() {
  return {
    keyboard: {
      type: Boolean,
      default: void 0
    },
    mask: {
      type: Boolean,
      default: void 0
    },
    afterClose: Function,
    closable: {
      type: Boolean,
      default: void 0
    },
    maskClosable: {
      type: Boolean,
      default: void 0
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    destroyOnClose: {
      type: Boolean,
      default: void 0
    },
    mousePosition: V.shape({
      x: Number,
      y: Number
    }).loose,
    title: V.any,
    footer: V.any,
    transitionName: String,
    maskTransitionName: String,
    animation: V.any,
    maskAnimation: V.any,
    wrapStyle: {
      type: Object,
      default: void 0
    },
    bodyStyle: {
      type: Object,
      default: void 0
    },
    maskStyle: {
      type: Object,
      default: void 0
    },
    prefixCls: String,
    wrapClassName: String,
    rootClassName: String,
    width: [String, Number],
    height: [String, Number],
    zIndex: Number,
    bodyProps: V.any,
    maskProps: V.any,
    wrapProps: V.any,
    getContainer: V.any,
    dialogStyle: {
      type: Object,
      default: void 0
    },
    dialogClass: String,
    closeIcon: V.any,
    forceRender: {
      type: Boolean,
      default: void 0
    },
    getOpenCount: Function,
    // https://github.com/ant-design/ant-design/issues/19771
    // https://github.com/react-component/dialog/issues/95
    focusTriggerAfterClose: {
      type: Boolean,
      default: void 0
    },
    onClose: Function,
    modalRender: Function
  };
}
function b$(e, t, n) {
  let o = t;
  return !o && n && (o = `${e}-${n}`), o;
}
let y$ = -1;
function bY() {
  return y$ += 1, y$;
}
function S$(e, t) {
  let n = e[`page${t ? "Y" : "X"}Offset`];
  const o = `scroll${t ? "Top" : "Left"}`;
  if (typeof n != "number") {
    const r = e.document;
    n = r.documentElement[o], typeof n != "number" && (n = r.body[o]);
  }
  return n;
}
function yY(e) {
  const t = e.getBoundingClientRect(), n = {
    left: t.left,
    top: t.top
  }, o = e.ownerDocument, r = o.defaultView || o.parentWindow;
  return n.left += S$(r), n.top += S$(r, !0), n;
}
const SY = {
  width: 0,
  height: 0,
  overflow: "hidden",
  outline: "none"
}, CY = {
  outline: "none"
}, $Y = Z({
  compatConfig: {
    MODE: 3
  },
  name: "DialogContent",
  inheritAttrs: !1,
  props: m(m({}, $p()), {
    motionName: String,
    ariaId: String,
    onVisibleChanged: Function,
    onMousedown: Function,
    onMouseup: Function
  }),
  setup(e, t) {
    let {
      expose: n,
      slots: o,
      attrs: r
    } = t;
    const l = Y(), a = Y(), i = Y();
    n({
      focus: () => {
        var p;
        (p = l.value) === null || p === void 0 || p.focus({
          preventScroll: !0
        });
      },
      changeActive: (p) => {
        const {
          activeElement: v
        } = document;
        p && v === a.value ? l.value.focus({
          preventScroll: !0
        }) : !p && v === l.value && a.value.focus({
          preventScroll: !0
        });
      }
    });
    const s = Y(), c = P(() => {
      const {
        width: p,
        height: v
      } = e, h = {};
      return p !== void 0 && (h.width = typeof p == "number" ? `${p}px` : p), v !== void 0 && (h.height = typeof v == "number" ? `${v}px` : v), s.value && (h.transformOrigin = s.value), h;
    }), u = () => {
      rt(() => {
        if (i.value) {
          const p = yY(i.value);
          s.value = e.mousePosition ? `${e.mousePosition.x - p.left}px ${e.mousePosition.y - p.top}px` : "";
        }
      });
    }, d = (p) => {
      e.onVisibleChanged(p);
    };
    return () => {
      var p, v, h, g;
      const {
        prefixCls: b,
        footer: y = (p = o.footer) === null || p === void 0 ? void 0 : p.call(o),
        title: S = (v = o.title) === null || v === void 0 ? void 0 : v.call(o),
        ariaId: C,
        closable: w,
        closeIcon: $ = (h = o.closeIcon) === null || h === void 0 ? void 0 : h.call(o),
        onClose: O,
        bodyStyle: x,
        bodyProps: I,
        onMousedown: E,
        onMouseup: _,
        visible: M,
        modalRender: R = o.modalRender,
        destroyOnClose: A,
        motionName: z
      } = e;
      let T;
      y && (T = f("div", {
        class: `${b}-footer`
      }, [y]));
      let N;
      S && (N = f("div", {
        class: `${b}-header`
      }, [f("div", {
        class: `${b}-title`,
        id: C
      }, [S])]));
      let k;
      w && (k = f("button", {
        type: "button",
        onClick: O,
        "aria-label": "Close",
        class: `${b}-close`
      }, [$ || f("span", {
        class: `${b}-close-x`
      }, null)]));
      const B = f("div", {
        class: `${b}-content`
      }, [k, N, f("div", D({
        class: `${b}-body`,
        style: x
      }, I), [(g = o.default) === null || g === void 0 ? void 0 : g.call(o)]), T]), F = Ho(z);
      return f(yn, D(D({}, F), {}, {
        onBeforeEnter: u,
        onAfterEnter: () => d(!0),
        onAfterLeave: () => d(!1)
      }), {
        default: () => [M || !A ? Tn(f("div", D(D({}, r), {}, {
          ref: i,
          key: "dialog-element",
          role: "document",
          style: [c.value, r.style],
          class: [b, r.class],
          onMousedown: E,
          onMouseup: _
        }), [f("div", {
          tabindex: 0,
          ref: l,
          style: CY
        }, [R ? R({
          originVNode: B
        }) : B]), f("div", {
          tabindex: 0,
          ref: a,
          style: SY
        }, null)]), [[Hn, M]]) : null]
      });
    };
  }
}), wY = Z({
  compatConfig: {
    MODE: 3
  },
  name: "DialogMask",
  props: {
    prefixCls: String,
    visible: Boolean,
    motionName: String,
    maskProps: Object
  },
  setup(e, t) {
    return () => {
      const {
        prefixCls: n,
        visible: o,
        maskProps: r,
        motionName: l
      } = e, a = Ho(l);
      return f(yn, a, {
        default: () => [Tn(f("div", D({
          class: `${n}-mask`
        }, r), null), [[Hn, o]])]
      });
    };
  }
}), C$ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "VcDialog",
  inheritAttrs: !1,
  props: Qe(m(m({}, $p()), {
    getOpenCount: Function,
    scrollLocker: Object
  }), {
    mask: !0,
    visible: !1,
    keyboard: !0,
    closable: !0,
    maskClosable: !0,
    destroyOnClose: !1,
    prefixCls: "rc-dialog",
    getOpenCount: () => null,
    focusTriggerAfterClose: !0
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = Q(), l = Q(), a = Q(), i = Q(e.visible), s = Q(`vcDialogTitle${bY()}`), c = (y) => {
      var S, C;
      if (y)
        sl(l.value, document.activeElement) || (r.value = document.activeElement, (S = a.value) === null || S === void 0 || S.focus());
      else {
        const w = i.value;
        if (i.value = !1, e.mask && r.value && e.focusTriggerAfterClose) {
          try {
            r.value.focus({
              preventScroll: !0
            });
          } catch {
          }
          r.value = null;
        }
        w && ((C = e.afterClose) === null || C === void 0 || C.call(e));
      }
    }, u = (y) => {
      var S;
      (S = e.onClose) === null || S === void 0 || S.call(e, y);
    }, d = Q(!1), p = Q(), v = () => {
      clearTimeout(p.value), d.value = !0;
    }, h = () => {
      p.value = setTimeout(() => {
        d.value = !1;
      });
    }, g = (y) => {
      if (!e.maskClosable)
        return null;
      d.value ? d.value = !1 : l.value === y.target && u(y);
    }, b = (y) => {
      if (e.keyboard && y.keyCode === ce.ESC) {
        y.stopPropagation(), u(y);
        return;
      }
      e.visible && y.keyCode === ce.TAB && a.value.changeActive(!y.shiftKey);
    };
    return ie(() => e.visible, () => {
      e.visible && (i.value = !0);
    }, {
      flush: "post"
    }), et(() => {
      var y;
      clearTimeout(p.value), (y = e.scrollLocker) === null || y === void 0 || y.unLock();
    }), Le(() => {
      var y, S;
      (y = e.scrollLocker) === null || y === void 0 || y.unLock(), i.value && ((S = e.scrollLocker) === null || S === void 0 || S.lock());
    }), () => {
      const {
        prefixCls: y,
        mask: S,
        visible: C,
        maskTransitionName: w,
        maskAnimation: $,
        zIndex: O,
        wrapClassName: x,
        rootClassName: I,
        wrapStyle: E,
        closable: _,
        maskProps: M,
        maskStyle: R,
        transitionName: A,
        animation: z,
        wrapProps: T,
        title: N = o.title
      } = e, {
        style: k,
        class: B
      } = n;
      return f("div", D({
        class: [`${y}-root`, I]
      }, wl(e, {
        data: !0
      })), [f(wY, {
        prefixCls: y,
        visible: S && C,
        motionName: b$(y, w, $),
        style: m({
          zIndex: O
        }, R),
        maskProps: M
      }, null), f("div", D({
        tabIndex: -1,
        onKeydown: b,
        class: ee(`${y}-wrap`, x),
        ref: l,
        onClick: g,
        role: "dialog",
        "aria-labelledby": N ? s.value : null,
        style: m(m({
          zIndex: O
        }, E), {
          display: i.value ? null : "none"
        })
      }, T), [f($Y, D(D({}, ot(e, ["scrollLocker"])), {}, {
        style: k,
        class: B,
        onMousedown: v,
        onMouseup: h,
        ref: a,
        closable: _,
        ariaId: s.value,
        prefixCls: y,
        visible: C,
        onClose: u,
        onVisibleChanged: c,
        motionName: b$(y, A, z)
      }), o)])]);
    };
  }
}), xY = $p(), xI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "DialogWrap",
  inheritAttrs: !1,
  props: Qe(xY, {
    visible: !1
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = Y(e.visible);
    return Rh({}, {
      inTriggerContext: !1
    }), ie(() => e.visible, () => {
      e.visible && (r.value = !0);
    }, {
      flush: "post"
    }), () => {
      const {
        visible: l,
        getContainer: a,
        forceRender: i,
        destroyOnClose: s = !1,
        afterClose: c
      } = e;
      let u = m(m(m({}, e), n), {
        ref: "_component",
        key: "dialog"
      });
      return a === !1 ? f(C$, D(D({}, u), {}, {
        getOpenCount: () => 2
      }), o) : !i && s && !r.value ? null : f(lc, {
        autoLock: !0,
        visible: l,
        forceRender: i,
        getContainer: a
      }, {
        default: (d) => (u = m(m(m({}, u), d), {
          afterClose: () => {
            c == null || c(), r.value = !1;
          }
        }), f(C$, u, o))
      });
    };
  }
});
function OY(e) {
  const t = Y(null), n = xt(m({}, e)), o = Y([]), r = (l) => {
    t.value === null && (o.value = [], t.value = Ze(() => {
      let a;
      o.value.forEach((i) => {
        a = m(m({}, a), i);
      }), m(n, a), t.value = null;
    })), o.value.push(l);
  };
  return Ke(() => {
    t.value && Ze.cancel(t.value);
  }), [n, r];
}
function $$(e, t, n, o) {
  const r = t + n, l = (n - o) / 2;
  if (n > o) {
    if (t > 0)
      return {
        [e]: l
      };
    if (t < 0 && r < o)
      return {
        [e]: -l
      };
  } else if (t < 0 || r > o)
    return {
      [e]: t < 0 ? l : -l
    };
  return {};
}
function PY(e, t, n, o) {
  const {
    width: r,
    height: l
  } = rD();
  let a = null;
  return e <= r && t <= l ? a = {
    x: 0,
    y: 0
  } : (e > r || t > l) && (a = m(m({}, $$("x", n, e, r)), $$("y", o, t, l))), a;
}
var IY = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const w$ = Symbol("previewGroupContext"), Sb = {
  provide: (e) => {
    Je(w$, e);
  },
  inject: () => tt(w$, {
    isPreviewGroup: Q(!1),
    previewUrls: P(() => /* @__PURE__ */ new Map()),
    setPreviewUrls: () => {
    },
    current: Y(null),
    setCurrent: () => {
    },
    setShowPreview: () => {
    },
    setMousePosition: () => {
    },
    registerImage: null,
    rootClassName: ""
  })
}, EY = () => ({
  previewPrefixCls: String,
  preview: {
    type: [Boolean, Object],
    default: !0
  },
  icons: {
    type: Object,
    default: () => ({})
  }
}), OI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "PreviewGroup",
  inheritAttrs: !1,
  props: EY(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = P(() => {
      const $ = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0,
        current: 0
      };
      return typeof e.preview == "object" ? EI(e.preview, $) : $;
    }), r = xt(/* @__PURE__ */ new Map()), l = Y(), a = P(() => o.value.visible), i = P(() => o.value.getContainer), s = ($, O) => {
      var x, I;
      (I = (x = o.value).onVisibleChange) === null || I === void 0 || I.call(x, $, O);
    }, [c, u] = Rt(!!a.value, {
      value: a,
      onChange: s
    }), d = Y(null), p = P(() => a.value !== void 0), v = P(() => Array.from(r.keys())), h = P(() => v.value[o.value.current]), g = P(() => new Map(Array.from(r).filter(($) => {
      let [, {
        canPreview: O
      }] = $;
      return !!O;
    }).map(($) => {
      let [O, {
        url: x
      }] = $;
      return [O, x];
    }))), b = function($, O) {
      let x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      r.set($, {
        url: O,
        canPreview: x
      });
    }, y = ($) => {
      l.value = $;
    }, S = ($) => {
      d.value = $;
    }, C = function($, O) {
      let x = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !0;
      const I = () => {
        r.delete($);
      };
      return r.set($, {
        url: O,
        canPreview: x
      }), I;
    }, w = ($) => {
      $ == null || $.stopPropagation(), u(!1), S(null);
    };
    return ie(h, ($) => {
      y($);
    }, {
      immediate: !0,
      flush: "post"
    }), Le(() => {
      c.value && p.value && y(h.value);
    }, {
      flush: "post"
    }), Sb.provide({
      isPreviewGroup: Q(!0),
      previewUrls: g,
      setPreviewUrls: b,
      current: l,
      setCurrent: y,
      setShowPreview: u,
      setMousePosition: S,
      registerImage: C
    }), () => {
      const $ = IY(o.value, []);
      return f(Fe, null, [n.default && n.default(), f(PI, D(D({}, $), {}, {
        "ria-hidden": !c.value,
        visible: c.value,
        prefixCls: e.previewPrefixCls,
        onClose: w,
        mousePosition: d.value,
        src: g.value.get(l.value),
        icons: e.icons,
        getContainer: i.value
      }), null)]);
    };
  }
}), Nl = {
  x: 0,
  y: 0
}, TY = m(m({}, $p()), {
  src: String,
  alt: String,
  rootClassName: String,
  icons: {
    type: Object,
    default: () => ({})
  }
}), PI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Preview",
  inheritAttrs: !1,
  props: TY,
  emits: ["close", "afterClose"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o
    } = t;
    const {
      rotateLeft: r,
      rotateRight: l,
      zoomIn: a,
      zoomOut: i,
      close: s,
      left: c,
      right: u,
      flipX: d,
      flipY: p
    } = xt(e.icons), v = Q(1), h = Q(0), g = xt({
      x: 1,
      y: 1
    }), [b, y] = OY(Nl), S = () => n("close"), C = Q(), w = xt({
      originX: 0,
      originY: 0,
      deltaX: 0,
      deltaY: 0
    }), $ = Q(!1), O = Sb.inject(), {
      previewUrls: x,
      current: I,
      isPreviewGroup: E,
      setCurrent: _
    } = O, M = P(() => x.value.size), R = P(() => Array.from(x.value.keys())), A = P(() => R.value.indexOf(I.value)), z = P(() => E.value ? x.value.get(I.value) : e.src), T = P(() => E.value && M.value > 1), N = Q({
      wheelDirection: 0
    }), k = () => {
      v.value = 1, h.value = 0, g.x = 1, g.y = 1, y(Nl), n("afterClose");
    }, B = (be) => {
      be ? v.value += 0.5 : v.value++, y(Nl);
    }, F = (be) => {
      v.value > 1 && (be ? v.value -= 0.5 : v.value--), y(Nl);
    }, L = () => {
      h.value += 90;
    }, j = () => {
      h.value -= 90;
    }, H = () => {
      g.x = -g.x;
    }, K = () => {
      g.y = -g.y;
    }, X = (be) => {
      be.preventDefault(), be.stopPropagation(), A.value > 0 && _(R.value[A.value - 1]);
    }, W = (be) => {
      be.preventDefault(), be.stopPropagation(), A.value < M.value - 1 && _(R.value[A.value + 1]);
    }, q = ee({
      [`${e.prefixCls}-moving`]: $.value
    }), J = `${e.prefixCls}-operations-operation`, ne = `${e.prefixCls}-operations-icon`, te = [{
      icon: s,
      onClick: S,
      type: "close"
    }, {
      icon: a,
      onClick: () => B(),
      type: "zoomIn"
    }, {
      icon: i,
      onClick: () => F(),
      type: "zoomOut",
      disabled: P(() => v.value === 1)
    }, {
      icon: l,
      onClick: L,
      type: "rotateRight"
    }, {
      icon: r,
      onClick: j,
      type: "rotateLeft"
    }, {
      icon: d,
      onClick: H,
      type: "flipX"
    }, {
      icon: p,
      onClick: K,
      type: "flipY"
    }], G = () => {
      if (e.visible && $.value) {
        const be = C.value.offsetWidth * v.value, ue = C.value.offsetHeight * v.value, {
          left: de,
          top: Se
        } = hd(C.value), xe = h.value % 180 !== 0;
        $.value = !1;
        const he = PY(xe ? ue : be, xe ? be : ue, de, Se);
        he && y(m({}, he));
      }
    }, U = (be) => {
      be.button === 0 && (be.preventDefault(), be.stopPropagation(), w.deltaX = be.pageX - b.x, w.deltaY = be.pageY - b.y, w.originX = b.x, w.originY = b.y, $.value = !0);
    }, re = (be) => {
      e.visible && $.value && y({
        x: be.pageX - w.deltaX,
        y: be.pageY - w.deltaY
      });
    }, se = (be) => {
      if (!e.visible)
        return;
      be.preventDefault();
      const ue = be.deltaY;
      N.value = {
        wheelDirection: ue
      };
    }, me = (be) => {
      !e.visible || !T.value || (be.preventDefault(), be.keyCode === ce.LEFT ? A.value > 0 && _(R.value[A.value - 1]) : be.keyCode === ce.RIGHT && A.value < M.value - 1 && _(R.value[A.value + 1]));
    }, Ce = () => {
      e.visible && (v.value !== 1 && (v.value = 1), (b.x !== Nl.x || b.y !== Nl.y) && y(Nl));
    };
    let fe = () => {
    };
    return Ke(() => {
      ie([() => e.visible, $], () => {
        fe();
        let be, ue;
        const de = Bt(window, "mouseup", G, !1), Se = Bt(window, "mousemove", re, !1), xe = Bt(window, "wheel", se, {
          passive: !1
        }), he = Bt(window, "keydown", me, !1);
        try {
          window.top !== window.self && (be = Bt(window.top, "mouseup", G, !1), ue = Bt(window.top, "mousemove", re, !1));
        } catch (we) {
          ct(!1, `[vc-image] ${we}`);
        }
        fe = () => {
          de.remove(), Se.remove(), xe.remove(), he.remove(), be && be.remove(), ue && ue.remove();
        };
      }, {
        flush: "post",
        immediate: !0
      }), ie([N], () => {
        const {
          wheelDirection: be
        } = N.value;
        be > 0 ? F(!0) : be < 0 && B(!0);
      });
    }), uo(() => {
      fe();
    }), () => {
      const {
        visible: be,
        prefixCls: ue,
        rootClassName: de
      } = e;
      return f(xI, D(D({}, o), {}, {
        transitionName: e.transitionName,
        maskTransitionName: e.maskTransitionName,
        closable: !1,
        keyboard: !0,
        prefixCls: ue,
        onClose: S,
        afterClose: k,
        visible: be,
        wrapClassName: q,
        rootClassName: de,
        getContainer: e.getContainer
      }), {
        default: () => [f("div", {
          class: [`${e.prefixCls}-operations-wrapper`, de]
        }, [f("ul", {
          class: `${e.prefixCls}-operations`
        }, [te.map((Se) => {
          let {
            icon: xe,
            onClick: he,
            type: we,
            disabled: Me
          } = Se;
          return f("li", {
            class: ee(J, {
              [`${e.prefixCls}-operations-operation-disabled`]: Me && (Me == null ? void 0 : Me.value)
            }),
            onClick: he,
            key: we
          }, [tr(xe, {
            class: ne
          })]);
        })])]), f("div", {
          class: `${e.prefixCls}-img-wrapper`,
          style: {
            transform: `translate3d(${b.x}px, ${b.y}px, 0)`
          }
        }, [f("img", {
          onMousedown: U,
          onDblclick: Ce,
          ref: C,
          class: `${e.prefixCls}-img`,
          src: z.value,
          alt: e.alt,
          style: {
            transform: `scale3d(${g.x * v.value}, ${g.y * v.value}, 1) rotate(${h.value}deg)`
          }
        }, null)]), T.value && f("div", {
          class: ee(`${e.prefixCls}-switch-left`, {
            [`${e.prefixCls}-switch-left-disabled`]: A.value <= 0
          }),
          onClick: X
        }, [c]), T.value && f("div", {
          class: ee(`${e.prefixCls}-switch-right`, {
            [`${e.prefixCls}-switch-right-disabled`]: A.value >= M.value - 1
          }),
          onClick: W
        }, [u])]
      });
    };
  }
});
var MY = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const II = () => ({
  src: String,
  wrapperClassName: String,
  wrapperStyle: {
    type: Object,
    default: void 0
  },
  rootClassName: String,
  prefixCls: String,
  previewPrefixCls: String,
  width: [Number, String],
  height: [Number, String],
  previewMask: {
    type: [Boolean, Function],
    default: void 0
  },
  placeholder: V.any,
  fallback: String,
  preview: {
    type: [Boolean, Object],
    default: !0
  },
  onClick: {
    type: Function
  },
  onError: {
    type: Function
  }
}), EI = (e, t) => {
  const n = m({}, e);
  return Object.keys(t).forEach((o) => {
    e[o] === void 0 && (n[o] = t[o]);
  }), n;
};
let _Y = 0;
const TI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "VcImage",
  inheritAttrs: !1,
  props: II(),
  emits: ["click", "error"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r
    } = t;
    const l = P(() => e.prefixCls), a = P(() => `${l.value}-preview`), i = P(() => {
      const B = {
        visible: void 0,
        onVisibleChange: () => {
        },
        getContainer: void 0
      };
      return typeof e.preview == "object" ? EI(e.preview, B) : B;
    }), s = P(() => {
      var B;
      return (B = i.value.src) !== null && B !== void 0 ? B : e.src;
    }), c = P(() => e.placeholder && e.placeholder !== !0 || o.placeholder), u = P(() => i.value.visible), d = P(() => i.value.getContainer), p = P(() => u.value !== void 0), v = (B, F) => {
      var L, j;
      (j = (L = i.value).onVisibleChange) === null || j === void 0 || j.call(L, B, F);
    }, [h, g] = Rt(!!u.value, {
      value: u,
      onChange: v
    }), b = Y(c.value ? "loading" : "normal");
    ie(() => e.src, () => {
      b.value = c.value ? "loading" : "normal";
    });
    const y = Y(null), S = P(() => b.value === "error"), C = Sb.inject(), {
      isPreviewGroup: w,
      setCurrent: $,
      setShowPreview: O,
      setMousePosition: x,
      registerImage: I
    } = C, E = Y(_Y++), _ = P(() => e.preview && !S.value), M = () => {
      b.value = "normal";
    }, R = (B) => {
      b.value = "error", r("error", B);
    }, A = (B) => {
      if (!p.value) {
        const {
          left: F,
          top: L
        } = hd(B.target);
        w.value ? ($(E.value), x({
          x: F,
          y: L
        })) : y.value = {
          x: F,
          y: L
        };
      }
      w.value ? O(!0) : g(!0), r("click", B);
    }, z = () => {
      g(!1), p.value || (y.value = null);
    }, T = Y(null);
    ie(() => T, () => {
      b.value === "loading" && T.value.complete && (T.value.naturalWidth || T.value.naturalHeight) && M();
    });
    let N = () => {
    };
    Ke(() => {
      ie([s, _], () => {
        if (N(), !w.value)
          return () => {
          };
        N = I(E.value, s.value, _.value), _.value || N();
      }, {
        flush: "post",
        immediate: !0
      });
    }), uo(() => {
      N();
    });
    const k = (B) => TB(B) ? B + "px" : B;
    return () => {
      const {
        prefixCls: B,
        wrapperClassName: F,
        fallback: L,
        src: j,
        placeholder: H,
        wrapperStyle: K,
        rootClassName: X,
        width: W,
        height: q,
        crossorigin: J,
        decoding: ne,
        alt: te,
        sizes: G,
        srcset: U,
        usemap: re,
        class: se,
        style: me
      } = m(m({}, e), n), Ce = i.value, {
        icons: fe,
        maskClassName: be
      } = Ce, ue = MY(Ce, ["icons", "maskClassName"]), de = ee(B, F, X, {
        [`${B}-error`]: S.value
      }), Se = S.value && L ? L : s.value, xe = {
        crossorigin: J,
        decoding: ne,
        alt: te,
        sizes: G,
        srcset: U,
        usemap: re,
        width: W,
        height: q,
        class: ee(`${B}-img`, {
          [`${B}-img-placeholder`]: H === !0
        }, se),
        style: m({
          height: k(q)
        }, me)
      };
      return f(Fe, null, [f("div", {
        class: de,
        onClick: _.value ? A : (he) => {
          r("click", he);
        },
        style: m({
          width: k(W),
          height: k(q)
        }, K)
      }, [f("img", D(D(D({}, xe), S.value && L ? {
        src: L
      } : {
        onLoad: M,
        onError: R,
        src: j
      }), {}, {
        ref: T
      }), null), b.value === "loading" && f("div", {
        "aria-hidden": "true",
        class: `${B}-placeholder`
      }, [H || o.placeholder && o.placeholder()]), o.previewMask && _.value && f("div", {
        class: [`${B}-mask`, be]
      }, [o.previewMask()])]), !w.value && _.value && f(PI, D(D({}, ue), {}, {
        "aria-hidden": !h.value,
        visible: h.value,
        prefixCls: a.value,
        onClose: z,
        mousePosition: y.value,
        src: Se,
        alt: te,
        getContainer: d.value,
        icons: fe,
        rootClassName: X
      }), null)]);
    };
  }
});
TI.PreviewGroup = OI;
const AY = TI;
var DY = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M672 418H144c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H188V494h440v326z" } }, { tag: "path", attrs: { d: "M819.3 328.5c-78.8-100.7-196-153.6-314.6-154.2l-.2-64c0-6.5-7.6-10.1-12.6-6.1l-128 101c-4 3.1-3.9 9.1 0 12.3L492 318.6c5.1 4 12.7.4 12.6-6.1v-63.9c12.9.1 25.9.9 38.8 2.5 42.1 5.2 82.1 18.2 119 38.7 38.1 21.2 71.2 49.7 98.4 84.3 27.1 34.7 46.7 73.7 58.1 115.8a325.95 325.95 0 016.5 140.9h74.9c14.8-103.6-11.3-213-81-302.3z" } }] }, name: "rotate-left", theme: "outlined" };
function x$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      NY(e, r, n[r]);
    });
  }
  return e;
}
function NY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Cb = function(t, n) {
  var o = x$({}, t, n.attrs);
  return f(Ge, x$({}, o, {
    icon: DY
  }), null);
};
Cb.displayName = "RotateLeftOutlined";
Cb.inheritAttrs = !1;
var RY = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M480.5 251.2c13-1.6 25.9-2.4 38.8-2.5v63.9c0 6.5 7.5 10.1 12.6 6.1L660 217.6c4-3.2 4-9.2 0-12.3l-128-101c-5.1-4-12.6-.4-12.6 6.1l-.2 64c-118.6.5-235.8 53.4-314.6 154.2A399.75 399.75 0 00123.5 631h74.9c-.9-5.3-1.7-10.7-2.4-16.1-5.1-42.1-2.1-84.1 8.9-124.8 11.4-42.2 31-81.1 58.1-115.8 27.2-34.7 60.3-63.2 98.4-84.3 37-20.6 76.9-33.6 119.1-38.8z" } }, { tag: "path", attrs: { d: "M880 418H352c-17.7 0-32 14.3-32 32v414c0 17.7 14.3 32 32 32h528c17.7 0 32-14.3 32-32V450c0-17.7-14.3-32-32-32zm-44 402H396V494h440v326z" } }] }, name: "rotate-right", theme: "outlined" };
function O$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      kY(e, r, n[r]);
    });
  }
  return e;
}
function kY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var $b = function(t, n) {
  var o = O$({}, t, n.attrs);
  return f(Ge, O$({}, o, {
    icon: RY
  }), null);
};
$b.displayName = "RotateRightOutlined";
$b.inheritAttrs = !1;
var BY = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H519V309c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v134H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h118v134c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V519h118c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-in", theme: "outlined" };
function P$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      FY(e, r, n[r]);
    });
  }
  return e;
}
function FY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var wb = function(t, n) {
  var o = P$({}, t, n.attrs);
  return f(Ge, P$({}, o, {
    icon: BY
  }), null);
};
wb.displayName = "ZoomInOutlined";
wb.inheritAttrs = !1;
var LY = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M637 443H325c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h312c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8zm284 424L775 721c122.1-148.9 113.6-369.5-26-509-148-148.1-388.4-148.1-537 0-148.1 148.6-148.1 389 0 537 139.5 139.6 360.1 148.1 509 26l146 146c3.2 2.8 8.3 2.8 11 0l43-43c2.8-2.7 2.8-7.8 0-11zM696 696c-118.8 118.7-311.2 118.7-430 0-118.7-118.8-118.7-311.2 0-430 118.8-118.7 311.2-118.7 430 0 118.7 118.8 118.7 311.2 0 430z" } }] }, name: "zoom-out", theme: "outlined" };
function I$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      zY(e, r, n[r]);
    });
  }
  return e;
}
function zY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var xb = function(t, n) {
  var o = I$({}, t, n.attrs);
  return f(Ge, I$({}, o, {
    icon: LY
  }), null);
};
xb.displayName = "ZoomOutOutlined";
xb.inheritAttrs = !1;
var HY = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M847.9 592H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h605.2L612.9 851c-4.1 5.2-.4 13 6.3 13h72.5c4.9 0 9.5-2.2 12.6-6.1l168.8-214.1c16.5-21 1.6-51.8-25.2-51.8zM872 356H266.8l144.3-183c4.1-5.2.4-13-6.3-13h-72.5c-4.9 0-9.5 2.2-12.6 6.1L150.9 380.2c-16.5 21-1.6 51.8 25.1 51.8h696c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, name: "swap", theme: "outlined" };
function E$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      jY(e, r, n[r]);
    });
  }
  return e;
}
function jY(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Zd = function(t, n) {
  var o = E$({}, t, n.attrs);
  return f(Ge, E$({}, o, {
    icon: HY
  }), null);
};
Zd.displayName = "SwapOutlined";
Zd.inheritAttrs = !1;
function T$(e) {
  return {
    position: e,
    top: 0,
    insetInlineEnd: 0,
    bottom: 0,
    insetInlineStart: 0
  };
}
const MI = (e) => {
  const {
    componentCls: t
  } = e;
  return [{
    [`${t}-root`]: {
      [`${t}${e.antCls}-zoom-enter, ${t}${e.antCls}-zoom-appear`]: {
        // reset scale avoid mousePosition bug
        transform: "none",
        opacity: 0,
        animationDuration: e.motionDurationSlow,
        // https://github.com/ant-design/ant-design/issues/11777
        userSelect: "none"
      },
      [`${t}${e.antCls}-zoom-leave ${t}-content`]: {
        pointerEvents: "none"
      },
      [`${t}-mask`]: m(m({}, T$("fixed")), {
        zIndex: e.zIndexPopupBase,
        height: "100%",
        backgroundColor: e.colorBgMask,
        [`${t}-hidden`]: {
          display: "none"
        }
      }),
      [`${t}-wrap`]: m(m({}, T$("fixed")), {
        overflow: "auto",
        outline: 0,
        WebkitOverflowScrolling: "touch"
      })
    }
  }, {
    [`${t}-root`]: l0(e)
  }];
}, VY = (e) => {
  const {
    componentCls: t
  } = e;
  return [
    // ======================== Root =========================
    {
      [`${t}-root`]: {
        [`${t}-wrap`]: {
          zIndex: e.zIndexPopupBase,
          position: "fixed",
          inset: 0,
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        },
        [`${t}-wrap-rtl`]: {
          direction: "rtl"
        },
        [`${t}-centered`]: {
          textAlign: "center",
          "&::before": {
            display: "inline-block",
            width: 0,
            height: "100%",
            verticalAlign: "middle",
            content: '""'
          },
          [t]: {
            top: 0,
            display: "inline-block",
            paddingBottom: 0,
            textAlign: "start",
            verticalAlign: "middle"
          }
        },
        [`@media (max-width: ${e.screenSMMax})`]: {
          [t]: {
            maxWidth: "calc(100vw - 16px)",
            margin: `${e.marginXS} auto`
          },
          [`${t}-centered`]: {
            [t]: {
              flex: 1
            }
          }
        }
      }
    },
    // ======================== Modal ========================
    {
      [t]: m(m({}, qe(e)), {
        pointerEvents: "none",
        position: "relative",
        top: 100,
        width: "auto",
        maxWidth: `calc(100vw - ${e.margin * 2}px)`,
        margin: "0 auto",
        paddingBottom: e.paddingLG,
        [`${t}-title`]: {
          margin: 0,
          color: e.modalHeadingColor,
          fontWeight: e.fontWeightStrong,
          fontSize: e.modalHeaderTitleFontSize,
          lineHeight: e.modalHeaderTitleLineHeight,
          wordWrap: "break-word"
        },
        [`${t}-content`]: {
          position: "relative",
          backgroundColor: e.modalContentBg,
          backgroundClip: "padding-box",
          border: 0,
          borderRadius: e.borderRadiusLG,
          boxShadow: e.boxShadowSecondary,
          pointerEvents: "auto",
          padding: `${e.paddingMD}px ${e.paddingContentHorizontalLG}px`
        },
        [`${t}-close`]: m({
          position: "absolute",
          top: (e.modalHeaderCloseSize - e.modalCloseBtnSize) / 2,
          insetInlineEnd: (e.modalHeaderCloseSize - e.modalCloseBtnSize) / 2,
          zIndex: e.zIndexPopupBase + 10,
          padding: 0,
          color: e.modalCloseColor,
          fontWeight: e.fontWeightStrong,
          lineHeight: 1,
          textDecoration: "none",
          background: "transparent",
          borderRadius: e.borderRadiusSM,
          width: e.modalConfirmIconSize,
          height: e.modalConfirmIconSize,
          border: 0,
          outline: 0,
          cursor: "pointer",
          transition: `color ${e.motionDurationMid}, background-color ${e.motionDurationMid}`,
          "&-x": {
            display: "block",
            fontSize: e.fontSizeLG,
            fontStyle: "normal",
            lineHeight: `${e.modalCloseBtnSize}px`,
            textAlign: "center",
            textTransform: "none",
            textRendering: "auto"
          },
          "&:hover": {
            color: e.modalIconHoverColor,
            backgroundColor: e.wireframe ? "transparent" : e.colorFillContent,
            textDecoration: "none"
          },
          "&:active": {
            backgroundColor: e.wireframe ? "transparent" : e.colorFillContentHover
          }
        }, Xr(e)),
        [`${t}-header`]: {
          color: e.colorText,
          background: e.modalHeaderBg,
          borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`,
          marginBottom: e.marginXS
        },
        [`${t}-body`]: {
          fontSize: e.fontSize,
          lineHeight: e.lineHeight,
          wordWrap: "break-word"
        },
        [`${t}-footer`]: {
          textAlign: "end",
          background: e.modalFooterBg,
          marginTop: e.marginSM,
          [`${e.antCls}-btn + ${e.antCls}-btn:not(${e.antCls}-dropdown-trigger)`]: {
            marginBottom: 0,
            marginInlineStart: e.marginXS
          }
        },
        [`${t}-open`]: {
          overflow: "hidden"
        }
      })
    },
    // ======================== Pure =========================
    {
      [`${t}-pure-panel`]: {
        top: "auto",
        padding: 0,
        display: "flex",
        flexDirection: "column",
        [`${t}-content,
          ${t}-body,
          ${t}-confirm-body-wrapper`]: {
          display: "flex",
          flexDirection: "column",
          flex: "auto"
        },
        [`${t}-confirm-body`]: {
          marginBottom: "auto"
        }
      }
    }
  ];
}, WY = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-confirm`;
  return {
    [n]: {
      "&-rtl": {
        direction: "rtl"
      },
      [`${e.antCls}-modal-header`]: {
        display: "none"
      },
      [`${n}-body-wrapper`]: m({}, nr()),
      [`${n}-body`]: {
        display: "flex",
        flexWrap: "wrap",
        alignItems: "center",
        [`${n}-title`]: {
          flex: "0 0 100%",
          display: "block",
          // create BFC to avoid
          // https://user-images.githubusercontent.com/507615/37702510-ba844e06-2d2d-11e8-9b67-8e19be57f445.png
          overflow: "hidden",
          color: e.colorTextHeading,
          fontWeight: e.fontWeightStrong,
          fontSize: e.modalHeaderTitleFontSize,
          lineHeight: e.modalHeaderTitleLineHeight,
          [`+ ${n}-content`]: {
            marginBlockStart: e.marginXS,
            flexBasis: "100%",
            maxWidth: `calc(100% - ${e.modalConfirmIconSize + e.marginSM}px)`
          }
        },
        [`${n}-content`]: {
          color: e.colorText,
          fontSize: e.fontSize
        },
        [`> ${e.iconCls}`]: {
          flex: "none",
          marginInlineEnd: e.marginSM,
          fontSize: e.modalConfirmIconSize,
          [`+ ${n}-title`]: {
            flex: 1
          },
          // `content` after `icon` should set marginLeft
          [`+ ${n}-title + ${n}-content`]: {
            marginInlineStart: e.modalConfirmIconSize + e.marginSM
          }
        }
      },
      [`${n}-btns`]: {
        textAlign: "end",
        marginTop: e.marginSM,
        [`${e.antCls}-btn + ${e.antCls}-btn`]: {
          marginBottom: 0,
          marginInlineStart: e.marginXS
        }
      }
    },
    [`${n}-error ${n}-body > ${e.iconCls}`]: {
      color: e.colorError
    },
    [`${n}-warning ${n}-body > ${e.iconCls},
        ${n}-confirm ${n}-body > ${e.iconCls}`]: {
      color: e.colorWarning
    },
    [`${n}-info ${n}-body > ${e.iconCls}`]: {
      color: e.colorInfo
    },
    [`${n}-success ${n}-body > ${e.iconCls}`]: {
      color: e.colorSuccess
    },
    // https://github.com/ant-design/ant-design/issues/37329
    [`${t}-zoom-leave ${t}-btns`]: {
      pointerEvents: "none"
    }
  };
}, KY = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-root`]: {
      [`${t}-wrap-rtl`]: {
        direction: "rtl",
        [`${t}-confirm-body`]: {
          direction: "rtl"
        }
      }
    }
  };
}, GY = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e, o = `${t}-confirm`;
  return {
    [t]: {
      [`${t}-content`]: {
        padding: 0
      },
      [`${t}-header`]: {
        padding: e.modalHeaderPadding,
        borderBottom: `${e.modalHeaderBorderWidth}px ${e.modalHeaderBorderStyle} ${e.modalHeaderBorderColorSplit}`,
        marginBottom: 0
      },
      [`${t}-body`]: {
        padding: e.modalBodyPadding
      },
      [`${t}-footer`]: {
        padding: `${e.modalFooterPaddingVertical}px ${e.modalFooterPaddingHorizontal}px`,
        borderTop: `${e.modalFooterBorderWidth}px ${e.modalFooterBorderStyle} ${e.modalFooterBorderColorSplit}`,
        borderRadius: `0 0 ${e.borderRadiusLG}px ${e.borderRadiusLG}px`,
        marginTop: 0
      }
    },
    [o]: {
      [`${n}-modal-body`]: {
        padding: `${e.padding * 2}px ${e.padding * 2}px ${e.paddingLG}px`
      },
      [`${o}-body`]: {
        [`> ${e.iconCls}`]: {
          marginInlineEnd: e.margin,
          // `content` after `icon` should set marginLeft
          [`+ ${o}-title + ${o}-content`]: {
            marginInlineStart: e.modalConfirmIconSize + e.margin
          }
        }
      },
      [`${o}-btns`]: {
        marginTop: e.marginLG
      }
    }
  };
}, XY = Xe("Modal", (e) => {
  const t = e.padding, n = e.fontSizeHeading5, o = e.lineHeightHeading5, r = He(e, {
    modalBodyPadding: e.paddingLG,
    modalHeaderBg: e.colorBgElevated,
    modalHeaderPadding: `${t}px ${e.paddingLG}px`,
    modalHeaderBorderWidth: e.lineWidth,
    modalHeaderBorderStyle: e.lineType,
    modalHeaderTitleLineHeight: o,
    modalHeaderTitleFontSize: n,
    modalHeaderBorderColorSplit: e.colorSplit,
    modalHeaderCloseSize: o * n + t * 2,
    modalContentBg: e.colorBgElevated,
    modalHeadingColor: e.colorTextHeading,
    modalCloseColor: e.colorTextDescription,
    modalFooterBg: "transparent",
    modalFooterBorderColorSplit: e.colorSplit,
    modalFooterBorderStyle: e.lineType,
    modalFooterPaddingVertical: e.paddingXS,
    modalFooterPaddingHorizontal: e.padding,
    modalFooterBorderWidth: e.lineWidth,
    modalConfirmTitleFontSize: e.fontSizeLG,
    modalIconHoverColor: e.colorIconHover,
    modalConfirmIconSize: e.fontSize * e.lineHeight,
    modalCloseBtnSize: e.controlHeightLG * 0.55
  });
  return [VY(r), WY(r), KY(r), MI(r), e.wireframe && GY(r), Ni(r, "zoom")];
}), xm = (e) => ({
  position: e || "absolute",
  inset: 0
}), UY = (e) => {
  const {
    iconCls: t,
    motionDurationSlow: n,
    paddingXXS: o,
    marginXXS: r,
    prefixCls: l
  } = e;
  return {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    color: "#fff",
    background: new Ct("#000").setAlpha(0.5).toRgbString(),
    cursor: "pointer",
    opacity: 0,
    transition: `opacity ${n}`,
    [`.${l}-mask-info`]: m(m({}, tn), {
      padding: `0 ${o}px`,
      [t]: {
        marginInlineEnd: r,
        svg: {
          verticalAlign: "baseline"
        }
      }
    })
  };
}, YY = (e) => {
  const {
    previewCls: t,
    modalMaskBg: n,
    paddingSM: o,
    previewOperationColorDisabled: r,
    motionDurationSlow: l
  } = e, a = new Ct(n).setAlpha(0.1), i = a.clone().setAlpha(0.2);
  return {
    [`${t}-operations`]: m(m({}, qe(e)), {
      display: "flex",
      flexDirection: "row-reverse",
      alignItems: "center",
      color: e.previewOperationColor,
      listStyle: "none",
      background: a.toRgbString(),
      pointerEvents: "auto",
      "&-operation": {
        marginInlineStart: o,
        padding: o,
        cursor: "pointer",
        transition: `all ${l}`,
        userSelect: "none",
        "&:hover": {
          background: i.toRgbString()
        },
        "&-disabled": {
          color: r,
          pointerEvents: "none"
        },
        "&:last-of-type": {
          marginInlineStart: 0
        }
      },
      "&-progress": {
        position: "absolute",
        left: {
          _skip_check_: !0,
          value: "50%"
        },
        transform: "translateX(-50%)"
      },
      "&-icon": {
        fontSize: e.previewOperationSize
      }
    })
  };
}, qY = (e) => {
  const {
    modalMaskBg: t,
    iconCls: n,
    previewOperationColorDisabled: o,
    previewCls: r,
    zIndexPopup: l,
    motionDurationSlow: a
  } = e, i = new Ct(t).setAlpha(0.1), s = i.clone().setAlpha(0.2);
  return {
    [`${r}-switch-left, ${r}-switch-right`]: {
      position: "fixed",
      insetBlockStart: "50%",
      zIndex: l + 1,
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      width: e.imagePreviewSwitchSize,
      height: e.imagePreviewSwitchSize,
      marginTop: -e.imagePreviewSwitchSize / 2,
      color: e.previewOperationColor,
      background: i.toRgbString(),
      borderRadius: "50%",
      transform: "translateY(-50%)",
      cursor: "pointer",
      transition: `all ${a}`,
      pointerEvents: "auto",
      userSelect: "none",
      "&:hover": {
        background: s.toRgbString()
      },
      "&-disabled": {
        "&, &:hover": {
          color: o,
          background: "transparent",
          cursor: "not-allowed",
          [`> ${n}`]: {
            cursor: "not-allowed"
          }
        }
      },
      [`> ${n}`]: {
        fontSize: e.previewOperationSize
      }
    },
    [`${r}-switch-left`]: {
      insetInlineStart: e.marginSM
    },
    [`${r}-switch-right`]: {
      insetInlineEnd: e.marginSM
    }
  };
}, ZY = (e) => {
  const {
    motionEaseOut: t,
    previewCls: n,
    motionDurationSlow: o,
    componentCls: r
  } = e;
  return [
    {
      [`${r}-preview-root`]: {
        [n]: {
          height: "100%",
          textAlign: "center",
          pointerEvents: "none"
        },
        [`${n}-body`]: m(m({}, xm()), {
          overflow: "hidden"
        }),
        [`${n}-img`]: {
          maxWidth: "100%",
          maxHeight: "100%",
          verticalAlign: "middle",
          transform: "scale3d(1, 1, 1)",
          cursor: "grab",
          transition: `transform ${o} ${t} 0s`,
          userSelect: "none",
          pointerEvents: "auto",
          "&-wrapper": m(m({}, xm()), {
            transition: `transform ${o} ${t} 0s`,
            // https://github.com/ant-design/ant-design/issues/39913
            // TailwindCSS will reset img default style.
            // Let's set back.
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            "&::before": {
              display: "inline-block",
              width: 1,
              height: "50%",
              marginInlineEnd: -1,
              content: '""'
            }
          })
        },
        [`${n}-moving`]: {
          [`${n}-preview-img`]: {
            cursor: "grabbing",
            "&-wrapper": {
              transitionDuration: "0s"
            }
          }
        }
      }
    },
    // Override
    {
      [`${r}-preview-root`]: {
        [`${n}-wrap`]: {
          zIndex: e.zIndexPopup
        }
      }
    },
    // Preview operations & switch
    {
      [`${r}-preview-operations-wrapper`]: {
        position: "fixed",
        insetBlockStart: 0,
        insetInlineEnd: 0,
        zIndex: e.zIndexPopup + 1,
        width: "100%"
      },
      "&": [YY(e), qY(e)]
    }
  ];
}, QY = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    // ============================== image ==============================
    [t]: {
      position: "relative",
      display: "inline-block",
      [`${t}-img`]: {
        width: "100%",
        height: "auto",
        verticalAlign: "middle"
      },
      [`${t}-img-placeholder`]: {
        backgroundColor: e.colorBgContainerDisabled,
        backgroundImage: "url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNMTQuNSAyLjVoLTEzQS41LjUgMCAwIDAgMSAzdjEwYS41LjUgMCAwIDAgLjUuNWgxM2EuNS41IDAgMCAwIC41LS41VjNhLjUuNSAwIDAgMC0uNS0uNXpNNS4yODEgNC43NWExIDEgMCAwIDEgMCAyIDEgMSAwIDAgMSAwLTJ6bTguMDMgNi44M2EuMTI3LjEyNyAwIDAgMS0uMDgxLjAzSDIuNzY5YS4xMjUuMTI1IDAgMCAxLS4wOTYtLjIwN2wyLjY2MS0zLjE1NmEuMTI2LjEyNiAwIDAgMSAuMTc3LS4wMTZsLjAxNi4wMTZMNy4wOCAxMC4wOWwyLjQ3LTIuOTNhLjEyNi4xMjYgMCAwIDEgLjE3Ny0uMDE2bC4wMTUuMDE2IDMuNTg4IDQuMjQ0YS4xMjcuMTI3IDAgMCAxLS4wMi4xNzV6IiBmaWxsPSIjOEM4QzhDIiBmaWxsLXJ1bGU9Im5vbnplcm8iLz48L3N2Zz4=')",
        backgroundRepeat: "no-repeat",
        backgroundPosition: "center center",
        backgroundSize: "30%"
      },
      [`${t}-mask`]: m({}, UY(e)),
      [`${t}-mask:hover`]: {
        opacity: 1
      },
      [`${t}-placeholder`]: m({}, xm())
    }
  };
}, JY = (e) => {
  const {
    previewCls: t
  } = e;
  return {
    [`${t}-root`]: Ni(e, "zoom"),
    "&": l0(e, !0)
  };
}, _I = Xe("Image", (e) => {
  const t = `${e.componentCls}-preview`, n = He(e, {
    previewCls: t,
    modalMaskBg: new Ct("#000").setAlpha(0.45).toRgbString(),
    imagePreviewSwitchSize: e.controlHeightLG
  });
  return [QY(n), ZY(n), MI(He(n, {
    componentCls: t
  })), JY(n)];
}, (e) => ({
  zIndexPopup: e.zIndexPopupBase + 80,
  previewOperationColor: new Ct(e.colorTextLightSolid).toRgbString(),
  previewOperationColorDisabled: new Ct(e.colorTextLightSolid).setAlpha(0.25).toRgbString(),
  previewOperationSize: e.fontSizeIcon * 1.5
  // FIXME: fontSizeIconLG
})), AI = {
  rotateLeft: f(Cb, null, null),
  rotateRight: f($b, null, null),
  zoomIn: f(wb, null, null),
  zoomOut: f(xb, null, null),
  close: f(Kn, null, null),
  left: f(wr, null, null),
  right: f(Po, null, null),
  flipX: f(Zd, null, null),
  flipY: f(Zd, {
    rotate: 90
  }, null)
}, eq = () => ({
  previewPrefixCls: String,
  preview: _t()
}), DI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AImagePreviewGroup",
  inheritAttrs: !1,
  props: eq(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: r,
      rootPrefixCls: l
    } = Ie("image", e), a = P(() => `${r.value}-preview`), [i, s] = _I(r), c = P(() => {
      const {
        preview: u
      } = e;
      if (u === !1)
        return u;
      const d = typeof u == "object" ? u : {};
      return m(m({}, d), {
        rootClassName: s.value,
        transitionName: Vn(l.value, "zoom", d.transitionName),
        maskTransitionName: Vn(l.value, "fade", d.maskTransitionName)
      });
    });
    return () => i(f(OI, D(D({}, m(m({}, n), e)), {}, {
      preview: c.value,
      icons: AI,
      previewPrefixCls: a.value
    }), o));
  }
}), Gl = Z({
  name: "AImage",
  inheritAttrs: !1,
  props: II(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      rootPrefixCls: l,
      configProvider: a
    } = Ie("image", e), [i, s] = _I(r), c = P(() => {
      const {
        preview: u
      } = e;
      if (u === !1)
        return u;
      const d = typeof u == "object" ? u : {};
      return m(m({
        icons: AI
      }, d), {
        transitionName: Vn(l.value, "zoom", d.transitionName),
        maskTransitionName: Vn(l.value, "fade", d.maskTransitionName)
      });
    });
    return () => {
      var u, d;
      const p = ((d = (u = a.locale) === null || u === void 0 ? void 0 : u.value) === null || d === void 0 ? void 0 : d.Image) || Zn.Image, v = () => f("div", {
        class: `${r.value}-mask-info`
      }, [f(Sc, null, null), p == null ? void 0 : p.preview]), {
        previewMask: h = n.previewMask || v
      } = e;
      return i(f(AY, D(D({}, m(m(m({}, o), e), {
        prefixCls: r.value
      })), {}, {
        preview: c.value,
        rootClassName: ee(e.rootClassName, s.value)
      }), m(m({}, n), {
        previewMask: typeof h == "function" ? h : null
      })));
    };
  }
});
Gl.PreviewGroup = DI;
Gl.install = function(e) {
  return e.component(Gl.name, Gl), e.component(Gl.PreviewGroup.name, Gl.PreviewGroup), e;
};
var tq = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M890.5 755.3L537.9 269.2c-12.8-17.6-39-17.6-51.7 0L133.5 755.3A8 8 0 00140 768h75c5.1 0 9.9-2.5 12.9-6.6L512 369.8l284.1 391.6c3 4.1 7.8 6.6 12.9 6.6h75c6.5 0 10.3-7.4 6.5-12.7z" } }] }, name: "up", theme: "outlined" };
function M$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      nq(e, r, n[r]);
    });
  }
  return e;
}
function nq(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ob = function(t, n) {
  var o = M$({}, t, n.attrs);
  return f(Ge, M$({}, o, {
    icon: tq
  }), null);
};
Ob.displayName = "UpOutlined";
Ob.inheritAttrs = !1;
function Om() {
  return typeof BigInt == "function";
}
function xs(e) {
  let t = e.trim(), n = t.startsWith("-");
  n && (t = t.slice(1)), t = t.replace(/(\.\d*[^0])0*$/, "$1").replace(/\.0*$/, "").replace(/^0+/, ""), t.startsWith(".") && (t = `0${t}`);
  const o = t || "0", r = o.split("."), l = r[0] || "0", a = r[1] || "0";
  l === "0" && a === "0" && (n = !1);
  const i = n ? "-" : "";
  return {
    negative: n,
    negativeStr: i,
    trimStr: o,
    integerStr: l,
    decimalStr: a,
    fullStr: `${i}${o}`
  };
}
function Pb(e) {
  const t = String(e);
  return !Number.isNaN(Number(t)) && t.includes("e");
}
function ec(e) {
  const t = String(e);
  if (Pb(e)) {
    let n = Number(t.slice(t.indexOf("e-") + 2));
    const o = t.match(/\.(\d+)/);
    return o != null && o[1] && (n += o[1].length), n;
  }
  return t.includes(".") && Eb(t) ? t.length - t.indexOf(".") - 1 : 0;
}
function Ib(e) {
  let t = String(e);
  if (Pb(e)) {
    if (e > Number.MAX_SAFE_INTEGER)
      return String(Om() ? BigInt(e).toString() : Number.MAX_SAFE_INTEGER);
    if (e < Number.MIN_SAFE_INTEGER)
      return String(Om() ? BigInt(e).toString() : Number.MIN_SAFE_INTEGER);
    t = e.toFixed(ec(t));
  }
  return xs(t).fullStr;
}
function Eb(e) {
  return typeof e == "number" ? !Number.isNaN(e) : e ? (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(e) || // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(e) || // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(e)
  ) : !1;
}
function NI(e) {
  return !e && e !== 0 && !Number.isNaN(e) || !String(e).trim();
}
class Xl {
  constructor(t) {
    if (this.origin = "", NI(t)) {
      this.empty = !0;
      return;
    }
    this.origin = String(t), this.number = Number(t);
  }
  negate() {
    return new Xl(-this.toNumber());
  }
  add(t) {
    if (this.isInvalidate())
      return new Xl(t);
    const n = Number(t);
    if (Number.isNaN(n))
      return this;
    const o = this.number + n;
    if (o > Number.MAX_SAFE_INTEGER)
      return new Xl(Number.MAX_SAFE_INTEGER);
    if (o < Number.MIN_SAFE_INTEGER)
      return new Xl(Number.MIN_SAFE_INTEGER);
    const r = Math.max(ec(this.number), ec(n));
    return new Xl(o.toFixed(r));
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return Number.isNaN(this.number);
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(t) {
    return this.toNumber() === (t == null ? void 0 : t.toNumber());
  }
  lessEquals(t) {
    return this.add(t.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    return this.number;
  }
  toString() {
    return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0) ? this.isInvalidate() ? "" : Ib(this.number) : this.origin;
  }
}
class qa {
  constructor(t) {
    if (this.origin = "", NI(t)) {
      this.empty = !0;
      return;
    }
    if (this.origin = String(t), t === "-" || Number.isNaN(t)) {
      this.nan = !0;
      return;
    }
    let n = t;
    if (Pb(n) && (n = Number(n)), n = typeof n == "string" ? n : Ib(n), Eb(n)) {
      const o = xs(n);
      this.negative = o.negative;
      const r = o.trimStr.split(".");
      this.integer = BigInt(r[0]);
      const l = r[1] || "0";
      this.decimal = BigInt(l), this.decimalLen = l.length;
    } else
      this.nan = !0;
  }
  getMark() {
    return this.negative ? "-" : "";
  }
  getIntegerStr() {
    return this.integer.toString();
  }
  getDecimalStr() {
    return this.decimal.toString().padStart(this.decimalLen, "0");
  }
  /**
   * Align BigIntDecimal with same decimal length. e.g. 12.3 + 5 = 1230000
   * This is used for add function only.
   */
  alignDecimal(t) {
    const n = `${this.getMark()}${this.getIntegerStr()}${this.getDecimalStr().padEnd(t, "0")}`;
    return BigInt(n);
  }
  negate() {
    const t = new qa(this.toString());
    return t.negative = !t.negative, t;
  }
  add(t) {
    if (this.isInvalidate())
      return new qa(t);
    const n = new qa(t);
    if (n.isInvalidate())
      return this;
    const o = Math.max(this.getDecimalStr().length, n.getDecimalStr().length), r = this.alignDecimal(o), l = n.alignDecimal(o), a = (r + l).toString(), {
      negativeStr: i,
      trimStr: s
    } = xs(a), c = `${i}${s.padStart(o + 1, "0")}`;
    return new qa(`${c.slice(0, -o)}.${c.slice(-o)}`);
  }
  isEmpty() {
    return this.empty;
  }
  isNaN() {
    return this.nan;
  }
  isInvalidate() {
    return this.isEmpty() || this.isNaN();
  }
  equals(t) {
    return this.toString() === (t == null ? void 0 : t.toString());
  }
  lessEquals(t) {
    return this.add(t.negate().toString()).toNumber() <= 0;
  }
  toNumber() {
    return this.isNaN() ? NaN : Number(this.toString());
  }
  toString() {
    return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !0) ? this.isInvalidate() ? "" : xs(`${this.getMark()}${this.getIntegerStr()}.${this.getDecimalStr()}`).fullStr : this.origin;
  }
}
function fr(e) {
  return Om() ? new qa(e) : new Xl(e);
}
function Pm(e, t, n) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : !1;
  if (e === "")
    return "";
  const {
    negativeStr: r,
    integerStr: l,
    decimalStr: a
  } = xs(e), i = `${t}${a}`, s = `${r}${l}`;
  if (n >= 0) {
    const c = Number(a[n]);
    if (c >= 5 && !o) {
      const u = fr(e).add(`${r}0.${"0".repeat(n)}${10 - c}`);
      return Pm(u.toString(), t, n, o);
    }
    return n === 0 ? s : `${s}${t}${a.padEnd(n, "0").slice(0, n)}`;
  }
  return i === ".0" ? s : `${s}${i}`;
}
const oq = 200, rq = 600, lq = Z({
  compatConfig: {
    MODE: 3
  },
  name: "StepHandler",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    upDisabled: Boolean,
    downDisabled: Boolean,
    onStep: le()
  },
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o
    } = t;
    const r = Y(), l = (i, s) => {
      i.preventDefault(), o("step", s);
      function c() {
        o("step", s), r.value = setTimeout(c, oq);
      }
      r.value = setTimeout(c, rq);
    }, a = () => {
      clearTimeout(r.value);
    };
    return et(() => {
      a();
    }), () => {
      if (Bh())
        return null;
      const {
        prefixCls: i,
        upDisabled: s,
        downDisabled: c
      } = e, u = `${i}-handler`, d = ee(u, `${u}-up`, {
        [`${u}-up-disabled`]: s
      }), p = ee(u, `${u}-down`, {
        [`${u}-down-disabled`]: c
      }), v = {
        unselectable: "on",
        role: "button",
        onMouseup: a,
        onMouseleave: a
      }, {
        upNode: h,
        downNode: g
      } = n;
      return f("div", {
        class: `${u}-wrap`
      }, [f("span", D(D({}, v), {}, {
        onMousedown: (b) => {
          l(b, !0);
        },
        "aria-label": "Increase Value",
        "aria-disabled": s,
        class: d
      }), [(h == null ? void 0 : h()) || f("span", {
        unselectable: "on",
        class: `${i}-handler-up-inner`
      }, null)]), f("span", D(D({}, v), {}, {
        onMousedown: (b) => {
          l(b, !1);
        },
        "aria-label": "Decrease Value",
        "aria-disabled": c,
        class: p
      }), [(g == null ? void 0 : g()) || f("span", {
        unselectable: "on",
        class: `${i}-handler-down-inner`
      }, null)])]);
    };
  }
});
function aq(e, t) {
  const n = Y(null);
  function o() {
    try {
      const {
        selectionStart: l,
        selectionEnd: a,
        value: i
      } = e.value, s = i.substring(0, l), c = i.substring(a);
      n.value = {
        start: l,
        end: a,
        value: i,
        beforeTxt: s,
        afterTxt: c
      };
    } catch {
    }
  }
  function r() {
    if (e.value && n.value && t.value)
      try {
        const {
          value: l
        } = e.value, {
          beforeTxt: a,
          afterTxt: i,
          start: s
        } = n.value;
        let c = l.length;
        if (l.endsWith(i))
          c = l.length - n.value.afterTxt.length;
        else if (l.startsWith(a))
          c = a.length;
        else {
          const u = a[s - 1], d = l.indexOf(u, s - 1);
          d !== -1 && (c = d + 1);
        }
        e.value.setSelectionRange(c, c);
      } catch (l) {
        ct(!1, `Something warning of cursor restore. Please fire issue about this: ${l.message}`);
      }
  }
  return [o, r];
}
const iq = () => {
  const e = Q(0), t = () => {
    Ze.cancel(e.value);
  };
  return et(() => {
    t();
  }), (n) => {
    t(), e.value = Ze(() => {
      n();
    });
  };
};
var sq = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const _$ = (e, t) => e || t.isEmpty() ? t.toString() : t.toNumber(), A$ = (e) => {
  const t = fr(e);
  return t.isInvalidate() ? null : t;
}, RI = () => ({
  /** value will show as string */
  stringMode: ve(),
  defaultValue: je([String, Number]),
  value: je([String, Number]),
  prefixCls: ke(),
  min: je([String, Number]),
  max: je([String, Number]),
  step: je([String, Number], 1),
  tabindex: Number,
  controls: ve(!0),
  readonly: ve(),
  disabled: ve(),
  autofocus: ve(),
  keyboard: ve(!0),
  /** Parse display value to validate number */
  parser: le(),
  /** Transform `value` to display value show in input */
  formatter: le(),
  /** Syntactic sugar of `formatter`. Config precision of display. */
  precision: Number,
  /** Syntactic sugar of `formatter`. Config decimal separator of display. */
  decimalSeparator: String,
  onInput: le(),
  onChange: le(),
  onPressEnter: le(),
  onStep: le(),
  onBlur: le(),
  onFocus: le()
}), cq = Z({
  compatConfig: {
    MODE: 3
  },
  name: "InnerInputNumber",
  inheritAttrs: !1,
  props: m(m({}, RI()), {
    lazy: Boolean
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r,
      expose: l
    } = t;
    const a = Q(), i = Q(!1), s = Q(!1), c = Q(!1), u = Q(fr(e.value));
    function d(H) {
      e.value === void 0 && (u.value = H);
    }
    const p = (H, K) => {
      if (!K)
        return e.precision >= 0 ? e.precision : Math.max(ec(H), ec(e.step));
    }, v = (H) => {
      const K = String(H);
      if (e.parser)
        return e.parser(K);
      let X = K;
      return e.decimalSeparator && (X = X.replace(e.decimalSeparator, ".")), X.replace(/[^\w.-]+/g, "");
    }, h = Q(""), g = (H, K) => {
      if (e.formatter)
        return e.formatter(H, {
          userTyping: K,
          input: String(h.value)
        });
      let X = typeof H == "number" ? Ib(H) : H;
      if (!K) {
        const W = p(X, K);
        if (Eb(X) && (e.decimalSeparator || W >= 0)) {
          const q = e.decimalSeparator || ".";
          X = Pm(X, q, W);
        }
      }
      return X;
    }, b = (() => {
      const H = e.value;
      return u.value.isInvalidate() && ["string", "number"].includes(typeof H) ? Number.isNaN(H) ? "" : H : g(u.value.toString(), !1);
    })();
    h.value = b;
    function y(H, K) {
      h.value = g(
        // Invalidate number is sometime passed by external control, we should let it go
        // Otherwise is controlled by internal interactive logic which check by userTyping
        // You can ref 'show limited value when input is not focused' test for more info.
        H.isInvalidate() ? H.toString(!1) : H.toString(!K),
        K
      );
    }
    const S = P(() => A$(e.max)), C = P(() => A$(e.min)), w = P(() => !S.value || !u.value || u.value.isInvalidate() ? !1 : S.value.lessEquals(u.value)), $ = P(() => !C.value || !u.value || u.value.isInvalidate() ? !1 : u.value.lessEquals(C.value)), [O, x] = aq(a, i), I = (H) => S.value && !H.lessEquals(S.value) ? S.value : C.value && !C.value.lessEquals(H) ? C.value : null, E = (H) => !I(H), _ = (H, K) => {
      var X;
      let W = H, q = E(W) || W.isEmpty();
      if (!W.isEmpty() && !K && (W = I(W) || W, q = !0), !e.readonly && !e.disabled && q) {
        const J = W.toString(), ne = p(J, K);
        return ne >= 0 && (W = fr(Pm(J, ".", ne))), W.equals(u.value) || (d(W), (X = e.onChange) === null || X === void 0 || X.call(e, W.isEmpty() ? null : _$(e.stringMode, W)), e.value === void 0 && y(W, K)), W;
      }
      return u.value;
    }, M = iq(), R = (H) => {
      var K;
      if (O(), h.value = H, !c.value) {
        const X = v(H), W = fr(X);
        W.isNaN() || _(W, !0);
      }
      (K = e.onInput) === null || K === void 0 || K.call(e, H), M(() => {
        let X = H;
        e.parser || (X = H.replace(/。/g, ".")), X !== H && R(X);
      });
    }, A = () => {
      c.value = !0;
    }, z = () => {
      c.value = !1, R(a.value.value);
    }, T = (H) => {
      R(H.target.value);
    }, N = (H) => {
      var K, X;
      if (H && w.value || !H && $.value)
        return;
      s.value = !1;
      let W = fr(e.step);
      H || (W = W.negate());
      const q = (u.value || fr(0)).add(W.toString()), J = _(q, !1);
      (K = e.onStep) === null || K === void 0 || K.call(e, _$(e.stringMode, J), {
        offset: e.step,
        type: H ? "up" : "down"
      }), (X = a.value) === null || X === void 0 || X.focus();
    }, k = (H) => {
      const K = fr(v(h.value));
      let X = K;
      K.isNaN() ? X = u.value : X = _(K, H), e.value !== void 0 ? y(u.value, !1) : X.isNaN() || y(X, !1);
    }, B = () => {
      s.value = !0;
    }, F = (H) => {
      var K;
      const {
        which: X
      } = H;
      s.value = !0, X === ce.ENTER && (c.value || (s.value = !1), k(!1), (K = e.onPressEnter) === null || K === void 0 || K.call(e, H)), e.keyboard !== !1 && !c.value && [ce.UP, ce.DOWN].includes(X) && (N(ce.UP === X), H.preventDefault());
    }, L = () => {
      s.value = !1;
    }, j = (H) => {
      k(!1), i.value = !1, s.value = !1, r("blur", H);
    };
    return ie(() => e.precision, () => {
      u.value.isInvalidate() || y(u.value, !1);
    }, {
      flush: "post"
    }), ie(() => e.value, () => {
      const H = fr(e.value);
      u.value = H;
      const K = fr(v(h.value));
      (!H.equals(K) || !s.value || e.formatter) && y(H, s.value);
    }, {
      flush: "post"
    }), ie(h, () => {
      e.formatter && x();
    }, {
      flush: "post"
    }), ie(() => e.disabled, (H) => {
      H && (i.value = !1);
    }), l({
      focus: () => {
        var H;
        (H = a.value) === null || H === void 0 || H.focus();
      },
      blur: () => {
        var H;
        (H = a.value) === null || H === void 0 || H.blur();
      }
    }), () => {
      const H = m(m({}, n), e), {
        prefixCls: K = "rc-input-number",
        min: X,
        max: W,
        step: q = 1,
        defaultValue: J,
        value: ne,
        disabled: te,
        readonly: G,
        keyboard: U,
        controls: re = !0,
        autofocus: se,
        stringMode: me,
        parser: Ce,
        formatter: fe,
        precision: be,
        decimalSeparator: ue,
        onChange: de,
        onInput: Se,
        onPressEnter: xe,
        onStep: he,
        lazy: we,
        class: Me,
        style: ae
      } = H, oe = sq(H, ["prefixCls", "min", "max", "step", "defaultValue", "value", "disabled", "readonly", "keyboard", "controls", "autofocus", "stringMode", "parser", "formatter", "precision", "decimalSeparator", "onChange", "onInput", "onPressEnter", "onStep", "lazy", "class", "style"]), {
        upHandler: pe,
        downHandler: Pe
      } = o, Ee = `${K}-input`, ze = {};
      return we ? ze.onChange = T : ze.onInput = T, f("div", {
        class: ee(K, Me, {
          [`${K}-focused`]: i.value,
          [`${K}-disabled`]: te,
          [`${K}-readonly`]: G,
          [`${K}-not-a-number`]: u.value.isNaN(),
          [`${K}-out-of-range`]: !u.value.isInvalidate() && !E(u.value)
        }),
        style: ae,
        onKeydown: F,
        onKeyup: L
      }, [re && f(lq, {
        prefixCls: K,
        upDisabled: w.value,
        downDisabled: $.value,
        onStep: N
      }, {
        upNode: pe,
        downNode: Pe
      }), f("div", {
        class: `${Ee}-wrap`
      }, [f("input", D(D(D({
        autofocus: se,
        autocomplete: "off",
        role: "spinbutton",
        "aria-valuemin": X,
        "aria-valuemax": W,
        "aria-valuenow": u.value.isInvalidate() ? null : u.value.toString(),
        step: q
      }, oe), {}, {
        ref: a,
        class: Ee,
        value: h.value,
        disabled: te,
        readonly: G,
        onFocus: (ge) => {
          i.value = !0, r("focus", ge);
        }
      }, ze), {}, {
        onBlur: j,
        onCompositionstart: A,
        onCompositionend: z,
        onBeforeinput: B
      }), null)])]);
    };
  }
});
function kv(e) {
  return e != null;
}
const uq = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    lineType: o,
    colorBorder: r,
    borderRadius: l,
    fontSizeLG: a,
    controlHeightLG: i,
    controlHeightSM: s,
    colorError: c,
    inputPaddingHorizontalSM: u,
    colorTextDescription: d,
    motionDurationMid: p,
    colorPrimary: v,
    controlHeight: h,
    inputPaddingHorizontal: g,
    colorBgContainer: b,
    colorTextDisabled: y,
    borderRadiusSM: S,
    borderRadiusLG: C,
    controlWidth: w,
    handleVisible: $
  } = e;
  return [
    {
      [t]: m(m(m(m({}, qe(e)), Oa(e)), vc(e, t)), {
        display: "inline-block",
        width: w,
        margin: 0,
        padding: 0,
        border: `${n}px ${o} ${r}`,
        borderRadius: l,
        "&-rtl": {
          direction: "rtl",
          [`${t}-input`]: {
            direction: "rtl"
          }
        },
        "&-lg": {
          padding: 0,
          fontSize: a,
          borderRadius: C,
          [`input${t}-input`]: {
            height: i - 2 * n
          }
        },
        "&-sm": {
          padding: 0,
          borderRadius: S,
          [`input${t}-input`]: {
            height: s - 2 * n,
            padding: `0 ${u}px`
          }
        },
        "&:hover": m({}, Fi(e)),
        "&-focused": m({}, Sl(e)),
        "&-disabled": m(m({}, W0(e)), {
          [`${t}-input`]: {
            cursor: "not-allowed"
          }
        }),
        // ===================== Out Of Range =====================
        "&-out-of-range": {
          input: {
            color: c
          }
        },
        // Style for input-group: input with label, with button or dropdown...
        "&-group": m(m(m({}, qe(e)), k3(e)), {
          "&-wrapper": {
            display: "inline-block",
            textAlign: "start",
            verticalAlign: "top",
            [`${t}-affix-wrapper`]: {
              width: "100%"
            },
            // Size
            "&-lg": {
              [`${t}-group-addon`]: {
                borderRadius: C
              }
            },
            "&-sm": {
              [`${t}-group-addon`]: {
                borderRadius: S
              }
            }
          }
        }),
        [t]: {
          "&-input": m(m({
            width: "100%",
            height: h - 2 * n,
            padding: `0 ${g}px`,
            textAlign: "start",
            backgroundColor: "transparent",
            border: 0,
            borderRadius: l,
            outline: 0,
            transition: `all ${p} linear`,
            appearance: "textfield",
            color: e.colorText,
            fontSize: "inherit",
            verticalAlign: "top"
          }, V0(e.colorTextPlaceholder)), {
            '&[type="number"]::-webkit-inner-spin-button, &[type="number"]::-webkit-outer-spin-button': {
              margin: 0,
              /* stylelint-disable-next-line property-no-vendor-prefix */
              webkitAppearance: "none",
              appearance: "none"
            }
          })
        }
      })
    },
    // Handler
    {
      [t]: {
        [`&:hover ${t}-handler-wrap, &-focused ${t}-handler-wrap`]: {
          opacity: 1
        },
        [`${t}-handler-wrap`]: {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          width: e.handleWidth,
          height: "100%",
          background: b,
          borderStartStartRadius: 0,
          borderStartEndRadius: l,
          borderEndEndRadius: l,
          borderEndStartRadius: 0,
          opacity: $ === !0 ? 1 : 0,
          display: "flex",
          flexDirection: "column",
          alignItems: "stretch",
          transition: `opacity ${p} linear ${p}`,
          // Fix input number inside Menu makes icon too large
          // We arise the selector priority by nest selector here
          // https://github.com/ant-design/ant-design/issues/14367
          [`${t}-handler`]: {
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            flex: "auto",
            height: "40%",
            [`
              ${t}-handler-up-inner,
              ${t}-handler-down-inner
            `]: {
              marginInlineEnd: 0,
              fontSize: e.handleFontSize
            }
          }
        },
        [`${t}-handler`]: {
          height: "50%",
          overflow: "hidden",
          color: d,
          fontWeight: "bold",
          lineHeight: 0,
          textAlign: "center",
          cursor: "pointer",
          borderInlineStart: `${n}px ${o} ${r}`,
          transition: `all ${p} linear`,
          "&:active": {
            background: e.colorFillAlter
          },
          // Hover
          "&:hover": {
            height: "60%",
            [`
              ${t}-handler-up-inner,
              ${t}-handler-down-inner
            `]: {
              color: v
            }
          },
          "&-up-inner, &-down-inner": m(m({}, ha()), {
            color: d,
            transition: `all ${p} linear`,
            userSelect: "none"
          })
        },
        [`${t}-handler-up`]: {
          borderStartEndRadius: l
        },
        [`${t}-handler-down`]: {
          borderBlockStart: `${n}px ${o} ${r}`,
          borderEndEndRadius: l
        },
        // Disabled
        "&-disabled, &-readonly": {
          [`${t}-handler-wrap`]: {
            display: "none"
          },
          [`${t}-input`]: {
            color: "inherit"
          }
        },
        [`
          ${t}-handler-up-disabled,
          ${t}-handler-down-disabled
        `]: {
          cursor: "not-allowed"
        },
        [`
          ${t}-handler-up-disabled:hover &-handler-up-inner,
          ${t}-handler-down-disabled:hover &-handler-down-inner
        `]: {
          color: y
        }
      }
    },
    // Border-less
    {
      [`${t}-borderless`]: {
        borderColor: "transparent",
        boxShadow: "none",
        [`${t}-handler-down`]: {
          borderBlockStartWidth: 0
        }
      }
    }
  ];
}, dq = (e) => {
  const {
    componentCls: t,
    inputPaddingHorizontal: n,
    inputAffixPadding: o,
    controlWidth: r,
    borderRadiusLG: l,
    borderRadiusSM: a
  } = e;
  return {
    [`${t}-affix-wrapper`]: m(m(m({}, Oa(e)), vc(e, `${t}-affix-wrapper`)), {
      // or number handler will cover form status
      position: "relative",
      display: "inline-flex",
      width: r,
      padding: 0,
      paddingInlineStart: n,
      "&-lg": {
        borderRadius: l
      },
      "&-sm": {
        borderRadius: a
      },
      [`&:not(${t}-affix-wrapper-disabled):hover`]: m(m({}, Fi(e)), {
        zIndex: 1
      }),
      "&-focused, &:focus": {
        zIndex: 1
      },
      "&-disabled": {
        [`${t}[disabled]`]: {
          background: "transparent"
        }
      },
      [`> div${t}`]: {
        width: "100%",
        border: "none",
        outline: "none",
        [`&${t}-focused`]: {
          boxShadow: "none !important"
        }
      },
      [`input${t}-input`]: {
        padding: 0
      },
      "&::before": {
        width: 0,
        visibility: "hidden",
        content: '"\\a0"'
      },
      [`${t}-handler-wrap`]: {
        zIndex: 2
      },
      [t]: {
        "&-prefix, &-suffix": {
          display: "flex",
          flex: "none",
          alignItems: "center",
          pointerEvents: "none"
        },
        "&-prefix": {
          marginInlineEnd: o
        },
        "&-suffix": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineEnd: 0,
          zIndex: 1,
          height: "100%",
          marginInlineEnd: n,
          marginInlineStart: o
        }
      }
    })
  };
}, fq = Xe("InputNumber", (e) => {
  const t = Pa(e);
  return [
    uq(t),
    dq(t),
    // =====================================================
    // ==             Space Compact                       ==
    // =====================================================
    Ri(t)
  ];
}, (e) => ({
  controlWidth: 90,
  handleWidth: e.controlHeightSM - e.lineWidth * 2,
  handleFontSize: e.fontSize / 2,
  handleVisible: "auto"
}));
var pq = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const D$ = RI(), vq = () => m(m({}, D$), {
  size: ke(),
  bordered: ve(!0),
  placeholder: String,
  name: String,
  id: String,
  type: String,
  addonBefore: V.any,
  addonAfter: V.any,
  prefix: V.any,
  "onUpdate:value": D$.onChange,
  valueModifiers: Object,
  status: ke()
}), Bv = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AInputNumber",
  inheritAttrs: !1,
  props: vq(),
  // emits: ['focus', 'blur', 'change', 'input', 'update:value'],
  slots: Object,
  setup(e, t) {
    let {
      emit: n,
      expose: o,
      attrs: r,
      slots: l
    } = t;
    var a;
    const i = sn(), s = Sn.useInject(), c = P(() => ar(s.status, e.status)), {
      prefixCls: u,
      size: d,
      direction: p,
      disabled: v
    } = Ie("input-number", e), {
      compactSize: h,
      compactItemClassnames: g
    } = Ol(u, p), b = so(), y = P(() => {
      var A;
      return (A = v.value) !== null && A !== void 0 ? A : b.value;
    }), [S, C] = fq(u), w = P(() => h.value || d.value), $ = Q((a = e.value) !== null && a !== void 0 ? a : e.defaultValue), O = Q(!1);
    ie(() => e.value, () => {
      $.value = e.value;
    });
    const x = Q(null), I = () => {
      var A;
      (A = x.value) === null || A === void 0 || A.focus();
    };
    o({
      focus: I,
      blur: () => {
        var A;
        (A = x.value) === null || A === void 0 || A.blur();
      }
    });
    const _ = (A) => {
      e.value === void 0 && ($.value = A), n("update:value", A), n("change", A), i.onFieldChange();
    }, M = (A) => {
      O.value = !1, n("blur", A), i.onFieldBlur();
    }, R = (A) => {
      O.value = !0, n("focus", A);
    };
    return () => {
      var A, z, T, N;
      const {
        hasFeedback: k,
        isFormItemInput: B,
        feedbackIcon: F
      } = s, L = (A = e.id) !== null && A !== void 0 ? A : i.id.value, j = m(m(m({}, r), e), {
        id: L,
        disabled: y.value
      }), {
        class: H,
        bordered: K,
        readonly: X,
        style: W,
        addonBefore: q = (z = l.addonBefore) === null || z === void 0 ? void 0 : z.call(l),
        addonAfter: J = (T = l.addonAfter) === null || T === void 0 ? void 0 : T.call(l),
        prefix: ne = (N = l.prefix) === null || N === void 0 ? void 0 : N.call(l),
        valueModifiers: te = {}
      } = j, G = pq(j, ["class", "bordered", "readonly", "style", "addonBefore", "addonAfter", "prefix", "valueModifiers"]), U = u.value, re = ee({
        [`${U}-lg`]: w.value === "large",
        [`${U}-sm`]: w.value === "small",
        [`${U}-rtl`]: p.value === "rtl",
        [`${U}-readonly`]: X,
        [`${U}-borderless`]: !K,
        [`${U}-in-form-item`]: B
      }, Fn(U, c.value), H, g.value, C.value);
      let se = f(cq, D(D({}, ot(G, ["size", "defaultValue"])), {}, {
        ref: x,
        lazy: !!te.lazy,
        value: $.value,
        class: re,
        prefixCls: U,
        readonly: X,
        onChange: _,
        onBlur: M,
        onFocus: R
      }), {
        upHandler: l.upIcon ? () => f("span", {
          class: `${U}-handler-up-inner`
        }, [l.upIcon()]) : () => f(Ob, {
          class: `${U}-handler-up-inner`
        }, null),
        downHandler: l.downIcon ? () => f("span", {
          class: `${U}-handler-down-inner`
        }, [l.downIcon()]) : () => f(Or, {
          class: `${U}-handler-down-inner`
        }, null)
      });
      const me = kv(q) || kv(J), Ce = kv(ne);
      if (Ce || k) {
        const fe = ee(`${U}-affix-wrapper`, Fn(`${U}-affix-wrapper`, c.value, k), {
          [`${U}-affix-wrapper-focused`]: O.value,
          [`${U}-affix-wrapper-disabled`]: y.value,
          [`${U}-affix-wrapper-sm`]: w.value === "small",
          [`${U}-affix-wrapper-lg`]: w.value === "large",
          [`${U}-affix-wrapper-rtl`]: p.value === "rtl",
          [`${U}-affix-wrapper-readonly`]: X,
          [`${U}-affix-wrapper-borderless`]: !K,
          // className will go to addon wrapper
          [`${H}`]: !me && H
        }, C.value);
        se = f("div", {
          class: fe,
          style: W,
          onClick: I
        }, [Ce && f("span", {
          class: `${U}-prefix`
        }, [ne]), se, k && f("span", {
          class: `${U}-suffix`
        }, [F])]);
      }
      if (me) {
        const fe = `${U}-group`, be = `${fe}-addon`, ue = q ? f("div", {
          class: be
        }, [q]) : null, de = J ? f("div", {
          class: be
        }, [J]) : null, Se = ee(`${U}-wrapper`, fe, {
          [`${fe}-rtl`]: p.value === "rtl"
        }, C.value), xe = ee(`${U}-group-wrapper`, {
          [`${U}-group-wrapper-sm`]: w.value === "small",
          [`${U}-group-wrapper-lg`]: w.value === "large",
          [`${U}-group-wrapper-rtl`]: p.value === "rtl"
        }, Fn(`${u}-group-wrapper`, c.value, k), H, C.value);
        se = f("div", {
          class: xe,
          style: W
        }, [f("div", {
          class: Se
        }, [ue && f(Ks, null, {
          default: () => [f(Cd, null, {
            default: () => [ue]
          })]
        }), se, de && f(Ks, null, {
          default: () => [f(Cd, null, {
            default: () => [de]
          })]
        })])]);
      }
      return S(yt(se, {
        style: W
      }));
    };
  }
}), gq = m(Bv, {
  install: (e) => (e.component(Bv.name, Bv), e)
}), mq = (e) => {
  const {
    componentCls: t,
    colorBgContainer: n,
    colorBgBody: o,
    colorText: r
  } = e;
  return {
    [`${t}-sider-light`]: {
      background: n,
      [`${t}-sider-trigger`]: {
        color: r,
        background: n
      },
      [`${t}-sider-zero-width-trigger`]: {
        color: r,
        background: n,
        border: `1px solid ${o}`,
        borderInlineStart: 0
      }
    }
  };
}, hq = (e) => {
  const {
    antCls: t,
    // .ant
    componentCls: n,
    // .ant-layout
    colorText: o,
    colorTextLightSolid: r,
    colorBgHeader: l,
    colorBgBody: a,
    colorBgTrigger: i,
    layoutHeaderHeight: s,
    layoutHeaderPaddingInline: c,
    layoutHeaderColor: u,
    layoutFooterPadding: d,
    layoutTriggerHeight: p,
    layoutZeroTriggerSize: v,
    motionDurationMid: h,
    motionDurationSlow: g,
    fontSize: b,
    borderRadius: y
  } = e;
  return {
    [n]: m(m({
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      color: o,
      /* fix firefox can't set height smaller than content on flex item */
      minHeight: 0,
      background: a,
      "&, *": {
        boxSizing: "border-box"
      },
      [`&${n}-has-sider`]: {
        flexDirection: "row",
        [`> ${n}, > ${n}-content`]: {
          // https://segmentfault.com/a/1190000019498300
          width: 0
        }
      },
      [`${n}-header, &${n}-footer`]: {
        flex: "0 0 auto"
      },
      [`${n}-header`]: {
        height: s,
        paddingInline: c,
        color: u,
        lineHeight: `${s}px`,
        background: l,
        // Other components/menu/style/index.less line:686
        // Integration with header element so menu items have the same height
        [`${t}-menu`]: {
          lineHeight: "inherit"
        }
      },
      [`${n}-footer`]: {
        padding: d,
        color: o,
        fontSize: b,
        background: a
      },
      [`${n}-content`]: {
        flex: "auto",
        // fix firefox can't set height smaller than content on flex item
        minHeight: 0
      },
      [`${n}-sider`]: {
        position: "relative",
        // fix firefox can't set width smaller than content on flex item
        minWidth: 0,
        background: l,
        transition: `all ${h}, background 0s`,
        "&-children": {
          height: "100%",
          // Hack for fixing margin collapse bug
          // https://github.com/ant-design/ant-design/issues/7967
          // solution from https://stackoverflow.com/a/33132624/3040605
          marginTop: -0.1,
          paddingTop: 0.1,
          [`${t}-menu${t}-menu-inline-collapsed`]: {
            width: "auto"
          }
        },
        "&-has-trigger": {
          paddingBottom: p
        },
        "&-right": {
          order: 1
        },
        "&-trigger": {
          position: "fixed",
          bottom: 0,
          zIndex: 1,
          height: p,
          color: r,
          lineHeight: `${p}px`,
          textAlign: "center",
          background: i,
          cursor: "pointer",
          transition: `all ${h}`
        },
        "&-zero-width": {
          "> *": {
            overflow: "hidden"
          },
          "&-trigger": {
            position: "absolute",
            top: s,
            insetInlineEnd: -v,
            zIndex: 1,
            width: v,
            height: v,
            color: r,
            fontSize: e.fontSizeXL,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            background: l,
            borderStartStartRadius: 0,
            borderStartEndRadius: y,
            borderEndEndRadius: y,
            borderEndStartRadius: 0,
            cursor: "pointer",
            transition: `background ${g} ease`,
            "&::after": {
              position: "absolute",
              inset: 0,
              background: "transparent",
              transition: `all ${g}`,
              content: '""'
            },
            "&:hover::after": {
              // FIXME: Hardcode, but seems no need to create a token for this
              background: "rgba(255, 255, 255, 0.2)"
            },
            "&-right": {
              insetInlineStart: -v,
              borderStartStartRadius: y,
              borderStartEndRadius: 0,
              borderEndEndRadius: 0,
              borderEndStartRadius: y
            }
          }
        }
      }
    }, mq(e)), {
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, bq = Xe("Layout", (e) => {
  const {
    colorText: t,
    controlHeightSM: n,
    controlHeight: o,
    controlHeightLG: r,
    marginXXS: l
  } = e, a = r * 1.25, i = He(e, {
    // Layout
    layoutHeaderHeight: o * 2,
    layoutHeaderPaddingInline: a,
    layoutHeaderColor: t,
    layoutFooterPadding: `${n}px ${a}px`,
    layoutTriggerHeight: r + l * 2,
    layoutZeroTriggerSize: r
  });
  return [hq(i)];
}, (e) => {
  const {
    colorBgLayout: t
  } = e;
  return {
    colorBgHeader: "#001529",
    colorBgBody: t,
    colorBgTrigger: "#002140"
  };
}), Tb = () => ({
  prefixCls: String,
  hasSider: {
    type: Boolean,
    default: void 0
  },
  tagName: String
});
function wp(e) {
  let {
    suffixCls: t,
    tagName: n,
    name: o
  } = e;
  return (r) => Z({
    compatConfig: {
      MODE: 3
    },
    name: o,
    props: Tb(),
    setup(a, i) {
      let {
        slots: s
      } = i;
      const {
        prefixCls: c
      } = Ie(t, a);
      return () => {
        const u = m(m({}, a), {
          prefixCls: c.value,
          tagName: n
        });
        return f(r, u, s);
      };
    }
  });
}
const Mb = Z({
  compatConfig: {
    MODE: 3
  },
  props: Tb(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => f(e.tagName, {
      class: e.prefixCls
    }, n);
  }
}), yq = Z({
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: Tb(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("", e), [a, i] = bq(r), s = Y([]);
    Je(KO, {
      addSider: (d) => {
        s.value = [...s.value, d];
      },
      removeSider: (d) => {
        s.value = s.value.filter((p) => p !== d);
      }
    });
    const u = P(() => {
      const {
        prefixCls: d,
        hasSider: p
      } = e;
      return {
        [i.value]: !0,
        [`${d}`]: !0,
        [`${d}-has-sider`]: typeof p == "boolean" ? p : s.value.length > 0,
        [`${d}-rtl`]: l.value === "rtl"
      };
    });
    return () => {
      const {
        tagName: d
      } = e;
      return a(f(d, m(m({}, o), {
        class: [u.value, o.class]
      }), n));
    };
  }
}), Fv = wp({
  suffixCls: "layout",
  tagName: "section",
  name: "ALayout"
})(yq), Nu = wp({
  suffixCls: "layout-header",
  tagName: "header",
  name: "ALayoutHeader"
})(Mb), Ru = wp({
  suffixCls: "layout-footer",
  tagName: "footer",
  name: "ALayoutFooter"
})(Mb), ku = wp({
  suffixCls: "layout-content",
  tagName: "main",
  name: "ALayoutContent"
})(Mb);
var Sq = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0zm0 284a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, name: "bars", theme: "outlined" };
function N$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Cq(e, r, n[r]);
    });
  }
  return e;
}
function Cq(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var _b = function(t, n) {
  var o = N$({}, t, n.attrs);
  return f(Ge, N$({}, o, {
    icon: Sq
  }), null);
};
_b.displayName = "BarsOutlined";
_b.inheritAttrs = !1;
const R$ = {
  xs: "479.98px",
  sm: "575.98px",
  md: "767.98px",
  lg: "991.98px",
  xl: "1199.98px",
  xxl: "1599.98px",
  xxxl: "1999.98px"
}, $q = () => ({
  prefixCls: String,
  collapsible: {
    type: Boolean,
    default: void 0
  },
  collapsed: {
    type: Boolean,
    default: void 0
  },
  defaultCollapsed: {
    type: Boolean,
    default: void 0
  },
  reverseArrow: {
    type: Boolean,
    default: void 0
  },
  zeroWidthTriggerStyle: {
    type: Object,
    default: void 0
  },
  trigger: V.any,
  width: V.oneOfType([V.number, V.string]),
  collapsedWidth: V.oneOfType([V.number, V.string]),
  breakpoint: V.oneOf(Mn("xs", "sm", "md", "lg", "xl", "xxl", "xxxl")),
  theme: V.oneOf(Mn("light", "dark")).def("dark"),
  onBreakpoint: Function,
  onCollapse: Function
}), wq = /* @__PURE__ */ (() => {
  let e = 0;
  return function() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return e += 1, `${t}${e}`;
  };
})(), Bu = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ALayoutSider",
  inheritAttrs: !1,
  props: Qe($q(), {
    collapsible: !1,
    defaultCollapsed: !1,
    reverseArrow: !1,
    width: 200,
    collapsedWidth: 80
  }),
  emits: ["breakpoint", "update:collapsed", "collapse"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      slots: r
    } = t;
    const {
      prefixCls: l
    } = Ie("layout-sider", e), a = tt(KO, void 0), i = Q(!!(e.collapsed !== void 0 ? e.collapsed : e.defaultCollapsed)), s = Q(!1);
    ie(() => e.collapsed, () => {
      i.value = !!e.collapsed;
    }), Je(WO, i);
    const c = (g, b) => {
      e.collapsed === void 0 && (i.value = g), n("update:collapsed", g), n("collapse", g, b);
    }, u = Q((g) => {
      s.value = g.matches, n("breakpoint", g.matches), i.value !== g.matches && c(g.matches, "responsive");
    });
    let d;
    function p(g) {
      return u.value(g);
    }
    const v = wq("ant-sider-");
    a && a.addSider(v), Ke(() => {
      ie(() => e.breakpoint, () => {
        try {
          d == null || d.removeEventListener("change", p);
        } catch {
          d == null || d.removeListener(p);
        }
        if (typeof window < "u") {
          const {
            matchMedia: g
          } = window;
          if (g && e.breakpoint && e.breakpoint in R$) {
            d = g(`(max-width: ${R$[e.breakpoint]})`);
            try {
              d.addEventListener("change", p);
            } catch {
              d.addListener(p);
            }
            p(d);
          }
        }
      }, {
        immediate: !0
      });
    }), et(() => {
      try {
        d == null || d.removeEventListener("change", p);
      } catch {
        d == null || d.removeListener(p);
      }
      a && a.removeSider(v);
    });
    const h = () => {
      c(!i.value, "clickTrigger");
    };
    return () => {
      var g, b;
      const y = l.value, {
        collapsedWidth: S,
        width: C,
        reverseArrow: w,
        zeroWidthTriggerStyle: $,
        trigger: O = (g = r.trigger) === null || g === void 0 ? void 0 : g.call(r),
        collapsible: x,
        theme: I
      } = e, E = i.value ? S : C, _ = Id(E) ? `${E}px` : String(E), M = parseFloat(String(S || 0)) === 0 ? f("span", {
        onClick: h,
        class: ee(`${y}-zero-width-trigger`, `${y}-zero-width-trigger-${w ? "right" : "left"}`),
        style: $
      }, [O || f(_b, null, null)]) : null, R = {
        expanded: w ? f(Po, null, null) : f(wr, null, null),
        collapsed: w ? f(wr, null, null) : f(Po, null, null)
      }, A = i.value ? "collapsed" : "expanded", z = R[A], T = O !== null ? M || f("div", {
        class: `${y}-trigger`,
        onClick: h,
        style: {
          width: _
        }
      }, [O || z]) : null, N = [o.style, {
        flex: `0 0 ${_}`,
        maxWidth: _,
        minWidth: _,
        width: _
      }], k = ee(y, `${y}-${I}`, {
        [`${y}-collapsed`]: !!i.value,
        [`${y}-has-trigger`]: x && O !== null && !M,
        [`${y}-below`]: !!s.value,
        [`${y}-zero-width`]: parseFloat(_) === 0
      }, o.class);
      return f("aside", D(D({}, o), {}, {
        class: k,
        style: N
      }), [f("div", {
        class: `${y}-children`
      }, [(b = r.default) === null || b === void 0 ? void 0 : b.call(r)]), x || s.value && M ? T : null]);
    };
  }
}), xq = Nu, Oq = Ru, Pq = Bu, Iq = ku, Eq = m(Fv, {
  Header: Nu,
  Footer: Ru,
  Content: ku,
  Sider: Bu,
  install: (e) => (e.component(Fv.name, Fv), e.component(Nu.name, Nu), e.component(Ru.name, Ru), e.component(Bu.name, Bu), e.component(ku.name, ku), e)
});
function Tq(e, t, n) {
  var o = n || {}, r = o.noTrailing, l = r === void 0 ? !1 : r, a = o.noLeading, i = a === void 0 ? !1 : a, s = o.debounceMode, c = s === void 0 ? void 0 : s, u, d = !1, p = 0;
  function v() {
    u && clearTimeout(u);
  }
  function h(b) {
    var y = b || {}, S = y.upcomingOnly, C = S === void 0 ? !1 : S;
    v(), d = !C;
  }
  function g() {
    for (var b = arguments.length, y = new Array(b), S = 0; S < b; S++)
      y[S] = arguments[S];
    var C = this, w = Date.now() - p;
    if (d)
      return;
    function $() {
      p = Date.now(), t.apply(C, y);
    }
    function O() {
      u = void 0;
    }
    !i && c && !u && $(), v(), c === void 0 && w > e ? i ? (p = Date.now(), l || (u = setTimeout(c ? O : $, e))) : $() : l !== !0 && (u = setTimeout(c ? O : $, c === void 0 ? e - w : e));
  }
  return g.cancel = h, g;
}
function Mq(e, t, n) {
  var o = {}, r = o.atBegin, l = r === void 0 ? !1 : r;
  return Tq(e, t, {
    debounceMode: l !== !1
  });
}
const _q = new lt("antSpinMove", {
  to: {
    opacity: 1
  }
}), Aq = new lt("antRotate", {
  to: {
    transform: "rotate(405deg)"
  }
}), Dq = (e) => ({
  [`${e.componentCls}`]: m(m({}, qe(e)), {
    position: "absolute",
    display: "none",
    color: e.colorPrimary,
    textAlign: "center",
    verticalAlign: "middle",
    opacity: 0,
    transition: `transform ${e.motionDurationSlow} ${e.motionEaseInOutCirc}`,
    "&-spinning": {
      position: "static",
      display: "inline-block",
      opacity: 1
    },
    "&-nested-loading": {
      position: "relative",
      [`> div > ${e.componentCls}`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        zIndex: 4,
        display: "block",
        width: "100%",
        height: "100%",
        maxHeight: e.contentHeight,
        [`${e.componentCls}-dot`]: {
          position: "absolute",
          top: "50%",
          insetInlineStart: "50%",
          margin: -e.spinDotSize / 2
        },
        [`${e.componentCls}-text`]: {
          position: "absolute",
          top: "50%",
          width: "100%",
          paddingTop: (e.spinDotSize - e.fontSize) / 2 + 2,
          textShadow: `0 1px 2px ${e.colorBgContainer}`
          // FIXME: shadow
        },
        [`&${e.componentCls}-show-text ${e.componentCls}-dot`]: {
          marginTop: -(e.spinDotSize / 2) - 10
        },
        "&-sm": {
          [`${e.componentCls}-dot`]: {
            margin: -e.spinDotSizeSM / 2
          },
          [`${e.componentCls}-text`]: {
            paddingTop: (e.spinDotSizeSM - e.fontSize) / 2 + 2
          },
          [`&${e.componentCls}-show-text ${e.componentCls}-dot`]: {
            marginTop: -(e.spinDotSizeSM / 2) - 10
          }
        },
        "&-lg": {
          [`${e.componentCls}-dot`]: {
            margin: -(e.spinDotSizeLG / 2)
          },
          [`${e.componentCls}-text`]: {
            paddingTop: (e.spinDotSizeLG - e.fontSize) / 2 + 2
          },
          [`&${e.componentCls}-show-text ${e.componentCls}-dot`]: {
            marginTop: -(e.spinDotSizeLG / 2) - 10
          }
        }
      },
      [`${e.componentCls}-container`]: {
        position: "relative",
        transition: `opacity ${e.motionDurationSlow}`,
        "&::after": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          height: "100%",
          background: e.colorBgContainer,
          opacity: 0,
          transition: `all ${e.motionDurationSlow}`,
          content: '""',
          pointerEvents: "none"
        }
      },
      [`${e.componentCls}-blur`]: {
        clear: "both",
        opacity: 0.5,
        userSelect: "none",
        pointerEvents: "none",
        "&::after": {
          opacity: 0.4,
          pointerEvents: "auto"
        }
      }
    },
    // tip
    // ------------------------------
    "&-tip": {
      color: e.spinDotDefault
    },
    // dots
    // ------------------------------
    [`${e.componentCls}-dot`]: {
      position: "relative",
      display: "inline-block",
      fontSize: e.spinDotSize,
      width: "1em",
      height: "1em",
      "&-item": {
        position: "absolute",
        display: "block",
        width: (e.spinDotSize - e.marginXXS / 2) / 2,
        height: (e.spinDotSize - e.marginXXS / 2) / 2,
        backgroundColor: e.colorPrimary,
        borderRadius: "100%",
        transform: "scale(0.75)",
        transformOrigin: "50% 50%",
        opacity: 0.3,
        animationName: _q,
        animationDuration: "1s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear",
        animationDirection: "alternate",
        "&:nth-child(1)": {
          top: 0,
          insetInlineStart: 0
        },
        "&:nth-child(2)": {
          top: 0,
          insetInlineEnd: 0,
          animationDelay: "0.4s"
        },
        "&:nth-child(3)": {
          insetInlineEnd: 0,
          bottom: 0,
          animationDelay: "0.8s"
        },
        "&:nth-child(4)": {
          bottom: 0,
          insetInlineStart: 0,
          animationDelay: "1.2s"
        }
      },
      "&-spin": {
        transform: "rotate(45deg)",
        animationName: Aq,
        animationDuration: "1.2s",
        animationIterationCount: "infinite",
        animationTimingFunction: "linear"
      }
    },
    // Sizes
    // ------------------------------
    // small
    [`&-sm ${e.componentCls}-dot`]: {
      fontSize: e.spinDotSizeSM,
      i: {
        width: (e.spinDotSizeSM - e.marginXXS / 2) / 2,
        height: (e.spinDotSizeSM - e.marginXXS / 2) / 2
      }
    },
    // large
    [`&-lg ${e.componentCls}-dot`]: {
      fontSize: e.spinDotSizeLG,
      i: {
        width: (e.spinDotSizeLG - e.marginXXS) / 2,
        height: (e.spinDotSizeLG - e.marginXXS) / 2
      }
    },
    [`&${e.componentCls}-show-text ${e.componentCls}-text`]: {
      display: "block"
    }
  })
}), Nq = Xe("Spin", (e) => {
  const t = He(e, {
    spinDotDefault: e.colorTextDescription,
    spinDotSize: e.controlHeightLG / 2,
    spinDotSizeSM: e.controlHeightLG * 0.35,
    spinDotSizeLG: e.controlHeight
  });
  return [Dq(t)];
}, {
  contentHeight: 400
});
var Rq = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const kq = () => ({
  prefixCls: String,
  spinning: {
    type: Boolean,
    default: void 0
  },
  size: String,
  wrapperClassName: String,
  tip: V.any,
  delay: Number,
  indicator: V.any
});
let Fu = null;
function Bq(e, t) {
  return !!e && !!t && !isNaN(Number(t));
}
function Fq(e) {
  const t = e.indicator;
  Fu = typeof t == "function" ? t : () => f(t, null, null);
}
const br = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASpin",
  inheritAttrs: !1,
  props: Qe(kq(), {
    size: "default",
    spinning: !0,
    wrapperClassName: ""
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      prefixCls: r,
      size: l,
      direction: a
    } = Ie("spin", e), [i, s] = Nq(r), c = Q(e.spinning && !Bq(e.spinning, e.delay));
    let u;
    return ie([() => e.spinning, () => e.delay], () => {
      u == null || u.cancel(), u = Mq(e.delay, () => {
        c.value = e.spinning;
      }), u == null || u();
    }, {
      immediate: !0,
      flush: "post"
    }), et(() => {
      u == null || u.cancel();
    }), () => {
      var d, p;
      const {
        class: v
      } = n, h = Rq(n, ["class"]), {
        tip: g = (d = o.tip) === null || d === void 0 ? void 0 : d.call(o)
      } = e, b = (p = o.default) === null || p === void 0 ? void 0 : p.call(o), y = {
        [s.value]: !0,
        [r.value]: !0,
        [`${r.value}-sm`]: l.value === "small",
        [`${r.value}-lg`]: l.value === "large",
        [`${r.value}-spinning`]: c.value,
        [`${r.value}-show-text`]: !!g,
        [`${r.value}-rtl`]: a.value === "rtl",
        [v]: !!v
      };
      function S(w) {
        const $ = `${w}-dot`;
        let O = an(o, e, "indicator");
        return O === null ? null : (Array.isArray(O) && (O = O.length === 1 ? O[0] : O), In(O) ? tr(O, {
          class: $
        }) : Fu && In(Fu()) ? tr(Fu(), {
          class: $
        }) : f("span", {
          class: `${$} ${w}-dot-spin`
        }, [f("i", {
          class: `${w}-dot-item`
        }, null), f("i", {
          class: `${w}-dot-item`
        }, null), f("i", {
          class: `${w}-dot-item`
        }, null), f("i", {
          class: `${w}-dot-item`
        }, null)]));
      }
      const C = f("div", D(D({}, h), {}, {
        class: y,
        "aria-live": "polite",
        "aria-busy": c.value
      }), [S(r.value), g ? f("div", {
        class: `${r.value}-text`
      }, [g]) : null]);
      if (b && Lt(b).length) {
        const w = {
          [`${r.value}-container`]: !0,
          [`${r.value}-blur`]: c.value
        };
        return i(f("div", {
          class: [`${r.value}-nested-loading`, e.wrapperClassName, s.value]
        }, [c.value && f("div", {
          key: "loading"
        }, [C]), f("div", {
          class: w,
          key: "container"
        }, [b])]));
      }
      return i(C);
    };
  }
});
br.setDefaultIndicator = Fq;
br.install = function(e) {
  return e.component(br.name, br), e;
};
var Lq = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M272.9 512l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L186.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H532c6.7 0 10.4-7.7 6.3-12.9L272.9 512zm304 0l265.4-339.1c4.1-5.2.4-12.9-6.3-12.9h-77.3c-4.9 0-9.6 2.3-12.6 6.1L490.8 492.3a31.99 31.99 0 000 39.5l255.3 326.1c3 3.9 7.7 6.1 12.6 6.1H836c6.7 0 10.4-7.7 6.3-12.9L576.9 512z" } }] }, name: "double-left", theme: "outlined" };
function k$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      zq(e, r, n[r]);
    });
  }
  return e;
}
function zq(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Qd = function(t, n) {
  var o = k$({}, t, n.attrs);
  return f(Ge, k$({}, o, {
    icon: Lq
  }), null);
};
Qd.displayName = "DoubleLeftOutlined";
Qd.inheritAttrs = !1;
var Hq = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M533.2 492.3L277.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H188c-6.7 0-10.4 7.7-6.3 12.9L447.1 512 181.7 851.1A7.98 7.98 0 00188 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5zm304 0L581.9 166.1c-3-3.9-7.7-6.1-12.6-6.1H492c-6.7 0-10.4 7.7-6.3 12.9L751.1 512 485.7 851.1A7.98 7.98 0 00492 864h77.3c4.9 0 9.6-2.3 12.6-6.1l255.3-326.1c9.1-11.7 9.1-27.9 0-39.5z" } }] }, name: "double-right", theme: "outlined" };
function B$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      jq(e, r, n[r]);
    });
  }
  return e;
}
function jq(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Jd = function(t, n) {
  var o = B$({}, t, n.attrs);
  return f(Ge, B$({}, o, {
    icon: Hq
  }), null);
};
Jd.displayName = "DoubleRightOutlined";
Jd.inheritAttrs = !1;
const Vq = Z({
  name: "MiniSelect",
  compatConfig: {
    MODE: 3
  },
  inheritAttrs: !1,
  props: Xf(),
  Option: bn.Option,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    return () => {
      const r = m(m(m({}, e), {
        size: "small"
      }), n);
      return f(bn, r, o);
    };
  }
}), Wq = Z({
  name: "MiddleSelect",
  inheritAttrs: !1,
  props: Xf(),
  Option: bn.Option,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    return () => {
      const r = m(m(m({}, e), {
        size: "middle"
      }), n);
      return f(bn, r, o);
    };
  }
}), Rl = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Pager",
  inheritAttrs: !1,
  props: {
    rootPrefixCls: String,
    page: Number,
    active: {
      type: Boolean,
      default: void 0
    },
    last: {
      type: Boolean,
      default: void 0
    },
    locale: V.object,
    showTitle: {
      type: Boolean,
      default: void 0
    },
    itemRender: {
      type: Function,
      default: () => {
      }
    },
    onClick: {
      type: Function
    },
    onKeypress: {
      type: Function
    }
  },
  eimt: ["click", "keypress"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o
    } = t;
    const r = () => {
      n("click", e.page);
    }, l = (a) => {
      n("keypress", a, r, e.page);
    };
    return () => {
      const {
        showTitle: a,
        page: i,
        itemRender: s
      } = e, {
        class: c,
        style: u
      } = o, d = `${e.rootPrefixCls}-item`, p = ee(d, `${d}-${e.page}`, {
        [`${d}-active`]: e.active,
        [`${d}-disabled`]: !e.page
      }, c);
      return f("li", {
        onClick: r,
        onKeypress: l,
        title: a ? String(i) : null,
        tabindex: "0",
        class: p,
        style: u
      }, [s({
        page: i,
        type: "page",
        originalElement: f("a", {
          rel: "nofollow"
        }, [i])
      })]);
    };
  }
}), Ll = {
  ZERO: 48,
  NINE: 57,
  NUMPAD_ZERO: 96,
  NUMPAD_NINE: 105,
  BACKSPACE: 8,
  DELETE: 46,
  ENTER: 13,
  ARROW_UP: 38,
  ARROW_DOWN: 40
}, Kq = Z({
  compatConfig: {
    MODE: 3
  },
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    changeSize: Function,
    quickGo: Function,
    selectComponentClass: V.any,
    current: Number,
    pageSizeOptions: V.array.def(["10", "20", "50", "100"]),
    pageSize: Number,
    buildOptionText: Function,
    locale: V.object,
    rootPrefixCls: String,
    selectPrefixCls: String,
    goButton: V.any
  },
  setup(e) {
    const t = Y(""), n = P(() => !t.value || isNaN(t.value) ? void 0 : Number(t.value)), o = (s) => `${s.value} ${e.locale.items_per_page}`, r = (s) => {
      const {
        value: c
      } = s.target;
      t.value !== c && (t.value = c);
    }, l = (s) => {
      const {
        goButton: c,
        quickGo: u,
        rootPrefixCls: d
      } = e;
      if (!(c || t.value === ""))
        if (s.relatedTarget && (s.relatedTarget.className.indexOf(`${d}-item-link`) >= 0 || s.relatedTarget.className.indexOf(`${d}-item`) >= 0)) {
          t.value = "";
          return;
        } else
          u(n.value), t.value = "";
    }, a = (s) => {
      t.value !== "" && (s.keyCode === Ll.ENTER || s.type === "click") && (e.quickGo(n.value), t.value = "");
    }, i = P(() => {
      const {
        pageSize: s,
        pageSizeOptions: c
      } = e;
      return c.some((u) => u.toString() === s.toString()) ? c : c.concat([s.toString()]).sort((u, d) => {
        const p = isNaN(Number(u)) ? 0 : Number(u), v = isNaN(Number(d)) ? 0 : Number(d);
        return p - v;
      });
    });
    return () => {
      const {
        rootPrefixCls: s,
        locale: c,
        changeSize: u,
        quickGo: d,
        goButton: p,
        selectComponentClass: v,
        selectPrefixCls: h,
        pageSize: g,
        disabled: b
      } = e, y = `${s}-options`;
      let S = null, C = null, w = null;
      if (!u && !d)
        return null;
      if (u && v) {
        const $ = e.buildOptionText || o, O = i.value.map((x, I) => f(v.Option, {
          key: I,
          value: x
        }, {
          default: () => [$({
            value: x
          })]
        }));
        S = f(v, {
          disabled: b,
          prefixCls: h,
          showSearch: !1,
          class: `${y}-size-changer`,
          optionLabelProp: "children",
          value: (g || i.value[0]).toString(),
          onChange: (x) => u(Number(x)),
          getPopupContainer: (x) => x.parentNode
        }, {
          default: () => [O]
        });
      }
      return d && (p && (w = typeof p == "boolean" ? f("button", {
        type: "button",
        onClick: a,
        onKeyup: a,
        disabled: b,
        class: `${y}-quick-jumper-button`
      }, [c.jump_to_confirm]) : f("span", {
        onClick: a,
        onKeyup: a
      }, [p])), C = f("div", {
        class: `${y}-quick-jumper`
      }, [c.jump_to, f(Ti, {
        disabled: b,
        type: "text",
        value: t.value,
        onInput: r,
        onChange: r,
        onKeyup: a,
        onBlur: l
      }, null), c.page, w])), f("li", {
        class: `${y}`
      }, [S, C]);
    };
  }
});
var Gq = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function Xq(e) {
  return typeof e == "number" && isFinite(e) && Math.floor(e) === e;
}
function Uq(e) {
  let {
    originalElement: t
  } = e;
  return t;
}
function Mr(e, t, n) {
  const o = typeof e > "u" ? t.statePageSize : e;
  return Math.floor((n.total - 1) / o) + 1;
}
const Yq = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Pagination",
  mixins: [Ca],
  inheritAttrs: !1,
  props: {
    disabled: {
      type: Boolean,
      default: void 0
    },
    prefixCls: V.string.def("rc-pagination"),
    selectPrefixCls: V.string.def("rc-select"),
    current: Number,
    defaultCurrent: V.number.def(1),
    total: V.number.def(0),
    pageSize: Number,
    defaultPageSize: V.number.def(10),
    hideOnSinglePage: {
      type: Boolean,
      default: !1
    },
    showSizeChanger: {
      type: Boolean,
      default: void 0
    },
    showLessItems: {
      type: Boolean,
      default: !1
    },
    // showSizeChange: PropTypes.func.def(noop),
    selectComponentClass: V.any,
    showPrevNextJumpers: {
      type: Boolean,
      default: !0
    },
    showQuickJumper: V.oneOfType([V.looseBool, V.object]).def(!1),
    showTitle: {
      type: Boolean,
      default: !0
    },
    pageSizeOptions: V.arrayOf(V.oneOfType([V.number, V.string])),
    buildOptionText: Function,
    showTotal: Function,
    simple: {
      type: Boolean,
      default: void 0
    },
    locale: V.object.def(Bx),
    itemRender: V.func.def(Uq),
    prevIcon: V.any,
    nextIcon: V.any,
    jumpPrevIcon: V.any,
    jumpNextIcon: V.any,
    totalBoundaryShowSizeChanger: V.number.def(50)
  },
  data() {
    const e = this.$props;
    let t = xd([this.current, this.defaultCurrent]);
    const n = xd([this.pageSize, this.defaultPageSize]);
    return t = Math.min(t, Mr(n, void 0, e)), {
      stateCurrent: t,
      stateCurrentInputValue: t,
      statePageSize: n
    };
  },
  watch: {
    current(e) {
      this.setState({
        stateCurrent: e,
        stateCurrentInputValue: e
      });
    },
    pageSize(e) {
      const t = {};
      let n = this.stateCurrent;
      const o = Mr(e, this.$data, this.$props);
      n = n > o ? o : n, Rr(this, "current") || (t.stateCurrent = n, t.stateCurrentInputValue = n), t.statePageSize = e, this.setState(t);
    },
    stateCurrent(e, t) {
      this.$nextTick(() => {
        if (this.$refs.paginationNode) {
          const n = this.$refs.paginationNode.querySelector(`.${this.prefixCls}-item-${t}`);
          n && document.activeElement === n && n.blur();
        }
      });
    },
    total() {
      const e = {}, t = Mr(this.pageSize, this.$data, this.$props);
      if (Rr(this, "current")) {
        const n = Math.min(this.current, t);
        e.stateCurrent = n, e.stateCurrentInputValue = n;
      } else {
        let n = this.stateCurrent;
        n === 0 && t > 0 ? n = 1 : n = Math.min(this.stateCurrent, t), e.stateCurrent = n;
      }
      this.setState(e);
    }
  },
  methods: {
    getJumpPrevPage() {
      return Math.max(1, this.stateCurrent - (this.showLessItems ? 3 : 5));
    },
    getJumpNextPage() {
      return Math.min(Mr(void 0, this.$data, this.$props), this.stateCurrent + (this.showLessItems ? 3 : 5));
    },
    getItemIcon(e, t) {
      const {
        prefixCls: n
      } = this.$props;
      return Gx(this, e, this.$props) || f("button", {
        type: "button",
        "aria-label": t,
        class: `${n}-item-link`
      }, null);
    },
    getValidValue(e) {
      const t = e.target.value, n = Mr(void 0, this.$data, this.$props), {
        stateCurrentInputValue: o
      } = this.$data;
      let r;
      return t === "" ? r = t : isNaN(Number(t)) ? r = o : t >= n ? r = n : r = Number(t), r;
    },
    isValid(e) {
      return Xq(e) && e !== this.stateCurrent;
    },
    shouldDisplayQuickJumper() {
      const {
        showQuickJumper: e,
        pageSize: t,
        total: n
      } = this.$props;
      return n <= t ? !1 : e;
    },
    // calculatePage (p) {
    //   let pageSize = p
    //   if (typeof pageSize === 'undefined') {
    //     pageSize = this.statePageSize
    //   }
    //   return Math.floor((this.total - 1) / pageSize) + 1
    // },
    handleKeyDown(e) {
      (e.keyCode === Ll.ARROW_UP || e.keyCode === Ll.ARROW_DOWN) && e.preventDefault();
    },
    handleKeyUp(e) {
      const t = this.getValidValue(e), n = this.stateCurrentInputValue;
      t !== n && this.setState({
        stateCurrentInputValue: t
      }), e.keyCode === Ll.ENTER ? this.handleChange(t) : e.keyCode === Ll.ARROW_UP ? this.handleChange(t - 1) : e.keyCode === Ll.ARROW_DOWN && this.handleChange(t + 1);
    },
    changePageSize(e) {
      let t = this.stateCurrent;
      const n = t, o = Mr(e, this.$data, this.$props);
      t = t > o ? o : t, o === 0 && (t = this.stateCurrent), typeof e == "number" && (Rr(this, "pageSize") || this.setState({
        statePageSize: e
      }), Rr(this, "current") || this.setState({
        stateCurrent: t,
        stateCurrentInputValue: t
      })), this.__emit("update:pageSize", e), t !== n && this.__emit("update:current", t), this.__emit("showSizeChange", t, e), this.__emit("change", t, e);
    },
    handleChange(e) {
      const {
        disabled: t
      } = this.$props;
      let n = e;
      if (this.isValid(n) && !t) {
        const o = Mr(void 0, this.$data, this.$props);
        return n > o ? n = o : n < 1 && (n = 1), Rr(this, "current") || this.setState({
          stateCurrent: n,
          stateCurrentInputValue: n
        }), this.__emit("update:current", n), this.__emit("change", n, this.statePageSize), n;
      }
      return this.stateCurrent;
    },
    prev() {
      this.hasPrev() && this.handleChange(this.stateCurrent - 1);
    },
    next() {
      this.hasNext() && this.handleChange(this.stateCurrent + 1);
    },
    jumpPrev() {
      this.handleChange(this.getJumpPrevPage());
    },
    jumpNext() {
      this.handleChange(this.getJumpNextPage());
    },
    hasPrev() {
      return this.stateCurrent > 1;
    },
    hasNext() {
      return this.stateCurrent < Mr(void 0, this.$data, this.$props);
    },
    getShowSizeChanger() {
      const {
        showSizeChanger: e,
        total: t,
        totalBoundaryShowSizeChanger: n
      } = this.$props;
      return typeof e < "u" ? e : t > n;
    },
    runIfEnter(e, t) {
      if (e.key === "Enter" || e.charCode === 13) {
        e.preventDefault();
        for (var n = arguments.length, o = new Array(n > 2 ? n - 2 : 0), r = 2; r < n; r++)
          o[r - 2] = arguments[r];
        t(...o);
      }
    },
    runIfEnterPrev(e) {
      this.runIfEnter(e, this.prev);
    },
    runIfEnterNext(e) {
      this.runIfEnter(e, this.next);
    },
    runIfEnterJumpPrev(e) {
      this.runIfEnter(e, this.jumpPrev);
    },
    runIfEnterJumpNext(e) {
      this.runIfEnter(e, this.jumpNext);
    },
    handleGoTO(e) {
      (e.keyCode === Ll.ENTER || e.type === "click") && this.handleChange(this.stateCurrentInputValue);
    },
    renderPrev(e) {
      const {
        itemRender: t
      } = this.$props, n = t({
        page: e,
        type: "prev",
        originalElement: this.getItemIcon("prevIcon", "prev page")
      }), o = !this.hasPrev();
      return Gt(n) ? yt(n, o ? {
        disabled: o
      } : {}) : n;
    },
    renderNext(e) {
      const {
        itemRender: t
      } = this.$props, n = t({
        page: e,
        type: "next",
        originalElement: this.getItemIcon("nextIcon", "next page")
      }), o = !this.hasNext();
      return Gt(n) ? yt(n, o ? {
        disabled: o
      } : {}) : n;
    }
  },
  render() {
    const {
      prefixCls: e,
      disabled: t,
      hideOnSinglePage: n,
      total: o,
      locale: r,
      showQuickJumper: l,
      showLessItems: a,
      showTitle: i,
      showTotal: s,
      simple: c,
      itemRender: u,
      showPrevNextJumpers: d,
      jumpPrevIcon: p,
      jumpNextIcon: v,
      selectComponentClass: h,
      selectPrefixCls: g,
      pageSizeOptions: b
    } = this.$props, {
      stateCurrent: y,
      statePageSize: S
    } = this, C = rh(this.$attrs).extraAttrs, {
      class: w
    } = C, $ = Gq(C, ["class"]);
    if (n === !0 && this.total <= S)
      return null;
    const O = Mr(void 0, this.$data, this.$props), x = [];
    let I = null, E = null, _ = null, M = null, R = null;
    const A = l && l.goButton, z = a ? 1 : 2, T = y - 1 > 0 ? y - 1 : 0, N = y + 1 < O ? y + 1 : O, k = this.hasPrev(), B = this.hasNext();
    if (c)
      return A && (typeof A == "boolean" ? R = f("button", {
        type: "button",
        onClick: this.handleGoTO,
        onKeyup: this.handleGoTO
      }, [r.jump_to_confirm]) : R = f("span", {
        onClick: this.handleGoTO,
        onKeyup: this.handleGoTO
      }, [A]), R = f("li", {
        title: i ? `${r.jump_to}${y}/${O}` : null,
        class: `${e}-simple-pager`
      }, [R])), f("ul", D({
        class: ee(`${e} ${e}-simple`, {
          [`${e}-disabled`]: t
        }, w)
      }, $), [f("li", {
        title: i ? r.prev_page : null,
        onClick: this.prev,
        tabindex: k ? 0 : null,
        onKeypress: this.runIfEnterPrev,
        class: ee(`${e}-prev`, {
          [`${e}-disabled`]: !k
        }),
        "aria-disabled": !k
      }, [this.renderPrev(T)]), f("li", {
        title: i ? `${y}/${O}` : null,
        class: `${e}-simple-pager`
      }, [f(Ti, {
        type: "text",
        value: this.stateCurrentInputValue,
        disabled: t,
        onKeydown: this.handleKeyDown,
        onKeyup: this.handleKeyUp,
        onInput: this.handleKeyUp,
        onChange: this.handleKeyUp,
        size: "3"
      }, null), f("span", {
        class: `${e}-slash`
      }, [Ot("／")]), O]), f("li", {
        title: i ? r.next_page : null,
        onClick: this.next,
        tabindex: B ? 0 : null,
        onKeypress: this.runIfEnterNext,
        class: ee(`${e}-next`, {
          [`${e}-disabled`]: !B
        }),
        "aria-disabled": !B
      }, [this.renderNext(N)]), R]);
    if (O <= 3 + z * 2) {
      const K = {
        locale: r,
        rootPrefixCls: e,
        showTitle: i,
        itemRender: u,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter
      };
      O || x.push(f(Rl, D(D({}, K), {}, {
        key: "noPager",
        page: 1,
        class: `${e}-item-disabled`
      }), null));
      for (let X = 1; X <= O; X += 1) {
        const W = y === X;
        x.push(f(Rl, D(D({}, K), {}, {
          key: X,
          page: X,
          active: W
        }), null));
      }
    } else {
      const K = a ? r.prev_3 : r.prev_5, X = a ? r.next_3 : r.next_5;
      d && (I = f("li", {
        title: this.showTitle ? K : null,
        key: "prev",
        onClick: this.jumpPrev,
        tabindex: "0",
        onKeypress: this.runIfEnterJumpPrev,
        class: ee(`${e}-jump-prev`, {
          [`${e}-jump-prev-custom-icon`]: !!p
        })
      }, [u({
        page: this.getJumpPrevPage(),
        type: "jump-prev",
        originalElement: this.getItemIcon("jumpPrevIcon", "prev page")
      })]), E = f("li", {
        title: this.showTitle ? X : null,
        key: "next",
        tabindex: "0",
        onClick: this.jumpNext,
        onKeypress: this.runIfEnterJumpNext,
        class: ee(`${e}-jump-next`, {
          [`${e}-jump-next-custom-icon`]: !!v
        })
      }, [u({
        page: this.getJumpNextPage(),
        type: "jump-next",
        originalElement: this.getItemIcon("jumpNextIcon", "next page")
      })])), M = f(Rl, {
        locale: r,
        last: !0,
        rootPrefixCls: e,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: O,
        page: O,
        active: !1,
        showTitle: i,
        itemRender: u
      }, null), _ = f(Rl, {
        locale: r,
        rootPrefixCls: e,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: 1,
        page: 1,
        active: !1,
        showTitle: i,
        itemRender: u
      }, null);
      let W = Math.max(1, y - z), q = Math.min(y + z, O);
      y - 1 <= z && (q = 1 + z * 2), O - y <= z && (W = O - z * 2);
      for (let J = W; J <= q; J += 1) {
        const ne = y === J;
        x.push(f(Rl, {
          locale: r,
          rootPrefixCls: e,
          onClick: this.handleChange,
          onKeypress: this.runIfEnter,
          key: J,
          page: J,
          active: ne,
          showTitle: i,
          itemRender: u
        }, null));
      }
      y - 1 >= z * 2 && y !== 3 && (x[0] = f(Rl, {
        locale: r,
        rootPrefixCls: e,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: W,
        page: W,
        class: `${e}-item-after-jump-prev`,
        active: !1,
        showTitle: this.showTitle,
        itemRender: u
      }, null), x.unshift(I)), O - y >= z * 2 && y !== O - 2 && (x[x.length - 1] = f(Rl, {
        locale: r,
        rootPrefixCls: e,
        onClick: this.handleChange,
        onKeypress: this.runIfEnter,
        key: q,
        page: q,
        class: `${e}-item-before-jump-next`,
        active: !1,
        showTitle: this.showTitle,
        itemRender: u
      }, null), x.push(E)), W !== 1 && x.unshift(_), q !== O && x.push(M);
    }
    let F = null;
    s && (F = f("li", {
      class: `${e}-total-text`
    }, [s(o, [o === 0 ? 0 : (y - 1) * S + 1, y * S > o ? o : y * S])]));
    const L = !k || !O, j = !B || !O, H = this.buildOptionText || this.$slots.buildOptionText;
    return f("ul", D(D({
      unselectable: "on",
      ref: "paginationNode"
    }, $), {}, {
      class: ee({
        [`${e}`]: !0,
        [`${e}-disabled`]: t
      }, w)
    }), [F, f("li", {
      title: i ? r.prev_page : null,
      onClick: this.prev,
      tabindex: L ? null : 0,
      onKeypress: this.runIfEnterPrev,
      class: ee(`${e}-prev`, {
        [`${e}-disabled`]: L
      }),
      "aria-disabled": L
    }, [this.renderPrev(T)]), x, f("li", {
      title: i ? r.next_page : null,
      onClick: this.next,
      tabindex: j ? null : 0,
      onKeypress: this.runIfEnterNext,
      class: ee(`${e}-next`, {
        [`${e}-disabled`]: j
      }),
      "aria-disabled": j
    }, [this.renderNext(N)]), f(Kq, {
      disabled: t,
      locale: r,
      rootPrefixCls: e,
      selectComponentClass: h,
      selectPrefixCls: g,
      changeSize: this.getShowSizeChanger() ? this.changePageSize : null,
      current: y,
      pageSize: S,
      pageSizeOptions: b,
      buildOptionText: H || null,
      quickGo: this.shouldDisplayQuickJumper() ? this.handleChange : null,
      goButton: A
    }, null)]);
  }
}), qq = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-disabled`]: {
      "&, &:hover": {
        cursor: "not-allowed",
        [`${t}-item-link`]: {
          color: e.colorTextDisabled,
          cursor: "not-allowed"
        }
      },
      "&:focus-visible": {
        cursor: "not-allowed",
        [`${t}-item-link`]: {
          color: e.colorTextDisabled,
          cursor: "not-allowed"
        }
      }
    },
    [`&${t}-disabled`]: {
      cursor: "not-allowed",
      [`&${t}-mini`]: {
        [`
          &:hover ${t}-item:not(${t}-item-active),
          &:active ${t}-item:not(${t}-item-active),
          &:hover ${t}-item-link,
          &:active ${t}-item-link
        `]: {
          backgroundColor: "transparent"
        }
      },
      [`${t}-item`]: {
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        a: {
          color: e.colorTextDisabled,
          backgroundColor: "transparent",
          border: "none",
          cursor: "not-allowed"
        },
        "&-active": {
          borderColor: e.colorBorder,
          backgroundColor: e.paginationItemDisabledBgActive,
          "&:hover, &:active": {
            backgroundColor: e.paginationItemDisabledBgActive
          },
          a: {
            color: e.paginationItemDisabledColorActive
          }
        }
      },
      [`${t}-item-link`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        "&:hover, &:active": {
          backgroundColor: "transparent"
        },
        [`${t}-simple&`]: {
          backgroundColor: "transparent",
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      },
      [`${t}-simple-pager`]: {
        color: e.colorTextDisabled
      },
      [`${t}-jump-prev, ${t}-jump-next`]: {
        [`${t}-item-link-icon`]: {
          opacity: 0
        },
        [`${t}-item-ellipsis`]: {
          opacity: 1
        }
      }
    },
    [`&${t}-simple`]: {
      [`${t}-prev, ${t}-next`]: {
        [`&${t}-disabled ${t}-item-link`]: {
          "&:hover, &:active": {
            backgroundColor: "transparent"
          }
        }
      }
    }
  };
}, Zq = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`&${t}-mini ${t}-total-text, &${t}-mini ${t}-simple-pager`]: {
      height: e.paginationItemSizeSM,
      lineHeight: `${e.paginationItemSizeSM}px`
    },
    [`&${t}-mini ${t}-item`]: {
      minWidth: e.paginationItemSizeSM,
      height: e.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${e.paginationItemSizeSM - 2}px`
    },
    [`&${t}-mini ${t}-item:not(${t}-item-active)`]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&:hover": {
        backgroundColor: e.colorBgTextHover
      },
      "&:active": {
        backgroundColor: e.colorBgTextActive
      }
    },
    [`&${t}-mini ${t}-prev, &${t}-mini ${t}-next`]: {
      minWidth: e.paginationItemSizeSM,
      height: e.paginationItemSizeSM,
      margin: 0,
      lineHeight: `${e.paginationItemSizeSM}px`,
      [`&:hover ${t}-item-link`]: {
        backgroundColor: e.colorBgTextHover
      },
      [`&:active ${t}-item-link`]: {
        backgroundColor: e.colorBgTextActive
      },
      [`&${t}-disabled:hover ${t}-item-link`]: {
        backgroundColor: "transparent"
      }
    },
    [`
    &${t}-mini ${t}-prev ${t}-item-link,
    &${t}-mini ${t}-next ${t}-item-link
    `]: {
      backgroundColor: "transparent",
      borderColor: "transparent",
      "&::after": {
        height: e.paginationItemSizeSM,
        lineHeight: `${e.paginationItemSizeSM}px`
      }
    },
    [`&${t}-mini ${t}-jump-prev, &${t}-mini ${t}-jump-next`]: {
      height: e.paginationItemSizeSM,
      marginInlineEnd: 0,
      lineHeight: `${e.paginationItemSizeSM}px`
    },
    [`&${t}-mini ${t}-options`]: {
      marginInlineStart: e.paginationMiniOptionsMarginInlineStart,
      "&-size-changer": {
        top: e.paginationMiniOptionsSizeChangerTop
      },
      "&-quick-jumper": {
        height: e.paginationItemSizeSM,
        lineHeight: `${e.paginationItemSizeSM}px`,
        input: m(m({}, K0(e)), {
          width: e.paginationMiniQuickJumperInputWidth,
          height: e.controlHeightSM
        })
      }
    }
  };
}, Qq = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`
    &${t}-simple ${t}-prev,
    &${t}-simple ${t}-next
    `]: {
      height: e.paginationItemSizeSM,
      lineHeight: `${e.paginationItemSizeSM}px`,
      verticalAlign: "top",
      [`${t}-item-link`]: {
        height: e.paginationItemSizeSM,
        backgroundColor: "transparent",
        border: 0,
        "&:hover": {
          backgroundColor: e.colorBgTextHover
        },
        "&:active": {
          backgroundColor: e.colorBgTextActive
        },
        "&::after": {
          height: e.paginationItemSizeSM,
          lineHeight: `${e.paginationItemSizeSM}px`
        }
      }
    },
    [`&${t}-simple ${t}-simple-pager`]: {
      display: "inline-block",
      height: e.paginationItemSizeSM,
      marginInlineEnd: e.marginXS,
      input: {
        boxSizing: "border-box",
        height: "100%",
        marginInlineEnd: e.marginXS,
        padding: `0 ${e.paginationItemPaddingInline}px`,
        textAlign: "center",
        backgroundColor: e.paginationItemInputBg,
        border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
        borderRadius: e.borderRadius,
        outline: "none",
        transition: `border-color ${e.motionDurationMid}`,
        color: "inherit",
        "&:hover": {
          borderColor: e.colorPrimary
        },
        "&:focus": {
          borderColor: e.colorPrimaryHover,
          boxShadow: `${e.inputOutlineOffset}px 0 ${e.controlOutlineWidth}px ${e.controlOutline}`
        },
        "&[disabled]": {
          color: e.colorTextDisabled,
          backgroundColor: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          cursor: "not-allowed"
        }
      }
    }
  };
}, Jq = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-jump-prev, ${t}-jump-next`]: {
      outline: 0,
      [`${t}-item-container`]: {
        position: "relative",
        [`${t}-item-link-icon`]: {
          color: e.colorPrimary,
          fontSize: e.fontSizeSM,
          opacity: 0,
          transition: `all ${e.motionDurationMid}`,
          "&-svg": {
            top: 0,
            insetInlineEnd: 0,
            bottom: 0,
            insetInlineStart: 0,
            margin: "auto"
          }
        },
        [`${t}-item-ellipsis`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          display: "block",
          margin: "auto",
          color: e.colorTextDisabled,
          fontFamily: "Arial, Helvetica, sans-serif",
          letterSpacing: e.paginationEllipsisLetterSpacing,
          textAlign: "center",
          textIndent: e.paginationEllipsisTextIndent,
          opacity: 1,
          transition: `all ${e.motionDurationMid}`
        }
      },
      "&:hover": {
        [`${t}-item-link-icon`]: {
          opacity: 1
        },
        [`${t}-item-ellipsis`]: {
          opacity: 0
        }
      },
      "&:focus-visible": m({
        [`${t}-item-link-icon`]: {
          opacity: 1
        },
        [`${t}-item-ellipsis`]: {
          opacity: 0
        }
      }, Gr(e))
    },
    [`
    ${t}-prev,
    ${t}-jump-prev,
    ${t}-jump-next
    `]: {
      marginInlineEnd: e.marginXS
    },
    [`
    ${t}-prev,
    ${t}-next,
    ${t}-jump-prev,
    ${t}-jump-next
    `]: {
      display: "inline-block",
      minWidth: e.paginationItemSize,
      height: e.paginationItemSize,
      color: e.colorText,
      fontFamily: e.paginationFontFamily,
      lineHeight: `${e.paginationItemSize}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      borderRadius: e.borderRadius,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid}`
    },
    [`${t}-prev, ${t}-next`]: {
      fontFamily: "Arial, Helvetica, sans-serif",
      outline: 0,
      button: {
        color: e.colorText,
        cursor: "pointer",
        userSelect: "none"
      },
      [`${t}-item-link`]: {
        display: "block",
        width: "100%",
        height: "100%",
        padding: 0,
        fontSize: e.fontSizeSM,
        textAlign: "center",
        backgroundColor: "transparent",
        border: `${e.lineWidth}px ${e.lineType} transparent`,
        borderRadius: e.borderRadius,
        outline: "none",
        transition: `all ${e.motionDurationMid}`
      },
      [`&:focus-visible ${t}-item-link`]: m({}, Gr(e)),
      [`&:hover ${t}-item-link`]: {
        backgroundColor: e.colorBgTextHover
      },
      [`&:active ${t}-item-link`]: {
        backgroundColor: e.colorBgTextActive
      },
      [`&${t}-disabled:hover`]: {
        [`${t}-item-link`]: {
          backgroundColor: "transparent"
        }
      }
    },
    [`${t}-slash`]: {
      marginInlineEnd: e.paginationSlashMarginInlineEnd,
      marginInlineStart: e.paginationSlashMarginInlineStart
    },
    [`${t}-options`]: {
      display: "inline-block",
      marginInlineStart: e.margin,
      verticalAlign: "middle",
      "&-size-changer.-select": {
        display: "inline-block",
        width: "auto"
      },
      "&-quick-jumper": {
        display: "inline-block",
        height: e.controlHeight,
        marginInlineStart: e.marginXS,
        lineHeight: `${e.controlHeight}px`,
        verticalAlign: "top",
        input: m(m({}, Oa(e)), {
          width: e.controlHeightLG * 1.25,
          height: e.controlHeight,
          boxSizing: "border-box",
          margin: 0,
          marginInlineStart: e.marginXS,
          marginInlineEnd: e.marginXS
        })
      }
    }
  };
}, eZ = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-item`]: m(m({
      display: "inline-block",
      minWidth: e.paginationItemSize,
      height: e.paginationItemSize,
      marginInlineEnd: e.marginXS,
      fontFamily: e.paginationFontFamily,
      lineHeight: `${e.paginationItemSize - 2}px`,
      textAlign: "center",
      verticalAlign: "middle",
      listStyle: "none",
      backgroundColor: "transparent",
      border: `${e.lineWidth}px ${e.lineType} transparent`,
      borderRadius: e.borderRadius,
      outline: 0,
      cursor: "pointer",
      userSelect: "none",
      a: {
        display: "block",
        padding: `0 ${e.paginationItemPaddingInline}px`,
        color: e.colorText,
        transition: "none",
        "&:hover": {
          textDecoration: "none"
        }
      },
      [`&:not(${t}-item-active)`]: {
        "&:hover": {
          transition: `all ${e.motionDurationMid}`,
          backgroundColor: e.colorBgTextHover
        },
        "&:active": {
          backgroundColor: e.colorBgTextActive
        }
      }
    }, Xr(e)), {
      "&-active": {
        fontWeight: e.paginationFontWeightActive,
        backgroundColor: e.paginationItemBgActive,
        borderColor: e.colorPrimary,
        a: {
          color: e.colorPrimary
        },
        "&:hover": {
          borderColor: e.colorPrimaryHover
        },
        "&:hover a": {
          color: e.colorPrimaryHover
        }
      }
    })
  };
}, tZ = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: m(m(m(m(m(m(m(m({}, qe(e)), {
      "ul, ol": {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      "&::after": {
        display: "block",
        clear: "both",
        height: 0,
        overflow: "hidden",
        visibility: "hidden",
        content: '""'
      },
      [`${t}-total-text`]: {
        display: "inline-block",
        height: e.paginationItemSize,
        marginInlineEnd: e.marginXS,
        lineHeight: `${e.paginationItemSize - 2}px`,
        verticalAlign: "middle"
      }
    }), eZ(e)), Jq(e)), Qq(e)), Zq(e)), qq(e)), {
      // media query style
      [`@media only screen and (max-width: ${e.screenLG}px)`]: {
        [`${t}-item`]: {
          "&-after-jump-prev, &-before-jump-next": {
            display: "none"
          }
        }
      },
      [`@media only screen and (max-width: ${e.screenSM}px)`]: {
        [`${t}-options`]: {
          display: "none"
        }
      }
    }),
    // rtl style
    [`&${e.componentCls}-rtl`]: {
      direction: "rtl"
    }
  };
}, nZ = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}${t}-disabled`]: {
      "&, &:hover": {
        [`${t}-item-link`]: {
          borderColor: e.colorBorder
        }
      },
      "&:focus-visible": {
        [`${t}-item-link`]: {
          borderColor: e.colorBorder
        }
      },
      [`${t}-item, ${t}-item-link`]: {
        backgroundColor: e.colorBgContainerDisabled,
        borderColor: e.colorBorder,
        [`&:hover:not(${t}-item-active)`]: {
          backgroundColor: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          a: {
            color: e.colorTextDisabled
          }
        },
        [`&${t}-item-active`]: {
          backgroundColor: e.paginationItemDisabledBgActive
        }
      },
      [`${t}-prev, ${t}-next`]: {
        "&:hover button": {
          backgroundColor: e.colorBgContainerDisabled,
          borderColor: e.colorBorder,
          color: e.colorTextDisabled
        },
        [`${t}-item-link`]: {
          backgroundColor: e.colorBgContainerDisabled,
          borderColor: e.colorBorder
        }
      }
    },
    [t]: {
      [`${t}-prev, ${t}-next`]: {
        "&:hover button": {
          borderColor: e.colorPrimaryHover,
          backgroundColor: e.paginationItemBg
        },
        [`${t}-item-link`]: {
          backgroundColor: e.paginationItemLinkBg,
          borderColor: e.colorBorder
        },
        [`&:hover ${t}-item-link`]: {
          borderColor: e.colorPrimary,
          backgroundColor: e.paginationItemBg,
          color: e.colorPrimary
        },
        [`&${t}-disabled`]: {
          [`${t}-item-link`]: {
            borderColor: e.colorBorder,
            color: e.colorTextDisabled
          }
        }
      },
      [`${t}-item`]: {
        backgroundColor: e.paginationItemBg,
        border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
        [`&:hover:not(${t}-item-active)`]: {
          borderColor: e.colorPrimary,
          backgroundColor: e.paginationItemBg,
          a: {
            color: e.colorPrimary
          }
        },
        "&-active": {
          borderColor: e.colorPrimary
        }
      }
    }
  };
}, oZ = Xe("Pagination", (e) => {
  const t = He(e, {
    paginationItemSize: e.controlHeight,
    paginationFontFamily: e.fontFamily,
    paginationItemBg: e.colorBgContainer,
    paginationItemBgActive: e.colorBgContainer,
    paginationFontWeightActive: e.fontWeightStrong,
    paginationItemSizeSM: e.controlHeightSM,
    paginationItemInputBg: e.colorBgContainer,
    paginationMiniOptionsSizeChangerTop: 0,
    paginationItemDisabledBgActive: e.controlItemBgActiveDisabled,
    paginationItemDisabledColorActive: e.colorTextDisabled,
    paginationItemLinkBg: e.colorBgContainer,
    inputOutlineOffset: "0 0",
    paginationMiniOptionsMarginInlineStart: e.marginXXS / 2,
    paginationMiniQuickJumperInputWidth: e.controlHeightLG * 1.1,
    paginationItemPaddingInline: e.marginXXS * 1.5,
    paginationEllipsisLetterSpacing: e.marginXXS / 2,
    paginationSlashMarginInlineStart: e.marginXXS,
    paginationSlashMarginInlineEnd: e.marginSM,
    paginationEllipsisTextIndent: "0.13em"
    // magic for ui experience
  }, Pa(e));
  return [tZ(t), e.wireframe && nZ(t)];
});
var rZ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const lZ = () => ({
  total: Number,
  defaultCurrent: Number,
  disabled: ve(),
  current: Number,
  defaultPageSize: Number,
  pageSize: Number,
  hideOnSinglePage: ve(),
  showSizeChanger: ve(),
  pageSizeOptions: vt(),
  buildOptionText: le(),
  showQuickJumper: je([Boolean, Object]),
  showTotal: le(),
  size: ke(),
  simple: ve(),
  locale: Object,
  prefixCls: String,
  selectPrefixCls: String,
  totalBoundaryShowSizeChanger: Number,
  selectComponentClass: String,
  itemRender: le(),
  role: String,
  responsive: Boolean,
  showLessItems: ve(),
  onChange: le(),
  onShowSizeChange: le(),
  "onUpdate:current": le(),
  "onUpdate:pageSize": le()
}), aZ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "APagination",
  inheritAttrs: !1,
  props: lZ(),
  // emits: ['change', 'showSizeChange', 'update:current', 'update:pageSize'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      configProvider: l,
      direction: a,
      size: i
    } = Ie("pagination", e), [s, c] = oZ(r), u = P(() => l.getPrefixCls("select", e.selectPrefixCls)), d = ki(), [p] = jo("Pagination", n2, Te(e, "locale")), v = (h) => {
      const g = f("span", {
        class: `${h}-item-ellipsis`
      }, [Ot("•••")]), b = f("button", {
        class: `${h}-item-link`,
        type: "button",
        tabindex: -1
      }, [a.value === "rtl" ? f(Po, null, null) : f(wr, null, null)]), y = f("button", {
        class: `${h}-item-link`,
        type: "button",
        tabindex: -1
      }, [a.value === "rtl" ? f(wr, null, null) : f(Po, null, null)]), S = f("a", {
        rel: "nofollow",
        class: `${h}-item-link`
      }, [f("div", {
        class: `${h}-item-container`
      }, [a.value === "rtl" ? f(Jd, {
        class: `${h}-item-link-icon`
      }, null) : f(Qd, {
        class: `${h}-item-link-icon`
      }, null), g])]), C = f("a", {
        rel: "nofollow",
        class: `${h}-item-link`
      }, [f("div", {
        class: `${h}-item-container`
      }, [a.value === "rtl" ? f(Qd, {
        class: `${h}-item-link-icon`
      }, null) : f(Jd, {
        class: `${h}-item-link-icon`
      }, null), g])]);
      return {
        prevIcon: b,
        nextIcon: y,
        jumpPrevIcon: S,
        jumpNextIcon: C
      };
    };
    return () => {
      var h;
      const {
        itemRender: g = n.itemRender,
        buildOptionText: b = n.buildOptionText,
        selectComponentClass: y,
        responsive: S
      } = e, C = rZ(e, ["itemRender", "buildOptionText", "selectComponentClass", "responsive"]), w = i.value === "small" || !!(!((h = d.value) === null || h === void 0) && h.xs && !i.value && S), $ = m(m(m(m(m({}, C), v(r.value)), {
        prefixCls: r.value,
        selectPrefixCls: u.value,
        selectComponentClass: y || (w ? Vq : Wq),
        locale: p.value,
        buildOptionText: b
      }), o), {
        class: ee({
          [`${r.value}-mini`]: w,
          [`${r.value}-rtl`]: a.value === "rtl"
        }, o.class, c.value),
        itemRender: g
      });
      return s(f(Yq, $, null));
    };
  }
}), xp = kt(aZ), iZ = () => ({
  avatar: V.any,
  description: V.any,
  prefixCls: String,
  title: V.any
}), kI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AListItemMeta",
  props: iZ(),
  displayName: "AListItemMeta",
  __ANT_LIST_ITEM_META: !0,
  slots: Object,
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = Ie("list", e);
    return () => {
      var r, l, a, i, s, c;
      const u = `${o.value}-item-meta`, d = (r = e.title) !== null && r !== void 0 ? r : (l = n.title) === null || l === void 0 ? void 0 : l.call(n), p = (a = e.description) !== null && a !== void 0 ? a : (i = n.description) === null || i === void 0 ? void 0 : i.call(n), v = (s = e.avatar) !== null && s !== void 0 ? s : (c = n.avatar) === null || c === void 0 ? void 0 : c.call(n), h = f("div", {
        class: `${o.value}-item-meta-content`
      }, [d && f("h4", {
        class: `${o.value}-item-meta-title`
      }, [d]), p && f("div", {
        class: `${o.value}-item-meta-description`
      }, [p])]);
      return f("div", {
        class: u
      }, [v && f("div", {
        class: `${o.value}-item-meta-avatar`
      }, [v]), (d || p) && h]);
    };
  }
}), BI = Symbol("ListContextKey");
var sZ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const cZ = () => ({
  prefixCls: String,
  extra: V.any,
  actions: V.array,
  grid: Object,
  colStyle: {
    type: Object,
    default: void 0
  }
}), FI = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AListItem",
  inheritAttrs: !1,
  Meta: kI,
  props: cZ(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      itemLayout: r,
      grid: l
    } = tt(BI, {
      grid: Y(),
      itemLayout: Y()
    }), {
      prefixCls: a
    } = Ie("list", e), i = () => {
      var c;
      const u = ((c = n.default) === null || c === void 0 ? void 0 : c.call(n)) || [];
      let d;
      return u.forEach((p) => {
        ZT(p) && !nc(p) && (d = !0);
      }), d && u.length > 1;
    }, s = () => {
      var c, u;
      const d = (c = e.extra) !== null && c !== void 0 ? c : (u = n.extra) === null || u === void 0 ? void 0 : u.call(n);
      return r.value === "vertical" ? !!d : !i();
    };
    return () => {
      var c, u, d, p, v;
      const {
        class: h
      } = o, g = sZ(o, ["class"]), b = a.value, y = (c = e.extra) !== null && c !== void 0 ? c : (u = n.extra) === null || u === void 0 ? void 0 : u.call(n), S = (d = n.default) === null || d === void 0 ? void 0 : d.call(n);
      let C = (p = e.actions) !== null && p !== void 0 ? p : It((v = n.actions) === null || v === void 0 ? void 0 : v.call(n));
      C = C && !Array.isArray(C) ? [C] : C;
      const w = C && C.length > 0 && f("ul", {
        class: `${b}-item-action`,
        key: "actions"
      }, [C.map((x, I) => f("li", {
        key: `${b}-item-action-${I}`
      }, [x, I !== C.length - 1 && f("em", {
        class: `${b}-item-action-split`
      }, null)]))]), $ = l.value ? "div" : "li", O = f($, D(D({}, g), {}, {
        class: ee(`${b}-item`, {
          [`${b}-item-no-flex`]: !s()
        }, h)
      }), {
        default: () => [r.value === "vertical" && y ? [f("div", {
          class: `${b}-item-main`,
          key: "content"
        }, [S, w]), f("div", {
          class: `${b}-item-extra`,
          key: "extra"
        }, [y])] : [S, w, yt(y, {
          key: "extra"
        })]]
      });
      return l.value ? f(gp, {
        flex: 1,
        style: e.colStyle
      }, {
        default: () => [O]
      }) : O;
    };
  }
}), uZ = (e) => {
  const {
    listBorderedCls: t,
    componentCls: n,
    paddingLG: o,
    margin: r,
    padding: l,
    listItemPaddingSM: a,
    marginLG: i,
    borderRadiusLG: s
  } = e;
  return {
    [`${t}`]: {
      border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
      borderRadius: s,
      [`${n}-header,${n}-footer,${n}-item`]: {
        paddingInline: o
      },
      [`${n}-pagination`]: {
        margin: `${r}px ${i}px`
      }
    },
    [`${t}${n}-sm`]: {
      [`${n}-item,${n}-header,${n}-footer`]: {
        padding: a
      }
    },
    [`${t}${n}-lg`]: {
      [`${n}-item,${n}-header,${n}-footer`]: {
        padding: `${l}px ${o}px`
      }
    }
  };
}, dZ = (e) => {
  const {
    componentCls: t,
    screenSM: n,
    screenMD: o,
    marginLG: r,
    marginSM: l,
    margin: a
  } = e;
  return {
    [`@media screen and (max-width:${o})`]: {
      [`${t}`]: {
        [`${t}-item`]: {
          [`${t}-item-action`]: {
            marginInlineStart: r
          }
        }
      },
      [`${t}-vertical`]: {
        [`${t}-item`]: {
          [`${t}-item-extra`]: {
            marginInlineStart: r
          }
        }
      }
    },
    [`@media screen and (max-width: ${n})`]: {
      [`${t}`]: {
        [`${t}-item`]: {
          flexWrap: "wrap",
          [`${t}-action`]: {
            marginInlineStart: l
          }
        }
      },
      [`${t}-vertical`]: {
        [`${t}-item`]: {
          flexWrap: "wrap-reverse",
          [`${t}-item-main`]: {
            minWidth: e.contentWidth
          },
          [`${t}-item-extra`]: {
            margin: `auto auto ${a}px`
          }
        }
      }
    }
  };
}, fZ = (e) => {
  const {
    componentCls: t,
    antCls: n,
    controlHeight: o,
    minHeight: r,
    paddingSM: l,
    marginLG: a,
    padding: i,
    listItemPadding: s,
    colorPrimary: c,
    listItemPaddingSM: u,
    listItemPaddingLG: d,
    paddingXS: p,
    margin: v,
    colorText: h,
    colorTextDescription: g,
    motionDurationSlow: b,
    lineWidth: y
  } = e;
  return {
    [`${t}`]: m(m({}, qe(e)), {
      position: "relative",
      "*": {
        outline: "none"
      },
      [`${t}-header, ${t}-footer`]: {
        background: "transparent",
        paddingBlock: l
      },
      [`${t}-pagination`]: {
        marginBlockStart: a,
        textAlign: "end",
        // https://github.com/ant-design/ant-design/issues/20037
        [`${n}-pagination-options`]: {
          textAlign: "start"
        }
      },
      [`${t}-spin`]: {
        minHeight: r,
        textAlign: "center"
      },
      [`${t}-items`]: {
        margin: 0,
        padding: 0,
        listStyle: "none"
      },
      [`${t}-item`]: {
        display: "flex",
        alignItems: "center",
        justifyContent: "space-between",
        padding: s,
        color: h,
        [`${t}-item-meta`]: {
          display: "flex",
          flex: 1,
          alignItems: "flex-start",
          maxWidth: "100%",
          [`${t}-item-meta-avatar`]: {
            marginInlineEnd: i
          },
          [`${t}-item-meta-content`]: {
            flex: "1 0",
            width: 0,
            color: h
          },
          [`${t}-item-meta-title`]: {
            marginBottom: e.marginXXS,
            color: h,
            fontSize: e.fontSize,
            lineHeight: e.lineHeight,
            "> a": {
              color: h,
              transition: `all ${b}`,
              "&:hover": {
                color: c
              }
            }
          },
          [`${t}-item-meta-description`]: {
            color: g,
            fontSize: e.fontSize,
            lineHeight: e.lineHeight
          }
        },
        [`${t}-item-action`]: {
          flex: "0 0 auto",
          marginInlineStart: e.marginXXL,
          padding: 0,
          fontSize: 0,
          listStyle: "none",
          "& > li": {
            position: "relative",
            display: "inline-block",
            padding: `0 ${p}px`,
            color: g,
            fontSize: e.fontSize,
            lineHeight: e.lineHeight,
            textAlign: "center",
            "&:first-child": {
              paddingInlineStart: 0
            }
          },
          [`${t}-item-action-split`]: {
            position: "absolute",
            insetBlockStart: "50%",
            insetInlineEnd: 0,
            width: y,
            height: Math.ceil(e.fontSize * e.lineHeight) - e.marginXXS * 2,
            transform: "translateY(-50%)",
            backgroundColor: e.colorSplit
          }
        }
      },
      [`${t}-empty`]: {
        padding: `${i}px 0`,
        color: g,
        fontSize: e.fontSizeSM,
        textAlign: "center"
      },
      [`${t}-empty-text`]: {
        padding: i,
        color: e.colorTextDisabled,
        fontSize: e.fontSize,
        textAlign: "center"
      },
      // ============================ without flex ============================
      [`${t}-item-no-flex`]: {
        display: "block"
      }
    }),
    [`${t}-grid ${n}-col > ${t}-item`]: {
      display: "block",
      maxWidth: "100%",
      marginBlockEnd: v,
      paddingBlock: 0,
      borderBlockEnd: "none"
    },
    [`${t}-vertical ${t}-item`]: {
      alignItems: "initial",
      [`${t}-item-main`]: {
        display: "block",
        flex: 1
      },
      [`${t}-item-extra`]: {
        marginInlineStart: a
      },
      [`${t}-item-meta`]: {
        marginBlockEnd: i,
        [`${t}-item-meta-title`]: {
          marginBlockEnd: l,
          color: h,
          fontSize: e.fontSizeLG,
          lineHeight: e.lineHeightLG
        }
      },
      [`${t}-item-action`]: {
        marginBlockStart: i,
        marginInlineStart: "auto",
        "> li": {
          padding: `0 ${i}px`,
          "&:first-child": {
            paddingInlineStart: 0
          }
        }
      }
    },
    [`${t}-split ${t}-item`]: {
      borderBlockEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
      "&:last-child": {
        borderBlockEnd: "none"
      }
    },
    [`${t}-split ${t}-header`]: {
      borderBlockEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
    },
    [`${t}-split${t}-empty ${t}-footer`]: {
      borderTop: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
    },
    [`${t}-loading ${t}-spin-nested-loading`]: {
      minHeight: o
    },
    [`${t}-split${t}-something-after-last-item ${n}-spin-container > ${t}-items > ${t}-item:last-child`]: {
      borderBlockEnd: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`
    },
    [`${t}-lg ${t}-item`]: {
      padding: d
    },
    [`${t}-sm ${t}-item`]: {
      padding: u
    },
    // Horizontal
    [`${t}:not(${t}-vertical)`]: {
      [`${t}-item-no-flex`]: {
        [`${t}-item-action`]: {
          float: "right"
        }
      }
    }
  };
}, pZ = Xe("List", (e) => {
  const t = He(e, {
    listBorderedCls: `${e.componentCls}-bordered`,
    minHeight: e.controlHeightLG,
    listItemPadding: `${e.paddingContentVertical}px ${e.paddingContentHorizontalLG}px`,
    listItemPaddingSM: `${e.paddingContentVerticalSM}px ${e.paddingContentHorizontal}px`,
    listItemPaddingLG: `${e.paddingContentVerticalLG}px ${e.paddingContentHorizontalLG}px`
  });
  return [fZ(t), uZ(t), dZ(t)];
}, {
  contentWidth: 220
}), vZ = () => ({
  bordered: ve(),
  dataSource: vt(),
  extra: Rn(),
  grid: Re(),
  itemLayout: String,
  loading: je([Boolean, Object]),
  loadMore: Rn(),
  pagination: je([Boolean, Object]),
  prefixCls: String,
  rowKey: je([String, Number, Function]),
  renderItem: le(),
  size: String,
  split: ve(),
  header: Rn(),
  footer: Rn(),
  locale: Re()
}), al = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AList",
  inheritAttrs: !1,
  Item: FI,
  props: Qe(vZ(), {
    dataSource: [],
    bordered: !1,
    split: !0,
    loading: !1,
    pagination: !1
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    var r, l;
    Je(BI, {
      grid: Te(e, "grid"),
      itemLayout: Te(e, "itemLayout")
    });
    const a = {
      current: 1,
      total: 0
    }, {
      prefixCls: i,
      direction: s,
      renderEmpty: c
    } = Ie("list", e), [u, d] = pZ(i), p = P(() => e.pagination && typeof e.pagination == "object" ? e.pagination : {}), v = Y((r = p.value.defaultCurrent) !== null && r !== void 0 ? r : 1), h = Y((l = p.value.defaultPageSize) !== null && l !== void 0 ? l : 10);
    ie(p, () => {
      "current" in p.value && (v.value = p.value.current), "pageSize" in p.value && (h.value = p.value.pageSize);
    });
    const g = [], b = (A) => (z, T) => {
      v.value = z, h.value = T, p.value[A] && p.value[A](z, T);
    }, y = b("onChange"), S = b("onShowSizeChange"), C = P(() => typeof e.loading == "boolean" ? {
      spinning: e.loading
    } : e.loading), w = P(() => C.value && C.value.spinning), $ = P(() => {
      let A = "";
      switch (e.size) {
        case "large":
          A = "lg";
          break;
        case "small":
          A = "sm";
          break;
      }
      return A;
    }), O = P(() => ({
      [`${i.value}`]: !0,
      [`${i.value}-vertical`]: e.itemLayout === "vertical",
      [`${i.value}-${$.value}`]: $.value,
      [`${i.value}-split`]: e.split,
      [`${i.value}-bordered`]: e.bordered,
      [`${i.value}-loading`]: w.value,
      [`${i.value}-grid`]: !!e.grid,
      [`${i.value}-rtl`]: s.value === "rtl"
    })), x = P(() => {
      const A = m(m(m({}, a), {
        total: e.dataSource.length,
        current: v.value,
        pageSize: h.value
      }), e.pagination || {}), z = Math.ceil(A.total / A.pageSize);
      return A.current > z && (A.current = z), A;
    }), I = P(() => {
      let A = [...e.dataSource];
      return e.pagination && e.dataSource.length > (x.value.current - 1) * x.value.pageSize && (A = [...e.dataSource].splice((x.value.current - 1) * x.value.pageSize, x.value.pageSize)), A;
    }), E = ki(), _ = So(() => {
      for (let A = 0; A < Lr.length; A += 1) {
        const z = Lr[A];
        if (E.value[z])
          return z;
      }
    }), M = P(() => {
      if (!e.grid)
        return;
      const A = _.value && e.grid[_.value] ? e.grid[_.value] : e.grid.column;
      if (A)
        return {
          width: `${100 / A}%`,
          maxWidth: `${100 / A}%`
        };
    }), R = (A, z) => {
      var T;
      const N = (T = e.renderItem) !== null && T !== void 0 ? T : n.renderItem;
      if (!N)
        return null;
      let k;
      const B = typeof e.rowKey;
      return B === "function" ? k = e.rowKey(A) : B === "string" || B === "number" ? k = A[e.rowKey] : k = A.key, k || (k = `list-item-${z}`), g[z] = k, N({
        item: A,
        index: z
      });
    };
    return () => {
      var A, z, T, N, k, B, F, L;
      const j = (A = e.loadMore) !== null && A !== void 0 ? A : (z = n.loadMore) === null || z === void 0 ? void 0 : z.call(n), H = (T = e.footer) !== null && T !== void 0 ? T : (N = n.footer) === null || N === void 0 ? void 0 : N.call(n), K = (k = e.header) !== null && k !== void 0 ? k : (B = n.header) === null || B === void 0 ? void 0 : B.call(n), X = It((F = n.default) === null || F === void 0 ? void 0 : F.call(n)), W = !!(j || e.pagination || H), q = ee(m(m({}, O.value), {
        [`${i.value}-something-after-last-item`]: W
      }), o.class, d.value), J = e.pagination ? f("div", {
        class: `${i.value}-pagination`
      }, [f(xp, D(D({}, x.value), {}, {
        onChange: y,
        onShowSizeChange: S
      }), null)]) : null;
      let ne = w.value && f("div", {
        style: {
          minHeight: "53px"
        }
      }, null);
      if (I.value.length > 0) {
        g.length = 0;
        const G = I.value.map((re, se) => R(re, se)), U = G.map((re, se) => f("div", {
          key: g[se],
          style: M.value
        }, [re]));
        ne = e.grid ? f(rb, {
          gutter: e.grid.gutter
        }, {
          default: () => [U]
        }) : f("ul", {
          class: `${i.value}-items`
        }, [G]);
      } else
        !X.length && !w.value && (ne = f("div", {
          class: `${i.value}-empty-text`
        }, [((L = e.locale) === null || L === void 0 ? void 0 : L.emptyText) || c("List")]));
      const te = x.value.position || "bottom";
      return u(f("div", D(D({}, o), {}, {
        class: q
      }), [(te === "top" || te === "both") && J, K && f("div", {
        class: `${i.value}-header`
      }, [K]), f(br, C.value, {
        default: () => [ne, X]
      }), H && f("div", {
        class: `${i.value}-footer`
      }, [H]), j || (te === "bottom" || te === "both") && J]));
    };
  }
});
al.install = function(e) {
  return e.component(al.name, al), e.component(al.Item.name, al.Item), e.component(al.Item.Meta.name, al.Item.Meta), e;
};
function gZ(e) {
  const {
    selectionStart: t
  } = e;
  return e.value.slice(0, t);
}
function mZ(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return (Array.isArray(t) ? t : [t]).reduce((o, r) => {
    const l = e.lastIndexOf(r);
    return l > o.location ? {
      location: l,
      prefix: r
    } : o;
  }, {
    location: -1,
    prefix: ""
  });
}
function F$(e) {
  return (e || "").toLowerCase();
}
function hZ(e, t, n) {
  const o = e[0];
  if (!o || o === n)
    return e;
  let r = e;
  const l = t.length;
  for (let a = 0; a < l; a += 1)
    if (F$(r[a]) !== F$(t[a])) {
      r = r.slice(a);
      break;
    } else
      a === l - 1 && (r = r.slice(l));
  return r;
}
function bZ(e, t) {
  const {
    measureLocation: n,
    prefix: o,
    targetText: r,
    selectionStart: l,
    split: a
  } = t;
  let i = e.slice(0, n);
  i[i.length - a.length] === a && (i = i.slice(0, i.length - a.length)), i && (i = `${i}${a}`);
  let s = hZ(e.slice(l), r.slice(l - n - o.length), a);
  s.slice(0, a.length) === a && (s = s.slice(a.length));
  const c = `${i}${o}${r}${a}`;
  return {
    text: `${c}${s}`,
    selectionLocation: c.length
  };
}
function yZ(e, t) {
  e.setSelectionRange(t, t), e.blur(), e.focus();
}
function SZ(e, t) {
  const {
    split: n
  } = t;
  return !n || e.indexOf(n) === -1;
}
function CZ(e, t) {
  let {
    value: n = ""
  } = t;
  const o = e.toLowerCase();
  return n.toLowerCase().indexOf(o) !== -1;
}
const LI = Symbol("MentionsContextKey");
function $Z() {
}
const wZ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "DropdownMenu",
  props: {
    prefixCls: String,
    options: {
      type: Array,
      default: () => []
    }
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      activeIndex: o,
      setActiveIndex: r,
      selectOption: l,
      onFocus: a = $Z,
      loading: i
    } = tt(LI, {
      activeIndex: Q(),
      loading: Q(!1)
    });
    let s;
    const c = (u) => {
      clearTimeout(s), s = setTimeout(() => {
        a(u);
      });
    };
    return et(() => {
      clearTimeout(s);
    }), () => {
      var u;
      const {
        prefixCls: d,
        options: p
      } = e, v = p[o.value] || {};
      return f(en, {
        prefixCls: `${d}-menu`,
        activeKey: v.value,
        onSelect: (h) => {
          let {
            key: g
          } = h;
          const b = p.find((y) => {
            let {
              value: S
            } = y;
            return S === g;
          });
          l(b);
        },
        onMousedown: c
      }, {
        default: () => [!i.value && p.map((h, g) => {
          var b, y;
          const {
            value: S,
            disabled: C,
            label: w = h.value,
            class: $,
            style: O
          } = h;
          return f(hr, {
            key: S,
            disabled: C,
            onMouseenter: () => {
              r(g);
            },
            class: $,
            style: O
          }, {
            default: () => [(y = (b = n.option) === null || b === void 0 ? void 0 : b.call(n, h)) !== null && y !== void 0 ? y : typeof w == "function" ? w(h) : w]
          });
        }), !i.value && p.length === 0 ? f(hr, {
          key: "notFoundContent",
          disabled: !0
        }, {
          default: () => [(u = n.notFoundContent) === null || u === void 0 ? void 0 : u.call(n)]
        }) : null, i.value && f(hr, {
          key: "loading",
          disabled: !0
        }, {
          default: () => [f(br, {
            size: "small"
          }, null)]
        })]
      });
    };
  }
}), xZ = {
  bottomRight: {
    points: ["tl", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  bottomLeft: {
    points: ["tr", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["bl", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["br", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  }
}, OZ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "KeywordTrigger",
  props: {
    loading: {
      type: Boolean,
      default: void 0
    },
    options: {
      type: Array,
      default: () => []
    },
    prefixCls: String,
    placement: String,
    visible: {
      type: Boolean,
      default: void 0
    },
    transitionName: String,
    getPopupContainer: Function,
    direction: String,
    dropdownClassName: String
  },
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = () => `${e.prefixCls}-dropdown`, r = () => {
      const {
        options: a
      } = e;
      return f(wZ, {
        prefixCls: o(),
        options: a
      }, {
        notFoundContent: n.notFoundContent,
        option: n.option
      });
    }, l = P(() => {
      const {
        placement: a,
        direction: i
      } = e;
      let s = "topRight";
      return i === "rtl" ? s = a === "top" ? "topLeft" : "bottomLeft" : s = a === "top" ? "topRight" : "bottomRight", s;
    });
    return () => {
      const {
        visible: a,
        transitionName: i,
        getPopupContainer: s
      } = e;
      return f($a, {
        prefixCls: o(),
        popupVisible: a,
        popup: r(),
        popupClassName: e.dropdownClassName,
        popupPlacement: l.value,
        popupTransitionName: i,
        builtinPlacements: xZ,
        getPopupContainer: s
      }, {
        default: n.default
      });
    };
  }
}), PZ = Mn("top", "bottom"), zI = {
  autofocus: {
    type: Boolean,
    default: void 0
  },
  prefix: V.oneOfType([V.string, V.arrayOf(V.string)]),
  prefixCls: String,
  value: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  split: String,
  transitionName: String,
  placement: V.oneOf(PZ),
  character: V.any,
  characterRender: Function,
  filterOption: {
    type: [Boolean, Function]
  },
  validateSearch: Function,
  getPopupContainer: {
    type: Function
  },
  options: vt(),
  loading: {
    type: Boolean,
    default: void 0
  },
  rows: [Number, String],
  direction: {
    type: String
  }
}, HI = m(m({}, zI), {
  dropdownClassName: String
}), jI = {
  prefix: "@",
  split: " ",
  rows: 1,
  validateSearch: SZ,
  filterOption: () => CZ
};
Qe(HI, jI);
var L$ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function z$() {
}
const IZ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Mentions",
  inheritAttrs: !1,
  props: Qe(HI, jI),
  emits: ["change", "select", "search", "focus", "blur", "pressenter"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      expose: r,
      slots: l
    } = t;
    const a = Y(null), i = Y(null), s = Y(), c = xt({
      value: e.value || "",
      measuring: !1,
      measureLocation: 0,
      measureText: null,
      measurePrefix: "",
      activeIndex: 0,
      isFocus: !1
    });
    Le(() => {
      c.value = e.value;
    });
    const u = (M) => {
      n("change", M);
    }, d = (M) => {
      let {
        target: {
          value: R
        }
      } = M;
      u(R);
    }, p = (M, R, A) => {
      m(c, {
        measuring: !0,
        measureText: M,
        measurePrefix: R,
        measureLocation: A,
        activeIndex: 0
      });
    }, v = (M) => {
      m(c, {
        measuring: !1,
        measureLocation: 0,
        measureText: null
      }), M == null || M();
    }, h = (M) => {
      const {
        which: R
      } = M;
      if (c.measuring) {
        if (R === ce.UP || R === ce.DOWN) {
          const A = I.value.length, z = R === ce.UP ? -1 : 1, T = (c.activeIndex + z + A) % A;
          c.activeIndex = T, M.preventDefault();
        } else if (R === ce.ESC)
          v();
        else if (R === ce.ENTER) {
          if (M.preventDefault(), !I.value.length) {
            v();
            return;
          }
          const A = I.value[c.activeIndex];
          $(A);
        }
      }
    }, g = (M) => {
      const {
        key: R,
        which: A
      } = M, {
        measureText: z,
        measuring: T
      } = c, {
        prefix: N,
        validateSearch: k
      } = e, B = M.target;
      if (B.composing)
        return;
      const F = gZ(B), {
        location: L,
        prefix: j
      } = mZ(F, N);
      if ([ce.ESC, ce.UP, ce.DOWN, ce.ENTER].indexOf(A) === -1)
        if (L !== -1) {
          const H = F.slice(L + j.length), K = k(H, e), X = !!x(H).length;
          K ? (R === j || R === "Shift" || T || H !== z && X) && p(H, j, L) : T && v(), K && n("search", H, j);
        } else
          T && v();
    }, b = (M) => {
      c.measuring || n("pressenter", M);
    }, y = (M) => {
      C(M);
    }, S = (M) => {
      w(M);
    }, C = (M) => {
      clearTimeout(s.value);
      const {
        isFocus: R
      } = c;
      !R && M && n("focus", M), c.isFocus = !0;
    }, w = (M) => {
      s.value = setTimeout(() => {
        c.isFocus = !1, v(), n("blur", M);
      }, 100);
    }, $ = (M) => {
      const {
        split: R
      } = e, {
        value: A = ""
      } = M, {
        text: z,
        selectionLocation: T
      } = bZ(c.value, {
        measureLocation: c.measureLocation,
        targetText: A,
        prefix: c.measurePrefix,
        selectionStart: i.value.getSelectionStart(),
        split: R
      });
      u(z), v(() => {
        yZ(i.value.input, T);
      }), n("select", M, c.measurePrefix);
    }, O = (M) => {
      c.activeIndex = M;
    }, x = (M) => {
      const R = M || c.measureText || "", {
        filterOption: A
      } = e;
      return e.options.filter((T) => A ? A(R, T) : !0);
    }, I = P(() => x());
    return r({
      blur: () => {
        i.value.blur();
      },
      focus: () => {
        i.value.focus();
      }
    }), Je(LI, {
      activeIndex: Te(c, "activeIndex"),
      setActiveIndex: O,
      selectOption: $,
      onFocus: C,
      onBlur: w,
      loading: Te(e, "loading")
    }), co(() => {
      rt(() => {
        c.measuring && (a.value.scrollTop = i.value.getScrollTop());
      });
    }), () => {
      const {
        measureLocation: M,
        measurePrefix: R,
        measuring: A
      } = c, {
        prefixCls: z,
        placement: T,
        transitionName: N,
        getPopupContainer: k,
        direction: B
      } = e, F = L$(e, ["prefixCls", "placement", "transitionName", "getPopupContainer", "direction"]), {
        class: L,
        style: j
      } = o, H = L$(o, ["class", "style"]), K = ot(F, ["value", "prefix", "split", "validateSearch", "filterOption", "options", "loading"]), X = m(m(m({}, K), H), {
        onChange: z$,
        onSelect: z$,
        value: c.value,
        onInput: d,
        onBlur: S,
        onKeydown: h,
        onKeyup: g,
        onFocus: y,
        onPressenter: b
      });
      return f("div", {
        class: ee(z, L),
        style: j
      }, [f(Ti, D(D({}, X), {}, {
        ref: i,
        tag: "textarea"
      }), null), A && f("div", {
        ref: a,
        class: `${z}-measure`
      }, [c.value.slice(0, M), f(OZ, {
        prefixCls: z,
        transitionName: N,
        dropdownClassName: e.dropdownClassName,
        placement: T,
        options: A ? I.value : [],
        visible: !0,
        direction: B,
        getPopupContainer: k
      }, {
        default: () => [f("span", null, [R])],
        notFoundContent: l.notFoundContent,
        option: l.option
      }), c.value.slice(M + R.length)])]);
    };
  }
}), EZ = {
  value: String,
  disabled: Boolean,
  payload: Re()
}, VI = m(m({}, EZ), {
  label: _t([])
}), WI = {
  name: "Option",
  props: VI,
  render(e, t) {
    let {
      slots: n
    } = t;
    var o;
    return (o = n.default) === null || o === void 0 ? void 0 : o.call(n);
  }
};
Z(m({
  compatConfig: {
    MODE: 3
  }
}, WI));
const TZ = (e) => {
  const {
    componentCls: t,
    colorTextDisabled: n,
    controlItemBgHover: o,
    controlPaddingHorizontal: r,
    colorText: l,
    motionDurationSlow: a,
    lineHeight: i,
    controlHeight: s,
    inputPaddingHorizontal: c,
    inputPaddingVertical: u,
    fontSize: d,
    colorBgElevated: p,
    borderRadiusLG: v,
    boxShadowSecondary: h
  } = e, g = Math.round((e.controlHeight - e.fontSize * e.lineHeight) / 2);
  return {
    [t]: m(m(m(m(m({}, qe(e)), Oa(e)), {
      position: "relative",
      display: "inline-block",
      height: "auto",
      padding: 0,
      overflow: "hidden",
      lineHeight: i,
      whiteSpace: "pre-wrap",
      verticalAlign: "bottom"
    }), vc(e, t)), {
      "&-disabled": {
        "> textarea": m({}, W0(e))
      },
      "&-focused": m({}, Sl(e)),
      [`&-affix-wrapper ${t}-suffix`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: c,
        bottom: 0,
        zIndex: 1,
        display: "inline-flex",
        alignItems: "center",
        margin: "auto"
      },
      // ================= Input Area =================
      [`> textarea, ${t}-measure`]: {
        color: l,
        boxSizing: "border-box",
        minHeight: s - 2,
        margin: 0,
        padding: `${u}px ${c}px`,
        overflow: "inherit",
        overflowX: "hidden",
        overflowY: "auto",
        fontWeight: "inherit",
        fontSize: "inherit",
        fontFamily: "inherit",
        fontStyle: "inherit",
        fontVariant: "inherit",
        fontSizeAdjust: "inherit",
        fontStretch: "inherit",
        lineHeight: "inherit",
        direction: "inherit",
        letterSpacing: "inherit",
        whiteSpace: "inherit",
        textAlign: "inherit",
        verticalAlign: "top",
        wordWrap: "break-word",
        wordBreak: "inherit",
        tabSize: "inherit"
      },
      "> textarea": m({
        width: "100%",
        border: "none",
        outline: "none",
        resize: "none",
        backgroundColor: "inherit"
      }, V0(e.colorTextPlaceholder)),
      [`${t}-measure`]: {
        position: "absolute",
        top: 0,
        insetInlineEnd: 0,
        bottom: 0,
        insetInlineStart: 0,
        zIndex: -1,
        color: "transparent",
        pointerEvents: "none",
        "> span": {
          display: "inline-block",
          minHeight: "1em"
        }
      },
      // ================== Dropdown ==================
      "&-dropdown": m(m({}, qe(e)), {
        position: "absolute",
        top: -9999,
        insetInlineStart: -9999,
        zIndex: e.zIndexPopup,
        boxSizing: "border-box",
        fontSize: d,
        fontVariant: "initial",
        backgroundColor: p,
        borderRadius: v,
        outline: "none",
        boxShadow: h,
        "&-hidden": {
          display: "none"
        },
        [`${t}-dropdown-menu`]: {
          maxHeight: e.dropdownHeight,
          marginBottom: 0,
          paddingInlineStart: 0,
          overflow: "auto",
          listStyle: "none",
          outline: "none",
          "&-item": m(m({}, tn), {
            position: "relative",
            display: "block",
            minWidth: e.controlItemWidth,
            padding: `${g}px ${r}px`,
            color: l,
            fontWeight: "normal",
            lineHeight: i,
            cursor: "pointer",
            transition: `background ${a} ease`,
            "&:hover": {
              backgroundColor: o
            },
            "&:first-child": {
              borderStartStartRadius: v,
              borderStartEndRadius: v,
              borderEndStartRadius: 0,
              borderEndEndRadius: 0
            },
            "&:last-child": {
              borderStartStartRadius: 0,
              borderStartEndRadius: 0,
              borderEndStartRadius: v,
              borderEndEndRadius: v
            },
            "&-disabled": {
              color: n,
              cursor: "not-allowed",
              "&:hover": {
                color: n,
                backgroundColor: o,
                cursor: "not-allowed"
              }
            },
            "&-selected": {
              color: l,
              fontWeight: e.fontWeightStrong,
              backgroundColor: o
            },
            "&-active": {
              backgroundColor: o
            }
          })
        }
      })
    })
  };
}, MZ = Xe("Mentions", (e) => {
  const t = Pa(e);
  return [TZ(t)];
}, (e) => ({
  dropdownHeight: 250,
  controlItemWidth: 100,
  zIndexPopup: e.zIndexPopupBase + 50
}));
var H$ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function _Z() {
  return !0;
}
const AZ = function() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  const {
    prefix: n = "@",
    split: o = " "
  } = t, r = Array.isArray(n) ? n : [n];
  return e.split(o).map(function() {
    let l = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", a = null;
    return r.some((i) => l.slice(0, i.length) === i ? (a = i, !0) : !1), a !== null ? {
      prefix: a,
      value: l.slice(a.length)
    } : null;
  }).filter((l) => !!l && !!l.value);
}, DZ = () => m(m({}, zI), {
  loading: {
    type: Boolean,
    default: void 0
  },
  onFocus: {
    type: Function
  },
  onBlur: {
    type: Function
  },
  onSelect: {
    type: Function
  },
  onChange: {
    type: Function
  },
  onPressenter: {
    type: Function
  },
  "onUpdate:value": {
    type: Function
  },
  notFoundContent: V.any,
  defaultValue: String,
  id: String,
  status: String
}), Lv = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AMentions",
  inheritAttrs: !1,
  props: DZ(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r,
      expose: l
    } = t;
    var a, i, s;
    process.env.NODE_ENV !== "production" && nt(!It(((a = n.default) === null || a === void 0 ? void 0 : a.call(n)) || []).length, "Mentions", "`Mentions.Option` is deprecated. Please use `options` instead.");
    const {
      prefixCls: c,
      renderEmpty: u,
      direction: d
    } = Ie("mentions", e), [p, v] = MZ(c), h = Q(!1), g = Q(null), b = Q((s = (i = e.value) !== null && i !== void 0 ? i : e.defaultValue) !== null && s !== void 0 ? s : ""), y = sn(), S = Sn.useInject(), C = P(() => ar(S.status, e.status));
    h0({
      prefixCls: P(() => `${c.value}-menu`),
      mode: P(() => "vertical"),
      selectable: P(() => !1),
      onClick: () => {
      },
      validator: (A) => {
        let {
          mode: z
        } = A;
        Mt(!z || z === "vertical", "Mentions", `mode="${z}" is not supported for Mentions's Menu.`);
      }
    }), ie(() => e.value, (A) => {
      b.value = A;
    });
    const w = (A) => {
      h.value = !0, o("focus", A);
    }, $ = (A) => {
      h.value = !1, o("blur", A), y.onFieldBlur();
    }, O = function() {
      for (var A = arguments.length, z = new Array(A), T = 0; T < A; T++)
        z[T] = arguments[T];
      o("select", ...z), h.value = !0;
    }, x = (A) => {
      e.value === void 0 && (b.value = A), o("update:value", A), o("change", A), y.onFieldChange();
    }, I = () => {
      const A = e.notFoundContent;
      return A !== void 0 ? A : n.notFoundContent ? n.notFoundContent() : u("Select");
    }, E = () => {
      var A;
      return It(((A = n.default) === null || A === void 0 ? void 0 : A.call(n)) || []).map((z) => {
        var T, N;
        return m(m({}, Kx(z)), {
          label: (N = (T = z.children) === null || T === void 0 ? void 0 : T.default) === null || N === void 0 ? void 0 : N.call(T)
        });
      });
    };
    l({
      focus: () => {
        g.value.focus();
      },
      blur: () => {
        g.value.blur();
      }
    });
    const R = P(() => e.loading ? _Z : e.filterOption);
    return () => {
      const {
        disabled: A,
        getPopupContainer: z,
        rows: T = 1,
        id: N = y.id.value
      } = e, k = H$(e, ["disabled", "getPopupContainer", "rows", "id"]), {
        hasFeedback: B,
        feedbackIcon: F
      } = S, {
        class: L
      } = r, j = H$(r, ["class"]), H = ot(k, ["defaultValue", "onUpdate:value", "prefixCls"]), K = ee({
        [`${c.value}-disabled`]: A,
        [`${c.value}-focused`]: h.value,
        [`${c.value}-rtl`]: d.value === "rtl"
      }, Fn(c.value, C.value), !B && L, v.value), X = m(m(m(m({
        prefixCls: c.value
      }, H), {
        disabled: A,
        direction: d.value,
        filterOption: R.value,
        getPopupContainer: z,
        options: e.loading ? [{
          value: "ANTDV_SEARCHING",
          disabled: !0,
          label: f(br, {
            size: "small"
          }, null)
        }] : e.options || E(),
        class: K
      }), j), {
        rows: T,
        onChange: x,
        onSelect: O,
        onFocus: w,
        onBlur: $,
        ref: g,
        value: b.value,
        id: N
      }), W = f(IZ, D(D({}, X), {}, {
        dropdownClassName: v.value
      }), {
        notFoundContent: I,
        option: n.option
      });
      return p(B ? f("div", {
        class: ee(`${c.value}-affix-wrapper`, Fn(`${c.value}-affix-wrapper`, C.value, B), L, v.value)
      }, [W, f("span", {
        class: `${c.value}-suffix`
      }, [F])]) : W);
    };
  }
}), Lu = Z(m(m({
  compatConfig: {
    MODE: 3
  }
}, WI), {
  name: "AMentionsOption",
  props: VI
})), NZ = m(Lv, {
  Option: Lu,
  getMentions: AZ,
  install: (e) => (e.component(Lv.name, Lv), e.component(Lu.name, Lu), e)
});
var RZ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
let Im;
const kZ = (e) => {
  Im = {
    x: e.pageX,
    y: e.pageY
  }, setTimeout(() => Im = null, 100);
};
gP() && Bt(document.documentElement, "click", kZ, !0);
const BZ = () => ({
  prefixCls: String,
  /** @deprecated Please use `open` instead. */
  visible: {
    type: Boolean,
    default: void 0
  },
  open: {
    type: Boolean,
    default: void 0
  },
  confirmLoading: {
    type: Boolean,
    default: void 0
  },
  title: V.any,
  closable: {
    type: Boolean,
    default: void 0
  },
  closeIcon: V.any,
  onOk: Function,
  onCancel: Function,
  "onUpdate:visible": Function,
  "onUpdate:open": Function,
  onChange: Function,
  afterClose: Function,
  centered: {
    type: Boolean,
    default: void 0
  },
  width: [String, Number],
  footer: V.any,
  okText: V.any,
  okType: String,
  cancelText: V.any,
  icon: V.any,
  maskClosable: {
    type: Boolean,
    default: void 0
  },
  forceRender: {
    type: Boolean,
    default: void 0
  },
  okButtonProps: Re(),
  cancelButtonProps: Re(),
  destroyOnClose: {
    type: Boolean,
    default: void 0
  },
  wrapClassName: String,
  maskTransitionName: String,
  transitionName: String,
  getContainer: {
    type: [String, Function, Boolean, Object],
    default: void 0
  },
  zIndex: Number,
  bodyStyle: Re(),
  maskStyle: Re(),
  mask: {
    type: Boolean,
    default: void 0
  },
  keyboard: {
    type: Boolean,
    default: void 0
  },
  wrapProps: Object,
  focusTriggerAfterClose: {
    type: Boolean,
    default: void 0
  },
  modalRender: Function,
  mousePosition: Re()
}), zn = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AModal",
  inheritAttrs: !1,
  props: Qe(BZ(), {
    width: 520,
    confirmLoading: !1,
    okType: "primary"
  }),
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: r
    } = t;
    const [l] = jo("Modal"), {
      prefixCls: a,
      rootPrefixCls: i,
      direction: s,
      getPopupContainer: c
    } = Ie("modal", e), [u, d] = XY(a);
    Mt(e.visible === void 0, "Modal", "`visible` will be removed in next major version, please use `open` instead.");
    const p = (g) => {
      n("update:visible", !1), n("update:open", !1), n("cancel", g), n("change", !1);
    }, v = (g) => {
      n("ok", g);
    }, h = () => {
      var g, b;
      const {
        okText: y = (g = o.okText) === null || g === void 0 ? void 0 : g.call(o),
        okType: S,
        cancelText: C = (b = o.cancelText) === null || b === void 0 ? void 0 : b.call(o),
        confirmLoading: w
      } = e;
      return f(Fe, null, [f(Kt, D({
        onClick: p
      }, e.cancelButtonProps), {
        default: () => [C || l.value.cancelText]
      }), f(Kt, D(D({}, Ed(S)), {}, {
        loading: w,
        onClick: v
      }, e.okButtonProps), {
        default: () => [y || l.value.okText]
      })]);
    };
    return () => {
      var g, b;
      const {
        prefixCls: y,
        visible: S,
        open: C,
        wrapClassName: w,
        centered: $,
        getContainer: O,
        closeIcon: x = (g = o.closeIcon) === null || g === void 0 ? void 0 : g.call(o),
        focusTriggerAfterClose: I = !0
      } = e, E = RZ(e, ["prefixCls", "visible", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose"]), _ = ee(w, {
        [`${a.value}-centered`]: !!$,
        [`${a.value}-wrap-rtl`]: s.value === "rtl"
      });
      return u(f(xI, D(D(D({}, E), r), {}, {
        rootClassName: d.value,
        class: ee(d.value, r.class),
        getContainer: O || (c == null ? void 0 : c.value),
        prefixCls: a.value,
        wrapClassName: _,
        visible: C ?? S,
        onClose: p,
        focusTriggerAfterClose: I,
        transitionName: Vn(i.value, "zoom", e.transitionName),
        maskTransitionName: Vn(i.value, "fade", e.maskTransitionName),
        mousePosition: (b = E.mousePosition) !== null && b !== void 0 ? b : Im
      }), m(m({}, o), {
        footer: o.footer || h,
        closeIcon: () => f("span", {
          class: `${a.value}-close-x`
        }, [x || f(Kn, {
          class: `${a.value}-close-icon`
        }, null)])
      })));
    };
  }
}), KI = () => {
  const e = Q(!1);
  return et(() => {
    e.value = !0;
  }), e;
}, FZ = {
  type: {
    type: String
  },
  actionFn: Function,
  close: Function,
  autofocus: Boolean,
  prefixCls: String,
  buttonProps: Re(),
  emitEvent: Boolean,
  quitOnNullishReturnValue: Boolean
};
function j$(e) {
  return !!(e && e.then);
}
const Em = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ActionButton",
  props: FZ,
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Q(!1), r = Q(), l = Q(!1);
    let a;
    const i = KI();
    Ke(() => {
      e.autofocus && (a = setTimeout(() => {
        var d, p;
        return (p = (d = qn(r.value)) === null || d === void 0 ? void 0 : d.focus) === null || p === void 0 ? void 0 : p.call(d);
      }));
    }), et(() => {
      clearTimeout(a);
    });
    const s = function() {
      for (var d, p = arguments.length, v = new Array(p), h = 0; h < p; h++)
        v[h] = arguments[h];
      (d = e.close) === null || d === void 0 || d.call(e, ...v);
    }, c = (d) => {
      j$(d) && (l.value = !0, d.then(function() {
        i.value || (l.value = !1), s(...arguments), o.value = !1;
      }, (p) => (i.value || (l.value = !1), o.value = !1, Promise.reject(p))));
    }, u = (d) => {
      const {
        actionFn: p
      } = e;
      if (o.value)
        return;
      if (o.value = !0, !p) {
        s();
        return;
      }
      let v;
      if (e.emitEvent) {
        if (v = p(d), e.quitOnNullishReturnValue && !j$(v)) {
          o.value = !1, s(d);
          return;
        }
      } else if (p.length)
        v = p(e.close), o.value = !1;
      else if (v = p(), !v) {
        s();
        return;
      }
      c(v);
    };
    return () => {
      const {
        type: d,
        prefixCls: p,
        buttonProps: v
      } = e;
      return f(Kt, D(D(D({}, Ed(d)), {}, {
        onClick: u,
        loading: l.value,
        prefixCls: p
      }, v), {}, {
        ref: r
      }), n);
    };
  }
});
function Na(e) {
  return typeof e == "function" ? e() : e;
}
const GI = Z({
  name: "ConfirmDialog",
  inheritAttrs: !1,
  props: ["icon", "onCancel", "onOk", "close", "closable", "zIndex", "afterClose", "visible", "open", "keyboard", "centered", "getContainer", "maskStyle", "okButtonProps", "cancelButtonProps", "okType", "prefixCls", "okCancel", "width", "mask", "maskClosable", "okText", "cancelText", "autoFocusButton", "transitionName", "maskTransitionName", "type", "title", "content", "direction", "rootPrefixCls", "bodyStyle", "closeIcon", "modalRender", "focusTriggerAfterClose", "wrapClassName", "confirmPrefixCls", "footer"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const [o] = jo("Modal");
    return process.env.NODE_ENV !== "production" && Mt(e.visible === void 0, "Modal", "`visible` is deprecated, please use `open` instead."), () => {
      const {
        icon: r,
        onCancel: l,
        onOk: a,
        close: i,
        okText: s,
        closable: c = !1,
        zIndex: u,
        afterClose: d,
        keyboard: p,
        centered: v,
        getContainer: h,
        maskStyle: g,
        okButtonProps: b,
        cancelButtonProps: y,
        okCancel: S,
        width: C = 416,
        mask: w = !0,
        maskClosable: $ = !1,
        type: O,
        open: x,
        title: I,
        content: E,
        direction: _,
        closeIcon: M,
        modalRender: R,
        focusTriggerAfterClose: A,
        rootPrefixCls: z,
        bodyStyle: T,
        wrapClassName: N,
        footer: k
      } = e;
      let B = r;
      if (!r && r !== null)
        switch (O) {
          case "info":
            B = f(Pl, null, null);
            break;
          case "success":
            B = f(ir, null, null);
            break;
          case "error":
            B = f(Gn, null, null);
            break;
          default:
            B = f(sr, null, null);
        }
      const F = e.okType || "primary", L = e.prefixCls || "ant-modal", j = `${L}-confirm`, H = n.style || {}, K = S ?? O === "confirm", X = e.autoFocusButton === null ? !1 : e.autoFocusButton || "ok", W = `${L}-confirm`, q = ee(W, `${W}-${e.type}`, {
        [`${W}-rtl`]: _ === "rtl"
      }, n.class), J = o.value, ne = K && f(Em, {
        actionFn: l,
        close: i,
        autofocus: X === "cancel",
        buttonProps: y,
        prefixCls: `${z}-btn`
      }, {
        default: () => [Na(e.cancelText) || J.cancelText]
      });
      return f(zn, {
        prefixCls: L,
        class: q,
        wrapClassName: ee({
          [`${W}-centered`]: !!v
        }, N),
        onCancel: (te) => i == null ? void 0 : i({
          triggerCancel: !0
        }, te),
        open: x,
        title: "",
        footer: "",
        transitionName: Vn(z, "zoom", e.transitionName),
        maskTransitionName: Vn(z, "fade", e.maskTransitionName),
        mask: w,
        maskClosable: $,
        maskStyle: g,
        style: H,
        bodyStyle: T,
        width: C,
        zIndex: u,
        afterClose: d,
        keyboard: p,
        centered: v,
        getContainer: h,
        closable: c,
        closeIcon: M,
        modalRender: R,
        focusTriggerAfterClose: A
      }, {
        default: () => [f("div", {
          class: `${j}-body-wrapper`
        }, [f("div", {
          class: `${j}-body`
        }, [Na(B), I === void 0 ? null : f("span", {
          class: `${j}-title`
        }, [Na(I)]), f("div", {
          class: `${j}-content`
        }, [Na(E)])]), k !== void 0 ? Na(k) : f("div", {
          class: `${j}-btns`
        }, [ne, f(Em, {
          type: F,
          actionFn: a,
          close: i,
          autofocus: X === "ok",
          buttonProps: b,
          prefixCls: `${z}-btn`
        }, {
          default: () => [Na(s) || (K ? J.okText : J.justOkText)]
        })])])]
      });
    };
  }
}), ql = [], Cc = (e) => {
  const t = document.createDocumentFragment();
  let n = m(m({}, ot(e, ["parentContext", "appContext"])), {
    close: l,
    open: !0
  }), o = null;
  function r() {
    o && (yl(null, t), o = null);
    for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)
      u[d] = arguments[d];
    const p = u.some((v) => v && v.triggerCancel);
    e.onCancel && p && e.onCancel(() => {
    }, ...u.slice(1));
    for (let v = 0; v < ql.length; v++)
      if (ql[v] === l) {
        ql.splice(v, 1);
        break;
      }
  }
  function l() {
    for (var c = arguments.length, u = new Array(c), d = 0; d < c; d++)
      u[d] = arguments[d];
    n = m(m({}, n), {
      open: !1,
      afterClose: () => {
        typeof e.afterClose == "function" && e.afterClose(), r.apply(this, u);
      }
    }), n.visible && delete n.visible, a(n);
  }
  function a(c) {
    typeof c == "function" ? n = c(n) : n = m(m({}, n), c), o && d7(o, n, t);
  }
  const i = (c) => {
    const u = On, d = u.prefixCls, p = c.prefixCls || `${d}-modal`, v = u.iconPrefixCls, h = ZG();
    return f(oa, D(D({}, u), {}, {
      prefixCls: d
    }), {
      default: () => [f(GI, D(D({}, c), {}, {
        rootPrefixCls: d,
        prefixCls: p,
        iconPrefixCls: v,
        locale: h,
        cancelText: c.cancelText || h.cancelText
      }), null)]
    });
  };
  function s(c) {
    const u = f(i, m({}, c));
    return u.appContext = e.parentContext || e.appContext || u.appContext, yl(u, t), u;
  }
  return o = s(n), ql.push(l), {
    destroy: l,
    update: a
  };
};
function XI(e) {
  return m(m({}, e), {
    type: "warning"
  });
}
function UI(e) {
  return m(m({}, e), {
    type: "info"
  });
}
function YI(e) {
  return m(m({}, e), {
    type: "success"
  });
}
function qI(e) {
  return m(m({}, e), {
    type: "error"
  });
}
function ZI(e) {
  return m(m({}, e), {
    type: "confirm"
  });
}
const LZ = () => ({
  config: Object,
  afterClose: Function,
  destroyAction: Function,
  open: Boolean
}), zZ = Z({
  name: "HookModal",
  inheritAttrs: !1,
  props: Qe(LZ(), {
    config: {
      width: 520,
      okType: "primary"
    }
  }),
  setup(e, t) {
    let {
      expose: n
    } = t;
    var o;
    const r = P(() => e.open), l = P(() => e.config), {
      direction: a,
      getPrefixCls: i
    } = oc(), s = i("modal"), c = i(), u = () => {
      var h, g;
      e == null || e.afterClose(), (g = (h = l.value).afterClose) === null || g === void 0 || g.call(h);
    }, d = function() {
      e.destroyAction(...arguments);
    };
    n({
      destroy: d
    });
    const p = (o = l.value.okCancel) !== null && o !== void 0 ? o : l.value.type === "confirm", [v] = jo("Modal", Zn.Modal);
    return () => f(GI, D(D({
      prefixCls: s,
      rootPrefixCls: c
    }, l.value), {}, {
      close: d,
      open: r.value,
      afterClose: u,
      okText: l.value.okText || (p ? v == null ? void 0 : v.value.okText : v == null ? void 0 : v.value.justOkText),
      direction: l.value.direction || a.value,
      cancelText: l.value.cancelText || (v == null ? void 0 : v.value.cancelText)
    }), null);
  }
});
let V$ = 0;
const HZ = Z({
  name: "ElementsHolder",
  inheritAttrs: !1,
  setup(e, t) {
    let {
      expose: n
    } = t;
    const o = Q([]);
    return n({
      addModal: (l) => (o.value.push(l), o.value = o.value.slice(), () => {
        o.value = o.value.filter((a) => a !== l);
      })
    }), () => o.value.map((l) => l());
  }
});
function QI() {
  const e = Q(null), t = Q([]);
  ie(t, () => {
    t.value.length && ([...t.value].forEach((a) => {
      a();
    }), t.value = []);
  }, {
    immediate: !0
  });
  const n = (l) => function(i) {
    var s;
    V$ += 1;
    const c = Q(!0), u = Q(null), d = Q(hn(i)), p = Q({});
    ie(() => i, (C) => {
      b(m(m({}, kx(C) ? C.value : C), p.value));
    });
    const v = function() {
      c.value = !1;
      for (var C = arguments.length, w = new Array(C), $ = 0; $ < C; $++)
        w[$] = arguments[$];
      const O = w.some((x) => x && x.triggerCancel);
      d.value.onCancel && O && d.value.onCancel(() => {
      }, ...w.slice(1));
    };
    let h;
    const g = () => f(zZ, {
      key: `modal-${V$}`,
      config: l(d.value),
      ref: u,
      open: c.value,
      destroyAction: v,
      afterClose: () => {
        h == null || h();
      }
    }, null);
    h = (s = e.value) === null || s === void 0 ? void 0 : s.addModal(g), h && ql.push(h);
    const b = (C) => {
      d.value = m(m({}, d.value), C);
    };
    return {
      destroy: () => {
        u.value ? v() : t.value = [...t.value, v];
      },
      update: (C) => {
        p.value = C, u.value ? b(C) : t.value = [...t.value, () => b(C)];
      }
    };
  }, o = P(() => ({
    info: n(UI),
    success: n(YI),
    error: n(qI),
    warning: n(XI),
    confirm: n(ZI)
  })), r = Symbol("modalHolderKey");
  return [o.value, () => f(HZ, {
    key: r,
    ref: e
  }, null)];
}
function JI(e) {
  return Cc(XI(e));
}
zn.useModal = QI;
zn.info = function(t) {
  return Cc(UI(t));
};
zn.success = function(t) {
  return Cc(YI(t));
};
zn.error = function(t) {
  return Cc(qI(t));
};
zn.warning = JI;
zn.warn = JI;
zn.confirm = function(t) {
  return Cc(ZI(t));
};
zn.destroyAll = function() {
  for (; ql.length; ) {
    const t = ql.pop();
    t && t();
  }
};
zn.install = function(e) {
  return e.component(zn.name, zn), e;
};
const e6 = (e) => {
  const {
    value: t,
    formatter: n,
    precision: o,
    decimalSeparator: r,
    groupSeparator: l = "",
    prefixCls: a
  } = e;
  let i;
  if (typeof n == "function")
    i = n({
      value: t
    });
  else {
    const s = String(t), c = s.match(/^(-?)(\d*)(\.(\d+))?$/);
    if (!c)
      i = s;
    else {
      const u = c[1];
      let d = c[2] || "0", p = c[4] || "";
      d = d.replace(/\B(?=(\d{3})+(?!\d))/g, l), typeof o == "number" && (p = p.padEnd(o, "0").slice(0, o > 0 ? o : 0)), p && (p = `${r}${p}`), i = [f("span", {
        key: "int",
        class: `${a}-content-value-int`
      }, [u, d]), p && f("span", {
        key: "decimal",
        class: `${a}-content-value-decimal`
      }, [p])];
    }
  }
  return f("span", {
    class: `${a}-content-value`
  }, [i]);
};
e6.displayName = "StatisticNumber";
const jZ = (e) => {
  const {
    componentCls: t,
    marginXXS: n,
    padding: o,
    colorTextDescription: r,
    statisticTitleFontSize: l,
    colorTextHeading: a,
    statisticContentFontSize: i,
    statisticFontFamily: s
  } = e;
  return {
    [`${t}`]: m(m({}, qe(e)), {
      [`${t}-title`]: {
        marginBottom: n,
        color: r,
        fontSize: l
      },
      [`${t}-skeleton`]: {
        paddingTop: o
      },
      [`${t}-content`]: {
        color: a,
        fontSize: i,
        fontFamily: s,
        [`${t}-content-value`]: {
          display: "inline-block",
          direction: "ltr"
        },
        [`${t}-content-prefix, ${t}-content-suffix`]: {
          display: "inline-block"
        },
        [`${t}-content-prefix`]: {
          marginInlineEnd: n
        },
        [`${t}-content-suffix`]: {
          marginInlineStart: n
        }
      }
    })
  };
}, VZ = Xe("Statistic", (e) => {
  const {
    fontSizeHeading3: t,
    fontSize: n,
    fontFamily: o
  } = e, r = He(e, {
    statisticTitleFontSize: n,
    statisticContentFontSize: t,
    statisticFontFamily: o
  });
  return [jZ(r)];
}), t6 = () => ({
  prefixCls: String,
  decimalSeparator: String,
  groupSeparator: String,
  format: String,
  value: je([Number, String, Object]),
  valueStyle: {
    type: Object,
    default: void 0
  },
  valueRender: le(),
  formatter: _t(),
  precision: Number,
  prefix: Rn(),
  suffix: Rn(),
  title: Rn(),
  loading: ve()
}), Br = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AStatistic",
  inheritAttrs: !1,
  props: Qe(t6(), {
    decimalSeparator: ".",
    groupSeparator: ",",
    loading: !1
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("statistic", e), [a, i] = VZ(r);
    return () => {
      var s, c, u, d, p, v, h;
      const {
        value: g = 0,
        valueStyle: b,
        valueRender: y
      } = e, S = r.value, C = (s = e.title) !== null && s !== void 0 ? s : (c = n.title) === null || c === void 0 ? void 0 : c.call(n), w = (u = e.prefix) !== null && u !== void 0 ? u : (d = n.prefix) === null || d === void 0 ? void 0 : d.call(n), $ = (p = e.suffix) !== null && p !== void 0 ? p : (v = n.suffix) === null || v === void 0 ? void 0 : v.call(n), O = (h = e.formatter) !== null && h !== void 0 ? h : n.formatter;
      let x = f(e6, D({
        "data-for-update": Date.now()
      }, m(m({}, e), {
        prefixCls: S,
        value: g,
        formatter: O
      })), null);
      return y && (x = y(x)), a(f("div", D(D({}, o), {}, {
        class: [S, {
          [`${S}-rtl`]: l.value === "rtl"
        }, o.class, i.value]
      }), [C && f("div", {
        class: `${S}-title`
      }, [C]), f(Nn, {
        paragraph: !1,
        loading: e.loading
      }, {
        default: () => [f("div", {
          style: b,
          class: `${S}-content`
        }, [w && f("span", {
          class: `${S}-content-prefix`
        }, [w]), x, $ && f("span", {
          class: `${S}-content-suffix`
        }, [$])])]
      })]));
    };
  }
}), WZ = [
  ["Y", 1e3 * 60 * 60 * 24 * 365],
  ["M", 1e3 * 60 * 60 * 24 * 30],
  ["D", 1e3 * 60 * 60 * 24],
  ["H", 1e3 * 60 * 60],
  ["m", 1e3 * 60],
  ["s", 1e3],
  ["S", 1]
  // million seconds
];
function KZ(e, t) {
  let n = e;
  const o = /\[[^\]]*]/g, r = (t.match(o) || []).map((s) => s.slice(1, -1)), l = t.replace(o, "[]"), a = WZ.reduce((s, c) => {
    let [u, d] = c;
    if (s.includes(u)) {
      const p = Math.floor(n / d);
      return n -= p * d, s.replace(new RegExp(`${u}+`, "g"), (v) => {
        const h = v.length;
        return p.toString().padStart(h, "0");
      });
    }
    return s;
  }, l);
  let i = 0;
  return a.replace(o, () => {
    const s = r[i];
    return i += 1, s;
  });
}
function GZ(e, t) {
  const {
    format: n = ""
  } = t, o = new Date(e).getTime(), r = Date.now(), l = Math.max(o - r, 0);
  return KZ(l, n);
}
const XZ = 1e3 / 30;
function zv(e) {
  return new Date(e).getTime();
}
const UZ = () => m(m({}, t6()), {
  value: je([Number, String, Object]),
  format: String,
  onFinish: Function,
  onChange: Function
}), YZ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AStatisticCountdown",
  props: Qe(UZ(), {
    format: "HH:mm:ss"
  }),
  // emits: ['finish', 'change'],
  setup(e, t) {
    let {
      emit: n,
      slots: o
    } = t;
    const r = Y(), l = Y(), a = () => {
      const {
        value: d
      } = e;
      zv(d) >= Date.now() ? i() : s();
    }, i = () => {
      if (r.value)
        return;
      const d = zv(e.value);
      r.value = setInterval(() => {
        l.value.$forceUpdate(), d > Date.now() && n("change", d - Date.now()), a();
      }, XZ);
    }, s = () => {
      const {
        value: d
      } = e;
      r.value && (clearInterval(r.value), r.value = void 0, zv(d) < Date.now() && n("finish"));
    }, c = (d) => {
      let {
        value: p,
        config: v
      } = d;
      const {
        format: h
      } = e;
      return GZ(p, m(m({}, v), {
        format: h
      }));
    }, u = (d) => d;
    return Ke(() => {
      a();
    }), co(() => {
      a();
    }), et(() => {
      s();
    }), () => {
      const d = e.value;
      return f(Br, D({
        ref: l
      }, m(m({}, ot(e, ["onFinish", "onChange"])), {
        value: d,
        valueRender: u,
        formatter: c
      })), o);
    };
  }
});
Br.Countdown = YZ;
Br.install = function(e) {
  return e.component(Br.name, Br), e.component(Br.Countdown.name, Br.Countdown), e;
};
const qZ = Br.Countdown;
var ZZ = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M872 474H286.9l350.2-304c5.6-4.9 2.2-14-5.2-14h-88.5c-3.9 0-7.6 1.4-10.5 3.9L155 487.8a31.96 31.96 0 000 48.3L535.1 866c1.5 1.3 3.3 2 5.2 2h91.5c7.4 0 10.8-9.2 5.2-14L286.9 550H872c4.4 0 8-3.6 8-8v-60c0-4.4-3.6-8-8-8z" } }] }, name: "arrow-left", theme: "outlined" };
function W$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      QZ(e, r, n[r]);
    });
  }
  return e;
}
function QZ(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ab = function(t, n) {
  var o = W$({}, t, n.attrs);
  return f(Ge, W$({}, o, {
    icon: ZZ
  }), null);
};
Ab.displayName = "ArrowLeftOutlined";
Ab.inheritAttrs = !1;
var JZ = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M869 487.8L491.2 159.9c-2.9-2.5-6.6-3.9-10.5-3.9h-88.5c-7.4 0-10.8 9.2-5.2 14l350.2 304H152c-4.4 0-8 3.6-8 8v60c0 4.4 3.6 8 8 8h585.1L386.9 854c-5.6 4.9-2.2 14 5.2 14h91.5c1.9 0 3.8-.7 5.2-2L869 536.2a32.07 32.07 0 000-48.4z" } }] }, name: "arrow-right", theme: "outlined" };
function K$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      eQ(e, r, n[r]);
    });
  }
  return e;
}
function eQ(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Db = function(t, n) {
  var o = K$({}, t, n.attrs);
  return f(Ge, K$({}, o, {
    icon: JZ
  }), null);
};
Db.displayName = "ArrowRightOutlined";
Db.inheritAttrs = !1;
var tQ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const nQ = {
  border: 0,
  background: "transparent",
  padding: 0,
  lineHeight: "inherit",
  display: "inline-block"
}, ef = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TransButton",
  inheritAttrs: !1,
  props: {
    noStyle: {
      type: Boolean,
      default: void 0
    },
    onClick: Function,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    }
  },
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r,
      expose: l
    } = t;
    const a = Q(), i = (p) => {
      const {
        keyCode: v
      } = p;
      v === ce.ENTER && p.preventDefault();
    }, s = (p) => {
      const {
        keyCode: v
      } = p;
      v === ce.ENTER && o("click", p);
    }, c = (p) => {
      o("click", p);
    }, u = () => {
      a.value && a.value.focus();
    }, d = () => {
      a.value && a.value.blur();
    };
    return Ke(() => {
      e.autofocus && u();
    }), l({
      focus: u,
      blur: d
    }), () => {
      var p;
      const {
        noStyle: v,
        disabled: h
      } = e, g = tQ(e, ["noStyle", "disabled"]);
      let b = {};
      return v || (b = m({}, nQ)), h && (b.pointerEvents = "none"), f("div", D(D(D({
        role: "button",
        tabindex: 0,
        ref: a
      }, g), r), {}, {
        onClick: c,
        onKeydown: i,
        onKeyup: s,
        style: m(m({}, b), r.style || {})
      }), [(p = n.default) === null || p === void 0 ? void 0 : p.call(n)]);
    };
  }
}), oQ = {
  small: 8,
  middle: 16,
  large: 24
}, rQ = () => ({
  prefixCls: String,
  size: {
    type: [String, Number, Array]
  },
  direction: V.oneOf(Mn("horizontal", "vertical")).def("horizontal"),
  align: V.oneOf(Mn("start", "end", "center", "baseline")),
  wrap: ve()
});
function lQ(e) {
  return typeof e == "string" ? oQ[e] : e || 0;
}
const ui = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASpace",
  inheritAttrs: !1,
  props: rQ(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      space: l,
      direction: a
    } = Ie("space", e), [i, s] = K4(r), c = hP(), u = P(() => {
      var y, S, C;
      return (C = (y = e.size) !== null && y !== void 0 ? y : (S = l == null ? void 0 : l.value) === null || S === void 0 ? void 0 : S.size) !== null && C !== void 0 ? C : "small";
    }), d = Y(), p = Y();
    ie(u, () => {
      [d.value, p.value] = (Array.isArray(u.value) ? u.value : [u.value, u.value]).map((y) => lQ(y));
    }, {
      immediate: !0
    });
    const v = P(() => e.align === void 0 && e.direction === "horizontal" ? "center" : e.align), h = P(() => ee(r.value, s.value, `${r.value}-${e.direction}`, {
      [`${r.value}-rtl`]: a.value === "rtl",
      [`${r.value}-align-${v.value}`]: v.value
    })), g = P(() => a.value === "rtl" ? "marginLeft" : "marginRight"), b = P(() => {
      const y = {};
      return c.value && (y.columnGap = `${d.value}px`, y.rowGap = `${p.value}px`), m(m({}, y), e.wrap && {
        flexWrap: "wrap",
        marginBottom: `${-p.value}px`
      });
    });
    return () => {
      var y, S;
      const {
        wrap: C,
        direction: w = "horizontal"
      } = e, $ = (y = n.default) === null || y === void 0 ? void 0 : y.call(n), O = Lt($), x = O.length;
      if (x === 0)
        return null;
      const I = (S = n.split) === null || S === void 0 ? void 0 : S.call(n), E = `${r.value}-item`, _ = d.value, M = x - 1;
      return f("div", D(D({}, o), {}, {
        class: [h.value, o.class],
        style: [b.value, o.style]
      }), [O.map((R, A) => {
        let z = $.indexOf(R);
        z === -1 && (z = `$$space-${A}`);
        let T = {};
        return c.value || (w === "vertical" ? A < M && (T = {
          marginBottom: `${_ / (I ? 2 : 1)}px`
        }) : T = m(m({}, A < M && {
          [g.value]: `${_ / (I ? 2 : 1)}px`
        }), C && {
          paddingBottom: `${p.value}px`
        })), i(f(Fe, {
          key: z
        }, [f("div", {
          class: E,
          style: T
        }, [R]), A < M && I && f("span", {
          class: `${E}-split`,
          style: T
        }, [I])]));
      })]);
    };
  }
});
ui.Compact = wd;
ui.install = function(e) {
  return e.component(ui.name, ui), e.component(wd.name, wd), e;
};
const aQ = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      position: "relative",
      padding: `${e.pageHeaderPaddingVertical}px ${e.pageHeaderPadding}px`,
      backgroundColor: e.colorBgContainer,
      [`&${t}-ghost`]: {
        backgroundColor: e.pageHeaderGhostBg
      },
      "&.has-footer": {
        paddingBottom: 0
      },
      [`${t}-back`]: {
        marginRight: e.marginMD,
        fontSize: e.fontSizeLG,
        lineHeight: 1,
        "&-button": m(m({}, wf(e)), {
          color: e.pageHeaderBackColor,
          cursor: "pointer"
        })
      },
      [`${n}-divider-vertical`]: {
        height: "14px",
        margin: `0 ${e.marginSM}`,
        verticalAlign: "middle"
      },
      [`${n}-breadcrumb + &-heading`]: {
        marginTop: e.marginXS
      },
      [`${t}-heading`]: {
        display: "flex",
        justifyContent: "space-between",
        "&-left": {
          display: "flex",
          alignItems: "center",
          margin: `${e.marginXS / 2}px 0`,
          overflow: "hidden"
        },
        "&-title": m({
          marginRight: e.marginSM,
          marginBottom: 0,
          color: e.colorTextHeading,
          fontWeight: 600,
          fontSize: e.pageHeaderHeadingTitle,
          lineHeight: `${e.controlHeight}px`
        }, tn),
        [`${n}-avatar`]: {
          marginRight: e.marginSM
        },
        "&-sub-title": m({
          marginRight: e.marginSM,
          color: e.colorTextDescription,
          fontSize: e.pageHeaderHeadingSubTitle,
          lineHeight: e.lineHeight
        }, tn),
        "&-extra": {
          margin: `${e.marginXS / 2}px 0`,
          whiteSpace: "nowrap",
          "> *": {
            marginLeft: e.marginSM,
            whiteSpace: "unset"
          },
          "> *:first-child": {
            marginLeft: 0
          }
        }
      },
      [`${t}-content`]: {
        paddingTop: e.pageHeaderContentPaddingVertical
      },
      [`${t}-footer`]: {
        marginTop: e.marginMD,
        [`${n}-tabs`]: {
          [`> ${n}-tabs-nav`]: {
            margin: 0,
            "&::before": {
              border: "none"
            }
          },
          [`${n}-tabs-tab`]: {
            paddingTop: e.paddingXS,
            paddingBottom: e.paddingXS,
            fontSize: e.pageHeaderTabFontSize
          }
        }
      },
      [`${t}-compact ${t}-heading`]: {
        flexWrap: "wrap"
      },
      // rtl style
      [`&${e.componentCls}-rtl`]: {
        direction: "rtl"
      }
    })
  };
}, iQ = Xe("PageHeader", (e) => {
  const t = He(e, {
    pageHeaderPadding: e.paddingLG,
    pageHeaderPaddingVertical: e.paddingMD,
    pageHeaderPaddingBreadcrumb: e.paddingSM,
    pageHeaderContentPaddingVertical: e.paddingSM,
    pageHeaderBackColor: e.colorTextBase,
    pageHeaderGhostBg: "transparent",
    pageHeaderHeadingTitle: e.fontSizeHeading4,
    pageHeaderHeadingSubTitle: e.fontSize,
    pageHeaderTabFontSize: e.fontSizeLG
  });
  return [aQ(t)];
}), sQ = () => ({
  backIcon: Rn(),
  prefixCls: String,
  title: Rn(),
  subTitle: Rn(),
  breadcrumb: V.object,
  tags: Rn(),
  footer: Rn(),
  extra: Rn(),
  avatar: Re(),
  ghost: {
    type: Boolean,
    default: void 0
  },
  onBack: Function
}), cQ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "APageHeader",
  inheritAttrs: !1,
  props: sQ(),
  // emits: ['back'],
  slots: Object,
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: r
    } = t;
    const {
      prefixCls: l,
      direction: a,
      pageHeader: i
    } = Ie("page-header", e), [s, c] = iQ(l), u = Q(!1), d = KI(), p = (w) => {
      let {
        width: $
      } = w;
      d.value || (u.value = $ < 768);
    }, v = P(() => {
      var w, $, O;
      return (O = (w = e.ghost) !== null && w !== void 0 ? w : ($ = i == null ? void 0 : i.value) === null || $ === void 0 ? void 0 : $.ghost) !== null && O !== void 0 ? O : !0;
    }), h = () => {
      var w, $, O;
      return (O = (w = e.backIcon) !== null && w !== void 0 ? w : ($ = o.backIcon) === null || $ === void 0 ? void 0 : $.call(o)) !== null && O !== void 0 ? O : a.value === "rtl" ? f(Db, null, null) : f(Ab, null, null);
    }, g = (w) => !w || !e.onBack ? null : f(ma, {
      componentName: "PageHeader",
      children: ($) => {
        let {
          back: O
        } = $;
        return f("div", {
          class: `${l.value}-back`
        }, [f(ef, {
          onClick: (x) => {
            n("back", x);
          },
          class: `${l.value}-back-button`,
          "aria-label": O
        }, {
          default: () => [w]
        })]);
      }
    }, null), b = () => {
      var w;
      return e.breadcrumb ? f(ta, e.breadcrumb, null) : (w = o.breadcrumb) === null || w === void 0 ? void 0 : w.call(o);
    }, y = () => {
      var w, $, O, x, I, E, _, M, R;
      const {
        avatar: A
      } = e, z = (w = e.title) !== null && w !== void 0 ? w : ($ = o.title) === null || $ === void 0 ? void 0 : $.call(o), T = (O = e.subTitle) !== null && O !== void 0 ? O : (x = o.subTitle) === null || x === void 0 ? void 0 : x.call(o), N = (I = e.tags) !== null && I !== void 0 ? I : (E = o.tags) === null || E === void 0 ? void 0 : E.call(o), k = (_ = e.extra) !== null && _ !== void 0 ? _ : (M = o.extra) === null || M === void 0 ? void 0 : M.call(o), B = `${l.value}-heading`, F = z || T || N || k;
      if (!F)
        return null;
      const L = h(), j = g(L);
      return f("div", {
        class: B
      }, [(j || A || F) && f("div", {
        class: `${B}-left`
      }, [j, A ? f(ea, A, null) : (R = o.avatar) === null || R === void 0 ? void 0 : R.call(o), z && f("span", {
        class: `${B}-title`,
        title: typeof z == "string" ? z : void 0
      }, [z]), T && f("span", {
        class: `${B}-sub-title`,
        title: typeof T == "string" ? T : void 0
      }, [T]), N && f("span", {
        class: `${B}-tags`
      }, [N])]), k && f("span", {
        class: `${B}-extra`
      }, [f(ui, null, {
        default: () => [k]
      })])]);
    }, S = () => {
      var w, $;
      const O = (w = e.footer) !== null && w !== void 0 ? w : Lt(($ = o.footer) === null || $ === void 0 ? void 0 : $.call(o));
      return qT(O) ? null : f("div", {
        class: `${l.value}-footer`
      }, [O]);
    }, C = (w) => f("div", {
      class: `${l.value}-content`
    }, [w]);
    return () => {
      var w, $;
      const O = ((w = e.breadcrumb) === null || w === void 0 ? void 0 : w.routes) || o.breadcrumb, x = e.footer || o.footer, I = It(($ = o.default) === null || $ === void 0 ? void 0 : $.call(o)), E = ee(l.value, {
        "has-breadcrumb": O,
        "has-footer": x,
        [`${l.value}-ghost`]: v.value,
        [`${l.value}-rtl`]: a.value === "rtl",
        [`${l.value}-compact`]: u.value
      }, r.class, c.value);
      return s(f(Fo, {
        onResize: p
      }, {
        default: () => [f("div", D(D({}, r), {}, {
          class: E
        }), [b(), y(), I.length ? C(I) : null, S()])]
      }));
    };
  }
}), uQ = kt(cQ), dQ = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    zIndexPopup: o,
    colorText: r,
    colorWarning: l,
    marginXS: a,
    fontSize: i,
    fontWeightStrong: s,
    lineHeight: c
  } = e;
  return {
    [t]: {
      zIndex: o,
      [`${t}-inner-content`]: {
        color: r
      },
      [`${t}-message`]: {
        position: "relative",
        marginBottom: a,
        color: r,
        fontSize: i,
        display: "flex",
        flexWrap: "nowrap",
        alignItems: "start",
        [`> ${t}-message-icon ${n}`]: {
          color: l,
          fontSize: i,
          flex: "none",
          lineHeight: 1,
          paddingTop: (Math.round(i * c) - i) / 2
        },
        "&-title": {
          flex: "auto",
          marginInlineStart: a
        },
        "&-title-only": {
          fontWeight: s
        }
      },
      [`${t}-description`]: {
        position: "relative",
        marginInlineStart: i + a,
        marginBottom: a,
        color: r,
        fontSize: i
      },
      [`${t}-buttons`]: {
        textAlign: "end",
        button: {
          marginInlineStart: a
        }
      }
    }
  };
}, fQ = Xe("Popconfirm", (e) => dQ(e), (e) => {
  const {
    zIndexPopupBase: t
  } = e;
  return {
    zIndexPopup: t + 60
  };
});
var pQ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const vQ = () => m(m({}, c0()), {
  prefixCls: String,
  content: _t(),
  title: _t(),
  description: _t(),
  okType: ke("primary"),
  disabled: {
    type: Boolean,
    default: !1
  },
  okText: _t(),
  cancelText: _t(),
  icon: _t(),
  okButtonProps: Re(),
  cancelButtonProps: Re(),
  showCancel: {
    type: Boolean,
    default: !0
  },
  onConfirm: Function,
  onCancel: Function
}), gQ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "APopconfirm",
  inheritAttrs: !1,
  props: Qe(vQ(), m(m({}, IO()), {
    trigger: "click",
    placement: "top",
    mouseEnterDelay: 0.1,
    mouseLeaveDelay: 0.1,
    arrowPointAtCenter: !1,
    autoAdjustOverflow: !0,
    okType: "primary",
    disabled: !1
  })),
  slots: Object,
  // emits: ['update:open', 'visibleChange'],
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      expose: r,
      attrs: l
    } = t;
    const a = Y();
    Mt(e.visible === void 0, "Popconfirm", "`visible` will be removed in next major version, please use `open` instead."), r({
      getPopupDomNode: () => {
        var O, x;
        return (x = (O = a.value) === null || O === void 0 ? void 0 : O.getPopupDomNode) === null || x === void 0 ? void 0 : x.call(O);
      }
    });
    const [i, s] = Rt(!1, {
      value: Te(e, "open")
    }), c = (O, x) => {
      e.open === void 0 && s(O), o("update:open", O), o("openChange", O, x);
    }, u = (O) => {
      c(!1, O);
    }, d = (O) => {
      var x;
      return (x = e.onConfirm) === null || x === void 0 ? void 0 : x.call(e, O);
    }, p = (O) => {
      var x;
      c(!1, O), (x = e.onCancel) === null || x === void 0 || x.call(e, O);
    }, v = (O) => {
      O.keyCode === ce.ESC && i && c(!1, O);
    }, h = (O) => {
      const {
        disabled: x
      } = e;
      x || c(O);
    }, {
      prefixCls: g,
      getPrefixCls: b
    } = Ie("popconfirm", e), y = P(() => b()), S = P(() => b("btn")), [C] = fQ(g), [w] = jo("Popconfirm", Zn.Popconfirm), $ = () => {
      var O, x, I, E, _;
      const {
        okButtonProps: M,
        cancelButtonProps: R,
        title: A = (O = n.title) === null || O === void 0 ? void 0 : O.call(n),
        description: z = (x = n.description) === null || x === void 0 ? void 0 : x.call(n),
        cancelText: T = (I = n.cancel) === null || I === void 0 ? void 0 : I.call(n),
        okText: N = (E = n.okText) === null || E === void 0 ? void 0 : E.call(n),
        okType: k,
        icon: B = ((_ = n.icon) === null || _ === void 0 ? void 0 : _.call(n)) || f(sr, null, null),
        showCancel: F = !0
      } = e, {
        cancelButton: L,
        okButton: j
      } = n, H = m({
        onClick: p,
        size: "small"
      }, R), K = m(m(m({
        onClick: d
      }, Ed(k)), {
        size: "small"
      }), M);
      return f("div", {
        class: `${g.value}-inner-content`
      }, [f("div", {
        class: `${g.value}-message`
      }, [B && f("span", {
        class: `${g.value}-message-icon`
      }, [B]), f("div", {
        class: [`${g.value}-message-title`, {
          [`${g.value}-message-title-only`]: !!z
        }]
      }, [A])]), z && f("div", {
        class: `${g.value}-description`
      }, [z]), f("div", {
        class: `${g.value}-buttons`
      }, [F ? L ? L(H) : f(Kt, H, {
        default: () => [T || w.value.cancelText]
      }) : null, j ? j(K) : f(Em, {
        buttonProps: m(m({
          size: "small"
        }, Ed(k)), M),
        actionFn: d,
        close: u,
        prefixCls: S.value,
        quitOnNullishReturnValue: !0,
        emitEvent: !0
      }, {
        default: () => [N || w.value.okText]
      })])]);
    };
    return () => {
      var O;
      const {
        placement: x,
        overlayClassName: I,
        trigger: E = "click"
      } = e, _ = pQ(e, ["placement", "overlayClassName", "trigger"]), M = ot(_, ["title", "content", "cancelText", "okText", "onUpdate:open", "onConfirm", "onCancel", "prefixCls"]), R = ee(g.value, I);
      return C(f(p0, D(D(D({}, M), l), {}, {
        trigger: E,
        placement: x,
        onOpenChange: h,
        open: i.value,
        overlayClassName: R,
        transitionName: Vn(y.value, "zoom-big", e.transitionName),
        ref: a,
        "data-popover-inject": !0
      }), {
        default: () => [u7(((O = n.default) === null || O === void 0 ? void 0 : O.call(n)) || [], {
          onKeydown: (A) => {
            v(A);
          }
        }, !1)],
        content: $
      }));
    };
  }
}), mQ = kt(gQ), hQ = ["normal", "exception", "active", "success"], Op = () => ({
  prefixCls: String,
  type: ke(),
  percent: Number,
  format: le(),
  status: ke(),
  showInfo: ve(),
  strokeWidth: Number,
  strokeLinecap: ke(),
  strokeColor: _t(),
  trailColor: String,
  /** @deprecated Use `size` instead */
  width: Number,
  success: Re(),
  gapDegree: Number,
  gapPosition: ke(),
  size: je([String, Number, Array]),
  steps: Number,
  /** @deprecated Use `success` instead */
  successPercent: Number,
  title: String,
  progressStatus: ke()
});
function ra(e) {
  return !e || e < 0 ? 0 : e > 100 ? 100 : e;
}
function tf(e) {
  let {
    success: t,
    successPercent: n
  } = e, o = n;
  return t && "progress" in t && (nt(!1, "Progress", "`success.progress` is deprecated. Please use `success.percent` instead."), o = t.progress), t && "percent" in t && (o = t.percent), o;
}
function bQ(e) {
  let {
    percent: t,
    success: n,
    successPercent: o
  } = e;
  const r = ra(tf({
    success: n,
    successPercent: o
  }));
  return [r, ra(ra(t) - r)];
}
function yQ(e) {
  let {
    success: t = {},
    strokeColor: n
  } = e;
  const {
    strokeColor: o
  } = t;
  return [o || ei.green, n || null];
}
const Pp = (e, t, n) => {
  var o, r, l, a;
  let i = -1, s = -1;
  if (t === "step") {
    const c = n.steps, u = n.strokeWidth;
    typeof e == "string" || typeof e > "u" ? (i = e === "small" ? 2 : 14, s = u ?? 8) : typeof e == "number" ? [i, s] = [e, e] : [i = 14, s = 8] = e, i *= c;
  } else if (t === "line") {
    const c = n == null ? void 0 : n.strokeWidth;
    typeof e == "string" || typeof e > "u" ? s = c || (e === "small" ? 6 : 8) : typeof e == "number" ? [i, s] = [e, e] : [i = -1, s = 8] = e;
  } else
    (t === "circle" || t === "dashboard") && (typeof e == "string" || typeof e > "u" ? [i, s] = e === "small" ? [60, 60] : [120, 120] : typeof e == "number" ? [i, s] = [e, e] : (process.env.NODE_ENV !== "production" && nt(!1, "Progress", 'Type "circle" and "dashboard" do not accept array as `size`, please use number or preset size instead.'), i = (r = (o = e[0]) !== null && o !== void 0 ? o : e[1]) !== null && r !== void 0 ? r : 120, s = (a = (l = e[0]) !== null && l !== void 0 ? l : e[1]) !== null && a !== void 0 ? a : 120));
  return {
    width: i,
    height: s
  };
};
var SQ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const CQ = () => m(m({}, Op()), {
  strokeColor: _t(),
  direction: ke()
}), $Q = (e) => {
  let t = [];
  return Object.keys(e).forEach((n) => {
    const o = parseFloat(n.replace(/%/g, ""));
    isNaN(o) || t.push({
      key: o,
      value: e[n]
    });
  }), t = t.sort((n, o) => n.key - o.key), t.map((n) => {
    let {
      key: o,
      value: r
    } = n;
    return `${r} ${o}%`;
  }).join(", ");
}, wQ = (e, t) => {
  const {
    from: n = ei.blue,
    to: o = ei.blue,
    direction: r = t === "rtl" ? "to left" : "to right"
  } = e, l = SQ(e, ["from", "to", "direction"]);
  if (Object.keys(l).length !== 0) {
    const a = $Q(l);
    return {
      backgroundImage: `linear-gradient(${r}, ${a})`
    };
  }
  return {
    backgroundImage: `linear-gradient(${r}, ${n}, ${o})`
  };
}, xQ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressLine",
  inheritAttrs: !1,
  props: CQ(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = P(() => {
      const {
        strokeColor: v,
        direction: h
      } = e;
      return v && typeof v != "string" ? wQ(v, h) : {
        backgroundColor: v
      };
    }), l = P(() => e.strokeLinecap === "square" || e.strokeLinecap === "butt" ? 0 : void 0), a = P(() => e.trailColor ? {
      backgroundColor: e.trailColor
    } : void 0), i = P(() => {
      var v;
      return (v = e.size) !== null && v !== void 0 ? v : [-1, e.strokeWidth || (e.size === "small" ? 6 : 8)];
    }), s = P(() => Pp(i.value, "line", {
      strokeWidth: e.strokeWidth
    }));
    process.env.NODE_ENV !== "production" && nt("strokeWidth" in e, "Progress", "`strokeWidth` is deprecated. Please use `size` instead.");
    const c = P(() => {
      const {
        percent: v
      } = e;
      return m({
        width: `${ra(v)}%`,
        height: `${s.value.height}px`,
        borderRadius: l.value
      }, r.value);
    }), u = P(() => tf(e)), d = P(() => {
      const {
        success: v
      } = e;
      return {
        width: `${ra(u.value)}%`,
        height: `${s.value.height}px`,
        borderRadius: l.value,
        backgroundColor: v == null ? void 0 : v.strokeColor
      };
    }), p = {
      width: s.value.width < 0 ? "100%" : s.value.width,
      height: `${s.value.height}px`
    };
    return () => {
      var v;
      return f(Fe, null, [f("div", D(D({}, o), {}, {
        class: [`${e.prefixCls}-outer`, o.class],
        style: [o.style, p]
      }), [f("div", {
        class: `${e.prefixCls}-inner`,
        style: a.value
      }, [f("div", {
        class: `${e.prefixCls}-bg`,
        style: c.value
      }, null), u.value !== void 0 ? f("div", {
        class: `${e.prefixCls}-success-bg`,
        style: d.value
      }, null) : null])]), (v = n.default) === null || v === void 0 ? void 0 : v.call(n)]);
    };
  }
}), OQ = {
  percent: 0,
  prefixCls: "vc-progress",
  strokeColor: "#2db7f5",
  strokeLinecap: "round",
  strokeWidth: 1,
  trailColor: "#D9D9D9",
  trailWidth: 1
}, PQ = (e) => {
  const t = Y(null);
  return co(() => {
    const n = Date.now();
    let o = !1;
    e.value.forEach((r) => {
      const l = (r == null ? void 0 : r.$el) || r;
      if (!l)
        return;
      o = !0;
      const a = l.style;
      a.transitionDuration = ".3s, .3s, .3s, .06s", t.value && n - t.value < 100 && (a.transitionDuration = "0s, 0s");
    }), o && (t.value = Date.now());
  }), e;
}, IQ = {
  gapDegree: Number,
  gapPosition: {
    type: String
  },
  percent: {
    type: [Array, Number]
  },
  prefixCls: String,
  strokeColor: {
    type: [Object, String, Array]
  },
  strokeLinecap: {
    type: String
  },
  strokeWidth: Number,
  trailColor: String,
  trailWidth: Number,
  transition: String
};
var EQ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
let G$ = 0;
function X$(e) {
  return +e.replace("%", "");
}
function U$(e) {
  return Array.isArray(e) ? e : [e];
}
function Y$(e, t, n, o) {
  let r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0, l = arguments.length > 5 ? arguments[5] : void 0;
  const a = 50 - o / 2;
  let i = 0, s = -a, c = 0, u = -2 * a;
  switch (l) {
    case "left":
      i = -a, s = 0, c = 2 * a, u = 0;
      break;
    case "right":
      i = a, s = 0, c = -2 * a, u = 0;
      break;
    case "bottom":
      s = a, u = 2 * a;
      break;
  }
  const d = `M 50,50 m ${i},${s}
   a ${a},${a} 0 1 1 ${c},${-u}
   a ${a},${a} 0 1 1 ${-c},${u}`, p = Math.PI * 2 * a, v = {
    stroke: n,
    strokeDasharray: `${t / 100 * (p - r)}px ${p}px`,
    strokeDashoffset: `-${r / 2 + e / 100 * (p - r)}px`,
    transition: "stroke-dashoffset .3s ease 0s, stroke-dasharray .3s ease 0s, stroke .3s, stroke-width .06s ease .3s, opacity .3s ease 0s"
    // eslint-disable-line
  };
  return {
    pathString: d,
    pathStyle: v
  };
}
const TQ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "VCCircle",
  props: Qe(IQ, OQ),
  setup(e) {
    G$ += 1;
    const t = Y(G$), n = P(() => U$(e.percent)), o = P(() => U$(e.strokeColor)), [r, l] = X0();
    PQ(l);
    const a = () => {
      const {
        prefixCls: i,
        strokeWidth: s,
        strokeLinecap: c,
        gapDegree: u,
        gapPosition: d
      } = e;
      let p = 0;
      return n.value.map((v, h) => {
        const g = o.value[h] || o.value[o.value.length - 1], b = Object.prototype.toString.call(g) === "[object Object]" ? `url(#${i}-gradient-${t.value})` : "", {
          pathString: y,
          pathStyle: S
        } = Y$(p, v, g, s, u, d);
        p += v;
        const C = {
          key: h,
          d: y,
          stroke: b,
          "stroke-linecap": c,
          "stroke-width": s,
          opacity: v === 0 ? 0 : 1,
          "fill-opacity": "0",
          class: `${i}-circle-path`,
          style: S
        };
        return f("path", D({
          ref: r(h)
        }, C), null);
      });
    };
    return () => {
      const {
        prefixCls: i,
        strokeWidth: s,
        trailWidth: c,
        gapDegree: u,
        gapPosition: d,
        trailColor: p,
        strokeLinecap: v,
        strokeColor: h
      } = e, g = EQ(e, ["prefixCls", "strokeWidth", "trailWidth", "gapDegree", "gapPosition", "trailColor", "strokeLinecap", "strokeColor"]), {
        pathString: b,
        pathStyle: y
      } = Y$(0, 100, p, s, u, d);
      delete g.percent;
      const S = o.value.find((w) => Object.prototype.toString.call(w) === "[object Object]"), C = {
        d: b,
        stroke: p,
        "stroke-linecap": v,
        "stroke-width": c || s,
        "fill-opacity": "0",
        class: `${i}-circle-trail`,
        style: y
      };
      return f("svg", D({
        class: `${i}-circle`,
        viewBox: "0 0 100 100"
      }, g), [S && f("defs", null, [f("linearGradient", {
        id: `${i}-gradient-${t.value}`,
        x1: "100%",
        y1: "0%",
        x2: "0%",
        y2: "0%"
      }, [Object.keys(S).sort((w, $) => X$(w) - X$($)).map((w, $) => f("stop", {
        key: $,
        offset: w,
        "stop-color": S[w]
      }, null))])]), f("path", C, null), a().reverse()]);
    };
  }
}), MQ = () => m(m({}, Op()), {
  strokeColor: _t()
}), _Q = 3, AQ = (e) => _Q / e * 100, DQ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ProgressCircle",
  inheritAttrs: !1,
  props: Qe(MQ(), {
    trailColor: null
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = P(() => {
      var g;
      return (g = e.width) !== null && g !== void 0 ? g : 120;
    }), l = P(() => {
      var g;
      return (g = e.size) !== null && g !== void 0 ? g : [r.value, r.value];
    }), a = P(() => Pp(l.value, "circle")), i = P(() => {
      if (e.gapDegree || e.gapDegree === 0)
        return e.gapDegree;
      if (e.type === "dashboard")
        return 75;
    }), s = P(() => ({
      width: `${a.value.width}px`,
      height: `${a.value.height}px`,
      fontSize: `${a.value.width * 0.15 + 6}px`
    })), c = P(() => {
      var g;
      return (g = e.strokeWidth) !== null && g !== void 0 ? g : Math.max(AQ(a.value.width), 6);
    }), u = P(() => e.gapPosition || e.type === "dashboard" && "bottom" || void 0), d = P(() => bQ(e)), p = P(() => Object.prototype.toString.call(e.strokeColor) === "[object Object]"), v = P(() => yQ({
      success: e.success,
      strokeColor: e.strokeColor
    })), h = P(() => ({
      [`${e.prefixCls}-inner`]: !0,
      [`${e.prefixCls}-circle-gradient`]: p.value
    }));
    return () => {
      var g;
      const b = f(TQ, {
        percent: d.value,
        strokeWidth: c.value,
        trailWidth: c.value,
        strokeColor: v.value,
        strokeLinecap: e.strokeLinecap,
        trailColor: e.trailColor,
        prefixCls: e.prefixCls,
        gapDegree: i.value,
        gapPosition: u.value
      }, null);
      return f("div", D(D({}, o), {}, {
        class: [h.value, o.class],
        style: [o.style, s.value]
      }), [a.value.width <= 20 ? f(Ln, null, {
        default: () => [f("span", null, [b])],
        title: n.default
      }) : f(Fe, null, [b, (g = n.default) === null || g === void 0 ? void 0 : g.call(n)])]);
    };
  }
}), NQ = () => m(m({}, Op()), {
  steps: Number,
  strokeColor: je(),
  trailColor: String
}), RQ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: NQ(),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = P(() => Math.round(e.steps * ((e.percent || 0) / 100))), r = P(() => {
      var i;
      return (i = e.size) !== null && i !== void 0 ? i : [e.size === "small" ? 2 : 14, e.strokeWidth || 8];
    }), l = P(() => Pp(r.value, "step", {
      steps: e.steps,
      strokeWidth: e.strokeWidth || 8
    })), a = P(() => {
      const {
        steps: i,
        strokeColor: s,
        trailColor: c,
        prefixCls: u
      } = e, d = [];
      for (let p = 0; p < i; p += 1) {
        const v = Array.isArray(s) ? s[p] : s, h = {
          [`${u}-steps-item`]: !0,
          [`${u}-steps-item-active`]: p <= o.value - 1
        };
        d.push(f("div", {
          key: p,
          class: h,
          style: {
            backgroundColor: p <= o.value - 1 ? v : c,
            width: `${l.value.width / i}px`,
            height: `${l.value.height}px`
          }
        }, null));
      }
      return d;
    });
    return () => {
      var i;
      return f("div", {
        class: `${e.prefixCls}-steps-outer`
      }, [a.value, (i = n.default) === null || i === void 0 ? void 0 : i.call(n)]);
    };
  }
}), kQ = new lt("antProgressActive", {
  "0%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.1
  },
  "20%": {
    transform: "translateX(-100%) scaleX(0)",
    opacity: 0.5
  },
  to: {
    transform: "translateX(0) scaleX(1)",
    opacity: 0
  }
}), BQ = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      display: "inline-block",
      "&-rtl": {
        direction: "rtl"
      },
      "&-line": {
        position: "relative",
        width: "100%",
        fontSize: e.fontSize,
        marginInlineEnd: e.marginXS,
        marginBottom: e.marginXS
      },
      [`${t}-outer`]: {
        display: "inline-block",
        width: "100%"
      },
      [`&${t}-show-info`]: {
        [`${t}-outer`]: {
          marginInlineEnd: `calc(-2em - ${e.marginXS}px)`,
          paddingInlineEnd: `calc(2em + ${e.paddingXS}px)`
        }
      },
      [`${t}-inner`]: {
        position: "relative",
        display: "inline-block",
        width: "100%",
        overflow: "hidden",
        verticalAlign: "middle",
        backgroundColor: e.progressRemainingColor,
        borderRadius: e.progressLineRadius
      },
      [`${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorInfo
        }
      },
      [`${t}-success-bg, ${t}-bg`]: {
        position: "relative",
        backgroundColor: e.colorInfo,
        borderRadius: e.progressLineRadius,
        transition: `all ${e.motionDurationSlow} ${e.motionEaseInOutCirc}`
      },
      [`${t}-success-bg`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        backgroundColor: e.colorSuccess
      },
      [`${t}-text`]: {
        display: "inline-block",
        width: "2em",
        marginInlineStart: e.marginXS,
        color: e.progressInfoTextColor,
        lineHeight: 1,
        whiteSpace: "nowrap",
        textAlign: "start",
        verticalAlign: "middle",
        wordBreak: "normal",
        [n]: {
          fontSize: e.fontSize
        }
      },
      [`&${t}-status-active`]: {
        [`${t}-bg::before`]: {
          position: "absolute",
          inset: 0,
          backgroundColor: e.colorBgContainer,
          borderRadius: e.progressLineRadius,
          opacity: 0,
          animationName: kQ,
          animationDuration: e.progressActiveMotionDuration,
          animationTimingFunction: e.motionEaseOutQuint,
          animationIterationCount: "infinite",
          content: '""'
        }
      },
      [`&${t}-status-exception`]: {
        [`${t}-bg`]: {
          backgroundColor: e.colorError
        },
        [`${t}-text`]: {
          color: e.colorError
        }
      },
      [`&${t}-status-exception ${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorError
        }
      },
      [`&${t}-status-success`]: {
        [`${t}-bg`]: {
          backgroundColor: e.colorSuccess
        },
        [`${t}-text`]: {
          color: e.colorSuccess
        }
      },
      [`&${t}-status-success ${t}-inner:not(${t}-circle-gradient)`]: {
        [`${t}-circle-path`]: {
          stroke: e.colorSuccess
        }
      }
    })
  };
}, FQ = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: {
      [`${t}-circle-trail`]: {
        stroke: e.progressRemainingColor
      },
      [`&${t}-circle ${t}-inner`]: {
        position: "relative",
        lineHeight: 1,
        backgroundColor: "transparent"
      },
      [`&${t}-circle ${t}-text`]: {
        position: "absolute",
        insetBlockStart: "50%",
        insetInlineStart: 0,
        width: "100%",
        margin: 0,
        padding: 0,
        color: e.colorText,
        lineHeight: 1,
        whiteSpace: "normal",
        textAlign: "center",
        transform: "translateY(-50%)",
        [n]: {
          fontSize: `${e.fontSize / e.fontSizeSM}em`
        }
      },
      [`${t}-circle&-status-exception`]: {
        [`${t}-text`]: {
          color: e.colorError
        }
      },
      [`${t}-circle&-status-success`]: {
        [`${t}-text`]: {
          color: e.colorSuccess
        }
      }
    },
    [`${t}-inline-circle`]: {
      lineHeight: 1,
      [`${t}-inner`]: {
        verticalAlign: "bottom"
      }
    }
  };
}, LQ = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`${t}-steps`]: {
        display: "inline-block",
        "&-outer": {
          display: "flex",
          flexDirection: "row",
          alignItems: "center"
        },
        "&-item": {
          flexShrink: 0,
          minWidth: e.progressStepMinWidth,
          marginInlineEnd: e.progressStepMarginInlineEnd,
          backgroundColor: e.progressRemainingColor,
          transition: `all ${e.motionDurationSlow}`,
          "&-active": {
            backgroundColor: e.colorInfo
          }
        }
      }
    }
  };
}, zQ = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [t]: {
      [`${t}-small&-line, ${t}-small&-line ${t}-text ${n}`]: {
        fontSize: e.fontSizeSM
      }
    }
  };
}, HQ = Xe("Progress", (e) => {
  const t = e.marginXXS / 2, n = He(e, {
    progressLineRadius: 100,
    progressInfoTextColor: e.colorText,
    progressDefaultColor: e.colorInfo,
    progressRemainingColor: e.colorFillSecondary,
    progressStepMarginInlineEnd: t,
    progressStepMinWidth: t,
    progressActiveMotionDuration: "2.4s"
  });
  return [BQ(n), FQ(n), LQ(n), zQ(n)];
});
var jQ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const VQ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AProgress",
  inheritAttrs: !1,
  props: Qe(Op(), {
    type: "line",
    percent: 0,
    showInfo: !0,
    // null for different theme definition
    trailColor: null,
    size: "default",
    strokeLinecap: "round"
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("progress", e), [a, i] = HQ(r);
    process.env.NODE_ENV !== "production" && (nt("successPercent" in e, "Progress", "`successPercent` is deprecated. Please use `success.percent` instead."), nt("width" in e, "Progress", "`width` is deprecated. Please use `size` instead."));
    const s = P(() => Array.isArray(e.strokeColor) ? e.strokeColor[0] : e.strokeColor), c = P(() => {
      const {
        percent: h = 0
      } = e, g = tf(e);
      return parseInt(g !== void 0 ? g.toString() : h.toString(), 10);
    }), u = P(() => {
      const {
        status: h
      } = e;
      return !hQ.includes(h) && c.value >= 100 ? "success" : h || "normal";
    }), d = P(() => {
      const {
        type: h,
        showInfo: g,
        size: b
      } = e, y = r.value;
      return {
        [y]: !0,
        [`${y}-inline-circle`]: h === "circle" && Pp(b, "circle").width <= 20,
        [`${y}-${h === "dashboard" && "circle" || h}`]: !0,
        [`${y}-status-${u.value}`]: !0,
        [`${y}-show-info`]: g,
        [`${y}-${b}`]: b,
        [`${y}-rtl`]: l.value === "rtl",
        [i.value]: !0
      };
    }), p = P(() => typeof e.strokeColor == "string" || Array.isArray(e.strokeColor) ? e.strokeColor : void 0), v = () => {
      const {
        showInfo: h,
        format: g,
        type: b,
        percent: y,
        title: S
      } = e, C = tf(e);
      if (!h)
        return null;
      let w;
      const $ = g || (n == null ? void 0 : n.format) || ((x) => `${x}%`), O = b === "line";
      return g || n != null && n.format || u.value !== "exception" && u.value !== "success" ? w = $(ra(y), ra(C)) : u.value === "exception" ? w = O ? f(Gn, null, null) : f(Kn, null, null) : u.value === "success" && (w = O ? f(ir, null, null) : f(Mi, null, null)), f("span", {
        class: `${r.value}-text`,
        title: S === void 0 && typeof w == "string" ? w : void 0
      }, [w]);
    };
    return () => {
      const {
        type: h,
        steps: g,
        title: b
      } = e, {
        class: y
      } = o, S = jQ(o, ["class"]), C = v();
      let w;
      return h === "line" ? w = g ? f(RQ, D(D({}, e), {}, {
        strokeColor: p.value,
        prefixCls: r.value,
        steps: g
      }), {
        default: () => [C]
      }) : f(xQ, D(D({}, e), {}, {
        strokeColor: s.value,
        prefixCls: r.value,
        direction: l.value
      }), {
        default: () => [C]
      }) : (h === "circle" || h === "dashboard") && (w = f(DQ, D(D({}, e), {}, {
        prefixCls: r.value,
        strokeColor: s.value,
        progressStatus: u.value
      }), {
        default: () => [C]
      })), a(f("div", D(D({
        role: "progressbar"
      }, S), {}, {
        class: [d.value, y],
        title: b
      }), [w]));
    };
  }
}), Nb = kt(VQ);
function WQ(e) {
  let t = e.scrollX;
  const n = "scrollLeft";
  if (typeof t != "number") {
    const o = e.document;
    t = o.documentElement[n], typeof t != "number" && (t = o.body[n]);
  }
  return t;
}
function KQ(e) {
  let t, n;
  const o = e.ownerDocument, {
    body: r
  } = o, l = o && o.documentElement, a = e.getBoundingClientRect();
  return t = a.left, n = a.top, t -= l.clientLeft || r.clientLeft || 0, n -= l.clientTop || r.clientTop || 0, {
    left: t,
    top: n
  };
}
function GQ(e) {
  const t = KQ(e), n = e.ownerDocument, o = n.defaultView || n.parentWindow;
  return t.left += WQ(o), t.left;
}
var XQ = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M908.1 353.1l-253.9-36.9L540.7 86.1c-3.1-6.3-8.2-11.4-14.5-14.5-15.8-7.8-35-1.3-42.9 14.5L369.8 316.2l-253.9 36.9c-7 1-13.4 4.3-18.3 9.3a32.05 32.05 0 00.6 45.3l183.7 179.1-43.4 252.9a31.95 31.95 0 0046.4 33.7L512 754l227.1 119.4c6.2 3.3 13.4 4.4 20.3 3.2 17.4-3 29.1-19.5 26.1-36.9l-43.4-252.9 183.7-179.1c5-4.9 8.3-11.3 9.3-18.3 2.7-17.5-9.5-33.7-27-36.3z" } }] }, name: "star", theme: "filled" };
function q$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      UQ(e, r, n[r]);
    });
  }
  return e;
}
function UQ(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Rb = function(t, n) {
  var o = q$({}, t, n.attrs);
  return f(Ge, q$({}, o, {
    icon: XQ
  }), null);
};
Rb.displayName = "StarFilled";
Rb.inheritAttrs = !1;
const YQ = {
  value: Number,
  index: Number,
  prefixCls: String,
  allowHalf: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  character: V.any,
  characterRender: Function,
  focused: {
    type: Boolean,
    default: void 0
  },
  count: Number,
  onClick: Function,
  onHover: Function
}, qQ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Star",
  inheritAttrs: !1,
  props: YQ,
  emits: ["hover", "click"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    const o = (i) => {
      const {
        index: s
      } = e;
      n("hover", i, s);
    }, r = (i) => {
      const {
        index: s
      } = e;
      n("click", i, s);
    }, l = (i) => {
      const {
        index: s
      } = e;
      i.keyCode === 13 && n("click", i, s);
    }, a = P(() => {
      const {
        prefixCls: i,
        index: s,
        value: c,
        allowHalf: u,
        focused: d
      } = e, p = s + 1;
      let v = i;
      return c === 0 && s === 0 && d ? v += ` ${i}-focused` : u && c + 0.5 >= p && c < p ? (v += ` ${i}-half ${i}-active`, d && (v += ` ${i}-focused`)) : (v += p <= c ? ` ${i}-full` : ` ${i}-zero`, p === c && d && (v += ` ${i}-focused`)), v;
    });
    return () => {
      const {
        disabled: i,
        prefixCls: s,
        characterRender: c,
        character: u,
        index: d,
        count: p,
        value: v
      } = e, h = typeof u == "function" ? u({
        disabled: i,
        prefixCls: s,
        index: d,
        count: p,
        value: v
      }) : u;
      let g = f("li", {
        class: a.value
      }, [f("div", {
        onClick: i ? null : r,
        onKeydown: i ? null : l,
        onMousemove: i ? null : o,
        role: "radio",
        "aria-checked": v > d ? "true" : "false",
        "aria-posinset": d + 1,
        "aria-setsize": p,
        tabindex: i ? -1 : 0
      }, [f("div", {
        class: `${s}-first`
      }, [h]), f("div", {
        class: `${s}-second`
      }, [h])])]);
      return c && (g = c(g, e)), g;
    };
  }
}), ZQ = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-star`]: {
      position: "relative",
      display: "inline-block",
      color: "inherit",
      cursor: "pointer",
      "&:not(:last-child)": {
        marginInlineEnd: e.marginXS
      },
      "> div": {
        transition: `all ${e.motionDurationMid}, outline 0s`,
        "&:hover": {
          transform: e.rateStarHoverScale
        },
        "&:focus": {
          outline: 0
        },
        "&:focus-visible": {
          outline: `${e.lineWidth}px dashed ${e.rateStarColor}`,
          transform: e.rateStarHoverScale
        }
      },
      "&-first, &-second": {
        color: e.defaultColor,
        transition: `all ${e.motionDurationMid}`,
        userSelect: "none",
        [e.iconCls]: {
          verticalAlign: "middle"
        }
      },
      "&-first": {
        position: "absolute",
        top: 0,
        insetInlineStart: 0,
        width: "50%",
        height: "100%",
        overflow: "hidden",
        opacity: 0
      },
      [`&-half ${t}-star-first, &-half ${t}-star-second`]: {
        opacity: 1
      },
      [`&-half ${t}-star-first, &-full ${t}-star-second`]: {
        color: "inherit"
      }
    }
  };
}, QQ = (e) => ({
  [`&-rtl${e.componentCls}`]: {
    direction: "rtl"
  }
}), JQ = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: m(m(m(m(m({}, qe(e)), {
      display: "inline-block",
      margin: 0,
      padding: 0,
      color: e.rateStarColor,
      fontSize: e.rateStarSize,
      lineHeight: "unset",
      listStyle: "none",
      outline: "none",
      // disable styles
      [`&-disabled${t} ${t}-star`]: {
        cursor: "default",
        "&:hover": {
          transform: "scale(1)"
        }
      }
    }), ZQ(e)), {
      // text styles
      [`+ ${t}-text`]: {
        display: "inline-block",
        marginInlineStart: e.marginXS,
        fontSize: e.fontSize
      }
    }), QQ(e))
  };
}, eJ = Xe("Rate", (e) => {
  const {
    colorFillContent: t
  } = e, n = He(e, {
    rateStarColor: e["yellow-6"],
    rateStarSize: e.controlHeightLG * 0.5,
    rateStarHoverScale: "scale(1.1)",
    defaultColor: t
  });
  return [JQ(n)];
}), tJ = () => ({
  prefixCls: String,
  count: Number,
  value: Number,
  allowHalf: {
    type: Boolean,
    default: void 0
  },
  allowClear: {
    type: Boolean,
    default: void 0
  },
  tooltips: Array,
  disabled: {
    type: Boolean,
    default: void 0
  },
  character: V.any,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  tabindex: V.oneOfType([V.number, V.string]),
  direction: String,
  id: String,
  onChange: Function,
  onHoverChange: Function,
  "onUpdate:value": Function,
  onFocus: Function,
  onBlur: Function,
  onKeydown: Function
}), nJ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ARate",
  inheritAttrs: !1,
  props: Qe(tJ(), {
    value: 0,
    count: 5,
    allowHalf: !1,
    allowClear: !0,
    tabindex: 0,
    direction: "ltr"
  }),
  // emits: ['hoverChange', 'update:value', 'change', 'focus', 'blur', 'keydown'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r,
      expose: l
    } = t;
    const {
      prefixCls: a,
      direction: i
    } = Ie("rate", e), [s, c] = eJ(a), u = sn(), d = Y(), [p, v] = X0(), h = xt({
      value: e.value,
      focused: !1,
      cleanedValue: null,
      hoverValue: void 0
    });
    ie(() => e.value, () => {
      h.value = e.value;
    });
    const g = (M) => qn(v.value.get(M)), b = (M, R) => {
      const A = i.value === "rtl";
      let z = M + 1;
      if (e.allowHalf) {
        const T = g(M), N = GQ(T), k = T.clientWidth;
        (A && R - N > k / 2 || !A && R - N < k / 2) && (z -= 0.5);
      }
      return z;
    }, y = (M) => {
      e.value === void 0 && (h.value = M), r("update:value", M), r("change", M), u.onFieldChange();
    }, S = (M, R) => {
      const A = b(R, M.pageX);
      A !== h.cleanedValue && (h.hoverValue = A, h.cleanedValue = null), r("hoverChange", A);
    }, C = () => {
      h.hoverValue = void 0, h.cleanedValue = null, r("hoverChange", void 0);
    }, w = (M, R) => {
      const {
        allowClear: A
      } = e, z = b(R, M.pageX);
      let T = !1;
      A && (T = z === h.value), C(), y(T ? 0 : z), h.cleanedValue = T ? z : null;
    }, $ = (M) => {
      h.focused = !0, r("focus", M);
    }, O = (M) => {
      h.focused = !1, r("blur", M), u.onFieldBlur();
    }, x = (M) => {
      const {
        keyCode: R
      } = M, {
        count: A,
        allowHalf: z
      } = e, T = i.value === "rtl";
      R === ce.RIGHT && h.value < A && !T ? (z ? h.value += 0.5 : h.value += 1, y(h.value), M.preventDefault()) : R === ce.LEFT && h.value > 0 && !T || R === ce.RIGHT && h.value > 0 && T ? (z ? h.value -= 0.5 : h.value -= 1, y(h.value), M.preventDefault()) : R === ce.LEFT && h.value < A && T && (z ? h.value += 0.5 : h.value += 1, y(h.value), M.preventDefault()), r("keydown", M);
    }, I = () => {
      e.disabled || d.value.focus();
    };
    l({
      focus: I,
      blur: () => {
        e.disabled || d.value.blur();
      }
    }), Ke(() => {
      const {
        autofocus: M,
        disabled: R
      } = e;
      M && !R && I();
    });
    const _ = (M, R) => {
      let {
        index: A
      } = R;
      const {
        tooltips: z
      } = e;
      return z ? f(Ln, {
        title: z[A]
      }, {
        default: () => [M]
      }) : M;
    };
    return () => {
      const {
        count: M,
        allowHalf: R,
        disabled: A,
        tabindex: z,
        id: T = u.id.value
      } = e, {
        class: N,
        style: k
      } = o, B = [], F = A ? `${a.value}-disabled` : "", L = e.character || n.character || (() => f(Rb, null, null));
      for (let H = 0; H < M; H++)
        B.push(f(qQ, {
          ref: p(H),
          key: H,
          index: H,
          count: M,
          disabled: A,
          prefixCls: `${a.value}-star`,
          allowHalf: R,
          value: h.hoverValue === void 0 ? h.value : h.hoverValue,
          onClick: w,
          onHover: S,
          character: L,
          characterRender: _,
          focused: h.focused
        }, null));
      const j = ee(a.value, F, N, {
        [c.value]: !0,
        [`${a.value}-rtl`]: i.value === "rtl"
      });
      return s(f("ul", D(D({}, o), {}, {
        id: T,
        class: j,
        style: k,
        onMouseleave: A ? null : C,
        tabindex: A ? -1 : z,
        onFocus: A ? null : $,
        onBlur: A ? null : O,
        onKeydown: A ? null : x,
        ref: d,
        role: "radiogroup"
      }), [B]));
    };
  }
}), oJ = kt(nJ);
var rJ = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, name: "warning", theme: "filled" };
function Z$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      lJ(e, r, n[r]);
    });
  }
  return e;
}
function lJ(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var kb = function(t, n) {
  var o = Z$({}, t, n.attrs);
  return f(Ge, Z$({}, o, {
    icon: rJ
  }), null);
};
kb.displayName = "WarningFilled";
kb.inheritAttrs = !1;
const aJ = () => f("svg", {
  width: "252",
  height: "294"
}, [f("defs", null, [f("path", {
  d: "M0 .387h251.772v251.772H0z"
}, null)]), f("g", {
  fill: "none",
  "fill-rule": "evenodd"
}, [f("g", {
  transform: "translate(0 .012)"
}, [f("mask", {
  fill: "#fff"
}, null), f("path", {
  d: "M0 127.32v-2.095C0 56.279 55.892.387 124.838.387h2.096c68.946 0 124.838 55.892 124.838 124.838v2.096c0 68.946-55.892 124.838-124.838 124.838h-2.096C55.892 252.16 0 196.267 0 127.321",
  fill: "#E4EBF7",
  mask: "url(#b)"
}, null)]), f("path", {
  d: "M39.755 130.84a8.276 8.276 0 1 1-16.468-1.66 8.276 8.276 0 0 1 16.468 1.66",
  fill: "#FFF"
}, null), f("path", {
  d: "M36.975 134.297l10.482 5.943M48.373 146.508l-12.648 10.788",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), f("path", {
  d: "M39.875 159.352a5.667 5.667 0 1 1-11.277-1.136 5.667 5.667 0 0 1 11.277 1.136M57.588 143.247a5.708 5.708 0 1 1-11.358-1.145 5.708 5.708 0 0 1 11.358 1.145M99.018 26.875l29.82-.014a4.587 4.587 0 1 0-.003-9.175l-29.82.013a4.587 4.587 0 1 0 .003 9.176M110.424 45.211l29.82-.013a4.588 4.588 0 0 0-.004-9.175l-29.82.013a4.587 4.587 0 1 0 .004 9.175",
  fill: "#FFF"
}, null), f("path", {
  d: "M112.798 26.861v-.002l15.784-.006a4.588 4.588 0 1 0 .003 9.175l-15.783.007v-.002a4.586 4.586 0 0 0-.004-9.172M184.523 135.668c-.553 5.485-5.447 9.483-10.931 8.93-5.485-.553-9.483-5.448-8.93-10.932.552-5.485 5.447-9.483 10.932-8.93 5.485.553 9.483 5.447 8.93 10.932",
  fill: "#FFF"
}, null), f("path", {
  d: "M179.26 141.75l12.64 7.167M193.006 156.477l-15.255 13.011",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), f("path", {
  d: "M184.668 170.057a6.835 6.835 0 1 1-13.6-1.372 6.835 6.835 0 0 1 13.6 1.372M203.34 153.325a6.885 6.885 0 1 1-13.7-1.382 6.885 6.885 0 0 1 13.7 1.382",
  fill: "#FFF"
}, null), f("path", {
  d: "M151.931 192.324a2.222 2.222 0 1 1-4.444 0 2.222 2.222 0 0 1 4.444 0zM225.27 116.056a2.222 2.222 0 1 1-4.445 0 2.222 2.222 0 0 1 4.444 0zM216.38 151.08a2.223 2.223 0 1 1-4.446-.001 2.223 2.223 0 0 1 4.446 0zM176.917 107.636a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM195.291 92.165a2.223 2.223 0 1 1-4.445 0 2.223 2.223 0 0 1 4.445 0zM202.058 180.711a2.223 2.223 0 1 1-4.446 0 2.223 2.223 0 0 1 4.446 0z",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), f("path", {
  stroke: "#FFF",
  "stroke-width": "2",
  d: "M214.404 153.302l-1.912 20.184-10.928 5.99M173.661 174.792l-6.356 9.814h-11.36l-4.508 6.484M174.941 125.168v-15.804M220.824 117.25l-12.84 7.901-15.31-7.902V94.39"
}, null), f("path", {
  d: "M166.588 65.936h-3.951a4.756 4.756 0 0 1-4.743-4.742 4.756 4.756 0 0 1 4.743-4.743h3.951a4.756 4.756 0 0 1 4.743 4.743 4.756 4.756 0 0 1-4.743 4.742",
  fill: "#FFF"
}, null), f("path", {
  d: "M174.823 30.03c0-16.281 13.198-29.48 29.48-29.48 16.28 0 29.48 13.199 29.48 29.48 0 16.28-13.2 29.48-29.48 29.48-16.282 0-29.48-13.2-29.48-29.48",
  fill: "#1890FF"
}, null), f("path", {
  d: "M205.952 38.387c.5.5.785 1.142.785 1.928s-.286 1.465-.785 1.964c-.572.5-1.214.75-2 .75-.785 0-1.429-.285-1.929-.785-.572-.5-.82-1.143-.82-1.929s.248-1.428.82-1.928c.5-.5 1.144-.75 1.93-.75.785 0 1.462.25 1.999.75m4.285-19.463c1.428 1.249 2.143 2.963 2.143 5.142 0 1.712-.427 3.13-1.219 4.25-.067.096-.137.18-.218.265-.416.429-1.41 1.346-2.956 2.699a5.07 5.07 0 0 0-1.428 1.75 5.207 5.207 0 0 0-.536 2.357v.5h-4.107v-.5c0-1.357.215-2.536.714-3.5.464-.964 1.857-2.464 4.178-4.536l.43-.5c.643-.785.964-1.643.964-2.535 0-1.18-.358-2.108-1-2.785-.678-.68-1.643-1.001-2.858-1.001-1.536 0-2.642.464-3.357 1.43-.37.5-.621 1.135-.76 1.904a1.999 1.999 0 0 1-1.971 1.63h-.004c-1.277 0-2.257-1.183-1.98-2.43.337-1.518 1.02-2.78 2.073-3.784 1.536-1.5 3.607-2.25 6.25-2.25 2.32 0 4.214.607 5.642 1.894",
  fill: "#FFF"
}, null), f("path", {
  d: "M52.04 76.131s21.81 5.36 27.307 15.945c5.575 10.74-6.352 9.26-15.73 4.935-10.86-5.008-24.7-11.822-11.577-20.88",
  fill: "#FFB594"
}, null), f("path", {
  d: "M90.483 67.504l-.449 2.893c-.753.49-4.748-2.663-4.748-2.663l-1.645.748-1.346-5.684s6.815-4.589 8.917-5.018c2.452-.501 9.884.94 10.7 2.278 0 0 1.32.486-2.227.69-3.548.203-5.043.447-6.79 3.132-1.747 2.686-2.412 3.624-2.412 3.624",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M128.055 111.367c-2.627-7.724-6.15-13.18-8.917-15.478-3.5-2.906-9.34-2.225-11.366-4.187-1.27-1.231-3.215-1.197-3.215-1.197s-14.98-3.158-16.828-3.479c-2.37-.41-2.124-.714-6.054-1.405-1.57-1.907-2.917-1.122-2.917-1.122l-7.11-1.383c-.853-1.472-2.423-1.023-2.423-1.023l-2.468-.897c-1.645 9.976-7.74 13.796-7.74 13.796 1.795 1.122 15.703 8.3 15.703 8.3l5.107 37.11s-3.321 5.694 1.346 9.109c0 0 19.883-3.743 34.921-.329 0 0 3.047-2.546.972-8.806.523-3.01 1.394-8.263 1.736-11.622.385.772 2.019 1.918 3.14 3.477 0 0 9.407-7.365 11.052-14.012-.832-.723-1.598-1.585-2.267-2.453-.567-.736-.358-2.056-.765-2.717-.669-1.084-1.804-1.378-1.907-1.682",
  fill: "#FFF"
}, null), f("path", {
  d: "M101.09 289.998s4.295 2.041 7.354 1.021c2.821-.94 4.53.668 7.08 1.178 2.55.51 6.874 1.1 11.686-1.26-.103-5.51-6.889-3.98-11.96-6.713-2.563-1.38-3.784-4.722-3.598-8.799h-9.402s-1.392 10.52-1.16 14.573",
  fill: "#CBD1D1"
}, null), f("path", {
  d: "M101.067 289.826s2.428 1.271 6.759.653c3.058-.437 3.712.481 7.423 1.031 3.712.55 10.724-.069 11.823-.894.413 1.1-.343 2.063-.343 2.063s-1.512.603-4.812.824c-2.03.136-5.8.291-7.607-.503-1.787-1.375-5.247-1.903-5.728-.241-3.918.95-7.355-.286-7.355-.286l-.16-2.647z",
  fill: "#2B0849"
}, null), f("path", {
  d: "M108.341 276.044h3.094s-.103 6.702 4.536 8.558c-4.64.618-8.558-2.303-7.63-8.558",
  fill: "#A4AABA"
}, null), f("path", {
  d: "M57.542 272.401s-2.107 7.416-4.485 12.306c-1.798 3.695-4.225 7.492 5.465 7.492 6.648 0 8.953-.48 7.423-6.599-1.53-6.12.266-13.199.266-13.199h-8.669z",
  fill: "#CBD1D1"
}, null), f("path", {
  d: "M51.476 289.793s2.097 1.169 6.633 1.169c6.083 0 8.249-1.65 8.249-1.65s.602 1.114-.619 2.165c-.993.855-3.597 1.591-7.39 1.546-4.145-.048-5.832-.566-6.736-1.168-.825-.55-.687-1.58-.137-2.062",
  fill: "#2B0849"
}, null), f("path", {
  d: "M58.419 274.304s.033 1.519-.314 2.93c-.349 1.42-1.078 3.104-1.13 4.139-.058 1.151 4.537 1.58 5.155.034.62-1.547 1.294-6.427 1.913-7.252.619-.825-4.903-2.119-5.624.15",
  fill: "#A4AABA"
}, null), f("path", {
  d: "M99.66 278.514l13.378.092s1.298-54.52 1.853-64.403c.554-9.882 3.776-43.364 1.002-63.128l-12.547-.644-22.849.78s-.434 3.966-1.195 9.976c-.063.496-.682.843-.749 1.365-.075.585.423 1.354.32 1.966-2.364 14.08-6.377 33.104-8.744 46.677-.116.666-1.234 1.009-1.458 2.691-.04.302.211 1.525.112 1.795-6.873 18.744-10.949 47.842-14.277 61.885l14.607-.014s2.197-8.57 4.03-16.97c2.811-12.886 23.111-85.01 23.111-85.01l3.016-.521 1.043 46.35s-.224 1.234.337 2.02c.56.785-.56 1.123-.392 2.244l.392 1.794s-.449 7.178-.898 11.89c-.448 4.71-.092 39.165-.092 39.165",
  fill: "#7BB2F9"
}, null), f("path", {
  d: "M76.085 221.626c1.153.094 4.038-2.019 6.955-4.935M106.36 225.142s2.774-1.11 6.103-3.883",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M107.275 222.1s2.773-1.11 6.102-3.884",
  stroke: "#648BD8",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M74.74 224.767s2.622-.591 6.505-3.365M86.03 151.634c-.27 3.106.3 8.525-4.336 9.123M103.625 149.88s.11 14.012-1.293 15.065c-2.219 1.664-2.99 1.944-2.99 1.944M99.79 150.438s.035 12.88-1.196 24.377M93.673 175.911s7.212-1.664 9.431-1.664M74.31 205.861a212.013 212.013 0 0 1-.979 4.56s-1.458 1.832-1.009 3.776c.449 1.944-.947 2.045-4.985 15.355-1.696 5.59-4.49 18.591-6.348 27.597l-.231 1.12M75.689 197.807a320.934 320.934 0 0 1-.882 4.754M82.591 152.233L81.395 162.7s-1.097.15-.5 2.244c.113 1.346-2.674 15.775-5.18 30.43M56.12 274.418h13.31",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M116.241 148.22s-17.047-3.104-35.893.2c.158 2.514-.003 4.15-.003 4.15s14.687-2.818 35.67-.312c.252-2.355.226-4.038.226-4.038",
  fill: "#192064"
}, null), f("path", {
  d: "M106.322 151.165l.003-4.911a.81.81 0 0 0-.778-.815c-2.44-.091-5.066-.108-7.836-.014a.818.818 0 0 0-.789.815l-.003 4.906a.81.81 0 0 0 .831.813c2.385-.06 4.973-.064 7.73.017a.815.815 0 0 0 .842-.81",
  fill: "#FFF"
}, null), f("path", {
  d: "M105.207 150.233l.002-3.076a.642.642 0 0 0-.619-.646 94.321 94.321 0 0 0-5.866-.01.65.65 0 0 0-.63.647v3.072a.64.64 0 0 0 .654.644 121.12 121.12 0 0 1 5.794.011c.362.01.665-.28.665-.642",
  fill: "#192064"
}, null), f("path", {
  d: "M100.263 275.415h12.338M101.436 270.53c.006 3.387.042 5.79.111 6.506M101.451 264.548a915.75 915.75 0 0 0-.015 4.337M100.986 174.965l.898 44.642s.673 1.57-.225 2.692c-.897 1.122 2.468.673.898 2.243-1.57 1.57.897 1.122 0 3.365-.596 1.489-.994 21.1-1.096 35.146",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M46.876 83.427s-.516 6.045 7.223 5.552c11.2-.712 9.218-9.345 31.54-21.655-.786-2.708-2.447-4.744-2.447-4.744s-11.068 3.11-22.584 8.046c-6.766 2.9-13.395 6.352-13.732 12.801M104.46 91.057l.941-5.372-8.884-11.43-5.037 5.372-1.74 7.834a.321.321 0 0 0 .108.32c.965.8 6.5 5.013 14.347 3.544a.332.332 0 0 0 .264-.268",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M93.942 79.387s-4.533-2.853-2.432-6.855c1.623-3.09 4.513 1.133 4.513 1.133s.52-3.642 3.121-3.642c.52-1.04 1.561-4.162 1.561-4.162s11.445 2.601 13.526 3.121c0 5.203-2.304 19.424-7.84 19.861-8.892.703-12.449-9.456-12.449-9.456",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M113.874 73.446c2.601-2.081 3.47-9.722 3.47-9.722s-2.479-.49-6.64-2.05c-4.683-2.081-12.798-4.747-17.48.976-9.668 3.223-2.05 19.823-2.05 19.823l2.713-3.021s-3.935-3.287-2.08-6.243c2.17-3.462 3.92 1.073 3.92 1.073s.637-2.387 3.581-3.342c.355-.71 1.036-2.674 1.432-3.85a1.073 1.073 0 0 1 1.263-.704c2.4.558 8.677 2.019 11.356 2.662.522.125.871.615.82 1.15l-.305 3.248z",
  fill: "#520038"
}, null), f("path", {
  d: "M104.977 76.064c-.103.61-.582 1.038-1.07.956-.489-.083-.801-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.644.698 1.254M112.132 77.694c-.103.61-.582 1.038-1.07.956-.488-.083-.8-.644-.698-1.254.103-.61.582-1.038 1.07-.956.488.082.8.643.698 1.254",
  fill: "#552950"
}, null), f("path", {
  stroke: "#DB836E",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  d: "M110.13 74.84l-.896 1.61-.298 4.357h-2.228"
}, null), f("path", {
  d: "M110.846 74.481s1.79-.716 2.506.537",
  stroke: "#5C2552",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M92.386 74.282s.477-1.114 1.113-.716c.637.398 1.274 1.433.558 1.99-.717.556.159 1.67.159 1.67",
  stroke: "#DB836E",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M103.287 72.93s1.83 1.113 4.137.954",
  stroke: "#5C2552",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M103.685 81.762s2.227 1.193 4.376 1.193M104.64 84.308s.954.398 1.511.318M94.693 81.205s2.308 7.4 10.424 7.639",
  stroke: "#DB836E",
  "stroke-width": "1.118",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M81.45 89.384s.45 5.647-4.935 12.787M69 82.654s-.726 9.282-8.204 14.206",
  stroke: "#E4EBF7",
  "stroke-width": "1.101",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M129.405 122.865s-5.272 7.403-9.422 10.768",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M119.306 107.329s.452 4.366-2.127 32.062",
  stroke: "#E4EBF7",
  "stroke-width": "1.101",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M150.028 151.232h-49.837a1.01 1.01 0 0 1-1.01-1.01v-31.688c0-.557.452-1.01 1.01-1.01h49.837c.558 0 1.01.453 1.01 1.01v31.688a1.01 1.01 0 0 1-1.01 1.01",
  fill: "#F2D7AD"
}, null), f("path", {
  d: "M150.29 151.232h-19.863v-33.707h20.784v32.786a.92.92 0 0 1-.92.92",
  fill: "#F4D19D"
}, null), f("path", {
  d: "M123.554 127.896H92.917a.518.518 0 0 1-.425-.816l6.38-9.113c.193-.277.51-.442.85-.442h31.092l-7.26 10.371z",
  fill: "#F2D7AD"
}, null), f("path", {
  fill: "#CC9B6E",
  d: "M123.689 128.447H99.25v-.519h24.169l7.183-10.26.424.298z"
}, null), f("path", {
  d: "M158.298 127.896h-18.669a2.073 2.073 0 0 1-1.659-.83l-7.156-9.541h19.965c.49 0 .95.23 1.244.622l6.69 8.92a.519.519 0 0 1-.415.83",
  fill: "#F4D19D"
}, null), f("path", {
  fill: "#CC9B6E",
  d: "M157.847 128.479h-19.384l-7.857-10.475.415-.31 7.7 10.266h19.126zM130.554 150.685l-.032-8.177.519-.002.032 8.177z"
}, null), f("path", {
  fill: "#CC9B6E",
  d: "M130.511 139.783l-.08-21.414.519-.002.08 21.414zM111.876 140.932l-.498-.143 1.479-5.167.498.143zM108.437 141.06l-2.679-2.935 2.665-3.434.41.318-2.397 3.089 2.384 2.612zM116.607 141.06l-.383-.35 2.383-2.612-2.397-3.089.41-.318 2.665 3.434z"
}, null), f("path", {
  d: "M154.316 131.892l-3.114-1.96.038 3.514-1.043.092c-1.682.115-3.634.23-4.789.23-1.902 0-2.693 2.258 2.23 2.648l-2.645-.596s-2.168 1.317.504 2.3c0 0-1.58 1.217.561 2.58-.584 3.504 5.247 4.058 7.122 3.59 1.876-.47 4.233-2.359 4.487-5.16.28-3.085-.89-5.432-3.35-7.238",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M153.686 133.577s-6.522.47-8.36.372c-1.836-.098-1.904 2.19 2.359 2.264 3.739.15 5.451-.044 5.451-.044",
  stroke: "#DB836E",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M145.16 135.877c-1.85 1.346.561 2.355.561 2.355s3.478.898 6.73.617",
  stroke: "#DB836E",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M151.89 141.71s-6.28.111-6.73-2.132c-.223-1.346.45-1.402.45-1.402M146.114 140.868s-1.103 3.16 5.44 3.533M151.202 129.932v3.477M52.838 89.286c3.533-.337 8.423-1.248 13.582-7.754",
  stroke: "#DB836E",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M168.567 248.318a6.647 6.647 0 0 1-6.647-6.647v-66.466a6.647 6.647 0 1 1 13.294 0v66.466a6.647 6.647 0 0 1-6.647 6.647",
  fill: "#5BA02E"
}, null), f("path", {
  d: "M176.543 247.653a6.647 6.647 0 0 1-6.646-6.647v-33.232a6.647 6.647 0 1 1 13.293 0v33.232a6.647 6.647 0 0 1-6.647 6.647",
  fill: "#92C110"
}, null), f("path", {
  d: "M186.443 293.613H158.92a3.187 3.187 0 0 1-3.187-3.187v-46.134a3.187 3.187 0 0 1 3.187-3.187h27.524a3.187 3.187 0 0 1 3.187 3.187v46.134a3.187 3.187 0 0 1-3.187 3.187",
  fill: "#F2D7AD"
}, null), f("path", {
  d: "M88.979 89.48s7.776 5.384 16.6 2.842",
  stroke: "#E4EBF7",
  "stroke-width": "1.101",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null)])]), iJ = () => f("svg", {
  width: "254",
  height: "294"
}, [f("defs", null, [f("path", {
  d: "M0 .335h253.49v253.49H0z"
}, null), f("path", {
  d: "M0 293.665h253.49V.401H0z"
}, null)]), f("g", {
  fill: "none",
  "fill-rule": "evenodd"
}, [f("g", {
  transform: "translate(0 .067)"
}, [f("mask", {
  fill: "#fff"
}, null), f("path", {
  d: "M0 128.134v-2.11C0 56.608 56.273.334 125.69.334h2.11c69.416 0 125.69 56.274 125.69 125.69v2.11c0 69.417-56.274 125.69-125.69 125.69h-2.11C56.273 253.824 0 197.551 0 128.134",
  fill: "#E4EBF7",
  mask: "url(#b)"
}, null)]), f("path", {
  d: "M39.989 132.108a8.332 8.332 0 1 1-16.581-1.671 8.332 8.332 0 0 1 16.58 1.671",
  fill: "#FFF"
}, null), f("path", {
  d: "M37.19 135.59l10.553 5.983M48.665 147.884l-12.734 10.861",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), f("path", {
  d: "M40.11 160.816a5.706 5.706 0 1 1-11.354-1.145 5.706 5.706 0 0 1 11.354 1.145M57.943 144.6a5.747 5.747 0 1 1-11.436-1.152 5.747 5.747 0 0 1 11.436 1.153M99.656 27.434l30.024-.013a4.619 4.619 0 1 0-.004-9.238l-30.024.013a4.62 4.62 0 0 0 .004 9.238M111.14 45.896l30.023-.013a4.62 4.62 0 1 0-.004-9.238l-30.024.013a4.619 4.619 0 1 0 .004 9.238",
  fill: "#FFF"
}, null), f("path", {
  d: "M113.53 27.421v-.002l15.89-.007a4.619 4.619 0 1 0 .005 9.238l-15.892.007v-.002a4.618 4.618 0 0 0-.004-9.234M150.167 70.091h-3.979a4.789 4.789 0 0 1-4.774-4.775 4.788 4.788 0 0 1 4.774-4.774h3.979a4.789 4.789 0 0 1 4.775 4.774 4.789 4.789 0 0 1-4.775 4.775",
  fill: "#FFF"
}, null), f("path", {
  d: "M171.687 30.234c0-16.392 13.289-29.68 29.681-29.68 16.392 0 29.68 13.288 29.68 29.68 0 16.393-13.288 29.681-29.68 29.681s-29.68-13.288-29.68-29.68",
  fill: "#FF603B"
}, null), f("path", {
  d: "M203.557 19.435l-.676 15.035a1.514 1.514 0 0 1-3.026 0l-.675-15.035a2.19 2.19 0 1 1 4.377 0m-.264 19.378c.513.477.77 1.1.77 1.87s-.257 1.393-.77 1.907c-.55.476-1.21.733-1.943.733a2.545 2.545 0 0 1-1.87-.77c-.55-.514-.806-1.136-.806-1.87 0-.77.256-1.393.806-1.87.513-.513 1.137-.733 1.87-.733.77 0 1.43.22 1.943.733",
  fill: "#FFF"
}, null), f("path", {
  d: "M119.3 133.275c4.426-.598 3.612-1.204 4.079-4.778.675-5.18-3.108-16.935-8.262-25.118-1.088-10.72-12.598-11.24-12.598-11.24s4.312 4.895 4.196 16.199c1.398 5.243.804 14.45.804 14.45s5.255 11.369 11.78 10.487",
  fill: "#FFB594"
}, null), f("path", {
  d: "M100.944 91.61s1.463-.583 3.211.582c8.08 1.398 10.368 6.706 11.3 11.368 1.864 1.282 1.864 2.33 1.864 3.496.365.777 1.515 3.03 1.515 3.03s-7.225 1.748-10.954 6.758c-1.399-6.41-6.936-25.235-6.936-25.235",
  fill: "#FFF"
}, null), f("path", {
  d: "M94.008 90.5l1.019-5.815-9.23-11.874-5.233 5.581-2.593 9.863s8.39 5.128 16.037 2.246",
  fill: "#FFB594"
}, null), f("path", {
  d: "M82.931 78.216s-4.557-2.868-2.445-6.892c1.632-3.107 4.537 1.139 4.537 1.139s.524-3.662 3.139-3.662c.523-1.046 1.569-4.184 1.569-4.184s11.507 2.615 13.6 3.138c-.001 5.23-2.317 19.529-7.884 19.969-8.94.706-12.516-9.508-12.516-9.508",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M102.971 72.243c2.616-2.093 3.489-9.775 3.489-9.775s-2.492-.492-6.676-2.062c-4.708-2.092-12.867-4.771-17.575.982-9.54 4.41-2.062 19.93-2.062 19.93l2.729-3.037s-3.956-3.304-2.092-6.277c2.183-3.48 3.943 1.08 3.943 1.08s.64-2.4 3.6-3.36c.356-.714 1.04-2.69 1.44-3.872a1.08 1.08 0 0 1 1.27-.707c2.41.56 8.723 2.03 11.417 2.676.524.126.876.619.825 1.156l-.308 3.266z",
  fill: "#520038"
}, null), f("path", {
  d: "M101.22 76.514c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.961.491.083.805.647.702 1.26M94.26 75.074c-.104.613-.585 1.044-1.076.96-.49-.082-.805-.646-.702-1.26.104-.613.585-1.044 1.076-.96.491.082.805.646.702 1.26",
  fill: "#552950"
}, null), f("path", {
  stroke: "#DB836E",
  "stroke-width": "1.063",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  d: "M99.206 73.644l-.9 1.62-.3 4.38h-2.24"
}, null), f("path", {
  d: "M99.926 73.284s1.8-.72 2.52.54",
  stroke: "#5C2552",
  "stroke-width": "1.117",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M81.367 73.084s.48-1.12 1.12-.72c.64.4 1.28 1.44.56 2s.16 1.68.16 1.68",
  stroke: "#DB836E",
  "stroke-width": "1.117",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M92.326 71.724s1.84 1.12 4.16.96",
  stroke: "#5C2552",
  "stroke-width": "1.117",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M92.726 80.604s2.24 1.2 4.4 1.2M93.686 83.164s.96.4 1.52.32M83.687 80.044s1.786 6.547 9.262 7.954",
  stroke: "#DB836E",
  "stroke-width": "1.063",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M95.548 91.663s-1.068 2.821-8.298 2.105c-7.23-.717-10.29-5.044-10.29-5.044",
  stroke: "#E4EBF7",
  "stroke-width": "1.136",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M78.126 87.478s6.526 4.972 16.47 2.486c0 0 9.577 1.02 11.536 5.322 5.36 11.77.543 36.835 0 39.962 3.496 4.055-.466 8.483-.466 8.483-15.624-3.548-35.81-.6-35.81-.6-4.849-3.546-1.223-9.044-1.223-9.044L62.38 110.32c-2.485-15.227.833-19.803 3.549-20.743 3.03-1.049 8.04-1.282 8.04-1.282.496-.058 1.08-.076 1.37-.233 2.36-1.282 2.787-.583 2.787-.583",
  fill: "#FFF"
}, null), f("path", {
  d: "M65.828 89.81s-6.875.465-7.59 8.156c-.466 8.857 3.03 10.954 3.03 10.954s6.075 22.102 16.796 22.957c8.39-2.176 4.758-6.702 4.661-11.42-.233-11.304-7.108-16.897-7.108-16.897s-4.212-13.75-9.789-13.75",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M71.716 124.225s.855 11.264 9.828 6.486c4.765-2.536 7.581-13.828 9.789-22.568 1.456-5.768 2.58-12.197 2.58-12.197l-4.973-1.709s-2.408 5.516-7.769 12.275c-4.335 5.467-9.144 11.11-9.455 17.713",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M108.463 105.191s1.747 2.724-2.331 30.535c2.376 2.216 1.053 6.012-.233 7.51",
  stroke: "#E4EBF7",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M123.262 131.527s-.427 2.732-11.77 1.981c-15.187-1.006-25.326-3.25-25.326-3.25l.933-5.8s.723.215 9.71-.068c11.887-.373 18.714-6.07 24.964-1.022 4.039 3.263 1.489 8.16 1.489 8.16",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M70.24 90.974s-5.593-4.739-11.054 2.68c-3.318 7.223.517 15.284 2.664 19.578-.31 3.729 2.33 4.311 2.33 4.311s.108.895 1.516 2.68c4.078-7.03 6.72-9.166 13.711-12.546-.328-.656-1.877-3.265-1.825-3.767.175-1.69-1.282-2.623-1.282-2.623s-.286-.156-1.165-2.738c-.788-2.313-2.036-5.177-4.895-7.575",
  fill: "#FFF"
}, null), f("path", {
  d: "M90.232 288.027s4.855 2.308 8.313 1.155c3.188-1.063 5.12.755 8.002 1.331 2.881.577 7.769 1.243 13.207-1.424-.117-6.228-7.786-4.499-13.518-7.588-2.895-1.56-4.276-5.336-4.066-9.944H91.544s-1.573 11.89-1.312 16.47",
  fill: "#CBD1D1"
}, null), f("path", {
  d: "M90.207 287.833s2.745 1.437 7.639.738c3.456-.494 3.223.66 7.418 1.282 4.195.621 13.092-.194 14.334-1.126.466 1.242-.388 2.33-.388 2.33s-1.709.682-5.438.932c-2.295.154-8.098.276-10.14-.621-2.02-1.554-4.894-1.515-6.06-.234-4.427 1.075-7.184-.31-7.184-.31l-.181-2.991z",
  fill: "#2B0849"
}, null), f("path", {
  d: "M98.429 272.257h3.496s-.117 7.574 5.127 9.671c-5.244.7-9.672-2.602-8.623-9.671",
  fill: "#A4AABA"
}, null), f("path", {
  d: "M44.425 272.046s-2.208 7.774-4.702 12.899c-1.884 3.874-4.428 7.854 5.729 7.854 6.97 0 9.385-.503 7.782-6.917-1.604-6.415.279-13.836.279-13.836h-9.088z",
  fill: "#CBD1D1"
}, null), f("path", {
  d: "M38.066 290.277s2.198 1.225 6.954 1.225c6.376 0 8.646-1.73 8.646-1.73s.63 1.168-.649 2.27c-1.04.897-3.77 1.668-7.745 1.621-4.347-.05-6.115-.593-7.062-1.224-.864-.577-.72-1.657-.144-2.162",
  fill: "#2B0849"
}, null), f("path", {
  d: "M45.344 274.041s.035 1.592-.329 3.07c-.365 1.49-1.13 3.255-1.184 4.34-.061 1.206 4.755 1.657 5.403.036.65-1.622 1.357-6.737 2.006-7.602.648-.865-5.14-2.222-5.896.156",
  fill: "#A4AABA"
}, null), f("path", {
  d: "M89.476 277.57l13.899.095s1.349-56.643 1.925-66.909c.576-10.267 3.923-45.052 1.042-65.585l-13.037-.669-23.737.81s-.452 4.12-1.243 10.365c-.065.515-.708.874-.777 1.417-.078.608.439 1.407.332 2.044-2.455 14.627-5.797 32.736-8.256 46.837-.121.693-1.282 1.048-1.515 2.796-.042.314.22 1.584.116 1.865-7.14 19.473-12.202 52.601-15.66 67.19l15.176-.015s2.282-10.145 4.185-18.871c2.922-13.389 24.012-88.32 24.012-88.32l3.133-.954-.158 48.568s-.233 1.282.35 2.098c.583.815-.581 1.167-.408 2.331l.408 1.864s-.466 7.458-.932 12.352c-.467 4.895 1.145 40.69 1.145 40.69",
  fill: "#7BB2F9"
}, null), f("path", {
  d: "M64.57 218.881c1.197.099 4.195-2.097 7.225-5.127M96.024 222.534s2.881-1.152 6.34-4.034",
  stroke: "#648BD8",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M96.973 219.373s2.882-1.153 6.34-4.034",
  stroke: "#648BD8",
  "stroke-width": "1.032",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M63.172 222.144s2.724-.614 6.759-3.496M74.903 146.166c-.281 3.226.31 8.856-4.506 9.478M93.182 144.344s.115 14.557-1.344 15.65c-2.305 1.73-3.107 2.02-3.107 2.02M89.197 144.923s.269 13.144-1.01 25.088M83.525 170.71s6.81-1.051 9.116-1.051M46.026 270.045l-.892 4.538M46.937 263.289l-.815 4.157M62.725 202.503c-.33 1.618-.102 1.904-.449 3.438 0 0-2.756 1.903-2.29 3.923.466 2.02-.31 3.424-4.505 17.252-1.762 5.807-4.233 18.922-6.165 28.278-.03.144-.521 2.646-1.14 5.8M64.158 194.136c-.295 1.658-.6 3.31-.917 4.938M71.33 146.787l-1.244 10.877s-1.14.155-.519 2.33c.117 1.399-2.778 16.39-5.382 31.615M44.242 273.727H58.07",
  stroke: "#648BD8",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M106.18 142.117c-3.028-.489-18.825-2.744-36.219.2a.625.625 0 0 0-.518.644c.063 1.307.044 2.343.015 2.995a.617.617 0 0 0 .716.636c3.303-.534 17.037-2.412 35.664-.266.347.04.66-.214.692-.56.124-1.347.16-2.425.17-3.029a.616.616 0 0 0-.52-.62",
  fill: "#192064"
}, null), f("path", {
  d: "M96.398 145.264l.003-5.102a.843.843 0 0 0-.809-.847 114.104 114.104 0 0 0-8.141-.014.85.85 0 0 0-.82.847l-.003 5.097c0 .476.388.857.864.845 2.478-.064 5.166-.067 8.03.017a.848.848 0 0 0 .876-.843",
  fill: "#FFF"
}, null), f("path", {
  d: "M95.239 144.296l.002-3.195a.667.667 0 0 0-.643-.672c-1.9-.061-3.941-.073-6.094-.01a.675.675 0 0 0-.654.672l-.002 3.192c0 .376.305.677.68.669 1.859-.042 3.874-.043 6.02.012.376.01.69-.291.691-.668",
  fill: "#192064"
}, null), f("path", {
  d: "M90.102 273.522h12.819M91.216 269.761c.006 3.519-.072 5.55 0 6.292M90.923 263.474c-.009 1.599-.016 2.558-.016 4.505M90.44 170.404l.932 46.38s.7 1.631-.233 2.796c-.932 1.166 2.564.7.932 2.33-1.63 1.633.933 1.166 0 3.497-.618 1.546-1.031 21.921-1.138 36.513",
  stroke: "#648BD8",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M73.736 98.665l2.214 4.312s2.098.816 1.865 2.68l.816 2.214M64.297 116.611c.233-.932 2.176-7.147 12.585-10.488M77.598 90.042s7.691 6.137 16.547 2.72",
  stroke: "#E4EBF7",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M91.974 86.954s5.476-.816 7.574-4.545c1.297-.345.72 2.212-.33 3.671-.7.971-1.01 1.554-1.01 1.554s.194.31.155.816c-.053.697-.175.653-.272 1.048-.081.335.108.657 0 1.049-.046.17-.198.5-.382.878-.12.249-.072.687-.2.948-.231.469-1.562 1.87-2.622 2.855-3.826 3.554-5.018 1.644-6.001-.408-.894-1.865-.661-5.127-.874-6.875-.35-2.914-2.622-3.03-1.923-4.429.343-.685 2.87.69 3.263 1.748.757 2.04 2.952 1.807 2.622 1.69",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M99.8 82.429c-.465.077-.35.272-.97 1.243-.622.971-4.817 2.932-6.39 3.224-2.589.48-2.278-1.56-4.254-2.855-1.69-1.107-3.562-.638-1.398 1.398.99.932.932 1.107 1.398 3.205.335 1.506-.64 3.67.7 5.593",
  stroke: "#DB836E",
  "stroke-width": ".774",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M79.543 108.673c-2.1 2.926-4.266 6.175-5.557 8.762",
  stroke: "#E59788",
  "stroke-width": ".774",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M87.72 124.768s-2.098-1.942-5.127-2.719c-3.03-.777-3.574-.155-5.516.078-1.942.233-3.885-.932-3.652.7.233 1.63 5.05 1.01 5.206 2.097.155 1.087-6.37 2.796-8.313 2.175-.777.777.466 1.864 2.02 2.175.233 1.554 2.253 1.554 2.253 1.554s.699 1.01 2.641 1.088c2.486 1.32 8.934-.7 10.954-1.554 2.02-.855-.466-5.594-.466-5.594",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M73.425 122.826s.66 1.127 3.167 1.418c2.315.27 2.563.583 2.563.583s-2.545 2.894-9.07 2.272M72.416 129.274s3.826.097 4.933-.718M74.98 130.75s1.961.136 3.36-.505M77.232 131.916s1.748.019 2.914-.505M73.328 122.321s-.595-1.032 1.262-.427c1.671.544 2.833.055 5.128.155 1.389.061 3.067-.297 3.982.15 1.606.784 3.632 2.181 3.632 2.181s10.526 1.204 19.033-1.127M78.864 108.104s-8.39 2.758-13.168 12.12",
  stroke: "#E59788",
  "stroke-width": ".774",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M109.278 112.533s3.38-3.613 7.575-4.662",
  stroke: "#E4EBF7",
  "stroke-width": "1.085",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M107.375 123.006s9.697-2.745 11.445-.88",
  stroke: "#E59788",
  "stroke-width": ".774",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M194.605 83.656l3.971-3.886M187.166 90.933l3.736-3.655M191.752 84.207l-4.462-4.56M198.453 91.057l-4.133-4.225M129.256 163.074l3.718-3.718M122.291 170.039l3.498-3.498M126.561 163.626l-4.27-4.27M132.975 170.039l-3.955-3.955",
  stroke: "#BFCDDD",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M190.156 211.779h-1.604a4.023 4.023 0 0 1-4.011-4.011V175.68a4.023 4.023 0 0 1 4.01-4.01h1.605a4.023 4.023 0 0 1 4.011 4.01v32.088a4.023 4.023 0 0 1-4.01 4.01",
  fill: "#A3B4C6"
}, null), f("path", {
  d: "M237.824 212.977a4.813 4.813 0 0 1-4.813 4.813h-86.636a4.813 4.813 0 0 1 0-9.626h86.636a4.813 4.813 0 0 1 4.813 4.813",
  fill: "#A3B4C6"
}, null), f("mask", {
  fill: "#fff"
}, null), f("path", {
  fill: "#A3B4C6",
  mask: "url(#d)",
  d: "M154.098 190.096h70.513v-84.617h-70.513z"
}, null), f("path", {
  d: "M224.928 190.096H153.78a3.219 3.219 0 0 1-3.208-3.209V167.92a3.219 3.219 0 0 1 3.208-3.21h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.219 3.219 0 0 1-3.21 3.209M224.928 130.832H153.78a3.218 3.218 0 0 1-3.208-3.208v-18.968a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.21v18.967a3.218 3.218 0 0 1-3.21 3.208",
  fill: "#BFCDDD",
  mask: "url(#d)"
}, null), f("path", {
  d: "M159.563 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 120.546a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 120.546h-22.461a.802.802 0 0 1-.802-.802v-3.208c0-.443.359-.803.802-.803h22.46c.444 0 .803.36.803.803v3.208c0 .443-.36.802-.802.802",
  fill: "#FFF",
  mask: "url(#d)"
}, null), f("path", {
  d: "M224.928 160.464H153.78a3.218 3.218 0 0 1-3.208-3.209v-18.967a3.219 3.219 0 0 1 3.208-3.209h71.148a3.219 3.219 0 0 1 3.209 3.209v18.967a3.218 3.218 0 0 1-3.21 3.209",
  fill: "#BFCDDD",
  mask: "url(#d)"
}, null), f("path", {
  d: "M173.455 130.832h49.301M164.984 130.832h6.089M155.952 130.832h6.75M173.837 160.613h49.3M165.365 160.613h6.089M155.57 160.613h6.751",
  stroke: "#7C90A5",
  "stroke-width": "1.124",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  mask: "url(#d)"
}, null), f("path", {
  d: "M159.563 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M166.98 151.038a2.407 2.407 0 1 1 0-4.814 2.407 2.407 0 0 1 0 4.814M174.397 151.038a2.407 2.407 0 1 1 .001-4.814 2.407 2.407 0 0 1 0 4.814M222.539 151.038h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802M159.563 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M166.98 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M174.397 179.987a2.407 2.407 0 1 1 0-4.813 2.407 2.407 0 0 1 0 4.813M222.539 179.987h-22.461a.802.802 0 0 1-.802-.802v-3.209c0-.443.359-.802.802-.802h22.46c.444 0 .803.36.803.802v3.209c0 .443-.36.802-.802.802",
  fill: "#FFF",
  mask: "url(#d)"
}, null), f("path", {
  d: "M203.04 221.108h-27.372a2.413 2.413 0 0 1-2.406-2.407v-11.448a2.414 2.414 0 0 1 2.406-2.407h27.372a2.414 2.414 0 0 1 2.407 2.407V218.7a2.413 2.413 0 0 1-2.407 2.407",
  fill: "#BFCDDD",
  mask: "url(#d)"
}, null), f("path", {
  d: "M177.259 207.217v11.52M201.05 207.217v11.52",
  stroke: "#A3B4C6",
  "stroke-width": "1.124",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  mask: "url(#d)"
}, null), f("path", {
  d: "M162.873 267.894a9.422 9.422 0 0 1-9.422-9.422v-14.82a9.423 9.423 0 0 1 18.845 0v14.82a9.423 9.423 0 0 1-9.423 9.422",
  fill: "#5BA02E",
  mask: "url(#d)"
}, null), f("path", {
  d: "M171.22 267.83a9.422 9.422 0 0 1-9.422-9.423v-3.438a9.423 9.423 0 0 1 18.845 0v3.438a9.423 9.423 0 0 1-9.422 9.423",
  fill: "#92C110",
  mask: "url(#d)"
}, null), f("path", {
  d: "M181.31 293.666h-27.712a3.209 3.209 0 0 1-3.209-3.21V269.79a3.209 3.209 0 0 1 3.209-3.21h27.711a3.209 3.209 0 0 1 3.209 3.21v20.668a3.209 3.209 0 0 1-3.209 3.209",
  fill: "#F2D7AD",
  mask: "url(#d)"
}, null)])]), sJ = () => f("svg", {
  width: "251",
  height: "294"
}, [f("g", {
  fill: "none",
  "fill-rule": "evenodd"
}, [f("path", {
  d: "M0 129.023v-2.084C0 58.364 55.591 2.774 124.165 2.774h2.085c68.574 0 124.165 55.59 124.165 124.165v2.084c0 68.575-55.59 124.166-124.165 124.166h-2.085C55.591 253.189 0 197.598 0 129.023",
  fill: "#E4EBF7"
}, null), f("path", {
  d: "M41.417 132.92a8.231 8.231 0 1 1-16.38-1.65 8.231 8.231 0 0 1 16.38 1.65",
  fill: "#FFF"
}, null), f("path", {
  d: "M38.652 136.36l10.425 5.91M49.989 148.505l-12.58 10.73",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), f("path", {
  d: "M41.536 161.28a5.636 5.636 0 1 1-11.216-1.13 5.636 5.636 0 0 1 11.216 1.13M59.154 145.261a5.677 5.677 0 1 1-11.297-1.138 5.677 5.677 0 0 1 11.297 1.138M100.36 29.516l29.66-.013a4.562 4.562 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 0 0 .005 9.126M111.705 47.754l29.659-.013a4.563 4.563 0 1 0-.004-9.126l-29.66.013a4.563 4.563 0 1 0 .005 9.126",
  fill: "#FFF"
}, null), f("path", {
  d: "M114.066 29.503V29.5l15.698-.007a4.563 4.563 0 1 0 .004 9.126l-15.698.007v-.002a4.562 4.562 0 0 0-.004-9.122M185.405 137.723c-.55 5.455-5.418 9.432-10.873 8.882-5.456-.55-9.432-5.418-8.882-10.873.55-5.455 5.418-9.432 10.873-8.882 5.455.55 9.432 5.418 8.882 10.873",
  fill: "#FFF"
}, null), f("path", {
  d: "M180.17 143.772l12.572 7.129M193.841 158.42L178.67 171.36",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), f("path", {
  d: "M185.55 171.926a6.798 6.798 0 1 1-13.528-1.363 6.798 6.798 0 0 1 13.527 1.363M204.12 155.285a6.848 6.848 0 1 1-13.627-1.375 6.848 6.848 0 0 1 13.626 1.375",
  fill: "#FFF"
}, null), f("path", {
  d: "M152.988 194.074a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0zM225.931 118.217a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM217.09 153.051a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.42 0zM177.84 109.842a2.21 2.21 0 1 1-4.422 0 2.21 2.21 0 0 1 4.421 0zM196.114 94.454a2.21 2.21 0 1 1-4.421 0 2.21 2.21 0 0 1 4.421 0zM202.844 182.523a2.21 2.21 0 1 1-4.42 0 2.21 2.21 0 0 1 4.42 0z",
  stroke: "#FFF",
  "stroke-width": "2"
}, null), f("path", {
  stroke: "#FFF",
  "stroke-width": "2",
  d: "M215.125 155.262l-1.902 20.075-10.87 5.958M174.601 176.636l-6.322 9.761H156.98l-4.484 6.449M175.874 127.28V111.56M221.51 119.404l-12.77 7.859-15.228-7.86V96.668"
}, null), f("path", {
  d: "M180.68 29.32C180.68 13.128 193.806 0 210 0c16.193 0 29.32 13.127 29.32 29.32 0 16.194-13.127 29.322-29.32 29.322-16.193 0-29.32-13.128-29.32-29.321",
  fill: "#A26EF4"
}, null), f("path", {
  d: "M221.45 41.706l-21.563-.125a1.744 1.744 0 0 1-1.734-1.754l.071-12.23a1.744 1.744 0 0 1 1.754-1.734l21.562.125c.964.006 1.74.791 1.735 1.755l-.071 12.229a1.744 1.744 0 0 1-1.754 1.734",
  fill: "#FFF"
}, null), f("path", {
  d: "M215.106 29.192c-.015 2.577-2.049 4.654-4.543 4.64-2.494-.014-4.504-2.115-4.489-4.693l.04-6.925c.016-2.577 2.05-4.654 4.543-4.64 2.494.015 4.504 2.116 4.49 4.693l-.04 6.925zm-4.53-14.074a6.877 6.877 0 0 0-6.916 6.837l-.043 7.368a6.877 6.877 0 0 0 13.754.08l.042-7.368a6.878 6.878 0 0 0-6.837-6.917zM167.566 68.367h-3.93a4.73 4.73 0 0 1-4.717-4.717 4.73 4.73 0 0 1 4.717-4.717h3.93a4.73 4.73 0 0 1 4.717 4.717 4.73 4.73 0 0 1-4.717 4.717",
  fill: "#FFF"
}, null), f("path", {
  d: "M168.214 248.838a6.611 6.611 0 0 1-6.61-6.611v-66.108a6.611 6.611 0 0 1 13.221 0v66.108a6.611 6.611 0 0 1-6.61 6.61",
  fill: "#5BA02E"
}, null), f("path", {
  d: "M176.147 248.176a6.611 6.611 0 0 1-6.61-6.61v-33.054a6.611 6.611 0 1 1 13.221 0v33.053a6.611 6.611 0 0 1-6.61 6.611",
  fill: "#92C110"
}, null), f("path", {
  d: "M185.994 293.89h-27.376a3.17 3.17 0 0 1-3.17-3.17v-45.887a3.17 3.17 0 0 1 3.17-3.17h27.376a3.17 3.17 0 0 1 3.17 3.17v45.886a3.17 3.17 0 0 1-3.17 3.17",
  fill: "#F2D7AD"
}, null), f("path", {
  d: "M81.972 147.673s6.377-.927 17.566-1.28c11.729-.371 17.57 1.086 17.57 1.086s3.697-3.855.968-8.424c1.278-12.077 5.982-32.827.335-48.273-1.116-1.339-3.743-1.512-7.536-.62-1.337.315-7.147-.149-7.983-.1l-15.311-.347s-3.487-.17-8.035-.508c-1.512-.113-4.227-1.683-5.458-.338-.406.443-2.425 5.669-1.97 16.077l8.635 35.642s-3.141 3.61 1.219 7.085",
  fill: "#FFF"
}, null), f("path", {
  d: "M75.768 73.325l-.9-6.397 11.982-6.52s7.302-.118 8.038 1.205c.737 1.324-5.616.993-5.616.993s-1.836 1.388-2.615 2.5c-1.654 2.363-.986 6.471-8.318 5.986-1.708.284-2.57 2.233-2.57 2.233",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M52.44 77.672s14.217 9.406 24.973 14.444c1.061.497-2.094 16.183-11.892 11.811-7.436-3.318-20.162-8.44-21.482-14.496-.71-3.258 2.543-7.643 8.401-11.76M141.862 80.113s-6.693 2.999-13.844 6.876c-3.894 2.11-10.137 4.704-12.33 7.988-6.224 9.314 3.536 11.22 12.947 7.503 6.71-2.651 28.999-12.127 13.227-22.367",
  fill: "#FFB594"
}, null), f("path", {
  d: "M76.166 66.36l3.06 3.881s-2.783 2.67-6.31 5.747c-7.103 6.195-12.803 14.296-15.995 16.44-3.966 2.662-9.754 3.314-12.177-.118-3.553-5.032.464-14.628 31.422-25.95",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M64.674 85.116s-2.34 8.413-8.912 14.447c.652.548 18.586 10.51 22.144 10.056 5.238-.669 6.417-18.968 1.145-20.531-.702-.208-5.901-1.286-8.853-2.167-.87-.26-1.611-1.71-3.545-.936l-1.98-.869zM128.362 85.826s5.318 1.956 7.325 13.734c-.546.274-17.55 12.35-21.829 7.805-6.534-6.94-.766-17.393 4.275-18.61 4.646-1.121 5.03-1.37 10.23-2.929",
  fill: "#FFF"
}, null), f("path", {
  d: "M78.18 94.656s.911 7.41-4.914 13.078",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M87.397 94.68s3.124 2.572 10.263 2.572c7.14 0 9.074-3.437 9.074-3.437",
  stroke: "#E4EBF7",
  "stroke-width": ".932",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M117.184 68.639l-6.781-6.177s-5.355-4.314-9.223-.893c-3.867 3.422 4.463 2.083 5.653 4.165 1.19 2.082.848 1.143-2.083.446-5.603-1.331-2.082.893 2.975 5.355 2.091 1.845 6.992.955 6.992.955l2.467-3.851z",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M105.282 91.315l-.297-10.937-15.918-.027-.53 10.45c-.026.403.17.788.515.999 2.049 1.251 9.387 5.093 15.799.424.287-.21.443-.554.431-.91",
  fill: "#FFB594"
}, null), f("path", {
  d: "M107.573 74.24c.817-1.147.982-9.118 1.015-11.928a1.046 1.046 0 0 0-.965-1.055l-4.62-.365c-7.71-1.044-17.071.624-18.253 6.346-5.482 5.813-.421 13.244-.421 13.244s1.963 3.566 4.305 6.791c.756 1.041.398-3.731 3.04-5.929 5.524-4.594 15.899-7.103 15.899-7.103",
  fill: "#5C2552"
}, null), f("path", {
  d: "M88.426 83.206s2.685 6.202 11.602 6.522c7.82.28 8.973-7.008 7.434-17.505l-.909-5.483c-6.118-2.897-15.478.54-15.478.54s-.576 2.044-.19 5.504c-2.276 2.066-1.824 5.618-1.824 5.618s-.905-1.922-1.98-2.321c-.86-.32-1.897.089-2.322 1.98-1.04 4.632 3.667 5.145 3.667 5.145",
  fill: "#FFC6A0"
}, null), f("path", {
  stroke: "#DB836E",
  "stroke-width": "1.145",
  "stroke-linecap": "round",
  "stroke-linejoin": "round",
  d: "M100.843 77.099l1.701-.928-1.015-4.324.674-1.406"
}, null), f("path", {
  d: "M105.546 74.092c-.022.713-.452 1.279-.96 1.263-.51-.016-.904-.607-.882-1.32.021-.713.452-1.278.96-1.263.51.016.904.607.882 1.32M97.592 74.349c-.022.713-.452 1.278-.961 1.263-.509-.016-.904-.607-.882-1.32.022-.713.452-1.279.961-1.263.51.016.904.606.882 1.32",
  fill: "#552950"
}, null), f("path", {
  d: "M91.132 86.786s5.269 4.957 12.679 2.327",
  stroke: "#DB836E",
  "stroke-width": "1.145",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M99.776 81.903s-3.592.232-1.44-2.79c1.59-1.496 4.897-.46 4.897-.46s1.156 3.906-3.457 3.25",
  fill: "#DB836E"
}, null), f("path", {
  d: "M102.88 70.6s2.483.84 3.402.715M93.883 71.975s2.492-1.144 4.778-1.073",
  stroke: "#5C2552",
  "stroke-width": "1.526",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M86.32 77.374s.961.879 1.458 2.106c-.377.48-1.033 1.152-.236 1.809M99.337 83.719s1.911.151 2.509-.254",
  stroke: "#DB836E",
  "stroke-width": "1.145",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M87.782 115.821l15.73-3.012M100.165 115.821l10.04-2.008",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M66.508 86.763s-1.598 8.83-6.697 14.078",
  stroke: "#E4EBF7",
  "stroke-width": "1.114",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M128.31 87.934s3.013 4.121 4.06 11.785",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M64.09 84.816s-6.03 9.912-13.607 9.903",
  stroke: "#DB836E",
  "stroke-width": ".795",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M112.366 65.909l-.142 5.32s5.993 4.472 11.945 9.202c4.482 3.562 8.888 7.455 10.985 8.662 4.804 2.766 8.9 3.355 11.076 1.808 4.071-2.894 4.373-9.878-8.136-15.263-4.271-1.838-16.144-6.36-25.728-9.73",
  fill: "#FFC6A0"
}, null), f("path", {
  d: "M130.532 85.488s4.588 5.757 11.619 6.214",
  stroke: "#DB836E",
  "stroke-width": ".75",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M121.708 105.73s-.393 8.564-1.34 13.612",
  stroke: "#E4EBF7",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M115.784 161.512s-3.57-1.488-2.678-7.14",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M101.52 290.246s4.326 2.057 7.408 1.03c2.842-.948 4.564.673 7.132 1.186 2.57.514 6.925 1.108 11.772-1.269-.104-5.551-6.939-4.01-12.048-6.763-2.582-1.39-3.812-4.757-3.625-8.863h-9.471s-1.402 10.596-1.169 14.68",
  fill: "#CBD1D1"
}, null), f("path", {
  d: "M101.496 290.073s2.447 1.281 6.809.658c3.081-.44 3.74.485 7.479 1.039 3.739.554 10.802-.07 11.91-.9.415 1.108-.347 2.077-.347 2.077s-1.523.608-4.847.831c-2.045.137-5.843.293-7.663-.507-1.8-1.385-5.286-1.917-5.77-.243-3.947.958-7.41-.288-7.41-.288l-.16-2.667z",
  fill: "#2B0849"
}, null), f("path", {
  d: "M108.824 276.19h3.116s-.103 6.751 4.57 8.62c-4.673.624-8.62-2.32-7.686-8.62",
  fill: "#A4AABA"
}, null), f("path", {
  d: "M57.65 272.52s-2.122 7.47-4.518 12.396c-1.811 3.724-4.255 7.548 5.505 7.548 6.698 0 9.02-.483 7.479-6.648-1.541-6.164.268-13.296.268-13.296H57.65z",
  fill: "#CBD1D1"
}, null), f("path", {
  d: "M51.54 290.04s2.111 1.178 6.682 1.178c6.128 0 8.31-1.662 8.31-1.662s.605 1.122-.624 2.18c-1 .862-3.624 1.603-7.444 1.559-4.177-.049-5.876-.57-6.786-1.177-.831-.554-.692-1.593-.138-2.078",
  fill: "#2B0849"
}, null), f("path", {
  d: "M58.533 274.438s.034 1.529-.315 2.95c-.352 1.431-1.087 3.127-1.139 4.17-.058 1.16 4.57 1.592 5.194.035.623-1.559 1.303-6.475 1.927-7.306.622-.831-4.94-2.135-5.667.15",
  fill: "#A4AABA"
}, null), f("path", {
  d: "M100.885 277.015l13.306.092s1.291-54.228 1.843-64.056c.552-9.828 3.756-43.13.997-62.788l-12.48-.64-22.725.776s-.433 3.944-1.19 9.921c-.062.493-.677.838-.744 1.358-.075.582.42 1.347.318 1.956-2.35 14.003-6.343 32.926-8.697 46.425-.116.663-1.227 1.004-1.45 2.677-.04.3.21 1.516.112 1.785-6.836 18.643-10.89 47.584-14.2 61.551l14.528-.014s2.185-8.524 4.008-16.878c2.796-12.817 22.987-84.553 22.987-84.553l3-.517 1.037 46.1s-.223 1.228.334 2.008c.558.782-.556 1.117-.39 2.233l.39 1.784s-.446 7.14-.892 11.826c-.446 4.685-.092 38.954-.092 38.954",
  fill: "#7BB2F9"
}, null), f("path", {
  d: "M77.438 220.434c1.146.094 4.016-2.008 6.916-4.91M107.55 223.931s2.758-1.103 6.069-3.862",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M108.459 220.905s2.759-1.104 6.07-3.863",
  stroke: "#648BD8",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M76.099 223.557s2.608-.587 6.47-3.346M87.33 150.82c-.27 3.088.297 8.478-4.315 9.073M104.829 149.075s.11 13.936-1.286 14.983c-2.207 1.655-2.975 1.934-2.975 1.934M101.014 149.63s.035 12.81-1.19 24.245M94.93 174.965s7.174-1.655 9.38-1.655M75.671 204.754c-.316 1.55-.64 3.067-.973 4.535 0 0-1.45 1.822-1.003 3.756.446 1.934-.943 2.034-4.96 15.273-1.686 5.559-4.464 18.49-6.313 27.447-.078.38-4.018 18.06-4.093 18.423M77.043 196.743a313.269 313.269 0 0 1-.877 4.729M83.908 151.414l-1.19 10.413s-1.091.148-.496 2.23c.111 1.34-2.66 15.692-5.153 30.267M57.58 272.94h13.238",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null), f("path", {
  d: "M117.377 147.423s-16.955-3.087-35.7.199c.157 2.501-.002 4.128-.002 4.128s14.607-2.802 35.476-.31c.251-2.342.226-4.017.226-4.017",
  fill: "#192064"
}, null), f("path", {
  d: "M107.511 150.353l.004-4.885a.807.807 0 0 0-.774-.81c-2.428-.092-5.04-.108-7.795-.014a.814.814 0 0 0-.784.81l-.003 4.88c0 .456.371.82.827.808a140.76 140.76 0 0 1 7.688.017.81.81 0 0 0 .837-.806",
  fill: "#FFF"
}, null), f("path", {
  d: "M106.402 149.426l.002-3.06a.64.64 0 0 0-.616-.643 94.135 94.135 0 0 0-5.834-.009.647.647 0 0 0-.626.643l-.001 3.056c0 .36.291.648.651.64 1.78-.04 3.708-.041 5.762.012.36.009.662-.279.662-.64",
  fill: "#192064"
}, null), f("path", {
  d: "M101.485 273.933h12.272M102.652 269.075c.006 3.368.04 5.759.11 6.47M102.667 263.125c-.009 1.53-.015 2.98-.016 4.313M102.204 174.024l.893 44.402s.669 1.561-.224 2.677c-.892 1.116 2.455.67.893 2.231-1.562 1.562.893 1.116 0 3.347-.592 1.48-.988 20.987-1.09 34.956",
  stroke: "#648BD8",
  "stroke-width": "1.051",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, null)])]), cJ = (e) => {
  const {
    componentCls: t,
    lineHeightHeading3: n,
    iconCls: o,
    padding: r,
    paddingXL: l,
    paddingXS: a,
    paddingLG: i,
    marginXS: s,
    lineHeight: c
  } = e;
  return {
    // Result
    [t]: {
      padding: `${i * 2}px ${l}px`,
      // RTL
      "&-rtl": {
        direction: "rtl"
      }
    },
    // Exception Status image
    [`${t} ${t}-image`]: {
      width: e.imageWidth,
      height: e.imageHeight,
      margin: "auto"
    },
    [`${t} ${t}-icon`]: {
      marginBottom: i,
      textAlign: "center",
      [`& > ${o}`]: {
        fontSize: e.resultIconFontSize
      }
    },
    [`${t} ${t}-title`]: {
      color: e.colorTextHeading,
      fontSize: e.resultTitleFontSize,
      lineHeight: n,
      marginBlock: s,
      textAlign: "center"
    },
    [`${t} ${t}-subtitle`]: {
      color: e.colorTextDescription,
      fontSize: e.resultSubtitleFontSize,
      lineHeight: c,
      textAlign: "center"
    },
    [`${t} ${t}-content`]: {
      marginTop: i,
      padding: `${i}px ${r * 2.5}px`,
      backgroundColor: e.colorFillAlter
    },
    [`${t} ${t}-extra`]: {
      margin: e.resultExtraMargin,
      textAlign: "center",
      "& > *": {
        marginInlineEnd: a,
        "&:last-child": {
          marginInlineEnd: 0
        }
      }
    }
  };
}, uJ = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [`${t}-success ${t}-icon > ${n}`]: {
      color: e.resultSuccessIconColor
    },
    [`${t}-error ${t}-icon > ${n}`]: {
      color: e.resultErrorIconColor
    },
    [`${t}-info ${t}-icon > ${n}`]: {
      color: e.resultInfoIconColor
    },
    [`${t}-warning ${t}-icon > ${n}`]: {
      color: e.resultWarningIconColor
    }
  };
}, dJ = (e) => [cJ(e), uJ(e)], fJ = (e) => dJ(e), pJ = Xe("Result", (e) => {
  const {
    paddingLG: t,
    fontSizeHeading3: n
  } = e, o = e.fontSize, r = `${t}px 0 0 0`, l = e.colorInfo, a = e.colorError, i = e.colorSuccess, s = e.colorWarning, c = He(e, {
    resultTitleFontSize: n,
    resultSubtitleFontSize: o,
    resultIconFontSize: n * 3,
    resultExtraMargin: r,
    resultInfoIconColor: l,
    resultErrorIconColor: a,
    resultSuccessIconColor: i,
    resultWarningIconColor: s
  });
  return [fJ(c)];
}, {
  imageWidth: 250,
  imageHeight: 295
}), vJ = {
  success: ir,
  error: Gn,
  info: sr,
  warning: kb
}, $c = {
  404: aJ,
  500: iJ,
  403: sJ
}, gJ = Object.keys($c), mJ = () => ({
  prefixCls: String,
  icon: V.any,
  status: {
    type: [Number, String],
    default: "info"
  },
  title: V.any,
  subTitle: V.any,
  extra: V.any
}), hJ = (e, t) => {
  let {
    status: n,
    icon: o
  } = t;
  if (gJ.includes(`${n}`)) {
    const a = $c[n];
    return f("div", {
      class: `${e}-icon ${e}-image`
    }, [f(a, null, null)]);
  }
  const r = vJ[n], l = o || f(r, null, null);
  return f("div", {
    class: `${e}-icon`
  }, [l]);
}, bJ = (e, t) => t && f("div", {
  class: `${e}-extra`
}, [t]), la = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AResult",
  inheritAttrs: !1,
  props: mJ(),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("result", e), [a, i] = pJ(r), s = P(() => ee(r.value, i.value, `${r.value}-${e.status}`, {
      [`${r.value}-rtl`]: l.value === "rtl"
    }));
    return () => {
      var c, u, d, p, v, h, g, b;
      const y = (c = e.title) !== null && c !== void 0 ? c : (u = n.title) === null || u === void 0 ? void 0 : u.call(n), S = (d = e.subTitle) !== null && d !== void 0 ? d : (p = n.subTitle) === null || p === void 0 ? void 0 : p.call(n), C = (v = e.icon) !== null && v !== void 0 ? v : (h = n.icon) === null || h === void 0 ? void 0 : h.call(n), w = (g = e.extra) !== null && g !== void 0 ? g : (b = n.extra) === null || b === void 0 ? void 0 : b.call(n), $ = r.value;
      return a(f("div", D(D({}, o), {}, {
        class: [s.value, o.class]
      }), [hJ($, {
        status: e.status,
        icon: C
      }), f("div", {
        class: `${$}-title`
      }, [y]), S && f("div", {
        class: `${$}-subtitle`
      }, [S]), bJ($, w), n.default && f("div", {
        class: `${$}-content`
      }, [n.default()])]));
    };
  }
});
la.PRESENTED_IMAGE_403 = $c[403];
la.PRESENTED_IMAGE_404 = $c[404];
la.PRESENTED_IMAGE_500 = $c[500];
la.install = function(e) {
  return e.component(la.name, la), e;
};
const yJ = kt(rb), Bb = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    included: o,
    vertical: r,
    style: l,
    class: a
  } = n;
  let {
    length: i,
    offset: s,
    reverse: c
  } = n;
  i < 0 && (c = !c, i = Math.abs(i), s = 100 - s);
  const u = r ? {
    [c ? "top" : "bottom"]: `${s}%`,
    [c ? "bottom" : "top"]: "auto",
    height: `${i}%`
  } : {
    [c ? "right" : "left"]: `${s}%`,
    [c ? "left" : "right"]: "auto",
    width: `${i}%`
  }, d = m(m({}, l), u);
  return o ? f("div", {
    class: a,
    style: d
  }, null) : null;
};
Bb.inheritAttrs = !1;
const SJ = (e, t, n, o, r, l) => {
  Mt(n ? o > 0 : !0, "Slider", "`Slider[step]` should be a positive number in order to make Slider[dots] work.");
  const a = Object.keys(t).map(parseFloat).sort((i, s) => i - s);
  if (n && o)
    for (let i = r; i <= l; i += o)
      a.indexOf(i) === -1 && a.push(i);
  return a;
}, n6 = (e, t) => {
  let {
    attrs: n
  } = t;
  const {
    prefixCls: o,
    vertical: r,
    reverse: l,
    marks: a,
    dots: i,
    step: s,
    included: c,
    lowerBound: u,
    upperBound: d,
    max: p,
    min: v,
    dotStyle: h,
    activeDotStyle: g
  } = n, b = p - v, y = SJ(r, a, i, s, v, p).map((S) => {
    const C = `${Math.abs(S - v) / b * 100}%`, w = !c && S === d || c && S <= d && S >= u;
    let $ = r ? m(m({}, h), {
      [l ? "top" : "bottom"]: C
    }) : m(m({}, h), {
      [l ? "right" : "left"]: C
    });
    w && ($ = m(m({}, $), g));
    const O = ee({
      [`${o}-dot`]: !0,
      [`${o}-dot-active`]: w,
      [`${o}-dot-reverse`]: l
    });
    return f("span", {
      class: O,
      style: $,
      key: S
    }, null);
  });
  return f("div", {
    class: `${o}-step`
  }, [y]);
};
n6.inheritAttrs = !1;
const o6 = (e, t) => {
  let {
    attrs: n,
    slots: o
  } = t;
  const {
    class: r,
    vertical: l,
    reverse: a,
    marks: i,
    included: s,
    upperBound: c,
    lowerBound: u,
    max: d,
    min: p,
    onClickLabel: v
  } = n, h = Object.keys(i), g = o.mark, b = d - p, y = h.map(parseFloat).sort((S, C) => S - C).map((S) => {
    const C = typeof i[S] == "function" ? i[S]() : i[S], w = typeof C == "object" && !Gt(C);
    let $ = w ? C.label : C;
    if (!$ && $ !== 0)
      return null;
    g && ($ = g({
      point: S,
      label: $
    }));
    const O = !s && S === c || s && S <= c && S >= u, x = ee({
      [`${r}-text`]: !0,
      [`${r}-text-active`]: O
    }), I = {
      marginBottom: "-50%",
      [a ? "top" : "bottom"]: `${(S - p) / b * 100}%`
    }, E = {
      transform: `translateX(${a ? "50%" : "-50%"})`,
      msTransform: `translateX(${a ? "50%" : "-50%"})`,
      [a ? "right" : "left"]: `${(S - p) / b * 100}%`
    }, _ = l ? I : E, M = w ? m(m({}, _), C.style) : _, R = {
      [on ? "onTouchstartPassive" : "onTouchstart"]: (A) => v(A, S)
    };
    return f("span", D({
      class: x,
      style: M,
      key: S,
      onMousedown: (A) => v(A, S)
    }, R), [$]);
  });
  return f("div", {
    class: r
  }, [y]);
};
o6.inheritAttrs = !1;
const r6 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Handle",
  inheritAttrs: !1,
  props: {
    prefixCls: String,
    vertical: {
      type: Boolean,
      default: void 0
    },
    offset: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    value: Number,
    tabindex: V.oneOfType([V.number, V.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    ariaLabel: String,
    ariaLabelledBy: String,
    ariaValueTextFormatter: Function,
    onMouseenter: {
      type: Function
    },
    onMouseleave: {
      type: Function
    },
    onMousedown: {
      type: Function
    }
  },
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      expose: r
    } = t;
    const l = Q(!1), a = Q(), i = () => {
      document.activeElement === a.value && (l.value = !0);
    }, s = (b) => {
      l.value = !1, o("blur", b);
    }, c = () => {
      l.value = !1;
    }, u = () => {
      var b;
      (b = a.value) === null || b === void 0 || b.focus();
    }, d = () => {
      var b;
      (b = a.value) === null || b === void 0 || b.blur();
    }, p = () => {
      l.value = !0, u();
    }, v = (b) => {
      b.preventDefault(), u(), o("mousedown", b);
    };
    r({
      focus: u,
      blur: d,
      clickFocus: p,
      ref: a
    });
    let h = null;
    Ke(() => {
      h = Bt(document, "mouseup", i);
    }), et(() => {
      h == null || h.remove();
    });
    const g = P(() => {
      const {
        vertical: b,
        offset: y,
        reverse: S
      } = e;
      return b ? {
        [S ? "top" : "bottom"]: `${y}%`,
        [S ? "bottom" : "top"]: "auto",
        transform: S ? null : "translateY(+50%)"
      } : {
        [S ? "right" : "left"]: `${y}%`,
        [S ? "left" : "right"]: "auto",
        transform: `translateX(${S ? "+" : "-"}50%)`
      };
    });
    return () => {
      const {
        prefixCls: b,
        disabled: y,
        min: S,
        max: C,
        value: w,
        tabindex: $,
        ariaLabel: O,
        ariaLabelledBy: x,
        ariaValueTextFormatter: I,
        onMouseenter: E,
        onMouseleave: _
      } = e, M = ee(n.class, {
        [`${b}-handle-click-focused`]: l.value
      }), R = {
        "aria-valuemin": S,
        "aria-valuemax": C,
        "aria-valuenow": w,
        "aria-disabled": !!y
      }, A = [n.style, g.value];
      let z = $ || 0;
      (y || $ === null) && (z = null);
      let T;
      I && (T = I(w));
      const N = m(m(m(m({}, n), {
        role: "slider",
        tabindex: z
      }), R), {
        class: M,
        onBlur: s,
        onKeydown: c,
        onMousedown: v,
        onMouseenter: E,
        onMouseleave: _,
        ref: a,
        style: A
      });
      return f("div", D(D({}, N), {}, {
        "aria-label": O,
        "aria-labelledby": x,
        "aria-valuetext": T
      }), null);
    };
  }
});
function Hv(e, t) {
  try {
    return Object.keys(t).some((n) => e.target === t[n].ref);
  } catch {
    return !1;
  }
}
function l6(e, t) {
  let {
    min: n,
    max: o
  } = t;
  return e < n || e > o;
}
function Q$(e) {
  return e.touches.length > 1 || e.type.toLowerCase() === "touchend" && e.touches.length > 0;
}
function J$(e, t) {
  let {
    marks: n,
    step: o,
    min: r,
    max: l
  } = t;
  const a = Object.keys(n).map(parseFloat);
  if (o !== null) {
    const s = Math.pow(10, a6(o)), c = Math.floor((l * s - r * s) / (o * s)), u = Math.min((e - r) / o, c), d = Math.round(u) * o + r;
    a.push(d);
  }
  const i = a.map((s) => Math.abs(e - s));
  return a[i.indexOf(Math.min(...i))];
}
function a6(e) {
  const t = e.toString();
  let n = 0;
  return t.indexOf(".") >= 0 && (n = t.length - t.indexOf(".") - 1), n;
}
function ew(e, t) {
  let n = 1;
  return window.visualViewport && (n = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2)), (e ? t.clientY : t.pageX) / n;
}
function tw(e, t) {
  let n = 1;
  return window.visualViewport && (n = +(window.visualViewport.width / document.body.getBoundingClientRect().width).toFixed(2)), (e ? t.touches[0].clientY : t.touches[0].pageX) / n;
}
function nw(e, t) {
  const n = t.getBoundingClientRect();
  return e ? n.top + n.height * 0.5 : window.scrollX + n.left + n.width * 0.5;
}
function Fb(e, t) {
  let {
    max: n,
    min: o
  } = t;
  return e <= o ? o : e >= n ? n : e;
}
function i6(e, t) {
  const {
    step: n
  } = t, o = isFinite(J$(e, t)) ? J$(e, t) : 0;
  return n === null ? o : parseFloat(o.toFixed(a6(n)));
}
function $i(e) {
  e.stopPropagation(), e.preventDefault();
}
function CJ(e, t, n) {
  const o = {
    increase: (a, i) => a + i,
    decrease: (a, i) => a - i
  }, r = o[e](Object.keys(n.marks).indexOf(JSON.stringify(t)), 1), l = Object.keys(n.marks)[r];
  return n.step ? o[e](t, n.step) : Object.keys(n.marks).length && n.marks[l] ? n.marks[l] : t;
}
function s6(e, t, n) {
  const o = "increase", r = "decrease";
  let l = o;
  switch (e.keyCode) {
    case ce.UP:
      l = t && n ? r : o;
      break;
    case ce.RIGHT:
      l = !t && n ? r : o;
      break;
    case ce.DOWN:
      l = t && n ? o : r;
      break;
    case ce.LEFT:
      l = !t && n ? o : r;
      break;
    case ce.END:
      return (a, i) => i.max;
    case ce.HOME:
      return (a, i) => i.min;
    case ce.PAGE_UP:
      return (a, i) => a + i.step * 2;
    case ce.PAGE_DOWN:
      return (a, i) => a - i.step * 2;
    default:
      return;
  }
  return (a, i) => CJ(l, a, i);
}
var $J = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function kl() {
}
function c6(e) {
  const t = {
    id: String,
    min: Number,
    max: Number,
    step: Number,
    marks: V.object,
    included: {
      type: Boolean,
      default: void 0
    },
    prefixCls: String,
    disabled: {
      type: Boolean,
      default: void 0
    },
    handle: Function,
    dots: {
      type: Boolean,
      default: void 0
    },
    vertical: {
      type: Boolean,
      default: void 0
    },
    reverse: {
      type: Boolean,
      default: void 0
    },
    minimumTrackStyle: V.object,
    maximumTrackStyle: V.object,
    handleStyle: V.oneOfType([V.object, V.arrayOf(V.object)]),
    trackStyle: V.oneOfType([V.object, V.arrayOf(V.object)]),
    railStyle: V.object,
    dotStyle: V.object,
    activeDotStyle: V.object,
    autofocus: {
      type: Boolean,
      default: void 0
    },
    draggableTrack: {
      type: Boolean,
      default: void 0
    }
  };
  return Z({
    compatConfig: {
      MODE: 3
    },
    name: "CreateSlider",
    mixins: [Ca, e],
    inheritAttrs: !1,
    props: Qe(t, {
      prefixCls: "rc-slider",
      min: 0,
      max: 100,
      step: 1,
      marks: {},
      included: !0,
      disabled: !1,
      dots: !1,
      vertical: !1,
      reverse: !1,
      trackStyle: [{}],
      handleStyle: [{}],
      railStyle: {},
      dotStyle: {},
      activeDotStyle: {}
    }),
    emits: ["change", "blur", "focus"],
    data() {
      const {
        step: n,
        max: o,
        min: r
      } = this, l = isFinite(o - r) ? (o - r) % n === 0 : !0;
      return Mt(n && Math.floor(n) === n ? l : !0, `Slider[max] - Slider[min] (${o - r}) should be a multiple of Slider[step] (${n})`), this.handlesRefs = {}, {};
    },
    mounted() {
      this.$nextTick(() => {
        this.document = this.sliderRef && this.sliderRef.ownerDocument;
        const {
          autofocus: n,
          disabled: o
        } = this;
        n && !o && this.focus();
      });
    },
    beforeUnmount() {
      this.$nextTick(() => {
        this.removeDocumentEvents();
      });
    },
    methods: {
      defaultHandle(n) {
        var {
          index: o,
          directives: r,
          className: l,
          style: a
        } = n, i = $J(n, ["index", "directives", "className", "style"]);
        if (delete i.dragging, i.value === null)
          return null;
        const s = m(m({}, i), {
          class: l,
          style: a,
          key: o
        });
        return f(r6, s, null);
      },
      onDown(n, o) {
        let r = o;
        const {
          draggableTrack: l,
          vertical: a
        } = this.$props, {
          bounds: i
        } = this.$data, s = l && this.positionGetValue ? this.positionGetValue(r) || [] : [], c = Hv(n, this.handlesRefs);
        if (this.dragTrack = l && i.length >= 2 && !c && !s.map((u, d) => {
          const p = d ? !0 : u >= i[d];
          return d === s.length - 1 ? u <= i[d] : p;
        }).some((u) => !u), this.dragTrack)
          this.dragOffset = r, this.startBounds = [...i];
        else {
          if (!c)
            this.dragOffset = 0;
          else {
            const u = nw(a, n.target);
            this.dragOffset = r - u, r = u;
          }
          this.onStart(r);
        }
      },
      onMouseDown(n) {
        if (n.button !== 0)
          return;
        this.removeDocumentEvents();
        const o = this.$props.vertical, r = ew(o, n);
        this.onDown(n, r), this.addDocumentMouseEvents();
      },
      onTouchStart(n) {
        if (Q$(n))
          return;
        const o = this.vertical, r = tw(o, n);
        this.onDown(n, r), this.addDocumentTouchEvents(), $i(n);
      },
      onFocus(n) {
        const {
          vertical: o
        } = this;
        if (Hv(n, this.handlesRefs) && !this.dragTrack) {
          const r = nw(o, n.target);
          this.dragOffset = 0, this.onStart(r), $i(n), this.$emit("focus", n);
        }
      },
      onBlur(n) {
        this.dragTrack || this.onEnd(), this.$emit("blur", n);
      },
      onMouseUp() {
        this.handlesRefs[this.prevMovedHandleIndex] && this.handlesRefs[this.prevMovedHandleIndex].clickFocus();
      },
      onMouseMove(n) {
        if (!this.sliderRef) {
          this.onEnd();
          return;
        }
        const o = ew(this.vertical, n);
        this.onMove(n, o - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onTouchMove(n) {
        if (Q$(n) || !this.sliderRef) {
          this.onEnd();
          return;
        }
        const o = tw(this.vertical, n);
        this.onMove(n, o - this.dragOffset, this.dragTrack, this.startBounds);
      },
      onKeyDown(n) {
        this.sliderRef && Hv(n, this.handlesRefs) && this.onKeyboard(n);
      },
      onClickMarkLabel(n, o) {
        n.stopPropagation(), this.onChange({
          sValue: o
        }), this.setState({
          sValue: o
        }, () => this.onEnd(!0));
      },
      getSliderStart() {
        const n = this.sliderRef, {
          vertical: o,
          reverse: r
        } = this, l = n.getBoundingClientRect();
        return o ? r ? l.bottom : l.top : window.scrollX + (r ? l.right : l.left);
      },
      getSliderLength() {
        const n = this.sliderRef;
        if (!n)
          return 0;
        const o = n.getBoundingClientRect();
        return this.vertical ? o.height : o.width;
      },
      addDocumentTouchEvents() {
        this.onTouchMoveListener = Bt(this.document, "touchmove", this.onTouchMove), this.onTouchUpListener = Bt(this.document, "touchend", this.onEnd);
      },
      addDocumentMouseEvents() {
        this.onMouseMoveListener = Bt(this.document, "mousemove", this.onMouseMove), this.onMouseUpListener = Bt(this.document, "mouseup", this.onEnd);
      },
      removeDocumentEvents() {
        this.onTouchMoveListener && this.onTouchMoveListener.remove(), this.onTouchUpListener && this.onTouchUpListener.remove(), this.onMouseMoveListener && this.onMouseMoveListener.remove(), this.onMouseUpListener && this.onMouseUpListener.remove();
      },
      focus() {
        var n;
        this.$props.disabled || (n = this.handlesRefs[0]) === null || n === void 0 || n.focus();
      },
      blur() {
        this.$props.disabled || Object.keys(this.handlesRefs).forEach((n) => {
          var o, r;
          (r = (o = this.handlesRefs[n]) === null || o === void 0 ? void 0 : o.blur) === null || r === void 0 || r.call(o);
        });
      },
      calcValue(n) {
        const {
          vertical: o,
          min: r,
          max: l
        } = this, a = Math.abs(Math.max(n, 0) / this.getSliderLength());
        return o ? (1 - a) * (l - r) + r : a * (l - r) + r;
      },
      calcValueByPos(n) {
        const r = (this.reverse ? -1 : 1) * (n - this.getSliderStart());
        return this.trimAlignValue(this.calcValue(r));
      },
      calcOffset(n) {
        const {
          min: o,
          max: r
        } = this, l = (n - o) / (r - o);
        return Math.max(0, l * 100);
      },
      saveSlider(n) {
        this.sliderRef = n;
      },
      saveHandle(n, o) {
        this.handlesRefs[n] = o;
      }
    },
    render() {
      const {
        prefixCls: n,
        marks: o,
        dots: r,
        step: l,
        included: a,
        disabled: i,
        vertical: s,
        reverse: c,
        min: u,
        max: d,
        maximumTrackStyle: p,
        railStyle: v,
        dotStyle: h,
        activeDotStyle: g,
        id: b
      } = this, {
        class: y,
        style: S
      } = this.$attrs, {
        tracks: C,
        handles: w
      } = this.renderSlider(), $ = ee(n, y, {
        [`${n}-with-marks`]: Object.keys(o).length,
        [`${n}-disabled`]: i,
        [`${n}-vertical`]: s,
        [`${n}-horizontal`]: !s
      }), O = {
        vertical: s,
        marks: o,
        included: a,
        lowerBound: this.getLowerBound(),
        upperBound: this.getUpperBound(),
        max: d,
        min: u,
        reverse: c,
        class: `${n}-mark`,
        onClickLabel: i ? kl : this.onClickMarkLabel
      }, x = {
        [on ? "onTouchstartPassive" : "onTouchstart"]: i ? kl : this.onTouchStart
      };
      return f("div", D(D({
        id: b,
        ref: this.saveSlider,
        tabindex: "-1",
        class: $
      }, x), {}, {
        onMousedown: i ? kl : this.onMouseDown,
        onMouseup: i ? kl : this.onMouseUp,
        onKeydown: i ? kl : this.onKeyDown,
        onFocus: i ? kl : this.onFocus,
        onBlur: i ? kl : this.onBlur,
        style: S
      }), [f("div", {
        class: `${n}-rail`,
        style: m(m({}, p), v)
      }, null), C, f(n6, {
        prefixCls: n,
        vertical: s,
        reverse: c,
        marks: o,
        dots: r,
        step: l,
        included: a,
        lowerBound: this.getLowerBound(),
        upperBound: this.getUpperBound(),
        max: d,
        min: u,
        dotStyle: h,
        activeDotStyle: g
      }, null), w, f(o6, O, {
        mark: this.$slots.mark
      }), hf(this)]);
    }
  });
}
const wJ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Slider",
  mixins: [Ca],
  inheritAttrs: !1,
  props: {
    defaultValue: Number,
    value: Number,
    disabled: {
      type: Boolean,
      default: void 0
    },
    autofocus: {
      type: Boolean,
      default: void 0
    },
    tabindex: V.oneOfType([V.number, V.string]),
    reverse: {
      type: Boolean,
      default: void 0
    },
    min: Number,
    max: Number,
    ariaLabelForHandle: String,
    ariaLabelledByForHandle: String,
    ariaValueTextFormatterForHandle: String,
    startPoint: Number
  },
  emits: ["beforeChange", "afterChange", "change"],
  data() {
    const e = this.defaultValue !== void 0 ? this.defaultValue : this.min, t = this.value !== void 0 ? this.value : e;
    return {
      sValue: this.trimAlignValue(t),
      dragging: !1
    };
  },
  watch: {
    value: {
      handler(e) {
        this.setChangeValue(e);
      },
      deep: !0
    },
    min() {
      const {
        sValue: e
      } = this;
      this.setChangeValue(e);
    },
    max() {
      const {
        sValue: e
      } = this;
      this.setChangeValue(e);
    }
  },
  methods: {
    setChangeValue(e) {
      const t = e !== void 0 ? e : this.sValue, n = this.trimAlignValue(t, this.$props);
      n !== this.sValue && (this.setState({
        sValue: n
      }), l6(t, this.$props) && this.$emit("change", n));
    },
    onChange(e) {
      const t = !Rr(this, "value"), n = e.sValue > this.max ? m(m({}, e), {
        sValue: this.max
      }) : e;
      t && this.setState(n);
      const o = n.sValue;
      this.$emit("change", o);
    },
    onStart(e) {
      this.setState({
        dragging: !0
      });
      const {
        sValue: t
      } = this;
      this.$emit("beforeChange", t);
      const n = this.calcValueByPos(e);
      this.startValue = n, this.startPosition = e, n !== t && (this.prevMovedHandleIndex = 0, this.onChange({
        sValue: n
      }));
    },
    onEnd(e) {
      const {
        dragging: t
      } = this;
      this.removeDocumentEvents(), (t || e) && this.$emit("afterChange", this.sValue), this.setState({
        dragging: !1
      });
    },
    onMove(e, t) {
      $i(e);
      const {
        sValue: n
      } = this, o = this.calcValueByPos(t);
      o !== n && this.onChange({
        sValue: o
      });
    },
    onKeyboard(e) {
      const {
        reverse: t,
        vertical: n
      } = this.$props, o = s6(e, n, t);
      if (o) {
        $i(e);
        const {
          sValue: r
        } = this, l = o(r, this.$props), a = this.trimAlignValue(l);
        if (a === r)
          return;
        this.onChange({
          sValue: a
        }), this.$emit("afterChange", a), this.onEnd();
      }
    },
    getLowerBound() {
      const e = this.$props.startPoint || this.$props.min;
      return this.$data.sValue > e ? e : this.$data.sValue;
    },
    getUpperBound() {
      return this.$data.sValue < this.$props.startPoint ? this.$props.startPoint : this.$data.sValue;
    },
    trimAlignValue(e) {
      let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (e === null)
        return null;
      const n = m(m({}, this.$props), t), o = Fb(e, n);
      return i6(o, n);
    },
    getTrack(e) {
      let {
        prefixCls: t,
        reverse: n,
        vertical: o,
        included: r,
        minimumTrackStyle: l,
        mergedTrackStyle: a,
        length: i,
        offset: s
      } = e;
      return f(Bb, {
        class: `${t}-track`,
        vertical: o,
        included: r,
        offset: s,
        reverse: n,
        length: i,
        style: m(m({}, l), a)
      }, null);
    },
    renderSlider() {
      const {
        prefixCls: e,
        vertical: t,
        included: n,
        disabled: o,
        minimumTrackStyle: r,
        trackStyle: l,
        handleStyle: a,
        tabindex: i,
        ariaLabelForHandle: s,
        ariaLabelledByForHandle: c,
        ariaValueTextFormatterForHandle: u,
        min: d,
        max: p,
        startPoint: v,
        reverse: h,
        handle: g,
        defaultHandle: b
      } = this, y = g || b, {
        sValue: S,
        dragging: C
      } = this, w = this.calcOffset(S), $ = y({
        class: `${e}-handle`,
        prefixCls: e,
        vertical: t,
        offset: w,
        value: S,
        dragging: C,
        disabled: o,
        min: d,
        max: p,
        reverse: h,
        index: 0,
        tabindex: i,
        ariaLabel: s,
        ariaLabelledBy: c,
        ariaValueTextFormatter: u,
        style: a[0] || a,
        ref: (I) => this.saveHandle(0, I),
        onFocus: this.onFocus,
        onBlur: this.onBlur
      }), O = v !== void 0 ? this.calcOffset(v) : 0, x = l[0] || l;
      return {
        tracks: this.getTrack({
          prefixCls: e,
          reverse: h,
          vertical: t,
          included: n,
          offset: O,
          minimumTrackStyle: r,
          mergedTrackStyle: x,
          length: w - O
        }),
        handles: $
      };
    }
  }
}), xJ = c6(wJ), Zi = (e) => {
  let {
    value: t,
    handle: n,
    bounds: o,
    props: r
  } = e;
  const {
    allowCross: l,
    pushable: a
  } = r, i = Number(a), s = Fb(t, r);
  let c = s;
  return !l && n != null && o !== void 0 && (n > 0 && s <= o[n - 1] + i && (c = o[n - 1] + i), n < o.length - 1 && s >= o[n + 1] - i && (c = o[n + 1] - i)), i6(c, r);
}, OJ = {
  defaultValue: V.arrayOf(V.number),
  value: V.arrayOf(V.number),
  count: Number,
  pushable: Z2(V.oneOfType([V.looseBool, V.number])),
  allowCross: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  reverse: {
    type: Boolean,
    default: void 0
  },
  tabindex: V.arrayOf(V.number),
  prefixCls: String,
  min: Number,
  max: Number,
  autofocus: {
    type: Boolean,
    default: void 0
  },
  ariaLabelGroupForHandles: Array,
  ariaLabelledByGroupForHandles: Array,
  ariaValueTextFormatterGroupForHandles: Array,
  draggableTrack: {
    type: Boolean,
    default: void 0
  }
}, PJ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Range",
  mixins: [Ca],
  inheritAttrs: !1,
  props: Qe(OJ, {
    count: 1,
    allowCross: !0,
    pushable: !1,
    tabindex: [],
    draggableTrack: !1,
    ariaLabelGroupForHandles: [],
    ariaLabelledByGroupForHandles: [],
    ariaValueTextFormatterGroupForHandles: []
  }),
  emits: ["beforeChange", "afterChange", "change"],
  displayName: "Range",
  data() {
    const {
      count: e,
      min: t,
      max: n
    } = this, o = Array(...Array(e + 1)).map(() => t), r = Rr(this, "defaultValue") ? this.defaultValue : o;
    let {
      value: l
    } = this;
    l === void 0 && (l = r);
    const a = l.map((s, c) => Zi({
      value: s,
      handle: c,
      props: this.$props
    }));
    return {
      sHandle: null,
      recent: a[0] === n ? 0 : a.length - 1,
      bounds: a
    };
  },
  watch: {
    value: {
      handler(e) {
        const {
          bounds: t
        } = this;
        this.setChangeValue(e || t);
      },
      deep: !0
    },
    min() {
      const {
        value: e
      } = this;
      this.setChangeValue(e || this.bounds);
    },
    max() {
      const {
        value: e
      } = this;
      this.setChangeValue(e || this.bounds);
    }
  },
  methods: {
    setChangeValue(e) {
      const {
        bounds: t
      } = this;
      let n = e.map((o, r) => Zi({
        value: o,
        handle: r,
        bounds: t,
        props: this.$props
      }));
      if (t.length === n.length) {
        if (n.every((o, r) => o === t[r]))
          return null;
      } else
        n = e.map((o, r) => Zi({
          value: o,
          handle: r,
          props: this.$props
        }));
      if (this.setState({
        bounds: n
      }), e.some((o) => l6(o, this.$props))) {
        const o = e.map((r) => Fb(r, this.$props));
        this.$emit("change", o);
      }
    },
    onChange(e) {
      if (!Rr(this, "value"))
        this.setState(e);
      else {
        const r = {};
        ["sHandle", "recent"].forEach((l) => {
          e[l] !== void 0 && (r[l] = e[l]);
        }), Object.keys(r).length && this.setState(r);
      }
      const o = m(m({}, this.$data), e).bounds;
      this.$emit("change", o);
    },
    positionGetValue(e) {
      const t = this.getValue(), n = this.calcValueByPos(e), o = this.getClosestBound(n), r = this.getBoundNeedMoving(n, o), l = t[r];
      if (n === l)
        return null;
      const a = [...t];
      return a[r] = n, a;
    },
    onStart(e) {
      const {
        bounds: t
      } = this;
      this.$emit("beforeChange", t);
      const n = this.calcValueByPos(e);
      this.startValue = n, this.startPosition = e;
      const o = this.getClosestBound(n);
      this.prevMovedHandleIndex = this.getBoundNeedMoving(n, o), this.setState({
        sHandle: this.prevMovedHandleIndex,
        recent: this.prevMovedHandleIndex
      });
      const r = t[this.prevMovedHandleIndex];
      if (n === r)
        return;
      const l = [...t];
      l[this.prevMovedHandleIndex] = n, this.onChange({
        bounds: l
      });
    },
    onEnd(e) {
      const {
        sHandle: t
      } = this;
      this.removeDocumentEvents(), t || (this.dragTrack = !1), (t !== null || e) && this.$emit("afterChange", this.bounds), this.setState({
        sHandle: null
      });
    },
    onMove(e, t, n, o) {
      $i(e);
      const {
        $data: r,
        $props: l
      } = this, a = l.max || 100, i = l.min || 0;
      if (n) {
        let p = l.vertical ? -t : t;
        p = l.reverse ? -p : p;
        const v = a - Math.max(...o), h = i - Math.min(...o), g = Math.min(Math.max(p / (this.getSliderLength() / 100), h), v), b = o.map((y) => Math.floor(Math.max(Math.min(y + g, a), i)));
        r.bounds.map((y, S) => y === b[S]).some((y) => !y) && this.onChange({
          bounds: b
        });
        return;
      }
      const {
        bounds: s,
        sHandle: c
      } = this, u = this.calcValueByPos(t), d = s[c];
      u !== d && this.moveTo(u);
    },
    onKeyboard(e) {
      const {
        reverse: t,
        vertical: n
      } = this.$props, o = s6(e, n, t);
      if (o) {
        $i(e);
        const {
          bounds: r,
          sHandle: l
        } = this, a = r[l === null ? this.recent : l], i = o(a, this.$props), s = Zi({
          value: i,
          handle: l,
          bounds: r,
          props: this.$props
        });
        if (s === a)
          return;
        this.moveTo(s, !0);
      }
    },
    getClosestBound(e) {
      const {
        bounds: t
      } = this;
      let n = 0;
      for (let o = 1; o < t.length - 1; o += 1)
        e >= t[o] && (n = o);
      return Math.abs(t[n + 1] - e) < Math.abs(t[n] - e) && (n += 1), n;
    },
    getBoundNeedMoving(e, t) {
      const {
        bounds: n,
        recent: o
      } = this;
      let r = t;
      const l = n[t + 1] === n[t];
      return l && n[o] === n[t] && (r = o), l && e !== n[t + 1] && (r = e < n[t + 1] ? t : t + 1), r;
    },
    getLowerBound() {
      return this.bounds[0];
    },
    getUpperBound() {
      const {
        bounds: e
      } = this;
      return e[e.length - 1];
    },
    /**
     * Returns an array of possible slider points, taking into account both
     * `marks` and `step`. The result is cached.
     */
    getPoints() {
      const {
        marks: e,
        step: t,
        min: n,
        max: o
      } = this, r = this.internalPointsCache;
      if (!r || r.marks !== e || r.step !== t) {
        const l = m({}, e);
        if (t !== null)
          for (let i = n; i <= o; i += t)
            l[i] = i;
        const a = Object.keys(l).map(parseFloat);
        a.sort((i, s) => i - s), this.internalPointsCache = {
          marks: e,
          step: t,
          points: a
        };
      }
      return this.internalPointsCache.points;
    },
    moveTo(e, t) {
      const n = [...this.bounds], {
        sHandle: o,
        recent: r
      } = this, l = o === null ? r : o;
      n[l] = e;
      let a = l;
      this.$props.pushable !== !1 ? this.pushSurroundingHandles(n, a) : this.$props.allowCross && (n.sort((i, s) => i - s), a = n.indexOf(e)), this.onChange({
        recent: a,
        sHandle: a,
        bounds: n
      }), t && (this.$emit("afterChange", n), this.setState({}, () => {
        this.handlesRefs[a].focus();
      }), this.onEnd());
    },
    pushSurroundingHandles(e, t) {
      const n = e[t], {
        pushable: o
      } = this, r = Number(o);
      let l = 0;
      if (e[t + 1] - n < r && (l = 1), n - e[t - 1] < r && (l = -1), l === 0)
        return;
      const a = t + l, i = l * (e[a] - n);
      this.pushHandle(e, a, l, r - i) || (e[t] = e[a] - l * r);
    },
    pushHandle(e, t, n, o) {
      const r = e[t];
      let l = e[t];
      for (; n * (l - r) < o; ) {
        if (!this.pushHandleOnePoint(e, t, n))
          return e[t] = r, !1;
        l = e[t];
      }
      return !0;
    },
    pushHandleOnePoint(e, t, n) {
      const o = this.getPoints(), l = o.indexOf(e[t]) + n;
      if (l >= o.length || l < 0)
        return !1;
      const a = t + n, i = o[l], {
        pushable: s
      } = this, c = Number(s), u = n * (e[a] - i);
      return this.pushHandle(e, a, n, c - u) ? (e[t] = i, !0) : !1;
    },
    trimAlignValue(e) {
      const {
        sHandle: t,
        bounds: n
      } = this;
      return Zi({
        value: e,
        handle: t,
        bounds: n,
        props: this.$props
      });
    },
    ensureValueNotConflict(e, t, n) {
      let {
        allowCross: o,
        pushable: r
      } = n;
      const l = this.$data || {}, {
        bounds: a
      } = l;
      if (e = e === void 0 ? l.sHandle : e, r = Number(r), !o && e != null && a !== void 0) {
        if (e > 0 && t <= a[e - 1] + r)
          return a[e - 1] + r;
        if (e < a.length - 1 && t >= a[e + 1] - r)
          return a[e + 1] - r;
      }
      return t;
    },
    getTrack(e) {
      let {
        bounds: t,
        prefixCls: n,
        reverse: o,
        vertical: r,
        included: l,
        offsets: a,
        trackStyle: i
      } = e;
      return t.slice(0, -1).map((s, c) => {
        const u = c + 1, d = ee({
          [`${n}-track`]: !0,
          [`${n}-track-${u}`]: !0
        });
        return f(Bb, {
          class: d,
          vertical: r,
          reverse: o,
          included: l,
          offset: a[u - 1],
          length: a[u] - a[u - 1],
          style: i[c],
          key: u
        }, null);
      });
    },
    renderSlider() {
      const {
        sHandle: e,
        bounds: t,
        prefixCls: n,
        vertical: o,
        included: r,
        disabled: l,
        min: a,
        max: i,
        reverse: s,
        handle: c,
        defaultHandle: u,
        trackStyle: d,
        handleStyle: p,
        tabindex: v,
        ariaLabelGroupForHandles: h,
        ariaLabelledByGroupForHandles: g,
        ariaValueTextFormatterGroupForHandles: b
      } = this, y = c || u, S = t.map(($) => this.calcOffset($)), C = `${n}-handle`, w = t.map(($, O) => {
        let x = v[O] || 0;
        (l || v[O] === null) && (x = null);
        const I = e === O;
        return y({
          class: ee({
            [C]: !0,
            [`${C}-${O + 1}`]: !0,
            [`${C}-dragging`]: I
          }),
          prefixCls: n,
          vertical: o,
          dragging: I,
          offset: S[O],
          value: $,
          index: O,
          tabindex: x,
          min: a,
          max: i,
          reverse: s,
          disabled: l,
          style: p[O],
          ref: (E) => this.saveHandle(O, E),
          onFocus: this.onFocus,
          onBlur: this.onBlur,
          ariaLabel: h[O],
          ariaLabelledBy: g[O],
          ariaValueTextFormatter: b[O]
        });
      });
      return {
        tracks: this.getTrack({
          bounds: t,
          prefixCls: n,
          reverse: s,
          vertical: o,
          included: r,
          offsets: S,
          trackStyle: d
        }),
        handles: w
      };
    }
  }
}), IJ = c6(PJ), EJ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "SliderTooltip",
  inheritAttrs: !1,
  props: PO(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = Y(null), l = Y(null);
    function a() {
      Ze.cancel(l.value), l.value = null;
    }
    function i() {
      l.value = Ze(() => {
        var c;
        (c = r.value) === null || c === void 0 || c.forcePopupAlign(), l.value = null;
      });
    }
    const s = () => {
      a(), e.open && i();
    };
    return ie([() => e.open, () => e.title], () => {
      s();
    }, {
      flush: "post",
      immediate: !0
    }), th(() => {
      s();
    }), et(() => {
      a();
    }), () => f(Ln, D(D({
      ref: r
    }, e), n), o);
  }
}), TJ = (e) => {
  const {
    componentCls: t,
    controlSize: n,
    dotSize: o,
    marginFull: r,
    marginPart: l,
    colorFillContentHover: a
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      position: "relative",
      height: n,
      margin: `${l}px ${r}px`,
      padding: 0,
      cursor: "pointer",
      touchAction: "none",
      "&-vertical": {
        margin: `${r}px ${l}px`
      },
      [`${t}-rail`]: {
        position: "absolute",
        backgroundColor: e.colorFillTertiary,
        borderRadius: e.borderRadiusXS,
        transition: `background-color ${e.motionDurationMid}`
      },
      [`${t}-track`]: {
        position: "absolute",
        backgroundColor: e.colorPrimaryBorder,
        borderRadius: e.borderRadiusXS,
        transition: `background-color ${e.motionDurationMid}`
      },
      "&:hover": {
        [`${t}-rail`]: {
          backgroundColor: e.colorFillSecondary
        },
        [`${t}-track`]: {
          backgroundColor: e.colorPrimaryBorderHover
        },
        [`${t}-dot`]: {
          borderColor: a
        },
        [`${t}-handle::after`]: {
          boxShadow: `0 0 0 ${e.handleLineWidth}px ${e.colorPrimaryBorderHover}`
        },
        [`${t}-dot-active`]: {
          borderColor: e.colorPrimary
        }
      },
      [`${t}-handle`]: {
        position: "absolute",
        width: e.handleSize,
        height: e.handleSize,
        outline: "none",
        [`${t}-dragging`]: {
          zIndex: 1
        },
        // 扩大选区
        "&::before": {
          content: '""',
          position: "absolute",
          insetInlineStart: -e.handleLineWidth,
          insetBlockStart: -e.handleLineWidth,
          width: e.handleSize + e.handleLineWidth * 2,
          height: e.handleSize + e.handleLineWidth * 2,
          backgroundColor: "transparent"
        },
        "&::after": {
          content: '""',
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: e.handleSize,
          height: e.handleSize,
          backgroundColor: e.colorBgElevated,
          boxShadow: `0 0 0 ${e.handleLineWidth}px ${e.colorPrimaryBorder}`,
          borderRadius: "50%",
          cursor: "pointer",
          transition: `
            inset-inline-start ${e.motionDurationMid},
            inset-block-start ${e.motionDurationMid},
            width ${e.motionDurationMid},
            height ${e.motionDurationMid},
            box-shadow ${e.motionDurationMid}
          `
        },
        "&:hover, &:active, &:focus": {
          "&::before": {
            insetInlineStart: -((e.handleSizeHover - e.handleSize) / 2 + e.handleLineWidthHover),
            insetBlockStart: -((e.handleSizeHover - e.handleSize) / 2 + e.handleLineWidthHover),
            width: e.handleSizeHover + e.handleLineWidthHover * 2,
            height: e.handleSizeHover + e.handleLineWidthHover * 2
          },
          "&::after": {
            boxShadow: `0 0 0 ${e.handleLineWidthHover}px ${e.colorPrimary}`,
            width: e.handleSizeHover,
            height: e.handleSizeHover,
            insetInlineStart: (e.handleSize - e.handleSizeHover) / 2,
            insetBlockStart: (e.handleSize - e.handleSizeHover) / 2
          }
        }
      },
      [`${t}-mark`]: {
        position: "absolute",
        fontSize: e.fontSize
      },
      [`${t}-mark-text`]: {
        position: "absolute",
        display: "inline-block",
        color: e.colorTextDescription,
        textAlign: "center",
        wordBreak: "keep-all",
        cursor: "pointer",
        userSelect: "none",
        "&-active": {
          color: e.colorText
        }
      },
      [`${t}-step`]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none"
      },
      [`${t}-dot`]: {
        position: "absolute",
        width: o,
        height: o,
        backgroundColor: e.colorBgElevated,
        border: `${e.handleLineWidth}px solid ${e.colorBorderSecondary}`,
        borderRadius: "50%",
        cursor: "pointer",
        transition: `border-color ${e.motionDurationSlow}`,
        "&-active": {
          borderColor: e.colorPrimaryBorder
        }
      },
      [`&${t}-disabled`]: {
        cursor: "not-allowed",
        [`${t}-rail`]: {
          backgroundColor: `${e.colorFillSecondary} !important`
        },
        [`${t}-track`]: {
          backgroundColor: `${e.colorTextDisabled} !important`
        },
        [`
          ${t}-dot
        `]: {
          backgroundColor: e.colorBgElevated,
          borderColor: e.colorTextDisabled,
          boxShadow: "none",
          cursor: "not-allowed"
        },
        [`${t}-handle::after`]: {
          backgroundColor: e.colorBgElevated,
          cursor: "not-allowed",
          width: e.handleSize,
          height: e.handleSize,
          boxShadow: `0 0 0 ${e.handleLineWidth}px ${new Ct(e.colorTextDisabled).onBackground(e.colorBgContainer).toHexString()}`,
          insetInlineStart: 0,
          insetBlockStart: 0
        },
        [`
          ${t}-mark-text,
          ${t}-dot
        `]: {
          cursor: "not-allowed !important"
        }
      }
    })
  };
}, u6 = (e, t) => {
  const {
    componentCls: n,
    railSize: o,
    handleSize: r,
    dotSize: l
  } = e, a = t ? "paddingBlock" : "paddingInline", i = t ? "width" : "height", s = t ? "height" : "width", c = t ? "insetBlockStart" : "insetInlineStart", u = t ? "top" : "insetInlineStart";
  return {
    [a]: o,
    [s]: o * 3,
    [`${n}-rail`]: {
      [i]: "100%",
      [s]: o
    },
    [`${n}-track`]: {
      [s]: o
    },
    [`${n}-handle`]: {
      [c]: (o * 3 - r) / 2
    },
    [`${n}-mark`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [u]: r,
      [i]: "100%"
    },
    [`${n}-step`]: {
      // Reset all
      insetInlineStart: 0,
      top: 0,
      [u]: o,
      [i]: "100%",
      [s]: o
    },
    [`${n}-dot`]: {
      position: "absolute",
      [c]: (o - l) / 2
    }
  };
}, MJ = (e) => {
  const {
    componentCls: t,
    marginPartWithMark: n
  } = e;
  return {
    [`${t}-horizontal`]: m(m({}, u6(e, !0)), {
      [`&${t}-with-marks`]: {
        marginBottom: n
      }
    })
  };
}, _J = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-vertical`]: m(m({}, u6(e, !1)), {
      height: "100%"
    })
  };
}, AJ = Xe("Slider", (e) => {
  const t = He(e, {
    marginPart: (e.controlHeight - e.controlSize) / 2,
    marginFull: e.controlSize / 2,
    marginPartWithMark: e.controlHeightLG - e.controlSize
  });
  return [TJ(t), MJ(t), _J(t)];
}, (e) => {
  const n = e.controlHeightLG / 4, o = e.controlHeightSM / 2, r = e.lineWidth + 1, l = e.lineWidth + 1 * 3;
  return {
    controlSize: n,
    railSize: 4,
    handleSize: n,
    handleSizeHover: o,
    dotSize: 8,
    handleLineWidth: r,
    handleLineWidthHover: l
  };
});
var ow = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const DJ = (e) => typeof e == "number" ? e.toString() : "", NJ = () => ({
  id: String,
  prefixCls: String,
  tooltipPrefixCls: String,
  range: je([Boolean, Object]),
  reverse: ve(),
  min: Number,
  max: Number,
  step: je([Object, Number]),
  marks: Re(),
  dots: ve(),
  value: je([Array, Number]),
  defaultValue: je([Array, Number]),
  included: ve(),
  disabled: ve(),
  vertical: ve(),
  tipFormatter: je([Function, Object], () => DJ),
  tooltipOpen: ve(),
  /** @deprecated `tooltipVisible` is deprecated. Please use `tooltipOpen` instead. */
  tooltipVisible: ve(),
  tooltipPlacement: ke(),
  getTooltipPopupContainer: le(),
  autofocus: ve(),
  handleStyle: je([Array, Object]),
  trackStyle: je([Array, Object]),
  onChange: le(),
  onAfterChange: le(),
  onFocus: le(),
  onBlur: le(),
  "onUpdate:value": le()
}), RJ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASlider",
  inheritAttrs: !1,
  props: NJ(),
  // emits: ['update:value', 'change', 'afterChange', 'blur'],
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r,
      expose: l
    } = t;
    process.env.NODE_ENV !== "production" && [["tooltipVisible", "tooltipOpen"]].forEach((x) => {
      let [I, E] = x;
      nt(e.tooltipVisible === void 0, "Slider", `\`${I}\` is deprecated, please use \`${E}\` instead.`);
    });
    const {
      prefixCls: a,
      rootPrefixCls: i,
      direction: s,
      getPopupContainer: c,
      configProvider: u
    } = Ie("slider", e), [d, p] = AJ(a), v = sn(), h = Y(), g = Y({}), b = (x, I) => {
      g.value[x] = I;
    }, y = P(() => e.tooltipPlacement ? e.tooltipPlacement : e.vertical ? s.value === "rtl" ? "left" : "right" : "top"), S = () => {
      var x;
      (x = h.value) === null || x === void 0 || x.focus();
    }, C = () => {
      var x;
      (x = h.value) === null || x === void 0 || x.blur();
    }, w = (x) => {
      r("update:value", x), r("change", x), v.onFieldChange();
    }, $ = (x) => {
      r("blur", x);
    };
    l({
      focus: S,
      blur: C
    });
    const O = (x) => {
      var {
        tooltipPrefixCls: I
      } = x, E = x.info, {
        value: _,
        dragging: M,
        index: R
      } = E, A = ow(E, ["value", "dragging", "index"]);
      const {
        tipFormatter: z,
        tooltipOpen: T = e.tooltipVisible,
        getTooltipPopupContainer: N
      } = e, k = z ? g.value[R] || M : !1, B = T || T === void 0 && k;
      return f(EJ, {
        prefixCls: I,
        title: z ? z(_) : "",
        open: B,
        placement: y.value,
        transitionName: `${i.value}-zoom-down`,
        key: R,
        overlayClassName: `${a.value}-tooltip`,
        getPopupContainer: N || (c == null ? void 0 : c.value)
      }, {
        default: () => [f(r6, D(D({}, A), {}, {
          value: _,
          onMouseenter: () => b(R, !0),
          onMouseleave: () => b(R, !1)
        }), null)]
      });
    };
    return () => {
      const {
        tooltipPrefixCls: x,
        range: I,
        id: E = v.id.value
      } = e, _ = ow(e, ["tooltipPrefixCls", "range", "id"]), M = u.getPrefixCls("tooltip", x), R = ee(n.class, {
        [`${a.value}-rtl`]: s.value === "rtl"
      }, p.value);
      s.value === "rtl" && !_.vertical && (_.reverse = !_.reverse);
      let A;
      return typeof I == "object" && (A = I.draggableTrack), d(I ? f(IJ, D(D(D({}, n), _), {}, {
        step: _.step,
        draggableTrack: A,
        class: R,
        ref: h,
        handle: (z) => O({
          tooltipPrefixCls: M,
          prefixCls: a.value,
          info: z
        }),
        prefixCls: a.value,
        onChange: w,
        onBlur: $
      }), {
        mark: o.mark
      }) : f(xJ, D(D(D({}, n), _), {}, {
        id: E,
        step: _.step,
        class: R,
        ref: h,
        handle: (z) => O({
          tooltipPrefixCls: M,
          prefixCls: a.value,
          info: z
        }),
        prefixCls: a.value,
        onChange: w,
        onBlur: $
      }), {
        mark: o.mark
      }));
    };
  }
}), kJ = kt(RJ);
function rw(e) {
  return typeof e == "string";
}
function BJ() {
}
const d6 = () => ({
  prefixCls: String,
  itemWidth: String,
  active: {
    type: Boolean,
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: void 0
  },
  status: ke(),
  iconPrefix: String,
  icon: V.any,
  adjustMarginRight: String,
  stepNumber: Number,
  stepIndex: Number,
  description: V.any,
  title: V.any,
  subTitle: V.any,
  progressDot: Z2(V.oneOfType([V.looseBool, V.func])),
  tailContent: V.any,
  icons: V.shape({
    finish: V.any,
    error: V.any
  }).loose,
  onClick: le(),
  onStepClick: le(),
  stepIcon: le(),
  itemRender: le(),
  __legacy: ve()
}), f6 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Step",
  inheritAttrs: !1,
  props: d6(),
  setup(e, t) {
    let {
      slots: n,
      emit: o,
      attrs: r
    } = t;
    const l = (i) => {
      o("click", i), o("stepClick", e.stepIndex);
    }, a = (i) => {
      let {
        icon: s,
        title: c,
        description: u
      } = i;
      const {
        prefixCls: d,
        stepNumber: p,
        status: v,
        iconPrefix: h,
        icons: g,
        progressDot: b = n.progressDot,
        stepIcon: y = n.stepIcon
      } = e;
      let S;
      const C = ee(`${d}-icon`, `${h}icon`, {
        [`${h}icon-${s}`]: s && rw(s),
        [`${h}icon-check`]: !s && v === "finish" && (g && !g.finish || !g),
        [`${h}icon-cross`]: !s && v === "error" && (g && !g.error || !g)
      }), w = f("span", {
        class: `${d}-icon-dot`
      }, null);
      return b ? typeof b == "function" ? S = f("span", {
        class: `${d}-icon`
      }, [b({
        iconDot: w,
        index: p - 1,
        status: v,
        title: c,
        description: u,
        prefixCls: d
      })]) : S = f("span", {
        class: `${d}-icon`
      }, [w]) : s && !rw(s) ? S = f("span", {
        class: `${d}-icon`
      }, [s]) : g && g.finish && v === "finish" ? S = f("span", {
        class: `${d}-icon`
      }, [g.finish]) : g && g.error && v === "error" ? S = f("span", {
        class: `${d}-icon`
      }, [g.error]) : s || v === "finish" || v === "error" ? S = f("span", {
        class: C
      }, null) : S = f("span", {
        class: `${d}-icon`
      }, [p]), y && (S = y({
        index: p - 1,
        status: v,
        title: c,
        description: u,
        node: S
      })), S;
    };
    return () => {
      var i, s, c, u;
      const {
        prefixCls: d,
        itemWidth: p,
        active: v,
        status: h = "wait",
        tailContent: g,
        adjustMarginRight: b,
        disabled: y,
        title: S = (i = n.title) === null || i === void 0 ? void 0 : i.call(n),
        description: C = (s = n.description) === null || s === void 0 ? void 0 : s.call(n),
        subTitle: w = (c = n.subTitle) === null || c === void 0 ? void 0 : c.call(n),
        icon: $ = (u = n.icon) === null || u === void 0 ? void 0 : u.call(n),
        onClick: O,
        onStepClick: x
      } = e, I = h || "wait", E = ee(`${d}-item`, `${d}-item-${I}`, {
        [`${d}-item-custom`]: $,
        [`${d}-item-active`]: v,
        [`${d}-item-disabled`]: y === !0
      }), _ = {};
      p && (_.width = p), b && (_.marginRight = b);
      const M = {
        onClick: O || BJ
      };
      x && !y && (M.role = "button", M.tabindex = 0, M.onClick = l);
      const R = f("div", D(D({}, ot(r, ["__legacy"])), {}, {
        class: [E, r.class],
        style: [r.style, _]
      }), [f("div", D(D({}, M), {}, {
        class: `${d}-item-container`
      }), [f("div", {
        class: `${d}-item-tail`
      }, [g]), f("div", {
        class: `${d}-item-icon`
      }, [a({
        icon: $,
        title: S,
        description: C
      })]), f("div", {
        class: `${d}-item-content`
      }, [f("div", {
        class: `${d}-item-title`
      }, [S, w && f("div", {
        title: typeof w == "string" ? w : void 0,
        class: `${d}-item-subtitle`
      }, [w])]), C && f("div", {
        class: `${d}-item-description`
      }, [C])])])]);
      return e.itemRender ? e.itemRender(R) : R;
    };
  }
});
var FJ = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const LJ = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Steps",
  props: {
    type: V.string.def("default"),
    prefixCls: V.string.def("vc-steps"),
    iconPrefix: V.string.def("vc"),
    direction: V.string.def("horizontal"),
    labelPlacement: V.string.def("horizontal"),
    status: ke("process"),
    size: V.string.def(""),
    progressDot: V.oneOfType([V.looseBool, V.func]).def(void 0),
    initial: V.number.def(0),
    current: V.number.def(0),
    items: V.array.def(() => []),
    icons: V.shape({
      finish: V.any,
      error: V.any
    }).loose,
    stepIcon: le(),
    isInline: V.looseBool,
    itemRender: le()
  },
  emits: ["change"],
  setup(e, t) {
    let {
      slots: n,
      emit: o
    } = t;
    const r = (i) => {
      const {
        current: s
      } = e;
      s !== i && o("change", i);
    }, l = (i, s, c) => {
      const {
        prefixCls: u,
        iconPrefix: d,
        status: p,
        current: v,
        initial: h,
        icons: g,
        stepIcon: b = n.stepIcon,
        isInline: y,
        itemRender: S,
        progressDot: C = n.progressDot
      } = e, w = y || C, $ = m(m({}, i), {
        class: ""
      }), O = h + s, x = {
        active: O === v,
        stepNumber: O + 1,
        stepIndex: O,
        key: O,
        prefixCls: u,
        iconPrefix: d,
        progressDot: w,
        stepIcon: b,
        icons: g,
        onStepClick: r
      };
      return p === "error" && s === v - 1 && ($.class = `${u}-next-error`), $.status || (O === v ? $.status = p : O < v ? $.status = "finish" : $.status = "wait"), y && ($.icon = void 0, $.subTitle = void 0), c ? c(m(m({}, $), x)) : (S && ($.itemRender = (I) => S($, I)), f(f6, D(D(D({}, $), x), {}, {
        __legacy: !1
      }), null));
    }, a = (i, s) => l(m({}, i.props), s, (c) => yt(i, c));
    return () => {
      var i;
      const {
        prefixCls: s,
        direction: c,
        type: u,
        labelPlacement: d,
        iconPrefix: p,
        status: v,
        size: h,
        current: g,
        progressDot: b = n.progressDot,
        initial: y,
        icons: S,
        items: C,
        isInline: w,
        itemRender: $
      } = e, O = FJ(e, ["prefixCls", "direction", "type", "labelPlacement", "iconPrefix", "status", "size", "current", "progressDot", "initial", "icons", "items", "isInline", "itemRender"]), x = u === "navigation", I = w || b, E = w ? "horizontal" : c, _ = w ? void 0 : h, M = I ? "vertical" : d, R = ee(s, `${s}-${c}`, {
        [`${s}-${_}`]: _,
        [`${s}-label-${M}`]: E === "horizontal",
        [`${s}-dot`]: !!I,
        [`${s}-navigation`]: x,
        [`${s}-inline`]: w
      });
      return f("div", D({
        class: R
      }, O), [C.filter((A) => A).map((A, z) => l(A, z)), Lt((i = n.default) === null || i === void 0 ? void 0 : i.call(n)).map(a)]);
    };
  }
}), zJ = (e) => {
  const {
    componentCls: t,
    stepsIconCustomTop: n,
    stepsIconCustomSize: o,
    stepsIconCustomFontSize: r
  } = e;
  return {
    [`${t}-item-custom`]: {
      [`> ${t}-item-container > ${t}-item-icon`]: {
        height: "auto",
        background: "none",
        border: 0,
        [`> ${t}-icon`]: {
          top: n,
          width: o,
          height: o,
          fontSize: r,
          lineHeight: `${o}px`
        }
      }
    },
    // Only adjust horizontal customize icon width
    [`&:not(${t}-vertical)`]: {
      [`${t}-item-custom`]: {
        [`${t}-item-icon`]: {
          width: "auto",
          background: "none"
        }
      }
    }
  };
}, HJ = (e) => {
  const {
    componentCls: t,
    stepsIconSize: n,
    lineHeight: o,
    stepsSmallIconSize: r
  } = e;
  return {
    [`&${t}-label-vertical`]: {
      [`${t}-item`]: {
        overflow: "visible",
        "&-tail": {
          marginInlineStart: n / 2 + e.controlHeightLG,
          padding: `${e.paddingXXS}px ${e.paddingLG}px`
        },
        "&-content": {
          display: "block",
          width: (n / 2 + e.controlHeightLG) * 2,
          marginTop: e.marginSM,
          textAlign: "center"
        },
        "&-icon": {
          display: "inline-block",
          marginInlineStart: e.controlHeightLG
        },
        "&-title": {
          paddingInlineEnd: 0,
          paddingInlineStart: 0,
          "&::after": {
            display: "none"
          }
        },
        "&-subtitle": {
          display: "block",
          marginBottom: e.marginXXS,
          marginInlineStart: 0,
          lineHeight: o
        }
      },
      [`&${t}-small:not(${t}-dot)`]: {
        [`${t}-item`]: {
          "&-icon": {
            marginInlineStart: e.controlHeightLG + (n - r) / 2
          }
        }
      }
    }
  };
}, jJ = (e) => {
  const {
    componentCls: t,
    stepsNavContentMaxWidth: n,
    stepsNavArrowColor: o,
    stepsNavActiveColor: r,
    motionDurationSlow: l
  } = e;
  return {
    [`&${t}-navigation`]: {
      paddingTop: e.paddingSM,
      [`&${t}-small`]: {
        [`${t}-item`]: {
          "&-container": {
            marginInlineStart: -e.marginSM
          }
        }
      },
      [`${t}-item`]: {
        overflow: "visible",
        textAlign: "center",
        "&-container": {
          display: "inline-block",
          height: "100%",
          marginInlineStart: -e.margin,
          paddingBottom: e.paddingSM,
          textAlign: "start",
          transition: `opacity ${l}`,
          [`${t}-item-content`]: {
            maxWidth: n
          },
          [`${t}-item-title`]: m(m({
            maxWidth: "100%",
            paddingInlineEnd: 0
          }, tn), {
            "&::after": {
              display: "none"
            }
          })
        },
        [`&:not(${t}-item-active)`]: {
          [`${t}-item-container[role='button']`]: {
            cursor: "pointer",
            "&:hover": {
              opacity: 0.85
            }
          }
        },
        "&:last-child": {
          flex: 1,
          "&::after": {
            display: "none"
          }
        },
        "&::after": {
          position: "absolute",
          top: `calc(50% - ${e.paddingSM / 2}px)`,
          insetInlineStart: "100%",
          display: "inline-block",
          width: e.fontSizeIcon,
          height: e.fontSizeIcon,
          borderTop: `${e.lineWidth}px ${e.lineType} ${o}`,
          borderBottom: "none",
          borderInlineStart: "none",
          borderInlineEnd: `${e.lineWidth}px ${e.lineType} ${o}`,
          transform: "translateY(-50%) translateX(-50%) rotate(45deg)",
          content: '""'
        },
        "&::before": {
          position: "absolute",
          bottom: 0,
          insetInlineStart: "50%",
          display: "inline-block",
          width: 0,
          height: e.lineWidthBold,
          backgroundColor: r,
          transition: `width ${l}, inset-inline-start ${l}`,
          transitionTimingFunction: "ease-out",
          content: '""'
        }
      },
      [`${t}-item${t}-item-active::before`]: {
        insetInlineStart: 0,
        width: "100%"
      }
    },
    [`&${t}-navigation${t}-vertical`]: {
      [`> ${t}-item`]: {
        marginInlineEnd: 0,
        "&::before": {
          display: "none"
        },
        [`&${t}-item-active::before`]: {
          top: 0,
          insetInlineEnd: 0,
          insetInlineStart: "unset",
          display: "block",
          width: e.lineWidth * 3,
          height: `calc(100% - ${e.marginLG}px)`
        },
        "&::after": {
          position: "relative",
          insetInlineStart: "50%",
          display: "block",
          width: e.controlHeight * 0.25,
          height: e.controlHeight * 0.25,
          marginBottom: e.marginXS,
          textAlign: "center",
          transform: "translateY(-50%) translateX(-50%) rotate(135deg)"
        },
        [`> ${t}-item-container > ${t}-item-tail`]: {
          visibility: "hidden"
        }
      }
    },
    [`&${t}-navigation${t}-horizontal`]: {
      [`> ${t}-item > ${t}-item-container > ${t}-item-tail`]: {
        visibility: "hidden"
      }
    }
  };
}, VJ = (e) => {
  const {
    antCls: t,
    componentCls: n
  } = e;
  return {
    [`&${n}-with-progress`]: {
      [`${n}-item`]: {
        paddingTop: e.paddingXXS,
        [`&-process ${n}-item-container ${n}-item-icon ${n}-icon`]: {
          color: e.processIconColor
        }
      },
      [`&${n}-vertical > ${n}-item `]: {
        paddingInlineStart: e.paddingXXS,
        [`> ${n}-item-container > ${n}-item-tail`]: {
          top: e.marginXXS,
          insetInlineStart: e.stepsIconSize / 2 - e.lineWidth + e.paddingXXS
        }
      },
      [`&, &${n}-small`]: {
        [`&${n}-horizontal ${n}-item:first-child`]: {
          paddingBottom: e.paddingXXS,
          paddingInlineStart: e.paddingXXS
        }
      },
      [`&${n}-small${n}-vertical > ${n}-item > ${n}-item-container > ${n}-item-tail`]: {
        insetInlineStart: e.stepsSmallIconSize / 2 - e.lineWidth + e.paddingXXS
      },
      [`&${n}-label-vertical`]: {
        [`${n}-item ${n}-item-tail`]: {
          top: e.margin - 2 * e.lineWidth
        }
      },
      [`${n}-item-icon`]: {
        position: "relative",
        [`${t}-progress`]: {
          position: "absolute",
          insetBlockStart: (e.stepsIconSize - e.stepsProgressSize - e.lineWidth * 2) / 2,
          insetInlineStart: (e.stepsIconSize - e.stepsProgressSize - e.lineWidth * 2) / 2
        }
      }
    }
  };
}, WJ = (e) => {
  const {
    componentCls: t,
    descriptionWidth: n,
    lineHeight: o,
    stepsCurrentDotSize: r,
    stepsDotSize: l,
    motionDurationSlow: a
  } = e;
  return {
    [`&${t}-dot, &${t}-dot${t}-small`]: {
      [`${t}-item`]: {
        "&-title": {
          lineHeight: o
        },
        "&-tail": {
          top: Math.floor((e.stepsDotSize - e.lineWidth * 3) / 2),
          width: "100%",
          marginTop: 0,
          marginBottom: 0,
          marginInline: `${n / 2}px 0`,
          padding: 0,
          "&::after": {
            width: `calc(100% - ${e.marginSM * 2}px)`,
            height: e.lineWidth * 3,
            marginInlineStart: e.marginSM
          }
        },
        "&-icon": {
          width: l,
          height: l,
          marginInlineStart: (e.descriptionWidth - l) / 2,
          paddingInlineEnd: 0,
          lineHeight: `${l}px`,
          background: "transparent",
          border: 0,
          [`${t}-icon-dot`]: {
            position: "relative",
            float: "left",
            width: "100%",
            height: "100%",
            borderRadius: 100,
            transition: `all ${a}`,
            /* expand hover area */
            "&::after": {
              position: "absolute",
              top: -e.marginSM,
              insetInlineStart: (l - e.controlHeightLG * 1.5) / 2,
              width: e.controlHeightLG * 1.5,
              height: e.controlHeight,
              background: "transparent",
              content: '""'
            }
          }
        },
        "&-content": {
          width: n
        },
        [`&-process ${t}-item-icon`]: {
          position: "relative",
          top: (l - r) / 2,
          width: r,
          height: r,
          lineHeight: `${r}px`,
          background: "none",
          marginInlineStart: (e.descriptionWidth - r) / 2
        },
        [`&-process ${t}-icon`]: {
          [`&:first-child ${t}-icon-dot`]: {
            insetInlineStart: 0
          }
        }
      }
    },
    [`&${t}-vertical${t}-dot`]: {
      [`${t}-item-icon`]: {
        marginTop: (e.controlHeight - l) / 2,
        marginInlineStart: 0,
        background: "none"
      },
      [`${t}-item-process ${t}-item-icon`]: {
        marginTop: (e.controlHeight - r) / 2,
        top: 0,
        insetInlineStart: (l - r) / 2,
        marginInlineStart: 0
      },
      // https://github.com/ant-design/ant-design/issues/18354
      [`${t}-item > ${t}-item-container > ${t}-item-tail`]: {
        top: (e.controlHeight - l) / 2,
        insetInlineStart: 0,
        margin: 0,
        padding: `${l + e.paddingXS}px 0 ${e.paddingXS}px`,
        "&::after": {
          marginInlineStart: (l - e.lineWidth) / 2
        }
      },
      [`&${t}-small`]: {
        [`${t}-item-icon`]: {
          marginTop: (e.controlHeightSM - l) / 2
        },
        [`${t}-item-process ${t}-item-icon`]: {
          marginTop: (e.controlHeightSM - r) / 2
        },
        [`${t}-item > ${t}-item-container > ${t}-item-tail`]: {
          top: (e.controlHeightSM - l) / 2
        }
      },
      [`${t}-item:first-child ${t}-icon-dot`]: {
        insetInlineStart: 0
      },
      [`${t}-item-content`]: {
        width: "inherit"
      }
    }
  };
}, KJ = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`&${t}-rtl`]: {
      direction: "rtl",
      [`${t}-item`]: {
        "&-subtitle": {
          float: "left"
        }
      },
      // nav
      [`&${t}-navigation`]: {
        [`${t}-item::after`]: {
          transform: "rotate(-45deg)"
        }
      },
      // vertical
      [`&${t}-vertical`]: {
        [`> ${t}-item`]: {
          "&::after": {
            transform: "rotate(225deg)"
          },
          [`${t}-item-icon`]: {
            float: "right"
          }
        }
      },
      // progress-dot
      [`&${t}-dot`]: {
        [`${t}-item-icon ${t}-icon-dot, &${t}-small ${t}-item-icon ${t}-icon-dot`]: {
          float: "right"
        }
      }
    }
  };
}, GJ = (e) => {
  const {
    componentCls: t,
    stepsSmallIconSize: n,
    // stepsSmallIconMargin,
    fontSizeSM: o,
    fontSize: r,
    colorTextDescription: l
  } = e;
  return {
    [`&${t}-small`]: {
      [`&${t}-horizontal:not(${t}-label-vertical) ${t}-item`]: {
        paddingInlineStart: e.paddingSM,
        "&:first-child": {
          paddingInlineStart: 0
        }
      },
      [`${t}-item-icon`]: {
        width: n,
        height: n,
        // margin: stepsSmallIconMargin,
        marginTop: 0,
        marginBottom: 0,
        marginInline: `0 ${e.marginXS}px`,
        fontSize: o,
        lineHeight: `${n}px`,
        textAlign: "center",
        borderRadius: n
      },
      [`${t}-item-title`]: {
        paddingInlineEnd: e.paddingSM,
        fontSize: r,
        lineHeight: `${n}px`,
        "&::after": {
          top: n / 2
        }
      },
      [`${t}-item-description`]: {
        color: l,
        fontSize: r
      },
      [`${t}-item-tail`]: {
        top: n / 2 - e.paddingXXS
      },
      [`${t}-item-custom ${t}-item-icon`]: {
        width: "inherit",
        height: "inherit",
        lineHeight: "inherit",
        background: "none",
        border: 0,
        borderRadius: 0,
        [`> ${t}-icon`]: {
          fontSize: n,
          lineHeight: `${n}px`,
          transform: "none"
        }
      }
    }
  };
}, XJ = (e) => {
  const {
    componentCls: t,
    stepsSmallIconSize: n,
    stepsIconSize: o
  } = e;
  return {
    [`&${t}-vertical`]: {
      display: "flex",
      flexDirection: "column",
      [`> ${t}-item`]: {
        display: "block",
        flex: "1 0 auto",
        paddingInlineStart: 0,
        overflow: "visible",
        [`${t}-item-icon`]: {
          float: "left",
          marginInlineEnd: e.margin
        },
        [`${t}-item-content`]: {
          display: "block",
          minHeight: e.controlHeight * 1.5,
          overflow: "hidden"
        },
        [`${t}-item-title`]: {
          lineHeight: `${o}px`
        },
        [`${t}-item-description`]: {
          paddingBottom: e.paddingSM
        }
      },
      [`> ${t}-item > ${t}-item-container > ${t}-item-tail`]: {
        position: "absolute",
        top: 0,
        insetInlineStart: e.stepsIconSize / 2 - e.lineWidth,
        width: e.lineWidth,
        height: "100%",
        padding: `${o + e.marginXXS * 1.5}px 0 ${e.marginXXS * 1.5}px`,
        "&::after": {
          width: e.lineWidth,
          height: "100%"
        }
      },
      [`> ${t}-item:not(:last-child) > ${t}-item-container > ${t}-item-tail`]: {
        display: "block"
      },
      [` > ${t}-item > ${t}-item-container > ${t}-item-content > ${t}-item-title`]: {
        "&::after": {
          display: "none"
        }
      },
      [`&${t}-small ${t}-item-container`]: {
        [`${t}-item-tail`]: {
          position: "absolute",
          top: 0,
          insetInlineStart: e.stepsSmallIconSize / 2 - e.lineWidth,
          padding: `${n + e.marginXXS * 1.5}px 0 ${e.marginXXS * 1.5}px`
        },
        [`${t}-item-title`]: {
          lineHeight: `${n}px`
        }
      }
    }
  };
}, UJ = (e) => {
  const {
    componentCls: t,
    inlineDotSize: n,
    inlineTitleColor: o,
    inlineTailColor: r
  } = e, l = e.paddingXS + e.lineWidth, a = {
    [`${t}-item-container ${t}-item-content ${t}-item-title`]: {
      color: o
    }
  };
  return {
    [`&${t}-inline`]: {
      width: "auto",
      display: "inline-flex",
      [`${t}-item`]: {
        flex: "none",
        "&-container": {
          padding: `${l}px ${e.paddingXXS}px 0`,
          margin: `0 ${e.marginXXS / 2}px`,
          borderRadius: e.borderRadiusSM,
          cursor: "pointer",
          transition: `background-color ${e.motionDurationMid}`,
          "&:hover": {
            background: e.controlItemBgHover
          },
          "&[role='button']:hover": {
            opacity: 1
          }
        },
        "&-icon": {
          width: n,
          height: n,
          marginInlineStart: `calc(50% - ${n / 2}px)`,
          [`> ${t}-icon`]: {
            top: 0
          },
          [`${t}-icon-dot`]: {
            borderRadius: e.fontSizeSM / 4
          }
        },
        "&-content": {
          width: "auto",
          marginTop: e.marginXS - e.lineWidth
        },
        "&-title": {
          color: o,
          fontSize: e.fontSizeSM,
          lineHeight: e.lineHeightSM,
          fontWeight: "normal",
          marginBottom: e.marginXXS / 2
        },
        "&-description": {
          display: "none"
        },
        "&-tail": {
          marginInlineStart: 0,
          top: l + n / 2,
          transform: "translateY(-50%)",
          "&:after": {
            width: "100%",
            height: e.lineWidth,
            borderRadius: 0,
            marginInlineStart: 0,
            background: r
          }
        },
        [`&:first-child ${t}-item-tail`]: {
          width: "50%",
          marginInlineStart: "50%"
        },
        [`&:last-child ${t}-item-tail`]: {
          display: "block",
          width: "50%"
        },
        "&-wait": m({
          [`${t}-item-icon ${t}-icon ${t}-icon-dot`]: {
            backgroundColor: e.colorBorderBg,
            border: `${e.lineWidth}px ${e.lineType} ${r}`
          }
        }, a),
        "&-finish": m({
          [`${t}-item-tail::after`]: {
            backgroundColor: r
          },
          [`${t}-item-icon ${t}-icon ${t}-icon-dot`]: {
            backgroundColor: r,
            border: `${e.lineWidth}px ${e.lineType} ${r}`
          }
        }, a),
        "&-error": a,
        "&-active, &-process": m({
          [`${t}-item-icon`]: {
            width: n,
            height: n,
            marginInlineStart: `calc(50% - ${n / 2}px)`,
            top: 0
          }
        }, a),
        [`&:not(${t}-item-active) > ${t}-item-container[role='button']:hover`]: {
          [`${t}-item-title`]: {
            color: o
          }
        }
      }
    }
  };
};
var Za;
(function(e) {
  e.wait = "wait", e.process = "process", e.finish = "finish", e.error = "error";
})(Za || (Za = {}));
const nu = (e, t) => {
  const n = `${t.componentCls}-item`, o = `${e}IconColor`, r = `${e}TitleColor`, l = `${e}DescriptionColor`, a = `${e}TailColor`, i = `${e}IconBgColor`, s = `${e}IconBorderColor`, c = `${e}DotColor`;
  return {
    [`${n}-${e} ${n}-icon`]: {
      backgroundColor: t[i],
      borderColor: t[s],
      [`> ${t.componentCls}-icon`]: {
        color: t[o],
        [`${t.componentCls}-icon-dot`]: {
          background: t[c]
        }
      }
    },
    [`${n}-${e}${n}-custom ${n}-icon`]: {
      [`> ${t.componentCls}-icon`]: {
        color: t[c]
      }
    },
    [`${n}-${e} > ${n}-container > ${n}-content > ${n}-title`]: {
      color: t[r],
      "&::after": {
        backgroundColor: t[a]
      }
    },
    [`${n}-${e} > ${n}-container > ${n}-content > ${n}-description`]: {
      color: t[l]
    },
    [`${n}-${e} > ${n}-container > ${n}-tail::after`]: {
      backgroundColor: t[a]
    }
  };
}, YJ = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e, o = `${t}-item`;
  return m(m(m(m(m(m({
    [o]: {
      position: "relative",
      display: "inline-block",
      flex: 1,
      overflow: "hidden",
      verticalAlign: "top",
      "&:last-child": {
        flex: "none",
        [`> ${o}-container > ${o}-tail, > ${o}-container >  ${o}-content > ${o}-title::after`]: {
          display: "none"
        }
      }
    },
    [`${o}-container`]: {
      outline: "none"
    },
    [`${o}-icon, ${o}-content`]: {
      display: "inline-block",
      verticalAlign: "top"
    },
    [`${o}-icon`]: {
      width: e.stepsIconSize,
      height: e.stepsIconSize,
      marginTop: 0,
      marginBottom: 0,
      marginInlineStart: 0,
      marginInlineEnd: e.marginXS,
      fontSize: e.stepsIconFontSize,
      fontFamily: e.fontFamily,
      lineHeight: `${e.stepsIconSize}px`,
      textAlign: "center",
      borderRadius: e.stepsIconSize,
      border: `${e.lineWidth}px ${e.lineType} transparent`,
      transition: `background-color ${n}, border-color ${n}`,
      [`${t}-icon`]: {
        position: "relative",
        top: e.stepsIconTop,
        color: e.colorPrimary,
        lineHeight: 1
      }
    },
    [`${o}-tail`]: {
      position: "absolute",
      top: e.stepsIconSize / 2 - e.paddingXXS,
      insetInlineStart: 0,
      width: "100%",
      "&::after": {
        display: "inline-block",
        width: "100%",
        height: e.lineWidth,
        background: e.colorSplit,
        borderRadius: e.lineWidth,
        transition: `background ${n}`,
        content: '""'
      }
    },
    [`${o}-title`]: {
      position: "relative",
      display: "inline-block",
      paddingInlineEnd: e.padding,
      color: e.colorText,
      fontSize: e.fontSizeLG,
      lineHeight: `${e.stepsTitleLineHeight}px`,
      "&::after": {
        position: "absolute",
        top: e.stepsTitleLineHeight / 2,
        insetInlineStart: "100%",
        display: "block",
        width: 9999,
        height: e.lineWidth,
        background: e.processTailColor,
        content: '""'
      }
    },
    [`${o}-subtitle`]: {
      display: "inline",
      marginInlineStart: e.marginXS,
      color: e.colorTextDescription,
      fontWeight: "normal",
      fontSize: e.fontSize
    },
    [`${o}-description`]: {
      color: e.colorTextDescription,
      fontSize: e.fontSize
    }
  }, nu(Za.wait, e)), nu(Za.process, e)), {
    [`${o}-process > ${o}-container > ${o}-title`]: {
      fontWeight: e.fontWeightStrong
    }
  }), nu(Za.finish, e)), nu(Za.error, e)), {
    [`${o}${t}-next-error > ${t}-item-title::after`]: {
      background: e.colorError
    },
    [`${o}-disabled`]: {
      cursor: "not-allowed"
    }
  });
}, qJ = (e) => {
  const {
    componentCls: t,
    motionDurationSlow: n
  } = e;
  return {
    [`& ${t}-item`]: {
      [`&:not(${t}-item-active)`]: {
        [`& > ${t}-item-container[role='button']`]: {
          cursor: "pointer",
          [`${t}-item`]: {
            [`&-title, &-subtitle, &-description, &-icon ${t}-icon`]: {
              transition: `color ${n}`
            }
          },
          "&:hover": {
            [`${t}-item`]: {
              "&-title, &-subtitle, &-description": {
                color: e.colorPrimary
              }
            }
          }
        },
        [`&:not(${t}-item-process)`]: {
          [`& > ${t}-item-container[role='button']:hover`]: {
            [`${t}-item`]: {
              "&-icon": {
                borderColor: e.colorPrimary,
                [`${t}-icon`]: {
                  color: e.colorPrimary
                }
              }
            }
          }
        }
      }
    },
    [`&${t}-horizontal:not(${t}-label-vertical)`]: {
      [`${t}-item`]: {
        paddingInlineStart: e.padding,
        whiteSpace: "nowrap",
        "&:first-child": {
          paddingInlineStart: 0
        },
        [`&:last-child ${t}-item-title`]: {
          paddingInlineEnd: 0
        },
        "&-tail": {
          display: "none"
        },
        "&-description": {
          maxWidth: e.descriptionWidth,
          whiteSpace: "normal"
        }
      }
    }
  };
}, ZJ = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: m(m(m(m(m(m(m(m(m(m(m(m(m({}, qe(e)), {
      display: "flex",
      width: "100%",
      fontSize: 0,
      textAlign: "initial"
    }), YJ(e)), qJ(e)), zJ(e)), GJ(e)), XJ(e)), HJ(e)), WJ(e)), jJ(e)), KJ(e)), VJ(e)), UJ(e))
  };
}, QJ = Xe("Steps", (e) => {
  const {
    wireframe: t,
    colorTextDisabled: n,
    fontSizeHeading3: o,
    fontSize: r,
    controlHeight: l,
    controlHeightLG: a,
    colorTextLightSolid: i,
    colorText: s,
    colorPrimary: c,
    colorTextLabel: u,
    colorTextDescription: d,
    colorTextQuaternary: p,
    colorFillContent: v,
    controlItemBgActive: h,
    colorError: g,
    colorBgContainer: b,
    colorBorderSecondary: y
  } = e, S = e.controlHeight, C = e.colorSplit, w = He(e, {
    // Steps variable default.less
    processTailColor: C,
    stepsNavArrowColor: n,
    stepsIconSize: S,
    stepsIconCustomSize: S,
    stepsIconCustomTop: 0,
    stepsIconCustomFontSize: a / 2,
    stepsIconTop: -0.5,
    stepsIconFontSize: r,
    stepsTitleLineHeight: l,
    stepsSmallIconSize: o,
    stepsDotSize: l / 4,
    stepsCurrentDotSize: a / 4,
    stepsNavContentMaxWidth: "auto",
    // Steps component less variable
    processIconColor: i,
    processTitleColor: s,
    processDescriptionColor: s,
    processIconBgColor: c,
    processIconBorderColor: c,
    processDotColor: c,
    waitIconColor: t ? n : u,
    waitTitleColor: d,
    waitDescriptionColor: d,
    waitTailColor: C,
    waitIconBgColor: t ? b : v,
    waitIconBorderColor: t ? n : "transparent",
    waitDotColor: n,
    finishIconColor: c,
    finishTitleColor: s,
    finishDescriptionColor: d,
    finishTailColor: c,
    finishIconBgColor: t ? b : h,
    finishIconBorderColor: t ? c : h,
    finishDotColor: c,
    errorIconColor: i,
    errorTitleColor: g,
    errorDescriptionColor: g,
    errorTailColor: C,
    errorIconBgColor: g,
    errorIconBorderColor: g,
    errorDotColor: g,
    stepsNavActiveColor: c,
    stepsProgressSize: a,
    // Steps inline variable
    inlineDotSize: 6,
    inlineTitleColor: p,
    inlineTailColor: y
  });
  return [ZJ(w)];
}, {
  descriptionWidth: 140
}), JJ = () => ({
  prefixCls: String,
  iconPrefix: String,
  current: Number,
  initial: Number,
  percent: Number,
  responsive: ve(),
  items: vt(),
  labelPlacement: ke(),
  status: ke(),
  size: ke(),
  direction: ke(),
  progressDot: je([Boolean, Function]),
  type: ke(),
  onChange: le(),
  "onUpdate:current": le()
}), jv = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASteps",
  inheritAttrs: !1,
  props: Qe(JJ(), {
    current: 0,
    responsive: !0,
    labelPlacement: "horizontal"
  }),
  slots: Object,
  // emits: ['update:current', 'change'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r
    } = t;
    const {
      prefixCls: l,
      direction: a,
      configProvider: i
    } = Ie("steps", e), [s, c] = QJ(l), [, u] = qr(), d = ki(), p = P(() => e.responsive && d.value.xs ? "vertical" : e.direction), v = P(() => i.getPrefixCls("", e.iconPrefix)), h = (C) => {
      r("update:current", C), r("change", C);
    }, g = P(() => e.type === "inline"), b = P(() => g.value ? void 0 : e.percent), y = (C) => {
      let {
        node: w,
        status: $
      } = C;
      if ($ === "process" && e.percent !== void 0) {
        const O = e.size === "small" ? u.value.controlHeight : u.value.controlHeightLG;
        return f("div", {
          class: `${l.value}-progress-icon`
        }, [f(Nb, {
          type: "circle",
          percent: b.value,
          size: O,
          strokeWidth: 4,
          format: () => null
        }, null), w]);
      }
      return w;
    }, S = P(() => ({
      finish: f(Mi, {
        class: `${l.value}-finish-icon`
      }, null),
      error: f(Kn, {
        class: `${l.value}-error-icon`
      }, null)
    }));
    return () => {
      const C = ee({
        [`${l.value}-rtl`]: a.value === "rtl",
        [`${l.value}-with-progress`]: b.value !== void 0
      }, n.class, c.value), w = ($, O) => $.description ? f(Ln, {
        title: $.description
      }, {
        default: () => [O]
      }) : O;
      return s(f(LJ, D(D(D({
        icons: S.value
      }, n), ot(e, ["percent", "responsive"])), {}, {
        items: e.items,
        direction: p.value,
        prefixCls: l.value,
        iconPrefix: v.value,
        class: C,
        onChange: h,
        isInline: g.value,
        itemRender: g.value ? w : void 0
      }), m({
        stepIcon: y
      }, o)));
    };
  }
}), zu = Z(m(m({
  compatConfig: {
    MODE: 3
  }
}, f6), {
  name: "AStep",
  props: d6()
})), eee = m(jv, {
  Step: zu,
  install: (e) => (e.component(jv.name, jv), e.component(zu.name, zu), e)
}), tee = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-inner`;
  return {
    [t]: {
      [`&${t}-small`]: {
        minWidth: e.switchMinWidthSM,
        height: e.switchHeightSM,
        lineHeight: `${e.switchHeightSM}px`,
        [`${t}-inner`]: {
          paddingInlineStart: e.switchInnerMarginMaxSM,
          paddingInlineEnd: e.switchInnerMarginMinSM,
          [`${n}-checked`]: {
            marginInlineStart: `calc(-100% + ${e.switchPinSizeSM + e.switchPadding * 2}px - ${e.switchInnerMarginMaxSM * 2}px)`,
            marginInlineEnd: `calc(100% - ${e.switchPinSizeSM + e.switchPadding * 2}px + ${e.switchInnerMarginMaxSM * 2}px)`
          },
          [`${n}-unchecked`]: {
            marginTop: -e.switchHeightSM,
            marginInlineStart: 0,
            marginInlineEnd: 0
          }
        },
        [`${t}-handle`]: {
          width: e.switchPinSizeSM,
          height: e.switchPinSizeSM
        },
        [`${t}-loading-icon`]: {
          top: (e.switchPinSizeSM - e.switchLoadingIconSize) / 2,
          fontSize: e.switchLoadingIconSize
        },
        [`&${t}-checked`]: {
          [`${t}-inner`]: {
            paddingInlineStart: e.switchInnerMarginMinSM,
            paddingInlineEnd: e.switchInnerMarginMaxSM,
            [`${n}-checked`]: {
              marginInlineStart: 0,
              marginInlineEnd: 0
            },
            [`${n}-unchecked`]: {
              marginInlineStart: `calc(100% - ${e.switchPinSizeSM + e.switchPadding * 2}px + ${e.switchInnerMarginMaxSM * 2}px)`,
              marginInlineEnd: `calc(-100% + ${e.switchPinSizeSM + e.switchPadding * 2}px - ${e.switchInnerMarginMaxSM * 2}px)`
            }
          },
          [`${t}-handle`]: {
            insetInlineStart: `calc(100% - ${e.switchPinSizeSM + e.switchPadding}px)`
          }
        },
        [`&:not(${t}-disabled):active`]: {
          [`&:not(${t}-checked) ${n}`]: {
            [`${n}-unchecked`]: {
              marginInlineStart: e.marginXXS / 2,
              marginInlineEnd: -e.marginXXS / 2
            }
          },
          [`&${t}-checked ${n}`]: {
            [`${n}-checked`]: {
              marginInlineStart: -e.marginXXS / 2,
              marginInlineEnd: e.marginXXS / 2
            }
          }
        }
      }
    }
  };
}, nee = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      [`${t}-loading-icon${e.iconCls}`]: {
        position: "relative",
        top: (e.switchPinSize - e.fontSize) / 2,
        color: e.switchLoadingIconColor,
        verticalAlign: "top"
      },
      [`&${t}-checked ${t}-loading-icon`]: {
        color: e.switchColor
      }
    }
  };
}, oee = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-handle`;
  return {
    [t]: {
      [n]: {
        position: "absolute",
        top: e.switchPadding,
        insetInlineStart: e.switchPadding,
        width: e.switchPinSize,
        height: e.switchPinSize,
        transition: `all ${e.switchDuration} ease-in-out`,
        "&::before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: 0,
          insetInlineStart: 0,
          backgroundColor: e.colorWhite,
          borderRadius: e.switchPinSize / 2,
          boxShadow: e.switchHandleShadow,
          transition: `all ${e.switchDuration} ease-in-out`,
          content: '""'
        }
      },
      [`&${t}-checked ${n}`]: {
        insetInlineStart: `calc(100% - ${e.switchPinSize + e.switchPadding}px)`
      },
      [`&:not(${t}-disabled):active`]: {
        [`${n}::before`]: {
          insetInlineEnd: e.switchHandleActiveInset,
          insetInlineStart: 0
        },
        [`&${t}-checked ${n}::before`]: {
          insetInlineEnd: 0,
          insetInlineStart: e.switchHandleActiveInset
        }
      }
    }
  };
}, ree = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-inner`;
  return {
    [t]: {
      [n]: {
        display: "block",
        overflow: "hidden",
        borderRadius: 100,
        height: "100%",
        paddingInlineStart: e.switchInnerMarginMax,
        paddingInlineEnd: e.switchInnerMarginMin,
        transition: `padding-inline-start ${e.switchDuration} ease-in-out, padding-inline-end ${e.switchDuration} ease-in-out`,
        [`${n}-checked, ${n}-unchecked`]: {
          display: "block",
          color: e.colorTextLightSolid,
          fontSize: e.fontSizeSM,
          transition: `margin-inline-start ${e.switchDuration} ease-in-out, margin-inline-end ${e.switchDuration} ease-in-out`,
          pointerEvents: "none"
        },
        [`${n}-checked`]: {
          marginInlineStart: `calc(-100% + ${e.switchPinSize + e.switchPadding * 2}px - ${e.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(100% - ${e.switchPinSize + e.switchPadding * 2}px + ${e.switchInnerMarginMax * 2}px)`
        },
        [`${n}-unchecked`]: {
          marginTop: -e.switchHeight,
          marginInlineStart: 0,
          marginInlineEnd: 0
        }
      },
      [`&${t}-checked ${n}`]: {
        paddingInlineStart: e.switchInnerMarginMin,
        paddingInlineEnd: e.switchInnerMarginMax,
        [`${n}-checked`]: {
          marginInlineStart: 0,
          marginInlineEnd: 0
        },
        [`${n}-unchecked`]: {
          marginInlineStart: `calc(100% - ${e.switchPinSize + e.switchPadding * 2}px + ${e.switchInnerMarginMax * 2}px)`,
          marginInlineEnd: `calc(-100% + ${e.switchPinSize + e.switchPadding * 2}px - ${e.switchInnerMarginMax * 2}px)`
        }
      },
      [`&:not(${t}-disabled):active`]: {
        [`&:not(${t}-checked) ${n}`]: {
          [`${n}-unchecked`]: {
            marginInlineStart: e.switchPadding * 2,
            marginInlineEnd: -e.switchPadding * 2
          }
        },
        [`&${t}-checked ${n}`]: {
          [`${n}-checked`]: {
            marginInlineStart: -e.switchPadding * 2,
            marginInlineEnd: e.switchPadding * 2
          }
        }
      }
    }
  };
}, lee = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: m(m(m(m({}, qe(e)), {
      position: "relative",
      display: "inline-block",
      boxSizing: "border-box",
      minWidth: e.switchMinWidth,
      height: e.switchHeight,
      lineHeight: `${e.switchHeight}px`,
      verticalAlign: "middle",
      background: e.colorTextQuaternary,
      border: "0",
      borderRadius: 100,
      cursor: "pointer",
      transition: `all ${e.motionDurationMid}`,
      userSelect: "none",
      [`&:hover:not(${t}-disabled)`]: {
        background: e.colorTextTertiary
      }
    }), Xr(e)), {
      [`&${t}-checked`]: {
        background: e.switchColor,
        [`&:hover:not(${t}-disabled)`]: {
          background: e.colorPrimaryHover
        }
      },
      [`&${t}-loading, &${t}-disabled`]: {
        cursor: "not-allowed",
        opacity: e.switchDisabledOpacity,
        "*": {
          boxShadow: "none",
          cursor: "not-allowed"
        }
      },
      // rtl style
      [`&${t}-rtl`]: {
        direction: "rtl"
      }
    })
  };
}, aee = Xe("Switch", (e) => {
  const t = e.fontSize * e.lineHeight, n = e.controlHeight / 2, o = 2, r = t - o * 2, l = n - o * 2, a = He(e, {
    switchMinWidth: r * 2 + o * 4,
    switchHeight: t,
    switchDuration: e.motionDurationMid,
    switchColor: e.colorPrimary,
    switchDisabledOpacity: e.opacityLoading,
    switchInnerMarginMin: r / 2,
    switchInnerMarginMax: r + o + o * 2,
    switchPadding: o,
    switchPinSize: r,
    switchBg: e.colorBgContainer,
    switchMinWidthSM: l * 2 + o * 2,
    switchHeightSM: n,
    switchInnerMarginMinSM: l / 2,
    switchInnerMarginMaxSM: l + o + o * 2,
    switchPinSizeSM: l,
    switchHandleShadow: `0 2px 4px 0 ${new Ct("#00230b").setAlpha(0.2).toRgbString()}`,
    switchLoadingIconSize: e.fontSizeIcon * 0.75,
    switchLoadingIconColor: `rgba(0, 0, 0, ${e.opacityLoading})`,
    switchHandleActiveInset: "-30%"
  });
  return [
    lee(a),
    // inner style
    ree(a),
    // handle style
    oee(a),
    // loading style
    nee(a),
    // small style
    tee(a)
  ];
}), iee = Mn("small", "default"), see = () => ({
  id: String,
  prefixCls: String,
  size: V.oneOf(iee),
  disabled: {
    type: Boolean,
    default: void 0
  },
  checkedChildren: V.any,
  unCheckedChildren: V.any,
  tabindex: V.oneOfType([V.string, V.number]),
  autofocus: {
    type: Boolean,
    default: void 0
  },
  loading: {
    type: Boolean,
    default: void 0
  },
  checked: V.oneOfType([V.string, V.number, V.looseBool]),
  checkedValue: V.oneOfType([V.string, V.number, V.looseBool]).def(!0),
  unCheckedValue: V.oneOfType([V.string, V.number, V.looseBool]).def(!1),
  onChange: {
    type: Function
  },
  onClick: {
    type: Function
  },
  onKeydown: {
    type: Function
  },
  onMouseup: {
    type: Function
  },
  "onUpdate:checked": {
    type: Function
  },
  onBlur: Function,
  onFocus: Function
}), cee = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ASwitch",
  __ANT_SWITCH: !0,
  inheritAttrs: !1,
  props: see(),
  slots: Object,
  // emits: ['update:checked', 'mouseup', 'change', 'click', 'keydown', 'blur'],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r,
      emit: l
    } = t;
    const a = sn(), i = so(), s = P(() => {
      var E;
      return (E = e.disabled) !== null && E !== void 0 ? E : i.value;
    });
    vf(() => {
      Mt(!("defaultChecked" in n), "Switch", "'defaultChecked' is deprecated, please use 'v-model:checked'"), Mt(!("value" in n), "Switch", "`value` is not validate prop, do you mean `checked`?");
    });
    const c = Y(e.checked !== void 0 ? e.checked : n.defaultChecked), u = P(() => c.value === e.checkedValue);
    ie(() => e.checked, () => {
      c.value = e.checked;
    });
    const {
      prefixCls: d,
      direction: p,
      size: v
    } = Ie("switch", e), [h, g] = aee(d), b = Y(), y = () => {
      var E;
      (E = b.value) === null || E === void 0 || E.focus();
    };
    r({
      focus: y,
      blur: () => {
        var E;
        (E = b.value) === null || E === void 0 || E.blur();
      }
    }), Ke(() => {
      rt(() => {
        e.autofocus && !s.value && b.value.focus();
      });
    });
    const C = (E, _) => {
      s.value || (l("update:checked", E), l("change", E, _), a.onFieldChange());
    }, w = (E) => {
      l("blur", E);
    }, $ = (E) => {
      y();
      const _ = u.value ? e.unCheckedValue : e.checkedValue;
      C(_, E), l("click", _, E);
    }, O = (E) => {
      E.keyCode === ce.LEFT ? C(e.unCheckedValue, E) : E.keyCode === ce.RIGHT && C(e.checkedValue, E), l("keydown", E);
    }, x = (E) => {
      var _;
      (_ = b.value) === null || _ === void 0 || _.blur(), l("mouseup", E);
    }, I = P(() => ({
      [`${d.value}-small`]: v.value === "small",
      [`${d.value}-loading`]: e.loading,
      [`${d.value}-checked`]: u.value,
      [`${d.value}-disabled`]: s.value,
      [d.value]: !0,
      [`${d.value}-rtl`]: p.value === "rtl",
      [g.value]: !0
    }));
    return () => {
      var E;
      return h(f(v0, null, {
        default: () => [f("button", D(D(D({}, ot(e, ["prefixCls", "checkedChildren", "unCheckedChildren", "checked", "autofocus", "checkedValue", "unCheckedValue", "id", "onChange", "onUpdate:checked"])), n), {}, {
          id: (E = e.id) !== null && E !== void 0 ? E : a.id.value,
          onKeydown: O,
          onClick: $,
          onBlur: w,
          onMouseup: x,
          type: "button",
          role: "switch",
          "aria-checked": c.value,
          disabled: s.value || e.loading,
          class: [n.class, I.value],
          ref: b
        }), [f("div", {
          class: `${d.value}-handle`
        }, [e.loading ? f(Qn, {
          class: `${d.value}-loading-icon`
        }, null) : null]), f("span", {
          class: `${d.value}-inner`
        }, [f("span", {
          class: `${d.value}-inner-checked`
        }, [an(o, e, "checkedChildren")]), f("span", {
          class: `${d.value}-inner-unchecked`
        }, [an(o, e, "unCheckedChildren")])])])]
      }));
    };
  }
}), uee = kt(cee), p6 = Symbol("TableContextProps"), dee = (e) => {
  Je(p6, e);
}, Ir = () => tt(p6, {}), fee = "RC_TABLE_KEY";
function v6(e) {
  return e == null ? [] : Array.isArray(e) ? e : [e];
}
function g6(e, t) {
  if (!t && typeof t != "number")
    return e;
  const n = v6(t);
  let o = e;
  for (let r = 0; r < n.length; r += 1) {
    if (!o)
      return null;
    const l = n[r];
    o = o[l];
  }
  return o;
}
function Ip(e) {
  const t = [], n = {};
  return e.forEach((o) => {
    const {
      key: r,
      dataIndex: l
    } = o || {};
    let a = r || v6(l).join("-") || fee;
    for (; n[a]; )
      a = `${a}_next`;
    n[a] = !0, t.push(a);
  }), t;
}
function pee() {
  const e = {};
  function t(l, a) {
    a && Object.keys(a).forEach((i) => {
      const s = a[i];
      s && typeof s == "object" ? (l[i] = l[i] || {}, t(l[i], s)) : l[i] = s;
    });
  }
  for (var n = arguments.length, o = new Array(n), r = 0; r < n; r++)
    o[r] = arguments[r];
  return o.forEach((l) => {
    t(e, l);
  }), e;
}
function Tm(e) {
  return e != null;
}
const m6 = Symbol("SlotsContextProps"), vee = (e) => {
  Je(m6, e);
}, Lb = () => tt(m6, P(() => ({}))), h6 = Symbol("ContextProps"), gee = (e) => {
  Je(h6, e);
}, mee = () => tt(h6, {
  onResizeColumn: () => {
  }
}), di = "RC_TABLE_INTERNAL_COL_DEFINE", b6 = Symbol("HoverContextProps"), hee = (e) => {
  Je(b6, e);
}, bee = () => tt(b6, {
  startRow: Q(-1),
  endRow: Q(-1),
  onHover() {
  }
}), Mm = Q(!1), yee = () => {
  Ke(() => {
    Mm.value = Mm.value || ob("position", "sticky");
  });
}, See = () => Mm;
var Cee = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function $ee(e, t, n, o) {
  const r = e + t - 1;
  return e <= o && r >= n;
}
function wee(e) {
  return e && typeof e == "object" && !Array.isArray(e) && !In(e);
}
const Ep = Z({
  name: "Cell",
  props: ["prefixCls", "record", "index", "renderIndex", "dataIndex", "customRender", "component", "colSpan", "rowSpan", "fixLeft", "fixRight", "firstFixLeft", "lastFixLeft", "firstFixRight", "lastFixRight", "appendNode", "additionalProps", "ellipsis", "align", "rowType", "isSticky", "column", "cellType", "transformCellText"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Lb(), {
      onHover: r,
      startRow: l,
      endRow: a
    } = bee(), i = P(() => {
      var g, b, y, S;
      return (y = (g = e.colSpan) !== null && g !== void 0 ? g : (b = e.additionalProps) === null || b === void 0 ? void 0 : b.colSpan) !== null && y !== void 0 ? y : (S = e.additionalProps) === null || S === void 0 ? void 0 : S.colspan;
    }), s = P(() => {
      var g, b, y, S;
      return (y = (g = e.rowSpan) !== null && g !== void 0 ? g : (b = e.additionalProps) === null || b === void 0 ? void 0 : b.rowSpan) !== null && y !== void 0 ? y : (S = e.additionalProps) === null || S === void 0 ? void 0 : S.rowspan;
    }), c = So(() => {
      const {
        index: g
      } = e;
      return $ee(g, s.value || 1, l.value, a.value);
    }), u = See(), d = (g, b) => {
      var y;
      const {
        record: S,
        index: C,
        additionalProps: w
      } = e;
      S && r(C, C + b - 1), (y = w == null ? void 0 : w.onMouseenter) === null || y === void 0 || y.call(w, g);
    }, p = (g) => {
      var b;
      const {
        record: y,
        additionalProps: S
      } = e;
      y && r(-1, -1), (b = S == null ? void 0 : S.onMouseleave) === null || b === void 0 || b.call(S, g);
    }, v = (g) => {
      const b = Lt(g)[0];
      return In(b) ? b.type === pf ? b.children : Array.isArray(b.children) ? v(b.children) : void 0 : b;
    }, h = Q(null);
    return ie([c, () => e.prefixCls, h], () => {
      const g = qn(h.value);
      g && (c.value ? Dd(g, `${e.prefixCls}-cell-row-hover`) : Nd(g, `${e.prefixCls}-cell-row-hover`));
    }), () => {
      var g, b, y, S, C, w;
      const {
        prefixCls: $,
        record: O,
        index: x,
        renderIndex: I,
        dataIndex: E,
        customRender: _,
        component: M = "td",
        fixLeft: R,
        fixRight: A,
        firstFixLeft: z,
        lastFixLeft: T,
        firstFixRight: N,
        lastFixRight: k,
        appendNode: B = (g = n.appendNode) === null || g === void 0 ? void 0 : g.call(n),
        additionalProps: F = {},
        ellipsis: L,
        align: j,
        rowType: H,
        isSticky: K,
        column: X = {},
        cellType: W
      } = e, q = `${$}-cell`;
      let J, ne;
      const te = (b = n.default) === null || b === void 0 ? void 0 : b.call(n);
      if (Tm(te) || W === "header")
        ne = te;
      else {
        const ae = g6(O, E);
        if (ne = ae, _) {
          const oe = _({
            text: ae,
            value: ae,
            record: O,
            index: x,
            renderIndex: I,
            column: X.__originColumn__
          });
          wee(oe) ? (process.env.NODE_ENV !== "production" && ct(!1, "`columns.customRender` return cell props is deprecated with perf issue, please use `customCell` instead."), ne = oe.children, J = oe.props) : ne = oe;
        }
        if (!(di in X) && W === "body" && o.value.bodyCell && !(!((y = X.slots) === null || y === void 0) && y.customRender)) {
          const oe = Pf(o.value, "bodyCell", {
            text: ae,
            value: ae,
            record: O,
            index: x,
            column: X.__originColumn__
          }, () => {
            const pe = ne === void 0 ? ae : ne;
            return [typeof pe == "object" && Gt(pe) || typeof pe != "object" ? pe : null];
          });
          ne = It(oe);
        }
        e.transformCellText && (ne = e.transformCellText({
          text: ne,
          record: O,
          index: x,
          column: X.__originColumn__
        }));
      }
      typeof ne == "object" && !Array.isArray(ne) && !In(ne) && (ne = null), L && (T || N) && (ne = f("span", {
        class: `${q}-content`
      }, [ne])), Array.isArray(ne) && ne.length === 1 && (ne = ne[0]);
      const G = J || {}, {
        colSpan: U,
        rowSpan: re,
        style: se,
        class: me
      } = G, Ce = Cee(G, ["colSpan", "rowSpan", "style", "class"]), fe = (S = U !== void 0 ? U : i.value) !== null && S !== void 0 ? S : 1, be = (C = re !== void 0 ? re : s.value) !== null && C !== void 0 ? C : 1;
      if (fe === 0 || be === 0)
        return null;
      const ue = {}, de = typeof R == "number" && u.value, Se = typeof A == "number" && u.value;
      de && (ue.position = "sticky", ue.left = `${R}px`), Se && (ue.position = "sticky", ue.right = `${A}px`);
      const xe = {};
      j && (xe.textAlign = j);
      let he;
      const we = L === !0 ? {
        showTitle: !0
      } : L;
      we && (we.showTitle || H === "header") && (typeof ne == "string" || typeof ne == "number" ? he = ne.toString() : In(ne) && (he = v([ne])));
      const Me = m(m(m({
        title: he
      }, Ce), F), {
        colSpan: fe !== 1 ? fe : null,
        rowSpan: be !== 1 ? be : null,
        class: ee(q, {
          [`${q}-fix-left`]: de && u.value,
          [`${q}-fix-left-first`]: z && u.value,
          [`${q}-fix-left-last`]: T && u.value,
          [`${q}-fix-right`]: Se && u.value,
          [`${q}-fix-right-first`]: N && u.value,
          [`${q}-fix-right-last`]: k && u.value,
          [`${q}-ellipsis`]: L,
          [`${q}-with-append`]: B,
          [`${q}-fix-sticky`]: (de || Se) && K && u.value
        }, F.class, me),
        onMouseenter: (ae) => {
          d(ae, be);
        },
        onMouseleave: p,
        style: [F.style, xe, ue, se]
      });
      return f(M, D(D({}, Me), {}, {
        ref: h
      }), {
        default: () => [B, ne, (w = n.dragHandle) === null || w === void 0 ? void 0 : w.call(n)]
      });
    };
  }
});
function zb(e, t, n, o, r) {
  const l = n[e] || {}, a = n[t] || {};
  let i, s;
  l.fixed === "left" ? i = o.left[e] : a.fixed === "right" && (s = o.right[t]);
  let c = !1, u = !1, d = !1, p = !1;
  const v = n[t + 1], h = n[e - 1];
  return r === "rtl" ? i !== void 0 ? p = !(h && h.fixed === "left") : s !== void 0 && (d = !(v && v.fixed === "right")) : i !== void 0 ? c = !(v && v.fixed === "left") : s !== void 0 && (u = !(h && h.fixed === "right")), {
    fixLeft: i,
    fixRight: s,
    lastFixLeft: c,
    firstFixRight: u,
    lastFixRight: d,
    firstFixLeft: p,
    isSticky: o.isSticky
  };
}
const lw = {
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  },
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  }
}, aw = 50, xee = Z({
  compatConfig: {
    MODE: 3
  },
  name: "DragHandle",
  props: {
    prefixCls: String,
    width: {
      type: Number,
      required: !0
    },
    minWidth: {
      type: Number,
      default: aw
    },
    maxWidth: {
      type: Number,
      default: 1 / 0
    },
    column: {
      type: Object,
      default: void 0
    }
  },
  setup(e) {
    let t = 0, n = {
      remove: () => {
      }
    }, o = {
      remove: () => {
      }
    };
    const r = () => {
      n.remove(), o.remove();
    };
    uo(() => {
      r();
    }), Le(() => {
      nt(!isNaN(e.width), "Table", "width must be a number when use resizable");
    });
    const {
      onResizeColumn: l
    } = mee(), a = P(() => typeof e.minWidth == "number" && !isNaN(e.minWidth) ? e.minWidth : aw), i = P(() => typeof e.maxWidth == "number" && !isNaN(e.maxWidth) ? e.maxWidth : 1 / 0), s = Wn();
    let c = 0;
    const u = Q(!1);
    let d;
    const p = (C) => {
      let w = 0;
      C.touches ? C.touches.length ? w = C.touches[0].pageX : w = C.changedTouches[0].pageX : w = C.pageX;
      const $ = t - w;
      let O = Math.max(c - $, a.value);
      O = Math.min(O, i.value), Ze.cancel(d), d = Ze(() => {
        l(O, e.column.__originColumn__);
      });
    }, v = (C) => {
      p(C);
    }, h = (C) => {
      u.value = !1, p(C), r();
    }, g = (C, w) => {
      u.value = !0, r(), c = s.vnode.el.parentNode.getBoundingClientRect().width, !(C instanceof MouseEvent && C.which !== 1) && (C.stopPropagation && C.stopPropagation(), t = C.touches ? C.touches[0].pageX : C.pageX, n = Bt(document.documentElement, w.move, v), o = Bt(document.documentElement, w.stop, h));
    }, b = (C) => {
      C.stopPropagation(), C.preventDefault(), g(C, lw.mouse);
    }, y = (C) => {
      C.stopPropagation(), C.preventDefault(), g(C, lw.touch);
    }, S = (C) => {
      C.stopPropagation(), C.preventDefault();
    };
    return () => {
      const {
        prefixCls: C
      } = e, w = {
        [on ? "onTouchstartPassive" : "onTouchstart"]: ($) => y($)
      };
      return f("div", D(D({
        class: `${C}-resize-handle ${u.value ? "dragging" : ""}`,
        onMousedown: b
      }, w), {}, {
        onClick: S
      }), [f("div", {
        class: `${C}-resize-handle-line`
      }, null)]);
    };
  }
}), Oee = Z({
  name: "HeaderRow",
  props: ["cells", "stickyOffsets", "flattenColumns", "rowComponent", "cellComponent", "index", "customHeaderRow"],
  setup(e) {
    const t = Ir();
    return () => {
      const {
        prefixCls: n,
        direction: o
      } = t, {
        cells: r,
        stickyOffsets: l,
        flattenColumns: a,
        rowComponent: i,
        cellComponent: s,
        customHeaderRow: c,
        index: u
      } = e;
      let d;
      c && (d = c(r.map((v) => v.column), u));
      const p = Ip(r.map((v) => v.column));
      return f(i, d, {
        default: () => [r.map((v, h) => {
          const {
            column: g
          } = v, b = zb(v.colStart, v.colEnd, a, l, o);
          let y;
          g && g.customHeaderCell && (y = v.column.customHeaderCell(g));
          const S = g;
          return f(Ep, D(D(D({}, v), {}, {
            cellType: "header",
            ellipsis: g.ellipsis,
            align: g.align,
            component: s,
            prefixCls: n,
            key: p[h]
          }, b), {}, {
            additionalProps: y,
            rowType: "header",
            column: g
          }), {
            default: () => g.title,
            dragHandle: () => S.resizable ? f(xee, {
              prefixCls: n,
              width: S.width,
              minWidth: S.minWidth,
              maxWidth: S.maxWidth,
              column: S
            }, null) : null
          });
        })]
      });
    };
  }
});
function Pee(e) {
  const t = [];
  function n(r, l) {
    let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    t[a] = t[a] || [];
    let i = l;
    return r.filter(Boolean).map((c) => {
      const u = {
        key: c.key,
        class: ee(c.className, c.class),
        // children: column.title,
        column: c,
        colStart: i
      };
      let d = 1;
      const p = c.children;
      return p && p.length > 0 && (d = n(p, i, a + 1).reduce((v, h) => v + h, 0), u.hasSubColumns = !0), "colSpan" in c && ({
        colSpan: d
      } = c), "rowSpan" in c && (u.rowSpan = c.rowSpan), u.colSpan = d, u.colEnd = u.colStart + d - 1, t[a].push(u), i += d, d;
    });
  }
  n(e, 0);
  const o = t.length;
  for (let r = 0; r < o; r += 1)
    t[r].forEach((l) => {
      !("rowSpan" in l) && !l.hasSubColumns && (l.rowSpan = o - r);
    });
  return t;
}
const iw = Z({
  name: "TableHeader",
  inheritAttrs: !1,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow"],
  setup(e) {
    const t = Ir(), n = P(() => Pee(e.columns));
    return () => {
      const {
        prefixCls: o,
        getComponent: r
      } = t, {
        stickyOffsets: l,
        flattenColumns: a,
        customHeaderRow: i
      } = e, s = r(["header", "wrapper"], "thead"), c = r(["header", "row"], "tr"), u = r(["header", "cell"], "th");
      return f(s, {
        class: `${o}-thead`
      }, {
        default: () => [n.value.map((d, p) => f(Oee, {
          key: p,
          flattenColumns: a,
          cells: d,
          stickyOffsets: l,
          rowComponent: c,
          cellComponent: u,
          customHeaderRow: i,
          index: p
        }, null))]
      });
    };
  }
}), y6 = Symbol("ExpandedRowProps"), Iee = (e) => {
  Je(y6, e);
}, Eee = () => tt(y6, {}), S6 = Z({
  name: "ExpandedRow",
  inheritAttrs: !1,
  props: ["prefixCls", "component", "cellComponent", "expanded", "colSpan", "isEmpty"],
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const r = Ir(), l = Eee(), {
      fixHeader: a,
      fixColumn: i,
      componentWidth: s,
      horizonScroll: c
    } = l;
    return () => {
      const {
        prefixCls: u,
        component: d,
        cellComponent: p,
        expanded: v,
        colSpan: h,
        isEmpty: g
      } = e;
      return f(d, {
        class: o.class,
        style: {
          display: v ? null : "none"
        }
      }, {
        default: () => [f(Ep, {
          component: p,
          prefixCls: u,
          colSpan: h
        }, {
          default: () => {
            var b;
            let y = (b = n.default) === null || b === void 0 ? void 0 : b.call(n);
            return (g ? c.value : i.value) && (y = f("div", {
              style: {
                width: `${s.value - (a.value ? r.scrollbarSize : 0)}px`,
                position: "sticky",
                left: 0,
                overflow: "hidden"
              },
              class: `${u}-expanded-row-fixed`
            }, [y])), y;
          }
        })]
      });
    };
  }
}), Tee = Z({
  name: "MeasureCell",
  props: ["columnKey"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    const o = Y();
    return Ke(() => {
      o.value && n("columnResize", e.columnKey, o.value.offsetWidth);
    }), () => f(Fo, {
      onResize: (r) => {
        let {
          offsetWidth: l
        } = r;
        n("columnResize", e.columnKey, l);
      }
    }, {
      default: () => [f("td", {
        ref: o,
        style: {
          padding: 0,
          border: 0,
          height: 0
        }
      }, [f("div", {
        style: {
          height: 0,
          overflow: "hidden"
        }
      }, [Ot(" ")])])]
    });
  }
}), C6 = Symbol("BodyContextProps"), Mee = (e) => {
  Je(C6, e);
}, $6 = () => tt(C6, {}), _ee = Z({
  name: "BodyRow",
  inheritAttrs: !1,
  props: ["record", "index", "renderIndex", "recordKey", "expandedKeys", "rowComponent", "cellComponent", "customRow", "rowExpandable", "indent", "rowKey", "getRowKey", "childrenColumnName"],
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const o = Ir(), r = $6(), l = Q(!1), a = P(() => e.expandedKeys && e.expandedKeys.has(e.recordKey));
    Le(() => {
      a.value && (l.value = !0);
    });
    const i = P(() => r.expandableType === "row" && (!e.rowExpandable || e.rowExpandable(e.record))), s = P(() => r.expandableType === "nest"), c = P(() => e.childrenColumnName && e.record && e.record[e.childrenColumnName]), u = P(() => i.value || s.value), d = (b, y) => {
      r.onTriggerExpand(b, y);
    }, p = P(() => {
      var b;
      return ((b = e.customRow) === null || b === void 0 ? void 0 : b.call(e, e.record, e.index)) || {};
    }), v = function(b) {
      var y, S;
      r.expandRowByClick && u.value && d(e.record, b);
      for (var C = arguments.length, w = new Array(C > 1 ? C - 1 : 0), $ = 1; $ < C; $++)
        w[$ - 1] = arguments[$];
      (S = (y = p.value) === null || y === void 0 ? void 0 : y.onClick) === null || S === void 0 || S.call(y, b, ...w);
    }, h = P(() => {
      const {
        record: b,
        index: y,
        indent: S
      } = e, {
        rowClassName: C
      } = r;
      return typeof C == "string" ? C : typeof C == "function" ? C(b, y, S) : "";
    }), g = P(() => Ip(r.flattenColumns));
    return () => {
      const {
        class: b,
        style: y
      } = n, {
        record: S,
        index: C,
        rowKey: w,
        indent: $ = 0,
        rowComponent: O,
        cellComponent: x
      } = e, {
        prefixCls: I,
        fixedInfoList: E,
        transformCellText: _
      } = o, {
        flattenColumns: M,
        expandedRowClassName: R,
        indentSize: A,
        expandIcon: z,
        expandedRowRender: T,
        expandIconColumnIndex: N
      } = r, k = f(O, D(D({}, p.value), {}, {
        "data-row-key": w,
        class: ee(b, `${I}-row`, `${I}-row-level-${$}`, h.value, p.value.class),
        style: [y, p.value.style],
        onClick: v
      }), {
        default: () => [M.map((F, L) => {
          const {
            customRender: j,
            dataIndex: H,
            className: K
          } = F, X = g[L], W = E[L];
          let q;
          F.customCell && (q = F.customCell(S, C, F));
          const J = L === (N || 0) && s.value ? f(Fe, null, [f("span", {
            style: {
              paddingLeft: `${A * $}px`
            },
            class: `${I}-row-indent indent-level-${$}`
          }, null), z({
            prefixCls: I,
            expanded: a.value,
            expandable: c.value,
            record: S,
            onExpand: d
          })]) : null;
          return f(Ep, D(D({
            cellType: "body",
            class: K,
            ellipsis: F.ellipsis,
            align: F.align,
            component: x,
            prefixCls: I,
            key: X,
            record: S,
            index: C,
            renderIndex: e.renderIndex,
            dataIndex: H,
            customRender: j
          }, W), {}, {
            additionalProps: q,
            column: F,
            transformCellText: _,
            appendNode: J
          }), null);
        })]
      });
      let B;
      if (i.value && (l.value || a.value)) {
        const F = T({
          record: S,
          index: C,
          indent: $ + 1,
          expanded: a.value
        }), L = R && R(S, C, $);
        B = f(S6, {
          expanded: a.value,
          class: ee(`${I}-expanded-row`, `${I}-expanded-row-level-${$ + 1}`, L),
          prefixCls: I,
          component: O,
          cellComponent: x,
          colSpan: M.length,
          isEmpty: !1
        }, {
          default: () => [F]
        });
      }
      return f(Fe, null, [k, B]);
    };
  }
});
function w6(e, t, n, o, r, l) {
  const a = [];
  a.push({
    record: e,
    indent: t,
    index: l
  });
  const i = r(e), s = o == null ? void 0 : o.has(i);
  if (e && Array.isArray(e[n]) && s)
    for (let c = 0; c < e[n].length; c += 1) {
      const u = w6(e[n][c], t + 1, n, o, r, c);
      a.push(...u);
    }
  return a;
}
function Aee(e, t, n, o) {
  return P(() => {
    const l = t.value, a = n.value, i = e.value;
    if (a != null && a.size) {
      const s = [];
      for (let c = 0; c < (i == null ? void 0 : i.length); c += 1) {
        const u = i[c];
        s.push(...w6(u, 0, l, a, o.value, c));
      }
      return s;
    }
    return i == null ? void 0 : i.map((s, c) => ({
      record: s,
      indent: 0,
      index: c
    }));
  });
}
const x6 = Symbol("ResizeContextProps"), Dee = (e) => {
  Je(x6, e);
}, Nee = () => tt(x6, {
  onColumnResize: () => {
  }
}), Ree = Z({
  name: "TableBody",
  props: ["data", "getRowKey", "measureColumnWidth", "expandedKeys", "customRow", "rowExpandable", "childrenColumnName"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Nee(), r = Ir(), l = $6(), a = Aee(Te(e, "data"), Te(e, "childrenColumnName"), Te(e, "expandedKeys"), Te(e, "getRowKey")), i = Q(-1), s = Q(-1);
    let c;
    return hee({
      startRow: i,
      endRow: s,
      onHover: (u, d) => {
        clearTimeout(c), c = setTimeout(() => {
          i.value = u, s.value = d;
        }, 100);
      }
    }), () => {
      var u;
      const {
        data: d,
        getRowKey: p,
        measureColumnWidth: v,
        expandedKeys: h,
        customRow: g,
        rowExpandable: b,
        childrenColumnName: y
      } = e, {
        onColumnResize: S
      } = o, {
        prefixCls: C,
        getComponent: w
      } = r, {
        flattenColumns: $
      } = l, O = w(["body", "wrapper"], "tbody"), x = w(["body", "row"], "tr"), I = w(["body", "cell"], "td");
      let E;
      d.length ? E = a.value.map((M, R) => {
        const {
          record: A,
          indent: z,
          index: T
        } = M, N = p(A, R);
        return f(_ee, {
          key: N,
          rowKey: N,
          record: A,
          recordKey: N,
          index: R,
          renderIndex: T,
          rowComponent: x,
          cellComponent: I,
          expandedKeys: h,
          customRow: g,
          getRowKey: p,
          rowExpandable: b,
          childrenColumnName: y,
          indent: z
        }, null);
      }) : E = f(S6, {
        expanded: !0,
        class: `${C}-placeholder`,
        prefixCls: C,
        component: x,
        cellComponent: I,
        colSpan: $.length,
        isEmpty: !0
      }, {
        default: () => [(u = n.emptyNode) === null || u === void 0 ? void 0 : u.call(n)]
      });
      const _ = Ip($);
      return f(O, {
        class: `${C}-tbody`
      }, {
        default: () => [v && f("tr", {
          "aria-hidden": "true",
          class: `${C}-measure-row`,
          style: {
            height: 0,
            fontSize: 0
          }
        }, [_.map((M) => f(Tee, {
          key: M,
          columnKey: M,
          onColumnResize: S
        }, null))]), E]
      });
    };
  }
}), pr = {};
var kee = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function _m(e) {
  return e.reduce((t, n) => {
    const {
      fixed: o
    } = n, r = o === !0 ? "left" : o, l = n.children;
    return l && l.length > 0 ? [...t, ..._m(l).map((a) => m({
      fixed: r
    }, a))] : [...t, m(m({}, n), {
      fixed: r
    })];
  }, []);
}
function Bee(e) {
  let t = !0;
  for (let o = 0; o < e.length; o += 1) {
    const r = e[o];
    if (t && r.fixed !== "left")
      t = !1;
    else if (!t && r.fixed === "left") {
      ct(!1, `Index ${o - 1} of \`columns\` missing \`fixed='left'\` prop.`);
      break;
    }
  }
  let n = !0;
  for (let o = e.length - 1; o >= 0; o -= 1) {
    const r = e[o];
    if (n && r.fixed !== "right")
      n = !1;
    else if (!n && r.fixed === "right") {
      ct(!1, `Index ${o + 1} of \`columns\` missing \`fixed='right'\` prop.`);
      break;
    }
  }
}
function Fee(e) {
  return e.map((t) => {
    const {
      fixed: n
    } = t, o = kee(t, ["fixed"]);
    let r = n;
    return n === "left" ? r = "right" : n === "right" && (r = "left"), m({
      fixed: r
    }, o);
  });
}
function Lee(e, t) {
  let {
    prefixCls: n,
    columns: o,
    // children,
    expandable: r,
    expandedKeys: l,
    getRowKey: a,
    onTriggerExpand: i,
    expandIcon: s,
    rowExpandable: c,
    expandIconColumnIndex: u,
    direction: d,
    expandRowByClick: p,
    expandColumnWidth: v,
    expandFixed: h
  } = e;
  const g = Lb(), b = P(() => {
    if (r.value) {
      let C = o.value.slice();
      if (process.env.NODE_ENV !== "production" && u.value >= 0 && ct(!1, "`expandIconColumnIndex` is deprecated. Please use `Table.EXPAND_COLUMN` in `columns` instead."), !C.includes(pr)) {
        const A = u.value || 0;
        A >= 0 && C.splice(A, 0, pr);
      }
      process.env.NODE_ENV !== "production" && C.filter((A) => A === pr).length > 1 && ct(!1, "There exist more than one `EXPAND_COLUMN` in `columns`.");
      const w = C.indexOf(pr);
      C = C.filter((A, z) => A !== pr || z === w);
      const $ = o.value[w];
      let O;
      (h.value === "left" || h.value) && !u.value ? O = "left" : (h.value === "right" || h.value) && u.value === o.value.length ? O = "right" : O = $ ? $.fixed : null;
      const x = l.value, I = c.value, E = s.value, _ = n.value, M = p.value, R = {
        [di]: {
          class: `${n.value}-expand-icon-col`,
          columnType: "EXPAND_COLUMN"
        },
        title: Pf(g.value, "expandColumnTitle", {}, () => [""]),
        fixed: O,
        class: `${n.value}-row-expand-icon-cell`,
        width: v.value,
        customRender: (A) => {
          let {
            record: z,
            index: T
          } = A;
          const N = a.value(z, T), k = x.has(N), B = I ? I(z) : !0, F = E({
            prefixCls: _,
            expanded: k,
            expandable: B,
            record: z,
            onExpand: i
          });
          return M ? f("span", {
            onClick: (L) => L.stopPropagation()
          }, [F]) : F;
        }
      };
      return C.map((A) => A === pr ? R : A);
    }
    return process.env.NODE_ENV !== "production" && o.value.includes(pr) && ct(!1, "`expandable` is not config but there exist `EXPAND_COLUMN` in `columns`."), o.value.filter((C) => C !== pr);
  }), y = P(() => {
    let C = b.value;
    return t.value && (C = t.value(C)), C.length || (C = [{
      customRender: () => null
    }]), C;
  }), S = P(() => d.value === "rtl" ? Fee(_m(y.value)) : _m(y.value));
  return process.env.NODE_ENV !== "production" && Le(() => {
    setTimeout(() => {
      Bee(S.value);
    });
  }), [y, S];
}
function O6(e) {
  const t = Q(e);
  let n;
  const o = Q([]);
  function r(l) {
    o.value.push(l), Ze.cancel(n), n = Ze(() => {
      const a = o.value;
      o.value = [], a.forEach((i) => {
        t.value = i(t.value);
      });
    });
  }
  return et(() => {
    Ze.cancel(n);
  }), [t, r];
}
function zee(e) {
  const t = Y(null), n = Y();
  function o() {
    clearTimeout(n.value);
  }
  function r(a) {
    t.value = a, o(), n.value = setTimeout(() => {
      t.value = null, n.value = void 0;
    }, 100);
  }
  function l() {
    return t.value;
  }
  return et(() => {
    o();
  }), [r, l];
}
function Hee(e, t, n) {
  return P(() => {
    const r = [], l = [];
    let a = 0, i = 0;
    const s = e.value, c = t.value, u = n.value;
    for (let d = 0; d < c; d += 1)
      if (u === "rtl") {
        l[d] = i, i += s[d] || 0;
        const p = c - d - 1;
        r[p] = a, a += s[p] || 0;
      } else {
        r[d] = a, a += s[d] || 0;
        const p = c - d - 1;
        l[p] = i, i += s[p] || 0;
      }
    return {
      left: r,
      right: l
    };
  });
}
var jee = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function P6(e) {
  let {
    colWidths: t,
    columns: n,
    columCount: o
  } = e;
  const r = [], l = o || n.length;
  let a = !1;
  for (let i = l - 1; i >= 0; i -= 1) {
    const s = t[i], c = n && n[i], u = c && c[di];
    if (s || u || a) {
      const d = u || {}, p = jee(d, ["columnType"]);
      r.unshift(f("col", D({
        key: i,
        style: {
          width: typeof s == "number" ? `${s}px` : s
        }
      }, p), null)), a = !0;
    }
  }
  return f("colgroup", null, [r]);
}
function Am(e, t) {
  let {
    slots: n
  } = t;
  var o;
  return f("div", null, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]);
}
Am.displayName = "Panel";
let Vee = 0;
const Wee = Z({
  name: "TableSummary",
  props: ["fixed"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Ir(), r = `table-summary-uni-key-${++Vee}`, l = P(() => e.fixed === "" || e.fixed);
    return Le(() => {
      o.summaryCollect(r, l.value);
    }), et(() => {
      o.summaryCollect(r, !1);
    }), () => {
      var a;
      return (a = n.default) === null || a === void 0 ? void 0 : a.call(n);
    };
  }
}), Kee = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATableSummaryRow",
  setup(e, t) {
    let {
      slots: n
    } = t;
    return () => {
      var o;
      return f("tr", null, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]);
    };
  }
}), I6 = Symbol("SummaryContextProps"), Gee = (e) => {
  Je(I6, e);
}, Xee = () => tt(I6, {}), Uee = Z({
  name: "ATableSummaryCell",
  props: ["index", "colSpan", "rowSpan", "align"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = Ir(), l = Xee();
    return () => {
      const {
        index: a,
        colSpan: i = 1,
        rowSpan: s,
        align: c
      } = e, {
        prefixCls: u,
        direction: d
      } = r, {
        scrollColumnIndex: p,
        stickyOffsets: v,
        flattenColumns: h
      } = l, b = a + i - 1 + 1 === p ? i + 1 : i, y = zb(a, a + b - 1, h, v, d);
      return f(Ep, D({
        class: n.class,
        index: a,
        component: "td",
        prefixCls: u,
        record: null,
        dataIndex: null,
        align: c,
        colSpan: b,
        rowSpan: s,
        customRender: () => {
          var S;
          return (S = o.default) === null || S === void 0 ? void 0 : S.call(o);
        }
      }, y), null);
    };
  }
}), ou = Z({
  name: "TableFooter",
  inheritAttrs: !1,
  props: ["stickyOffsets", "flattenColumns"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Ir();
    return Gee(xt({
      stickyOffsets: Te(e, "stickyOffsets"),
      flattenColumns: Te(e, "flattenColumns"),
      scrollColumnIndex: P(() => {
        const r = e.flattenColumns.length - 1, l = e.flattenColumns[r];
        return l != null && l.scrollbar ? r : null;
      })
    })), () => {
      var r;
      const {
        prefixCls: l
      } = o;
      return f("tfoot", {
        class: `${l}-summary`
      }, [(r = n.default) === null || r === void 0 ? void 0 : r.call(n)]);
    };
  }
}), Yee = Wee;
function qee(e) {
  let {
    prefixCls: t,
    record: n,
    onExpand: o,
    expanded: r,
    expandable: l
  } = e;
  const a = `${t}-row-expand-icon`;
  if (!l)
    return f("span", {
      class: [a, `${t}-row-spaced`]
    }, null);
  const i = (s) => {
    o(n, s), s.stopPropagation();
  };
  return f("span", {
    class: {
      [a]: !0,
      [`${t}-row-expanded`]: r,
      [`${t}-row-collapsed`]: !r
    },
    onClick: i
  }, null);
}
function Zee(e, t, n) {
  const o = [];
  function r(l) {
    (l || []).forEach((a, i) => {
      o.push(t(a, i)), r(a[n]);
    });
  }
  return r(e), o;
}
const Qee = Z({
  name: "StickyScrollBar",
  inheritAttrs: !1,
  props: ["offsetScroll", "container", "scrollBodyRef", "scrollBodySizeInfo"],
  emits: ["scroll"],
  setup(e, t) {
    let {
      emit: n,
      expose: o
    } = t;
    const r = Ir(), l = Q(0), a = Q(0), i = Q(0);
    Le(() => {
      l.value = e.scrollBodySizeInfo.scrollWidth || 0, a.value = e.scrollBodySizeInfo.clientWidth || 0, i.value = l.value && a.value * (a.value / l.value);
    }, {
      flush: "post"
    });
    const s = Q(), [c, u] = O6({
      scrollLeft: 0,
      isHiddenScrollBar: !0
    }), d = Y({
      delta: 0,
      x: 0
    }), p = Q(!1), v = () => {
      p.value = !1;
    }, h = (x) => {
      d.value = {
        delta: x.pageX - c.value.scrollLeft,
        x: 0
      }, p.value = !0, x.preventDefault();
    }, g = (x) => {
      const {
        buttons: I
      } = x || (window == null ? void 0 : window.event);
      if (!p.value || I === 0) {
        p.value && (p.value = !1);
        return;
      }
      let E = d.value.x + x.pageX - d.value.x - d.value.delta;
      E <= 0 && (E = 0), E + i.value >= a.value && (E = a.value - i.value), n("scroll", {
        scrollLeft: E / a.value * (l.value + 2)
      }), d.value.x = x.pageX;
    }, b = () => {
      if (!e.scrollBodyRef.value)
        return;
      const x = hd(e.scrollBodyRef.value).top, I = x + e.scrollBodyRef.value.offsetHeight, E = e.container === window ? document.documentElement.scrollTop + window.innerHeight : hd(e.container).top + e.container.clientHeight;
      I - md() <= E || x >= E - e.offsetScroll ? u((_) => m(m({}, _), {
        isHiddenScrollBar: !0
      })) : u((_) => m(m({}, _), {
        isHiddenScrollBar: !1
      }));
    };
    o({
      setScrollLeft: (x) => {
        u((I) => m(m({}, I), {
          scrollLeft: x / l.value * a.value || 0
        }));
      }
    });
    let S = null, C = null, w = null, $ = null;
    Ke(() => {
      S = Bt(document.body, "mouseup", v, !1), C = Bt(document.body, "mousemove", g, !1), w = Bt(window, "resize", b, !1);
    }), th(() => {
      rt(() => {
        b();
      });
    }), Ke(() => {
      setTimeout(() => {
        ie([i, p], () => {
          b();
        }, {
          immediate: !0,
          flush: "post"
        });
      });
    }), ie(() => e.container, () => {
      $ == null || $.remove(), $ = Bt(e.container, "scroll", b, !1);
    }, {
      immediate: !0,
      flush: "post"
    }), et(() => {
      S == null || S.remove(), C == null || C.remove(), $ == null || $.remove(), w == null || w.remove();
    }), ie(() => m({}, c.value), (x, I) => {
      x.isHiddenScrollBar !== (I == null ? void 0 : I.isHiddenScrollBar) && !x.isHiddenScrollBar && u((E) => {
        const _ = e.scrollBodyRef.value;
        return _ ? m(m({}, E), {
          scrollLeft: _.scrollLeft / _.scrollWidth * _.clientWidth
        }) : E;
      });
    }, {
      immediate: !0
    });
    const O = md();
    return () => {
      if (l.value <= a.value || !i.value || c.value.isHiddenScrollBar)
        return null;
      const {
        prefixCls: x
      } = r;
      return f("div", {
        style: {
          height: `${O}px`,
          width: `${a.value}px`,
          bottom: `${e.offsetScroll}px`
        },
        class: `${x}-sticky-scroll`
      }, [f("div", {
        onMousedown: h,
        ref: s,
        class: ee(`${x}-sticky-scroll-bar`, {
          [`${x}-sticky-scroll-bar-active`]: p.value
        }),
        style: {
          width: `${i.value}px`,
          transform: `translate3d(${c.value.scrollLeft}px, 0, 0)`
        }
      }, null)]);
    };
  }
}), sw = jn() ? window : null;
function Jee(e, t) {
  return P(() => {
    const {
      offsetHeader: n = 0,
      offsetSummary: o = 0,
      offsetScroll: r = 0,
      getContainer: l = () => sw
    } = typeof e.value == "object" ? e.value : {}, a = l() || sw, i = !!e.value;
    return {
      isSticky: i,
      stickyClassName: i ? `${t.value}-sticky-holder` : "",
      offsetHeader: n,
      offsetSummary: o,
      offsetScroll: r,
      container: a
    };
  });
}
function ete(e, t) {
  return P(() => {
    const n = [], o = e.value, r = t.value;
    for (let l = 0; l < r; l += 1) {
      const a = o[l];
      if (a !== void 0)
        n[l] = a;
      else
        return null;
    }
    return n;
  });
}
const cw = Z({
  name: "FixedHolder",
  inheritAttrs: !1,
  props: ["columns", "flattenColumns", "stickyOffsets", "customHeaderRow", "noData", "maxContentScroll", "colWidths", "columCount", "direction", "fixHeader", "stickyTopOffset", "stickyBottomOffset", "stickyClassName"],
  emits: ["scroll"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r
    } = t;
    const l = Ir(), a = P(() => l.isSticky && !e.fixHeader ? 0 : l.scrollbarSize), i = Y(), s = (g) => {
      const {
        currentTarget: b,
        deltaX: y
      } = g;
      y && (r("scroll", {
        currentTarget: b,
        scrollLeft: b.scrollLeft + y
      }), g.preventDefault());
    }, c = Y();
    Ke(() => {
      rt(() => {
        c.value = Bt(i.value, "wheel", s);
      });
    }), et(() => {
      var g;
      (g = c.value) === null || g === void 0 || g.remove();
    });
    const u = P(() => e.flattenColumns.every((g) => g.width && g.width !== 0 && g.width !== "0px")), d = Y([]), p = Y([]);
    Le(() => {
      const g = e.flattenColumns[e.flattenColumns.length - 1], b = {
        fixed: g ? g.fixed : null,
        scrollbar: !0,
        customHeaderCell: () => ({
          class: `${l.prefixCls}-cell-scrollbar`
        })
      };
      d.value = a.value ? [...e.columns, b] : e.columns, p.value = a.value ? [...e.flattenColumns, b] : e.flattenColumns;
    });
    const v = P(() => {
      const {
        stickyOffsets: g,
        direction: b
      } = e, {
        right: y,
        left: S
      } = g;
      return m(m({}, g), {
        left: b === "rtl" ? [...S.map((C) => C + a.value), 0] : S,
        right: b === "rtl" ? y : [...y.map((C) => C + a.value), 0],
        isSticky: l.isSticky
      });
    }), h = ete(Te(e, "colWidths"), Te(e, "columCount"));
    return () => {
      var g;
      const {
        noData: b,
        columCount: y,
        stickyTopOffset: S,
        stickyBottomOffset: C,
        stickyClassName: w,
        maxContentScroll: $
      } = e, {
        isSticky: O
      } = l;
      return f("div", {
        style: m({
          overflow: "hidden"
        }, O ? {
          top: `${S}px`,
          bottom: `${C}px`
        } : {}),
        ref: i,
        class: ee(n.class, {
          [w]: !!w
        })
      }, [f("table", {
        style: {
          tableLayout: "fixed",
          visibility: b || h.value ? null : "hidden"
        }
      }, [(!b || !$ || u.value) && f(P6, {
        colWidths: h.value ? [...h.value, a.value] : [],
        columCount: y + 1,
        columns: p.value
      }, null), (g = o.default) === null || g === void 0 ? void 0 : g.call(o, m(m({}, e), {
        stickyOffsets: v.value,
        columns: d.value,
        flattenColumns: p.value
      }))])]);
    };
  }
});
function uw(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), o = 1; o < t; o++)
    n[o - 1] = arguments[o];
  return xt(bB(n.map((r) => [r, Te(e, r)])));
}
const tte = [], nte = {}, Dm = "rc-table-internal-hook", ote = Z({
  name: "VcTable",
  inheritAttrs: !1,
  props: ["prefixCls", "data", "columns", "rowKey", "tableLayout", "scroll", "rowClassName", "title", "footer", "id", "showHeader", "components", "customRow", "customHeaderRow", "direction", "expandFixed", "expandColumnWidth", "expandedRowKeys", "defaultExpandedRowKeys", "expandedRowRender", "expandRowByClick", "expandIcon", "onExpand", "onExpandedRowsChange", "onUpdate:expandedRowKeys", "defaultExpandAllRows", "indentSize", "expandIconColumnIndex", "expandedRowClassName", "childrenColumnName", "rowExpandable", "sticky", "transformColumns", "internalHooks", "internalRefs", "canExpandable", "onUpdateInternalRefs", "transformCellText"],
  emits: ["expand", "expandedRowsChange", "updateInternalRefs", "update:expandedRowKeys"],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r
    } = t;
    const l = P(() => e.data || tte), a = P(() => !!l.value.length), i = P(() => pee(e.components, {})), s = (oe, pe) => g6(i.value, oe) || pe, c = P(() => {
      const oe = e.rowKey;
      return typeof oe == "function" ? oe : (pe) => {
        const Pe = pe && pe[oe];
        return process.env.NODE_ENV !== "production" && ct(Pe !== void 0, "Each record in table should have a unique `key` prop, or set `rowKey` to an unique primary key."), Pe;
      };
    }), u = P(() => e.expandIcon || qee), d = P(() => e.childrenColumnName || "children"), p = P(() => e.expandedRowRender ? "row" : e.canExpandable || l.value.some((oe) => oe && typeof oe == "object" && oe[d.value]) ? "nest" : !1), v = Q([]);
    Le(() => {
      e.defaultExpandedRowKeys && (v.value = e.defaultExpandedRowKeys), e.defaultExpandAllRows && (v.value = Zee(l.value, c.value, d.value));
    })();
    const g = P(() => new Set(e.expandedRowKeys || v.value || [])), b = (oe) => {
      const pe = c.value(oe, l.value.indexOf(oe));
      let Pe;
      const Ee = g.value.has(pe);
      Ee ? (g.value.delete(pe), Pe = [...g.value]) : Pe = [...g.value, pe], v.value = Pe, r("expand", !Ee, oe), r("update:expandedRowKeys", Pe), r("expandedRowsChange", Pe);
    };
    process.env.NODE_ENV !== "production" && e.expandedRowRender && l.value.some((oe) => Array.isArray(oe == null ? void 0 : oe[d.value])) && ct(!1, "`expandedRowRender` should not use with nested Table");
    const y = Y(0), [S, C] = Lee(m(m({}, Qo(e)), {
      // children,
      expandable: P(() => !!e.expandedRowRender),
      expandedKeys: g,
      getRowKey: c,
      onTriggerExpand: b,
      expandIcon: u
    }), P(() => e.internalHooks === Dm ? e.transformColumns : null)), w = P(() => ({
      columns: S.value,
      flattenColumns: C.value
    })), $ = Y(), O = Y(), x = Y(), I = Y({
      scrollWidth: 0,
      clientWidth: 0
    }), E = Y(), [_, M] = Pt(!1), [R, A] = Pt(!1), [z, T] = O6(/* @__PURE__ */ new Map()), N = P(() => Ip(C.value)), k = P(() => N.value.map((oe) => z.value.get(oe))), B = P(() => C.value.length), F = Hee(k, B, Te(e, "direction")), L = P(() => e.scroll && Tm(e.scroll.y)), j = P(() => e.scroll && Tm(e.scroll.x) || !!e.expandFixed), H = P(() => j.value && C.value.some((oe) => {
      let {
        fixed: pe
      } = oe;
      return pe;
    })), K = Y(), X = Jee(Te(e, "sticky"), Te(e, "prefixCls")), W = xt({}), q = P(() => {
      const oe = Object.values(W)[0];
      return (L.value || X.value.isSticky) && oe;
    }), J = (oe, pe) => {
      pe ? W[oe] = pe : delete W[oe];
    }, ne = Y({}), te = Y({}), G = Y({});
    Le(() => {
      L.value && (te.value = {
        overflowY: "scroll",
        maxHeight: jl(e.scroll.y)
      }), j.value && (ne.value = {
        overflowX: "auto"
      }, L.value || (te.value = {
        overflowY: "hidden"
      }), G.value = {
        width: e.scroll.x === !0 ? "auto" : jl(e.scroll.x),
        minWidth: "100%"
      });
    });
    const U = (oe, pe) => {
      If($.value) && T((Pe) => {
        if (Pe.get(oe) !== pe) {
          const Ee = new Map(Pe);
          return Ee.set(oe, pe), Ee;
        }
        return Pe;
      });
    }, [re, se] = zee();
    function me(oe, pe) {
      if (!pe)
        return;
      if (typeof pe == "function") {
        pe(oe);
        return;
      }
      const Pe = pe.$el || pe;
      Pe.scrollLeft !== oe && (Pe.scrollLeft = oe);
    }
    const Ce = (oe) => {
      let {
        currentTarget: pe,
        scrollLeft: Pe
      } = oe;
      var Ee;
      const ze = e.direction === "rtl", ge = typeof Pe == "number" ? Pe : pe.scrollLeft, ye = pe || nte;
      if ((!se() || se() === ye) && (re(ye), me(ge, O.value), me(ge, x.value), me(ge, E.value), me(ge, (Ee = K.value) === null || Ee === void 0 ? void 0 : Ee.setScrollLeft)), pe) {
        const {
          scrollWidth: $e,
          clientWidth: Ae
        } = pe;
        ze ? (M(-ge < $e - Ae), A(-ge > 0)) : (M(ge > 0), A(ge < $e - Ae));
      }
    }, fe = () => {
      j.value && x.value ? Ce({
        currentTarget: x.value
      }) : (M(!1), A(!1));
    };
    let be;
    const ue = (oe) => {
      oe !== y.value && (fe(), y.value = $.value ? $.value.offsetWidth : oe);
    }, de = (oe) => {
      let {
        width: pe
      } = oe;
      if (clearTimeout(be), y.value === 0) {
        ue(pe);
        return;
      }
      be = setTimeout(() => {
        ue(pe);
      }, 100);
    };
    ie([j, () => e.data, () => e.columns], () => {
      j.value && fe();
    }, {
      flush: "post"
    });
    const [Se, xe] = Pt(0);
    yee(), Ke(() => {
      rt(() => {
        var oe, pe;
        fe(), xe(UA(x.value).width), I.value = {
          scrollWidth: ((oe = x.value) === null || oe === void 0 ? void 0 : oe.scrollWidth) || 0,
          clientWidth: ((pe = x.value) === null || pe === void 0 ? void 0 : pe.clientWidth) || 0
        };
      });
    }), co(() => {
      rt(() => {
        var oe, pe;
        const Pe = ((oe = x.value) === null || oe === void 0 ? void 0 : oe.scrollWidth) || 0, Ee = ((pe = x.value) === null || pe === void 0 ? void 0 : pe.clientWidth) || 0;
        (I.value.scrollWidth !== Pe || I.value.clientWidth !== Ee) && (I.value = {
          scrollWidth: Pe,
          clientWidth: Ee
        });
      });
    }), Le(() => {
      e.internalHooks === Dm && e.internalRefs && e.onUpdateInternalRefs({
        body: x.value ? x.value.$el || x.value : null
      });
    }, {
      flush: "post"
    });
    const he = P(() => e.tableLayout ? e.tableLayout : H.value ? e.scroll.x === "max-content" ? "auto" : "fixed" : L.value || X.value.isSticky || C.value.some((oe) => {
      let {
        ellipsis: pe
      } = oe;
      return pe;
    }) ? "fixed" : "auto"), we = () => {
      var oe;
      return a.value ? null : ((oe = o.emptyText) === null || oe === void 0 ? void 0 : oe.call(o)) || "No Data";
    };
    dee(xt(m(m({}, Qo(uw(e, "prefixCls", "direction", "transformCellText"))), {
      getComponent: s,
      scrollbarSize: Se,
      fixedInfoList: P(() => C.value.map((oe, pe) => zb(pe, pe, C.value, F.value, e.direction))),
      isSticky: P(() => X.value.isSticky),
      summaryCollect: J
    }))), Mee(xt(m(m({}, Qo(uw(e, "rowClassName", "expandedRowClassName", "expandRowByClick", "expandedRowRender", "expandIconColumnIndex", "indentSize"))), {
      columns: S,
      flattenColumns: C,
      tableLayout: he,
      expandIcon: u,
      expandableType: p,
      onTriggerExpand: b
    }))), Dee({
      onColumnResize: U
    }), Iee({
      componentWidth: y,
      fixHeader: L,
      fixColumn: H,
      horizonScroll: j
    });
    const Me = () => f(Ree, {
      data: l.value,
      measureColumnWidth: L.value || j.value || X.value.isSticky,
      expandedKeys: g.value,
      rowExpandable: e.rowExpandable,
      getRowKey: c.value,
      customRow: e.customRow,
      childrenColumnName: d.value
    }, {
      emptyNode: we
    }), ae = () => f(P6, {
      colWidths: C.value.map((oe) => {
        let {
          width: pe
        } = oe;
        return pe;
      }),
      columns: C.value
    }, null);
    return () => {
      var oe;
      const {
        prefixCls: pe,
        scroll: Pe,
        tableLayout: Ee,
        direction: ze,
        // Additional Part
        title: ge = o.title,
        footer: ye = o.footer,
        // Customize
        id: $e,
        showHeader: Ae,
        customHeaderRow: Ve
      } = e, {
        isSticky: De,
        offsetHeader: We,
        offsetSummary: at,
        offsetScroll: gt,
        stickyClassName: ut,
        container: St
      } = X.value, wt = s(["table"], "table"), Xt = s(["body"]), qt = (oe = o.summary) === null || oe === void 0 ? void 0 : oe.call(o, {
        pageData: l.value
      });
      let gn = () => null;
      const Zt = {
        colWidths: k.value,
        columCount: C.value.length,
        stickyOffsets: F.value,
        customHeaderRow: Ve,
        fixHeader: L.value,
        scroll: Pe
      };
      if (process.env.NODE_ENV !== "production" && typeof Xt == "function" && a.value && !L.value && ct(!1, "`components.body` with render props is only work on `scroll.y`."), L.value || De) {
        let Io = () => null;
        typeof Xt == "function" ? (Io = () => Xt(l.value, {
          scrollbarSize: Se.value,
          ref: x,
          onScroll: Ce
        }), Zt.colWidths = C.value.map((eo, Ml) => {
          let {
            width: Oe
          } = eo;
          const Ue = Ml === S.value.length - 1 ? Oe - Se.value : Oe;
          return typeof Ue == "number" && !Number.isNaN(Ue) ? Ue : (ct(!1, "When use `components.body` with render props. Each column should have a fixed `width` value."), 0);
        })) : Io = () => f("div", {
          style: m(m({}, ne.value), te.value),
          onScroll: Ce,
          ref: x,
          class: ee(`${pe}-body`)
        }, [f(wt, {
          style: m(m({}, G.value), {
            tableLayout: he.value
          })
        }, {
          default: () => [ae(), Me(), !q.value && qt && f(ou, {
            stickyOffsets: F.value,
            flattenColumns: C.value
          }, {
            default: () => [qt]
          })]
        })]);
        const Vo = m(m(m({
          noData: !l.value.length,
          maxContentScroll: j.value && Pe.x === "max-content"
        }, Zt), w.value), {
          direction: ze,
          stickyClassName: ut,
          onScroll: Ce
        });
        gn = () => f(Fe, null, [Ae !== !1 && f(cw, D(D({}, Vo), {}, {
          stickyTopOffset: We,
          class: `${pe}-header`,
          ref: O
        }), {
          default: (eo) => f(Fe, null, [f(iw, eo, null), q.value === "top" && f(ou, eo, {
            default: () => [qt]
          })])
        }), Io(), q.value && q.value !== "top" && f(cw, D(D({}, Vo), {}, {
          stickyBottomOffset: at,
          class: `${pe}-summary`,
          ref: E
        }), {
          default: (eo) => f(ou, eo, {
            default: () => [qt]
          })
        }), De && x.value && f(Qee, {
          ref: K,
          offsetScroll: gt,
          scrollBodyRef: x,
          onScroll: Ce,
          container: St,
          scrollBodySizeInfo: I.value
        }, null)]);
      } else
        gn = () => f("div", {
          style: m(m({}, ne.value), te.value),
          class: ee(`${pe}-content`),
          onScroll: Ce,
          ref: x
        }, [f(wt, {
          style: m(m({}, G.value), {
            tableLayout: he.value
          })
        }, {
          default: () => [ae(), Ae !== !1 && f(iw, D(D({}, Zt), w.value), null), Me(), qt && f(ou, {
            stickyOffsets: F.value,
            flattenColumns: C.value
          }, {
            default: () => [qt]
          })]
        })]);
      const An = wl(n, {
        aria: !0,
        data: !0
      }), Jn = () => f("div", D(D({}, An), {}, {
        class: ee(pe, {
          [`${pe}-rtl`]: ze === "rtl",
          [`${pe}-ping-left`]: _.value,
          [`${pe}-ping-right`]: R.value,
          [`${pe}-layout-fixed`]: Ee === "fixed",
          [`${pe}-fixed-header`]: L.value,
          /** No used but for compatible */
          [`${pe}-fixed-column`]: H.value,
          [`${pe}-scroll-horizontal`]: j.value,
          [`${pe}-has-fix-left`]: C.value[0] && C.value[0].fixed,
          [`${pe}-has-fix-right`]: C.value[B.value - 1] && C.value[B.value - 1].fixed === "right",
          [n.class]: n.class
        }),
        style: n.style,
        id: $e,
        ref: $
      }), [ge && f(Am, {
        class: `${pe}-title`
      }, {
        default: () => [ge(l.value)]
      }), f("div", {
        class: `${pe}-container`
      }, [gn()]), ye && f(Am, {
        class: `${pe}-footer`
      }, {
        default: () => [ye(l.value)]
      })]);
      return j.value ? f(Fo, {
        onResize: de
      }, {
        default: Jn
      }) : Jn();
    };
  }
});
function rte() {
  const e = m({}, arguments.length <= 0 ? void 0 : arguments[0]);
  for (let t = 1; t < arguments.length; t++) {
    const n = t < 0 || arguments.length <= t ? void 0 : arguments[t];
    n && Object.keys(n).forEach((o) => {
      const r = n[o];
      r !== void 0 && (e[o] = r);
    });
  }
  return e;
}
const Nm = 10;
function lte(e, t) {
  const n = {
    current: e.current,
    pageSize: e.pageSize
  };
  return Object.keys(t && typeof t == "object" ? t : {}).forEach((r) => {
    const l = e[r];
    typeof l != "function" && (n[r] = l);
  }), n;
}
function ate(e, t, n) {
  const o = P(() => t.value && typeof t.value == "object" ? t.value : {}), r = P(() => o.value.total || 0), [l, a] = Pt(() => ({
    current: "defaultCurrent" in o.value ? o.value.defaultCurrent : 1,
    pageSize: "defaultPageSize" in o.value ? o.value.defaultPageSize : Nm
  })), i = P(() => {
    const u = rte(l.value, o.value, {
      total: r.value > 0 ? r.value : e.value
    }), d = Math.ceil((r.value || e.value) / u.pageSize);
    return u.current > d && (u.current = d || 1), u;
  }), s = (u, d) => {
    t.value !== !1 && a({
      current: u ?? 1,
      pageSize: d || i.value.pageSize
    });
  }, c = (u, d) => {
    var p, v;
    t.value && ((v = (p = o.value).onChange) === null || v === void 0 || v.call(p, u, d)), s(u, d), n(u, d || i.value.pageSize);
  };
  return [P(() => t.value === !1 ? {} : m(m({}, i.value), {
    onChange: c
  })), s];
}
function ite(e, t, n) {
  const o = Q({});
  ie([e, t, n], () => {
    const l = /* @__PURE__ */ new Map(), a = n.value, i = t.value;
    function s(c) {
      c.forEach((u, d) => {
        const p = a(u, d);
        l.set(p, u), u && typeof u == "object" && i in u && s(u[i] || []);
      });
    }
    s(e.value), o.value = {
      kvMap: l
    };
  }, {
    deep: !0,
    immediate: !0
  });
  function r(l) {
    return o.value.kvMap.get(l);
  }
  return [r];
}
const Yo = {}, Rm = "SELECT_ALL", km = "SELECT_INVERT", Bm = "SELECT_NONE", ste = [];
function E6(e, t) {
  let n = [];
  return (t || []).forEach((o) => {
    n.push(o), o && typeof o == "object" && e in o && (n = [...n, ...E6(e, o[e])]);
  }), n;
}
function cte(e, t) {
  const n = P(() => {
    const E = e.value || {}, {
      checkStrictly: _ = !0
    } = E;
    return m(m({}, E), {
      checkStrictly: _
    });
  }), [o, r] = Rt(n.value.selectedRowKeys || n.value.defaultSelectedRowKeys || ste, {
    value: P(() => n.value.selectedRowKeys)
  }), l = Q(/* @__PURE__ */ new Map()), a = (E) => {
    if (n.value.preserveSelectedRowKeys) {
      const _ = /* @__PURE__ */ new Map();
      E.forEach((M) => {
        let R = t.getRecordByKey(M);
        !R && l.value.has(M) && (R = l.value.get(M)), _.set(M, R);
      }), l.value = _;
    }
  };
  Le(() => {
    a(o.value);
  });
  const i = P(() => n.value.checkStrictly ? null : bc(t.data.value, {
    externalGetKey: t.getRowKey.value,
    childrenPropName: t.childrenColumnName.value
  }).keyEntities), s = P(() => E6(t.childrenColumnName.value, t.pageData.value)), c = P(() => {
    const E = /* @__PURE__ */ new Map(), _ = t.getRowKey.value, M = n.value.getCheckboxProps;
    return s.value.forEach((R, A) => {
      const z = _(R, A), T = (M ? M(R) : null) || {};
      E.set(z, T), process.env.NODE_ENV !== "production" && ("checked" in T || "defaultChecked" in T) && nt(!1, "Table", "Do not set `checked` or `defaultChecked` in `getCheckboxProps`. Please use `selectedRowKeys` instead.");
    }), E;
  }), {
    maxLevel: u,
    levelEntities: d
  } = fp(i), p = (E) => {
    var _;
    return !!(!((_ = c.value.get(t.getRowKey.value(E))) === null || _ === void 0) && _.disabled);
  }, v = P(() => {
    if (n.value.checkStrictly)
      return [o.value || [], []];
    const {
      checkedKeys: E,
      halfCheckedKeys: _
    } = Bo(o.value, !0, i.value, u.value, d.value, p);
    return [E || [], _];
  }), h = P(() => v.value[0]), g = P(() => v.value[1]), b = P(() => {
    const E = n.value.type === "radio" ? h.value.slice(0, 1) : h.value;
    return new Set(E);
  }), y = P(() => n.value.type === "radio" ? /* @__PURE__ */ new Set() : new Set(g.value)), [S, C] = Pt(null), w = (E) => {
    let _, M;
    a(E);
    const {
      preserveSelectedRowKeys: R,
      onChange: A
    } = n.value, {
      getRecordByKey: z
    } = t;
    R ? (_ = E, M = E.map((T) => l.value.get(T))) : (_ = [], M = [], E.forEach((T) => {
      const N = z(T);
      N !== void 0 && (_.push(T), M.push(N));
    })), r(_), A == null || A(_, M);
  }, $ = (E, _, M, R) => {
    const {
      onSelect: A
    } = n.value, {
      getRecordByKey: z
    } = t || {};
    if (A) {
      const T = M.map((N) => z(N));
      A(z(E), _, T, R);
    }
    w(M);
  }, O = P(() => {
    const {
      onSelectInvert: E,
      onSelectNone: _,
      selections: M,
      hideSelectAll: R
    } = n.value, {
      data: A,
      pageData: z,
      getRowKey: T,
      locale: N
    } = t;
    return !M || R ? null : (M === !0 ? [Rm, km, Bm] : M).map((B) => B === Rm ? {
      key: "all",
      text: N.value.selectionAll,
      onSelect() {
        w(A.value.map((F, L) => T.value(F, L)).filter((F) => {
          const L = c.value.get(F);
          return !(L != null && L.disabled) || b.value.has(F);
        }));
      }
    } : B === km ? {
      key: "invert",
      text: N.value.selectInvert,
      onSelect() {
        const F = new Set(b.value);
        z.value.forEach((j, H) => {
          const K = T.value(j, H), X = c.value.get(K);
          X != null && X.disabled || (F.has(K) ? F.delete(K) : F.add(K));
        });
        const L = Array.from(F);
        E && (nt(!1, "Table", "`onSelectInvert` will be removed in future. Please use `onChange` instead."), E(L)), w(L);
      }
    } : B === Bm ? {
      key: "none",
      text: N.value.selectNone,
      onSelect() {
        _ == null || _(), w(Array.from(b.value).filter((F) => {
          const L = c.value.get(F);
          return L == null ? void 0 : L.disabled;
        }));
      }
    } : B);
  }), x = P(() => s.value.length);
  return [(E) => {
    var _;
    const {
      onSelectAll: M,
      onSelectMultiple: R,
      columnWidth: A,
      type: z,
      fixed: T,
      renderCell: N,
      hideSelectAll: k,
      checkStrictly: B
    } = n.value, {
      prefixCls: F,
      getRecordByKey: L,
      getRowKey: j,
      expandType: H,
      getPopupContainer: K
    } = t;
    if (!e.value)
      return process.env.NODE_ENV !== "production" && nt(!E.includes(Yo), "Table", "`rowSelection` is not config but `SELECTION_COLUMN` exists in the `columns`."), E.filter((ue) => ue !== Yo);
    let X = E.slice();
    const W = new Set(b.value), q = s.value.map(j.value).filter((ue) => !c.value.get(ue).disabled), J = q.every((ue) => W.has(ue)), ne = q.some((ue) => W.has(ue)), te = () => {
      const ue = [];
      J ? q.forEach((Se) => {
        W.delete(Se), ue.push(Se);
      }) : q.forEach((Se) => {
        W.has(Se) || (W.add(Se), ue.push(Se));
      });
      const de = Array.from(W);
      M == null || M(!J, de.map((Se) => L(Se)), ue.map((Se) => L(Se))), w(de);
    };
    let G;
    if (z !== "radio") {
      let ue;
      if (O.value) {
        const we = f(en, {
          getPopupContainer: K.value
        }, {
          default: () => [O.value.map((Me, ae) => {
            const {
              key: oe,
              text: pe,
              onSelect: Pe
            } = Me;
            return f(en.Item, {
              key: oe || ae,
              onClick: () => {
                Pe == null || Pe(q);
              }
            }, {
              default: () => [pe]
            });
          })]
        });
        ue = f("div", {
          class: `${F.value}-selection-extra`
        }, [f(er, {
          overlay: we,
          getPopupContainer: K.value
        }, {
          default: () => [f("span", null, [f(Or, null, null)])]
        })]);
      }
      const de = s.value.map((we, Me) => {
        const ae = j.value(we, Me), oe = c.value.get(ae) || {};
        return m({
          checked: W.has(ae)
        }, oe);
      }).filter((we) => {
        let {
          disabled: Me
        } = we;
        return Me;
      }), Se = !!de.length && de.length === x.value, xe = Se && de.every((we) => {
        let {
          checked: Me
        } = we;
        return Me;
      }), he = Se && de.some((we) => {
        let {
          checked: Me
        } = we;
        return Me;
      });
      G = !k && f("div", {
        class: `${F.value}-selection`
      }, [f(io, {
        checked: Se ? xe : !!x.value && J,
        indeterminate: Se ? !xe && he : !J && ne,
        onChange: te,
        disabled: x.value === 0 || Se,
        "aria-label": ue ? "Custom selection" : "Select all",
        skipGroup: !0
      }, null), ue]);
    }
    let U;
    z === "radio" ? U = (ue) => {
      let {
        record: de,
        index: Se
      } = ue;
      const xe = j.value(de, Se), he = W.has(xe);
      return {
        node: f(Un, D(D({}, c.value.get(xe)), {}, {
          checked: he,
          onClick: (we) => we.stopPropagation(),
          onChange: (we) => {
            W.has(xe) || $(xe, !0, [xe], we.nativeEvent);
          }
        }), null),
        checked: he
      };
    } : U = (ue) => {
      let {
        record: de,
        index: Se
      } = ue;
      var xe;
      const he = j.value(de, Se), we = W.has(he), Me = y.value.has(he), ae = c.value.get(he);
      let oe;
      return H.value === "nest" ? (oe = Me, nt(typeof (ae == null ? void 0 : ae.indeterminate) != "boolean", "Table", "set `indeterminate` using `rowSelection.getCheckboxProps` is not allowed with tree structured dataSource.")) : oe = (xe = ae == null ? void 0 : ae.indeterminate) !== null && xe !== void 0 ? xe : Me, {
        node: f(io, D(D({}, ae), {}, {
          indeterminate: oe,
          checked: we,
          skipGroup: !0,
          onClick: (pe) => pe.stopPropagation(),
          onChange: (pe) => {
            let {
              nativeEvent: Pe
            } = pe;
            const {
              shiftKey: Ee
            } = Pe;
            let ze = -1, ge = -1;
            if (Ee && B) {
              const ye = /* @__PURE__ */ new Set([S.value, he]);
              q.some(($e, Ae) => {
                if (ye.has($e))
                  if (ze === -1)
                    ze = Ae;
                  else
                    return ge = Ae, !0;
                return !1;
              });
            }
            if (ge !== -1 && ze !== ge && B) {
              const ye = q.slice(ze, ge + 1), $e = [];
              we ? ye.forEach((Ve) => {
                W.has(Ve) && ($e.push(Ve), W.delete(Ve));
              }) : ye.forEach((Ve) => {
                W.has(Ve) || ($e.push(Ve), W.add(Ve));
              });
              const Ae = Array.from(W);
              R == null || R(!we, Ae.map((Ve) => L(Ve)), $e.map((Ve) => L(Ve))), w(Ae);
            } else {
              const ye = h.value;
              if (B) {
                const $e = we ? dr(ye, he) : _r(ye, he);
                $(he, !we, $e, Pe);
              } else {
                const $e = Bo([...ye, he], !0, i.value, u.value, d.value, p), {
                  checkedKeys: Ae,
                  halfCheckedKeys: Ve
                } = $e;
                let De = Ae;
                if (we) {
                  const We = new Set(Ae);
                  We.delete(he), De = Bo(Array.from(We), {
                    checked: !1,
                    halfCheckedKeys: Ve
                  }, i.value, u.value, d.value, p).checkedKeys;
                }
                $(he, !we, De, Pe);
              }
            }
            C(he);
          }
        }), null),
        checked: we
      };
    };
    const re = (ue) => {
      let {
        record: de,
        index: Se
      } = ue;
      const {
        node: xe,
        checked: he
      } = U({
        record: de,
        index: Se
      });
      return N ? N(he, de, Se, xe) : xe;
    };
    if (!X.includes(Yo))
      if (X.findIndex((ue) => {
        var de;
        return ((de = ue[di]) === null || de === void 0 ? void 0 : de.columnType) === "EXPAND_COLUMN";
      }) === 0) {
        const [ue, ...de] = X;
        X = [ue, Yo, ...de];
      } else
        X = [Yo, ...X];
    const se = X.indexOf(Yo);
    process.env.NODE_ENV !== "production" && X.filter((ue) => ue === Yo).length > 1 && nt(!1, "Table", "Multiple `SELECTION_COLUMN` exist in `columns`."), X = X.filter((ue, de) => ue !== Yo || de === se);
    const me = X[se - 1], Ce = X[se + 1];
    let fe = T;
    fe === void 0 && ((Ce == null ? void 0 : Ce.fixed) !== void 0 ? fe = Ce.fixed : (me == null ? void 0 : me.fixed) !== void 0 && (fe = me.fixed)), fe && me && ((_ = me[di]) === null || _ === void 0 ? void 0 : _.columnType) === "EXPAND_COLUMN" && me.fixed === void 0 && (me.fixed = fe);
    const be = {
      fixed: fe,
      width: A,
      className: `${F.value}-selection-column`,
      title: n.value.columnTitle || G,
      customRender: re,
      [di]: {
        class: `${F.value}-selection-col`
      }
    };
    return X.map((ue) => ue === Yo ? be : ue);
  }, b];
}
var ute = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "outlined" };
function dw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      dte(e, r, n[r]);
    });
  }
  return e;
}
function dte(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Hb = function(t, n) {
  var o = dw({}, t, n.attrs);
  return f(Ge, dw({}, o, {
    icon: ute
  }), null);
};
Hb.displayName = "CaretDownOutlined";
Hb.inheritAttrs = !1;
var fte = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z" } }] }, name: "caret-up", theme: "outlined" };
function fw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      pte(e, r, n[r]);
    });
  }
  return e;
}
function pte(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var jb = function(t, n) {
  var o = fw({}, t, n.attrs);
  return f(Ge, fw({}, o, {
    icon: fte
  }), null);
};
jb.displayName = "CaretUpOutlined";
jb.inheritAttrs = !1;
var vte = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function va(e, t) {
  return "key" in e && e.key !== void 0 && e.key !== null ? e.key : e.dataIndex ? Array.isArray(e.dataIndex) ? e.dataIndex.join(".") : e.dataIndex : t;
}
function wc(e, t) {
  return t ? `${t}-${e}` : `${e}`;
}
function Vb(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function T6() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  const t = It(e), n = [];
  return t.forEach((o) => {
    var r, l, a, i;
    if (!o)
      return;
    const s = o.key, c = ((r = o.props) === null || r === void 0 ? void 0 : r.style) || {}, u = ((l = o.props) === null || l === void 0 ? void 0 : l.class) || "", d = o.props || {};
    for (const [b, y] of Object.entries(d))
      d[Oi(b)] = y;
    const p = o.children || {}, {
      default: v
    } = p, h = vte(p, ["default"]), g = m(m(m({}, h), d), {
      style: c,
      class: u
    });
    if (s && (g.key = s), !((a = o.type) === null || a === void 0) && a.__ANT_TABLE_COLUMN_GROUP)
      g.children = T6(typeof v == "function" ? v() : v);
    else {
      const b = (i = o.children) === null || i === void 0 ? void 0 : i.default;
      g.customRender = g.customRender || b;
    }
    n.push(g);
  }), n;
}
const Hu = "ascend", Vv = "descend";
function nf(e) {
  return typeof e.sorter == "object" && typeof e.sorter.multiple == "number" ? e.sorter.multiple : !1;
}
function pw(e) {
  return typeof e == "function" ? e : e && typeof e == "object" && e.compare ? e.compare : !1;
}
function gte(e, t) {
  return t ? e[e.indexOf(t) + 1] : e[0];
}
function Fm(e, t, n) {
  let o = [];
  function r(l, a) {
    o.push({
      column: l,
      key: va(l, a),
      multiplePriority: nf(l),
      sortOrder: l.sortOrder
    });
  }
  return (e || []).forEach((l, a) => {
    const i = wc(a, n);
    l.children ? ("sortOrder" in l && r(l, i), o = [...o, ...Fm(l.children, t, i)]) : l.sorter && ("sortOrder" in l ? r(l, i) : t && l.defaultSortOrder && o.push({
      column: l,
      key: va(l, i),
      multiplePriority: nf(l),
      sortOrder: l.defaultSortOrder
    }));
  }), o;
}
function M6(e, t, n, o, r, l, a, i) {
  return (t || []).map((s, c) => {
    const u = wc(c, i);
    let d = s;
    if (d.sorter) {
      const p = d.sortDirections || r, v = d.showSorterTooltip === void 0 ? a : d.showSorterTooltip, h = va(d, u), g = n.find((E) => {
        let {
          key: _
        } = E;
        return _ === h;
      }), b = g ? g.sortOrder : null, y = gte(p, b), S = p.includes(Hu) && f(jb, {
        class: ee(`${e}-column-sorter-up`, {
          active: b === Hu
        }),
        role: "presentation"
      }, null), C = p.includes(Vv) && f(Hb, {
        role: "presentation",
        class: ee(`${e}-column-sorter-down`, {
          active: b === Vv
        })
      }, null), {
        cancelSort: w,
        triggerAsc: $,
        triggerDesc: O
      } = l || {};
      let x = w;
      y === Vv ? x = O : y === Hu && (x = $);
      const I = typeof v == "object" ? v : {
        title: x
      };
      d = m(m({}, d), {
        className: ee(d.className, {
          [`${e}-column-sort`]: b
        }),
        title: (E) => {
          const _ = f("div", {
            class: `${e}-column-sorters`
          }, [f("span", {
            class: `${e}-column-title`
          }, [Vb(s.title, E)]), f("span", {
            class: ee(`${e}-column-sorter`, {
              [`${e}-column-sorter-full`]: !!(S && C)
            })
          }, [f("span", {
            class: `${e}-column-sorter-inner`
          }, [S, C])])]);
          return v ? f(Ln, I, {
            default: () => [_]
          }) : _;
        },
        customHeaderCell: (E) => {
          const _ = s.customHeaderCell && s.customHeaderCell(E) || {}, M = _.onClick, R = _.onKeydown;
          return _.onClick = (A) => {
            o({
              column: s,
              key: h,
              sortOrder: y,
              multiplePriority: nf(s)
            }), M && M(A);
          }, _.onKeydown = (A) => {
            A.keyCode === ce.ENTER && (o({
              column: s,
              key: h,
              sortOrder: y,
              multiplePriority: nf(s)
            }), R == null || R(A));
          }, b && (_["aria-sort"] = b === "ascend" ? "ascending" : "descending"), _.class = ee(_.class, `${e}-column-has-sorters`), _.tabindex = 0, _;
        }
      });
    }
    return "children" in d && (d = m(m({}, d), {
      children: M6(e, d.children, n, o, r, l, a, u)
    })), d;
  });
}
function vw(e) {
  const {
    column: t,
    sortOrder: n
  } = e;
  return {
    column: t,
    order: n,
    field: t.dataIndex,
    columnKey: t.key
  };
}
function gw(e) {
  const t = e.filter((n) => {
    let {
      sortOrder: o
    } = n;
    return o;
  }).map(vw);
  return t.length === 0 && e.length ? m(m({}, vw(e[e.length - 1])), {
    column: void 0
  }) : t.length <= 1 ? t[0] || {} : t;
}
function Lm(e, t, n) {
  const o = t.slice().sort((a, i) => i.multiplePriority - a.multiplePriority), r = e.slice(), l = o.filter((a) => {
    let {
      column: {
        sorter: i
      },
      sortOrder: s
    } = a;
    return pw(i) && s;
  });
  return l.length ? r.sort((a, i) => {
    for (let s = 0; s < l.length; s += 1) {
      const c = l[s], {
        column: {
          sorter: u
        },
        sortOrder: d
      } = c, p = pw(u);
      if (p && d) {
        const v = p(a, i, d);
        if (v !== 0)
          return d === Hu ? v : -v;
      }
    }
    return 0;
  }).map((a) => {
    const i = a[n];
    return i ? m(m({}, a), {
      [n]: Lm(i, t, n)
    }) : a;
  }) : r;
}
function mte(e) {
  let {
    prefixCls: t,
    mergedColumns: n,
    onSorterChange: o,
    sortDirections: r,
    tableLocale: l,
    showSorterTooltip: a
  } = e;
  const [i, s] = Pt(Fm(n.value, !0)), c = P(() => {
    let h = !0;
    const g = Fm(n.value, !1);
    if (!g.length)
      return i.value;
    const b = [];
    function y(C) {
      h ? b.push(C) : b.push(m(m({}, C), {
        sortOrder: null
      }));
    }
    let S = null;
    return g.forEach((C) => {
      S === null ? (y(C), C.sortOrder && (C.multiplePriority === !1 ? h = !1 : S = !0)) : (S && C.multiplePriority !== !1 || (h = !1), y(C));
    }), b;
  }), u = P(() => {
    const h = c.value.map((g) => {
      let {
        column: b,
        sortOrder: y
      } = g;
      return {
        column: b,
        order: y
      };
    });
    return {
      sortColumns: h,
      // Legacy
      sortColumn: h[0] && h[0].column,
      sortOrder: h[0] && h[0].order
    };
  });
  function d(h) {
    let g;
    h.multiplePriority === !1 || !c.value.length || c.value[0].multiplePriority === !1 ? g = [h] : g = [...c.value.filter((b) => {
      let {
        key: y
      } = b;
      return y !== h.key;
    }), h], s(g), o(gw(g), g);
  }
  const p = (h) => M6(t.value, h, c.value, d, r.value, l.value, a.value), v = P(() => gw(c.value));
  return [p, c, u, v];
}
var hte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M349 838c0 17.7 14.2 32 31.8 32h262.4c17.6 0 31.8-14.3 31.8-32V642H349v196zm531.1-684H143.9c-24.5 0-39.8 26.7-27.5 48l221.3 376h348.8l221.3-376c12.1-21.3-3.2-48-27.7-48z" } }] }, name: "filter", theme: "filled" };
function mw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      bte(e, r, n[r]);
    });
  }
  return e;
}
function bte(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Wb = function(t, n) {
  var o = mw({}, t, n.attrs);
  return f(Ge, mw({}, o, {
    icon: hte
  }), null);
};
Wb.displayName = "FilterFilled";
Wb.inheritAttrs = !1;
const yte = (e) => {
  const {
    keyCode: t
  } = e;
  t === ce.ENTER && e.stopPropagation();
}, Ste = (e, t) => {
  let {
    slots: n
  } = t;
  var o;
  return f("div", {
    onClick: (r) => r.stopPropagation(),
    onKeydown: yte
  }, [(o = n.default) === null || o === void 0 ? void 0 : o.call(n)]);
}, hw = Z({
  compatConfig: {
    MODE: 3
  },
  name: "FilterSearch",
  inheritAttrs: !1,
  props: {
    value: ke(),
    onChange: le(),
    filterSearch: je([Boolean, Function]),
    tablePrefixCls: ke(),
    locale: Re()
  },
  setup(e) {
    return () => {
      const {
        value: t,
        onChange: n,
        filterSearch: o,
        tablePrefixCls: r,
        locale: l
      } = e;
      return o ? f("div", {
        class: `${r}-filter-dropdown-search`
      }, [f(fn, {
        placeholder: l.filterSearchPlaceholder,
        onChange: n,
        value: t,
        htmlSize: 1,
        class: `${r}-filter-dropdown-search-input`
      }, {
        prefix: () => f(_i, null, null)
      })]) : null;
    };
  }
});
var bw = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Cte = Z({
  compatConfig: {
    MODE: 3
  },
  name: "MotionTreeNode",
  inheritAttrs: !1,
  props: m(m({}, sP), {
    active: Boolean,
    motion: Object,
    motionNodes: {
      type: Array
    },
    onMotionStart: Function,
    onMotionEnd: Function,
    motionType: String
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = Q(!0), l = tb(), a = Q(!1), i = P(() => e.motion ? e.motion : dc()), s = (c, u) => {
      var d, p, v, h;
      u === "appear" ? (p = (d = i.value) === null || d === void 0 ? void 0 : d.onAfterEnter) === null || p === void 0 || p.call(d, c) : u === "leave" && ((h = (v = i.value) === null || v === void 0 ? void 0 : v.onAfterLeave) === null || h === void 0 || h.call(v, c)), a.value || e.onMotionEnd(), a.value = !0;
    };
    return ie(() => e.motionNodes, () => {
      e.motionNodes && e.motionType === "hide" && r.value && rt(() => {
        r.value = !1;
      });
    }, {
      immediate: !0,
      flush: "post"
    }), Ke(() => {
      e.motionNodes && e.onMotionStart();
    }), et(() => {
      e.motionNodes && s();
    }), () => {
      const {
        motion: c,
        motionNodes: u,
        motionType: d,
        active: p,
        eventKey: v
      } = e, h = bw(e, ["motion", "motionNodes", "motionType", "active", "eventKey"]);
      return u ? f(yn, D(D({}, i.value), {}, {
        appear: d === "show",
        onAfterAppear: (g) => s(g, "appear"),
        onAfterLeave: (g) => s(g, "leave")
      }), {
        default: () => [Tn(f("div", {
          class: `${l.value.prefixCls}-treenode-motion`
        }, [u.map((g) => {
          const b = bw(g.data, []), {
            title: y,
            key: S,
            isStart: C,
            isEnd: w
          } = g;
          return delete b.children, f(cm, D(D({}, b), {}, {
            title: y,
            active: p,
            data: g.data,
            key: S,
            eventKey: S,
            isStart: C,
            isEnd: w
          }), o);
        })]), [[Hn, r.value]])]
      }) : f(cm, D(D({
        class: n.class,
        style: n.style
      }, h), {}, {
        active: p,
        eventKey: v
      }), o);
    };
  }
});
function $te() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  const n = e.length, o = t.length;
  if (Math.abs(n - o) !== 1)
    return {
      add: !1,
      key: null
    };
  function r(l, a) {
    const i = /* @__PURE__ */ new Map();
    l.forEach((c) => {
      i.set(c, !0);
    });
    const s = a.filter((c) => !i.has(c));
    return s.length === 1 ? s[0] : null;
  }
  return n < o ? {
    add: !0,
    key: r(e, t)
  } : {
    add: !1,
    key: r(t, e)
  };
}
function yw(e, t, n) {
  const o = e.findIndex((a) => a.key === n), r = e[o + 1], l = t.findIndex((a) => a.key === n);
  if (r) {
    const a = t.findIndex((i) => i.key === r.key);
    return t.slice(l + 1, a);
  }
  return t.slice(l + 1);
}
var Sw = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Cw = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
}, wte = () => {
}, ga = `RC_TREE_MOTION_${Math.random()}`, zm = {
  key: ga
}, _6 = {
  key: ga,
  level: 0,
  index: 0,
  pos: "0",
  node: zm,
  nodes: [zm]
}, $w = {
  parent: null,
  children: [],
  pos: _6.pos,
  data: zm,
  title: null,
  key: ga,
  /** Hold empty list here since we do not use it */
  isStart: [],
  isEnd: []
};
function ww(e, t, n, o) {
  return t === !1 || !n ? e : e.slice(0, Math.ceil(n / o) + 1);
}
function xw(e) {
  const {
    key: t,
    pos: n
  } = e;
  return hc(t, n);
}
function xte(e) {
  let t = String(e.key), n = e;
  for (; n.parent; )
    n = n.parent, t = `${n.key} > ${t}`;
  return t;
}
const Ote = Z({
  compatConfig: {
    MODE: 3
  },
  name: "NodeList",
  inheritAttrs: !1,
  props: AW,
  setup(e, t) {
    let {
      expose: n,
      attrs: o
    } = t;
    const r = Y(), l = Y(), {
      expandedKeys: a,
      flattenNodes: i
    } = iP();
    n({
      scrollTo: (g) => {
        r.value.scrollTo(g);
      },
      getIndentWidth: () => l.value.offsetWidth
    });
    const s = Q(i.value), c = Q([]), u = Y(null);
    function d() {
      s.value = i.value, c.value = [], u.value = null, e.onListChangeEnd();
    }
    const p = tb();
    ie([() => a.value.slice(), i], (g, b) => {
      let [y, S] = g, [C, w] = b;
      const $ = $te(C, y);
      if ($.key !== null) {
        const {
          virtual: O,
          height: x,
          itemHeight: I
        } = e;
        if ($.add) {
          const E = w.findIndex((R) => {
            let {
              key: A
            } = R;
            return A === $.key;
          }), _ = ww(yw(w, S, $.key), O, x, I), M = w.slice();
          M.splice(E + 1, 0, $w), s.value = M, c.value = _, u.value = "show";
        } else {
          const E = S.findIndex((R) => {
            let {
              key: A
            } = R;
            return A === $.key;
          }), _ = ww(yw(S, w, $.key), O, x, I), M = S.slice();
          M.splice(E + 1, 0, $w), s.value = M, c.value = _, u.value = "hide";
        }
      } else
        w !== S && (s.value = S);
    }), ie(() => p.value.dragging, (g) => {
      g || d();
    });
    const v = P(() => e.motion === void 0 ? s.value : i.value), h = () => {
      e.onActiveChange(null);
    };
    return () => {
      const g = m(m({}, e), o), {
        prefixCls: b,
        selectable: y,
        checkable: S,
        disabled: C,
        motion: w,
        height: $,
        itemHeight: O,
        virtual: x,
        focusable: I,
        activeItem: E,
        focused: _,
        tabindex: M,
        onKeydown: R,
        onFocus: A,
        onBlur: z,
        onListChangeStart: T,
        onListChangeEnd: N
      } = g, k = Sw(g, ["prefixCls", "selectable", "checkable", "disabled", "motion", "height", "itemHeight", "virtual", "focusable", "activeItem", "focused", "tabindex", "onKeydown", "onFocus", "onBlur", "onListChangeStart", "onListChangeEnd"]);
      return f(Fe, null, [_ && E && f("span", {
        style: Cw,
        "aria-live": "assertive"
      }, [xte(E)]), f("div", null, [f("input", {
        style: Cw,
        disabled: I === !1 || C,
        tabindex: I !== !1 ? M : null,
        onKeydown: R,
        onFocus: A,
        onBlur: z,
        value: "",
        onChange: wte,
        "aria-label": "for screen reader"
      }, null)]), f("div", {
        class: `${b}-treenode`,
        "aria-hidden": !0,
        style: {
          position: "absolute",
          pointerEvents: "none",
          visibility: "hidden",
          height: 0,
          overflow: "hidden"
        }
      }, [f("div", {
        class: `${b}-indent`
      }, [f("div", {
        ref: l,
        class: `${b}-indent-unit`
      }, null)])]), f(N4, D(D({}, ot(k, ["onActiveChange"])), {}, {
        data: v.value,
        itemKey: xw,
        height: $,
        fullHeight: !1,
        virtual: x,
        itemHeight: O,
        prefixCls: `${b}-list`,
        ref: r,
        onVisibleChange: (B, F) => {
          const L = new Set(B);
          F.filter((H) => !L.has(H)).some((H) => xw(H) === ga) && d();
        }
      }), {
        default: (B) => {
          const {
            pos: F
          } = B, L = Sw(B.data, []), {
            title: j,
            key: H,
            isStart: K,
            isEnd: X
          } = B, W = hc(H, F);
          return delete L.key, delete L.children, f(Cte, D(D({}, L), {}, {
            eventKey: W,
            title: j,
            active: !!E && H === E.key,
            data: B.data,
            isStart: K,
            isEnd: X,
            motion: w,
            motionNodes: H === ga ? c.value : null,
            motionType: u.value,
            onMotionStart: T,
            onMotionEnd: d,
            onMousemove: h
          }), null);
        }
      })]);
    };
  }
});
function Pte(e) {
  let {
    dropPosition: t,
    dropLevelOffset: n,
    indent: o
  } = e;
  const r = {
    pointerEvents: "none",
    position: "absolute",
    right: 0,
    backgroundColor: "red",
    height: "2px"
  };
  switch (t) {
    case -1:
      r.top = 0, r.left = `${-n * o}px`;
      break;
    case 1:
      r.bottom = 0, r.left = `${-n * o}px`;
      break;
    case 0:
      r.bottom = 0, r.left = `${o}`;
      break;
  }
  return f("div", {
    style: r
  }, null);
}
const Ite = 10, A6 = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Tree",
  inheritAttrs: !1,
  props: Qe(cP(), {
    prefixCls: "vc-tree",
    showLine: !1,
    showIcon: !0,
    selectable: !0,
    multiple: !1,
    checkable: !1,
    disabled: !1,
    checkStrictly: !1,
    draggable: !1,
    expandAction: !1,
    defaultExpandParent: !0,
    autoExpandParent: !1,
    defaultExpandAll: !1,
    defaultExpandedKeys: [],
    defaultCheckedKeys: [],
    defaultSelectedKeys: [],
    dropIndicatorRender: Pte,
    allowDrop: () => !0
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r
    } = t;
    const l = Q(!1);
    let a = {};
    const i = Q(), s = Q([]), c = Q([]), u = Q([]), d = Q([]), p = Q([]), v = Q([]), h = {}, g = xt({
      draggingNodeKey: null,
      dragChildrenKeys: [],
      // dropTargetKey is the key of abstract-drop-node
      // the abstract-drop-node is the real drop node when drag and drop
      // not the DOM drag over node
      dropTargetKey: null,
      dropPosition: null,
      dropContainerKey: null,
      dropLevelOffset: null,
      dropTargetPos: null,
      dropAllowed: !0,
      // the abstract-drag-over-node
      // if mouse is on the bottom of top dom node or no the top of the bottom dom node
      // abstract-drag-over-node is the top node
      dragOverNodeKey: null
    }), b = Q([]);
    ie([() => e.treeData, () => e.children], () => {
      b.value = e.treeData !== void 0 ? e.treeData.slice() : dm(Yt(e.children));
    }, {
      immediate: !0,
      deep: !0
    });
    const y = Q({}), S = Q(!1), C = Q(null), w = Q(!1), $ = P(() => sp(e.fieldNames)), O = Q();
    let x = null, I = null, E = null;
    const _ = P(() => ({
      expandedKeysSet: M.value,
      selectedKeysSet: R.value,
      loadedKeysSet: A.value,
      loadingKeysSet: z.value,
      checkedKeysSet: T.value,
      halfCheckedKeysSet: N.value,
      dragOverNodeKey: g.dragOverNodeKey,
      dropPosition: g.dropPosition,
      keyEntities: y.value
    })), M = P(() => new Set(v.value)), R = P(() => new Set(s.value)), A = P(() => new Set(d.value)), z = P(() => new Set(p.value)), T = P(() => new Set(c.value)), N = P(() => new Set(u.value));
    Le(() => {
      if (b.value) {
        const ge = bc(b.value, {
          fieldNames: $.value
        });
        y.value = m({
          [ga]: _6
        }, ge.keyEntities);
      }
    });
    let k = !1;
    ie(
      [() => e.expandedKeys, () => e.autoExpandParent, y],
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      (ge, ye) => {
        let [$e, Ae] = ge, [Ve, De] = ye, We = v.value;
        if (e.expandedKeys !== void 0 || k && Ae !== De)
          We = e.autoExpandParent || !k && e.defaultExpandParent ? um(e.expandedKeys, y.value) : e.expandedKeys;
        else if (!k && e.defaultExpandAll) {
          const at = m({}, y.value);
          delete at[ga], We = Object.keys(at).map((gt) => at[gt].key);
        } else
          !k && e.defaultExpandedKeys && (We = e.autoExpandParent || e.defaultExpandParent ? um(e.defaultExpandedKeys, y.value) : e.defaultExpandedKeys);
        We && (v.value = We), k = !0;
      },
      {
        immediate: !0
      }
    );
    const B = Q([]);
    Le(() => {
      B.value = zW(b.value, v.value, $.value);
    }), Le(() => {
      e.selectable && (e.selectedKeys !== void 0 ? s.value = RC(e.selectedKeys, e) : !k && e.defaultSelectedKeys && (s.value = RC(e.defaultSelectedKeys, e)));
    });
    const {
      maxLevel: F,
      levelEntities: L
    } = fp(y);
    Le(() => {
      if (e.checkable) {
        let ge;
        if (e.checkedKeys !== void 0 ? ge = Ov(e.checkedKeys) || {} : !k && e.defaultCheckedKeys ? ge = Ov(e.defaultCheckedKeys) || {} : b.value && (ge = Ov(e.checkedKeys) || {
          checkedKeys: c.value,
          halfCheckedKeys: u.value
        }), ge) {
          let {
            checkedKeys: ye = [],
            halfCheckedKeys: $e = []
          } = ge;
          e.checkStrictly || ({
            checkedKeys: ye,
            halfCheckedKeys: $e
          } = Bo(ye, !0, y.value, F.value, L.value)), c.value = ye, u.value = $e;
        }
      }
    }), Le(() => {
      e.loadedKeys && (d.value = e.loadedKeys);
    });
    const j = () => {
      m(g, {
        dragOverNodeKey: null,
        dropPosition: null,
        dropLevelOffset: null,
        dropTargetKey: null,
        dropContainerKey: null,
        dropTargetPos: null,
        dropAllowed: !1
      });
    }, H = (ge) => {
      O.value.scrollTo(ge);
    };
    ie(() => e.activeKey, () => {
      e.activeKey !== void 0 && (C.value = e.activeKey);
    }, {
      immediate: !0
    }), ie(C, (ge) => {
      rt(() => {
        ge !== null && H({
          key: ge
        });
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const K = (ge) => {
      e.expandedKeys === void 0 && (v.value = ge);
    }, X = () => {
      g.draggingNodeKey !== null && m(g, {
        draggingNodeKey: null,
        dropPosition: null,
        dropContainerKey: null,
        dropTargetKey: null,
        dropLevelOffset: null,
        dropAllowed: !0,
        dragOverNodeKey: null
      }), x = null, E = null;
    }, W = (ge, ye) => {
      const {
        onDragend: $e
      } = e;
      g.dragOverNodeKey = null, X(), $e == null || $e({
        event: ge,
        node: ye.eventData
      }), I = null;
    }, q = (ge) => {
      W(ge, null), window.removeEventListener("dragend", q);
    }, J = (ge, ye) => {
      const {
        onDragstart: $e
      } = e, {
        eventKey: Ae,
        eventData: Ve
      } = ye;
      I = ye, x = {
        x: ge.clientX,
        y: ge.clientY
      };
      const De = dr(v.value, Ae);
      g.draggingNodeKey = Ae, g.dragChildrenKeys = kW(Ae, y.value), i.value = O.value.getIndentWidth(), K(De), window.addEventListener("dragend", q), $e && $e({
        event: ge,
        node: Ve
      });
    }, ne = (ge, ye) => {
      const {
        onDragenter: $e,
        onExpand: Ae,
        allowDrop: Ve,
        direction: De
      } = e, {
        pos: We,
        eventKey: at
      } = ye;
      if (E !== at && (E = at), !I) {
        j();
        return;
      }
      const {
        dropPosition: gt,
        dropLevelOffset: ut,
        dropTargetKey: St,
        dropContainerKey: wt,
        dropTargetPos: Xt,
        dropAllowed: qt,
        dragOverNodeKey: gn
      } = NC(ge, I, ye, i.value, x, Ve, B.value, y.value, M.value, De);
      if (
        // don't allow drop inside its children
        g.dragChildrenKeys.indexOf(St) !== -1 || // don't allow drop when drop is not allowed caculated by calcDropPosition
        !qt
      ) {
        j();
        return;
      }
      if (a || (a = {}), Object.keys(a).forEach((Zt) => {
        clearTimeout(a[Zt]);
      }), I.eventKey !== ye.eventKey && (a[We] = window.setTimeout(() => {
        if (g.draggingNodeKey === null)
          return;
        let Zt = v.value.slice();
        const An = y.value[ye.eventKey];
        An && (An.children || []).length && (Zt = _r(v.value, ye.eventKey)), K(Zt), Ae && Ae(Zt, {
          node: ye.eventData,
          expanded: !0,
          nativeEvent: ge
        });
      }, 800)), I.eventKey === St && ut === 0) {
        j();
        return;
      }
      m(g, {
        dragOverNodeKey: gn,
        dropPosition: gt,
        dropLevelOffset: ut,
        dropTargetKey: St,
        dropContainerKey: wt,
        dropTargetPos: Xt,
        dropAllowed: qt
      }), $e && $e({
        event: ge,
        node: ye.eventData,
        expandedKeys: v.value
      });
    }, te = (ge, ye) => {
      const {
        onDragover: $e,
        allowDrop: Ae,
        direction: Ve
      } = e;
      if (!I)
        return;
      const {
        dropPosition: De,
        dropLevelOffset: We,
        dropTargetKey: at,
        dropContainerKey: gt,
        dropAllowed: ut,
        dropTargetPos: St,
        dragOverNodeKey: wt
      } = NC(ge, I, ye, i.value, x, Ae, B.value, y.value, M.value, Ve);
      g.dragChildrenKeys.indexOf(at) !== -1 || !ut || (I.eventKey === at && We === 0 ? g.dropPosition === null && g.dropLevelOffset === null && g.dropTargetKey === null && g.dropContainerKey === null && g.dropTargetPos === null && g.dropAllowed === !1 && g.dragOverNodeKey === null || j() : De === g.dropPosition && We === g.dropLevelOffset && at === g.dropTargetKey && gt === g.dropContainerKey && St === g.dropTargetPos && ut === g.dropAllowed && wt === g.dragOverNodeKey || m(g, {
        dropPosition: De,
        dropLevelOffset: We,
        dropTargetKey: at,
        dropContainerKey: gt,
        dropTargetPos: St,
        dropAllowed: ut,
        dragOverNodeKey: wt
      }), $e && $e({
        event: ge,
        node: ye.eventData
      }));
    }, G = (ge, ye) => {
      E === ye.eventKey && !ge.currentTarget.contains(ge.relatedTarget) && (j(), E = null);
      const {
        onDragleave: $e
      } = e;
      $e && $e({
        event: ge,
        node: ye.eventData
      });
    }, U = function(ge, ye) {
      let $e = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      var Ae;
      const {
        dragChildrenKeys: Ve,
        dropPosition: De,
        dropTargetKey: We,
        dropTargetPos: at,
        dropAllowed: gt
      } = g;
      if (!gt)
        return;
      const {
        onDrop: ut
      } = e;
      if (g.dragOverNodeKey = null, X(), We === null)
        return;
      const St = m(m({}, xu(We, Yt(_.value))), {
        active: ((Ae = pe.value) === null || Ae === void 0 ? void 0 : Ae.key) === We,
        data: y.value[We].node
      }), wt = Ve.indexOf(We) !== -1;
      ct(!wt, "Can not drop to dragNode's children node. Maybe this is a bug of ant-design-vue. Please report an issue.");
      const Xt = nb(at), qt = {
        event: ge,
        node: Ou(St),
        dragNode: I ? I.eventData : null,
        dragNodesKeys: [I.eventKey].concat(Ve),
        dropToGap: De !== 0,
        dropPosition: De + Number(Xt[Xt.length - 1])
      };
      $e || ut == null || ut(qt), I = null;
    }, re = (ge, ye) => {
      const {
        expanded: $e,
        key: Ae
      } = ye, Ve = B.value.filter((We) => We.key === Ae)[0], De = Ou(m(m({}, xu(Ae, _.value)), {
        data: Ve.data
      }));
      K($e ? dr(v.value, Ae) : _r(v.value, Ae)), we(ge, De);
    }, se = (ge, ye) => {
      const {
        onClick: $e,
        expandAction: Ae
      } = e;
      Ae === "click" && re(ge, ye), $e && $e(ge, ye);
    }, me = (ge, ye) => {
      const {
        onDblclick: $e,
        expandAction: Ae
      } = e;
      (Ae === "doubleclick" || Ae === "dblclick") && re(ge, ye), $e && $e(ge, ye);
    }, Ce = (ge, ye) => {
      let $e = s.value;
      const {
        onSelect: Ae,
        multiple: Ve
      } = e, {
        selected: De
      } = ye, We = ye[$.value.key], at = !De;
      at ? Ve ? $e = _r($e, We) : $e = [We] : $e = dr($e, We);
      const gt = y.value, ut = $e.map((St) => {
        const wt = gt[St];
        return wt ? wt.node : null;
      }).filter((St) => St);
      e.selectedKeys === void 0 && (s.value = $e), Ae && Ae($e, {
        event: "select",
        selected: at,
        node: ye,
        selectedNodes: ut,
        nativeEvent: ge
      });
    }, fe = (ge, ye, $e) => {
      const {
        checkStrictly: Ae,
        onCheck: Ve
      } = e, De = ye[$.value.key];
      let We;
      const at = {
        event: "check",
        node: ye,
        checked: $e,
        nativeEvent: ge
      }, gt = y.value;
      if (Ae) {
        const ut = $e ? _r(c.value, De) : dr(c.value, De), St = dr(u.value, De);
        We = {
          checked: ut,
          halfChecked: St
        }, at.checkedNodes = ut.map((wt) => gt[wt]).filter((wt) => wt).map((wt) => wt.node), e.checkedKeys === void 0 && (c.value = ut);
      } else {
        let {
          checkedKeys: ut,
          halfCheckedKeys: St
        } = Bo([...c.value, De], !0, gt, F.value, L.value);
        if (!$e) {
          const wt = new Set(ut);
          wt.delete(De), {
            checkedKeys: ut,
            halfCheckedKeys: St
          } = Bo(Array.from(wt), {
            checked: !1,
            halfCheckedKeys: St
          }, gt, F.value, L.value);
        }
        We = ut, at.checkedNodes = [], at.checkedNodesPositions = [], at.halfCheckedKeys = St, ut.forEach((wt) => {
          const Xt = gt[wt];
          if (!Xt)
            return;
          const {
            node: qt,
            pos: gn
          } = Xt;
          at.checkedNodes.push(qt), at.checkedNodesPositions.push({
            node: qt,
            pos: gn
          });
        }), e.checkedKeys === void 0 && (c.value = ut, u.value = St);
      }
      Ve && Ve(We, at);
    }, be = (ge) => {
      const ye = ge[$.value.key], $e = new Promise((Ae, Ve) => {
        const {
          loadData: De,
          onLoad: We
        } = e;
        if (!De || A.value.has(ye) || z.value.has(ye))
          return null;
        De(ge).then(() => {
          const gt = _r(d.value, ye), ut = dr(p.value, ye);
          We && We(gt, {
            event: "load",
            node: ge
          }), e.loadedKeys === void 0 && (d.value = gt), p.value = ut, Ae();
        }).catch((gt) => {
          const ut = dr(p.value, ye);
          if (p.value = ut, h[ye] = (h[ye] || 0) + 1, h[ye] >= Ite) {
            ct(!1, "Retry for `loadData` many times but still failed. No more retry.");
            const St = _r(d.value, ye);
            e.loadedKeys === void 0 && (d.value = St), Ae();
          }
          Ve(gt);
        }), p.value = _r(p.value, ye);
      });
      return $e.catch(() => {
      }), $e;
    }, ue = (ge, ye) => {
      const {
        onMouseenter: $e
      } = e;
      $e && $e({
        event: ge,
        node: ye
      });
    }, de = (ge, ye) => {
      const {
        onMouseleave: $e
      } = e;
      $e && $e({
        event: ge,
        node: ye
      });
    }, Se = (ge, ye) => {
      const {
        onRightClick: $e
      } = e;
      $e && (ge.preventDefault(), $e({
        event: ge,
        node: ye
      }));
    }, xe = (ge) => {
      const {
        onFocus: ye
      } = e;
      S.value = !0, ye && ye(ge);
    }, he = (ge) => {
      const {
        onBlur: ye
      } = e;
      S.value = !1, oe(null), ye && ye(ge);
    }, we = (ge, ye) => {
      let $e = v.value;
      const {
        onExpand: Ae,
        loadData: Ve
      } = e, {
        expanded: De
      } = ye, We = ye[$.value.key];
      if (w.value)
        return;
      const at = $e.indexOf(We), gt = !De;
      if (ct(De && at !== -1 || !De && at === -1, "Expand state not sync with index check"), gt ? $e = _r($e, We) : $e = dr($e, We), K($e), Ae && Ae($e, {
        node: ye,
        expanded: gt,
        nativeEvent: ge
      }), gt && Ve) {
        const ut = be(ye);
        ut && ut.then(() => {
        }).catch((St) => {
          const wt = dr(v.value, We);
          K(wt), Promise.reject(St);
        });
      }
    }, Me = () => {
      w.value = !0;
    }, ae = () => {
      setTimeout(() => {
        w.value = !1;
      });
    }, oe = (ge) => {
      const {
        onActiveChange: ye
      } = e;
      C.value !== ge && (e.activeKey !== void 0 && (C.value = ge), ge !== null && H({
        key: ge
      }), ye && ye(ge));
    }, pe = P(() => C.value === null ? null : B.value.find((ge) => {
      let {
        key: ye
      } = ge;
      return ye === C.value;
    }) || null), Pe = (ge) => {
      let ye = B.value.findIndex((Ae) => {
        let {
          key: Ve
        } = Ae;
        return Ve === C.value;
      });
      ye === -1 && ge < 0 && (ye = B.value.length), ye = (ye + ge + B.value.length) % B.value.length;
      const $e = B.value[ye];
      if ($e) {
        const {
          key: Ae
        } = $e;
        oe(Ae);
      } else
        oe(null);
    }, Ee = P(() => Ou(m(m({}, xu(C.value, _.value)), {
      data: pe.value.data,
      active: !0
    }))), ze = (ge) => {
      const {
        onKeydown: ye,
        checkable: $e,
        selectable: Ae
      } = e;
      switch (ge.which) {
        case ce.UP: {
          Pe(-1), ge.preventDefault();
          break;
        }
        case ce.DOWN: {
          Pe(1), ge.preventDefault();
          break;
        }
      }
      const Ve = pe.value;
      if (Ve && Ve.data) {
        const De = Ve.data.isLeaf === !1 || !!(Ve.data.children || []).length, We = Ee.value;
        switch (ge.which) {
          case ce.LEFT: {
            De && M.value.has(C.value) ? we({}, We) : Ve.parent && oe(Ve.parent.key), ge.preventDefault();
            break;
          }
          case ce.RIGHT: {
            De && !M.value.has(C.value) ? we({}, We) : Ve.children && Ve.children.length && oe(Ve.children[0].key), ge.preventDefault();
            break;
          }
          case ce.ENTER:
          case ce.SPACE: {
            $e && !We.disabled && We.checkable !== !1 && !We.disableCheckbox ? fe({}, We, !T.value.has(C.value)) : !$e && Ae && !We.disabled && We.selectable !== !1 && Ce({}, We);
            break;
          }
        }
      }
      ye && ye(ge);
    };
    return r({
      onNodeExpand: we,
      scrollTo: H,
      onKeydown: ze,
      selectedKeys: P(() => s.value),
      checkedKeys: P(() => c.value),
      halfCheckedKeys: P(() => u.value),
      loadedKeys: P(() => d.value),
      loadingKeys: P(() => p.value),
      expandedKeys: P(() => v.value)
    }), uo(() => {
      window.removeEventListener("dragend", q), l.value = !0;
    }), MW({
      expandedKeys: v,
      selectedKeys: s,
      loadedKeys: d,
      loadingKeys: p,
      checkedKeys: c,
      halfCheckedKeys: u,
      expandedKeysSet: M,
      selectedKeysSet: R,
      loadedKeysSet: A,
      loadingKeysSet: z,
      checkedKeysSet: T,
      halfCheckedKeysSet: N,
      flattenNodes: B
    }), () => {
      const {
        // focused,
        // flattenNodes,
        // keyEntities,
        draggingNodeKey: ge,
        // activeKey,
        dropLevelOffset: ye,
        dropContainerKey: $e,
        dropTargetKey: Ae,
        dropPosition: Ve,
        dragOverNodeKey: De
        // indent,
      } = g, {
        prefixCls: We,
        showLine: at,
        focusable: gt,
        tabindex: ut = 0,
        selectable: St,
        showIcon: wt,
        icon: Xt = o.icon,
        switcherIcon: qt,
        draggable: gn,
        checkable: Zt,
        checkStrictly: An,
        disabled: Jn,
        motion: Io,
        loadData: Vo,
        filterTreeNode: eo,
        height: Ml,
        itemHeight: Oe,
        virtual: Ue,
        dropIndicatorRender: Ye,
        onContextmenu: Dt,
        onScroll: cn,
        direction: Qt,
        rootClassName: to,
        rootStyle: $n
      } = e, {
        class: cr,
        style: fo
      } = n, Eo = wl(m(m({}, e), n), {
        aria: !0,
        data: !0
      });
      let zt;
      return gn ? typeof gn == "object" ? zt = gn : typeof gn == "function" ? zt = {
        nodeDraggable: gn
      } : zt = {} : zt = !1, f(TW, {
        value: {
          prefixCls: We,
          selectable: St,
          showIcon: wt,
          icon: Xt,
          switcherIcon: qt,
          draggable: zt,
          draggingNodeKey: ge,
          checkable: Zt,
          customCheckable: o.checkable,
          checkStrictly: An,
          disabled: Jn,
          keyEntities: y.value,
          dropLevelOffset: ye,
          dropContainerKey: $e,
          dropTargetKey: Ae,
          dropPosition: Ve,
          dragOverNodeKey: De,
          dragging: ge !== null,
          indent: i.value,
          direction: Qt,
          dropIndicatorRender: Ye,
          loadData: Vo,
          filterTreeNode: eo,
          onNodeClick: se,
          onNodeDoubleClick: me,
          onNodeExpand: we,
          onNodeSelect: Ce,
          onNodeCheck: fe,
          onNodeLoad: be,
          onNodeMouseEnter: ue,
          onNodeMouseLeave: de,
          onNodeContextMenu: Se,
          onNodeDragStart: J,
          onNodeDragEnter: ne,
          onNodeDragOver: te,
          onNodeDragLeave: G,
          onNodeDragEnd: W,
          onNodeDrop: U,
          slots: o
        }
      }, {
        default: () => [f("div", {
          role: "tree",
          class: ee(We, cr, to, {
            [`${We}-show-line`]: at,
            [`${We}-focused`]: S.value,
            [`${We}-active-focused`]: C.value !== null
          }),
          style: $n
        }, [f(Ote, D({
          ref: O,
          prefixCls: We,
          style: fo,
          disabled: Jn,
          selectable: St,
          checkable: !!Zt,
          motion: Io,
          height: Ml,
          itemHeight: Oe,
          virtual: Ue,
          focusable: gt,
          focused: S.value,
          tabindex: ut,
          activeItem: pe.value,
          onFocus: xe,
          onBlur: he,
          onKeydown: ze,
          onActiveChange: oe,
          onListChangeStart: Me,
          onListChangeEnd: ae,
          onContextmenu: Dt,
          onScroll: cn
        }, Eo), null)])]
      });
    };
  }
});
var Ete = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, name: "file", theme: "outlined" };
function Ow(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Tte(e, r, n[r]);
    });
  }
  return e;
}
function Tte(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Tp = function(t, n) {
  var o = Ow({}, t, n.attrs);
  return f(Ge, Ow({}, o, {
    icon: Ete
  }), null);
};
Tp.displayName = "FileOutlined";
Tp.inheritAttrs = !1;
var Mte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h368c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "minus-square", theme: "outlined" };
function Pw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      _te(e, r, n[r]);
    });
  }
  return e;
}
function _te(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Kb = function(t, n) {
  var o = Pw({}, t, n.attrs);
  return f(Ge, Pw({}, o, {
    icon: Mte
  }), null);
};
Kb.displayName = "MinusSquareOutlined";
Kb.inheritAttrs = !1;
var Ate = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M328 544h152v152c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V544h152c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H544V328c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8v152H328c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }, { tag: "path", attrs: { d: "M880 112H144c-17.7 0-32 14.3-32 32v736c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V144c0-17.7-14.3-32-32-32zm-40 728H184V184h656v656z" } }] }, name: "plus-square", theme: "outlined" };
function Iw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Dte(e, r, n[r]);
    });
  }
  return e;
}
function Dte(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Gb = function(t, n) {
  var o = Iw({}, t, n.attrs);
  return f(Ge, Iw({}, o, {
    icon: Ate
  }), null);
};
Gb.displayName = "PlusSquareOutlined";
Gb.inheritAttrs = !1;
var Nte = { icon: { tag: "svg", attrs: { viewBox: "0 0 1024 1024", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" } }] }, name: "caret-down", theme: "filled" };
function Ew(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Rte(e, r, n[r]);
    });
  }
  return e;
}
function Rte(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Xb = function(t, n) {
  var o = Ew({}, t, n.attrs);
  return f(Ge, Ew({}, o, {
    icon: Nte
  }), null);
};
Xb.displayName = "CaretDownFilled";
Xb.inheritAttrs = !1;
function D6(e, t, n, o, r) {
  const {
    isLeaf: l,
    expanded: a,
    loading: i
  } = n;
  let s = t;
  if (i)
    return f(Qn, {
      class: `${e}-switcher-loading-icon`
    }, null);
  let c;
  r && typeof r == "object" && (c = r.showLeafIcon);
  let u = null;
  const d = `${e}-switcher-icon`;
  return l ? r ? c && o ? o(n) : (typeof r == "object" && !c ? u = f("span", {
    class: `${e}-switcher-leaf-line`
  }, null) : u = f(Tp, {
    class: `${e}-switcher-line-icon`
  }, null), u) : null : (u = f(Xb, {
    class: d
  }, null), r && (u = a ? f(Kb, {
    class: `${e}-switcher-line-icon`
  }, null) : f(Gb, {
    class: `${e}-switcher-line-icon`
  }, null)), typeof t == "function" ? s = t(m(m({}, n), {
    defaultIcon: u,
    switcherCls: d
  })) : Gt(s) && (s = tr(s, {
    class: d
  })), s || u);
}
const Tw = 4;
function kte(e) {
  const {
    dropPosition: t,
    dropLevelOffset: n,
    prefixCls: o,
    indent: r,
    direction: l = "ltr"
  } = e, a = l === "ltr" ? "left" : "right", i = l === "ltr" ? "right" : "left", s = {
    [a]: `${-n * r + Tw}px`,
    [i]: 0
  };
  switch (t) {
    case -1:
      s.top = "-3px";
      break;
    case 1:
      s.bottom = "-3px";
      break;
    default:
      s.bottom = "-3px", s[a] = `${r + Tw}px`;
      break;
  }
  return f("div", {
    style: s,
    class: `${o}-drop-indicator`
  }, null);
}
const Bte = new lt("ant-tree-node-fx-do-not-use", {
  "0%": {
    opacity: 0
  },
  "100%": {
    opacity: 1
  }
}), Fte = (e, t) => ({
  [`.${e}-switcher-icon`]: {
    display: "inline-block",
    fontSize: 10,
    verticalAlign: "baseline",
    svg: {
      transition: `transform ${t.motionDurationSlow}`
    }
  }
}), Lte = (e, t) => ({
  [`.${e}-drop-indicator`]: {
    position: "absolute",
    // it should displayed over the following node
    zIndex: 1,
    height: 2,
    backgroundColor: t.colorPrimary,
    borderRadius: 1,
    pointerEvents: "none",
    "&:after": {
      position: "absolute",
      top: -3,
      insetInlineStart: -6,
      width: 8,
      height: 8,
      backgroundColor: "transparent",
      border: `${t.lineWidthBold}px solid ${t.colorPrimary}`,
      borderRadius: "50%",
      content: '""'
    }
  }
}), zte = (e, t) => {
  const {
    treeCls: n,
    treeNodeCls: o,
    treeNodePadding: r,
    treeTitleHeight: l
  } = t, a = (l - t.fontSizeLG) / 2, i = t.paddingXS;
  return {
    [n]: m(m({}, qe(t)), {
      background: t.colorBgContainer,
      borderRadius: t.borderRadius,
      transition: `background-color ${t.motionDurationSlow}`,
      [`&${n}-rtl`]: {
        // >>> Switcher
        [`${n}-switcher`]: {
          "&_close": {
            [`${n}-switcher-icon`]: {
              svg: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      },
      [`&-focused:not(:hover):not(${n}-active-focused)`]: m({}, Gr(t)),
      // =================== Virtual List ===================
      [`${n}-list-holder-inner`]: {
        alignItems: "flex-start"
      },
      [`&${n}-block-node`]: {
        [`${n}-list-holder-inner`]: {
          alignItems: "stretch",
          // >>> Title
          [`${n}-node-content-wrapper`]: {
            flex: "auto"
          },
          // >>> Drag
          [`${o}.dragging`]: {
            position: "relative",
            "&:after": {
              position: "absolute",
              top: 0,
              insetInlineEnd: 0,
              bottom: r,
              insetInlineStart: 0,
              border: `1px solid ${t.colorPrimary}`,
              opacity: 0,
              animationName: Bte,
              animationDuration: t.motionDurationSlow,
              animationPlayState: "running",
              animationFillMode: "forwards",
              content: '""',
              pointerEvents: "none"
            }
          }
        }
      },
      // ===================== TreeNode =====================
      [`${o}`]: {
        display: "flex",
        alignItems: "flex-start",
        padding: `0 0 ${r}px 0`,
        outline: "none",
        "&-rtl": {
          direction: "rtl"
        },
        // Disabled
        "&-disabled": {
          // >>> Title
          [`${n}-node-content-wrapper`]: {
            color: t.colorTextDisabled,
            cursor: "not-allowed",
            "&:hover": {
              background: "transparent"
            }
          }
        },
        [`&-active ${n}-node-content-wrapper`]: m({}, Gr(t)),
        [`&:not(${o}-disabled).filter-node ${n}-title`]: {
          color: "inherit",
          fontWeight: 500
        },
        "&-draggable": {
          [`${n}-draggable-icon`]: {
            width: l,
            lineHeight: `${l}px`,
            textAlign: "center",
            visibility: "visible",
            opacity: 0.2,
            transition: `opacity ${t.motionDurationSlow}`,
            [`${o}:hover &`]: {
              opacity: 0.45
            }
          },
          [`&${o}-disabled`]: {
            [`${n}-draggable-icon`]: {
              visibility: "hidden"
            }
          }
        }
      },
      // >>> Indent
      [`${n}-indent`]: {
        alignSelf: "stretch",
        whiteSpace: "nowrap",
        userSelect: "none",
        "&-unit": {
          display: "inline-block",
          width: l
        }
      },
      // >>> Drag Handler
      [`${n}-draggable-icon`]: {
        visibility: "hidden"
      },
      // >>> Switcher
      [`${n}-switcher`]: m(m({}, Fte(e, t)), {
        position: "relative",
        flex: "none",
        alignSelf: "stretch",
        width: l,
        margin: 0,
        lineHeight: `${l}px`,
        textAlign: "center",
        cursor: "pointer",
        userSelect: "none",
        "&-noop": {
          cursor: "default"
        },
        "&_close": {
          [`${n}-switcher-icon`]: {
            svg: {
              transform: "rotate(-90deg)"
            }
          }
        },
        "&-loading-icon": {
          color: t.colorPrimary
        },
        "&-leaf-line": {
          position: "relative",
          zIndex: 1,
          display: "inline-block",
          width: "100%",
          height: "100%",
          // https://github.com/ant-design/ant-design/issues/31884
          "&:before": {
            position: "absolute",
            top: 0,
            insetInlineEnd: l / 2,
            bottom: -r,
            marginInlineStart: -1,
            borderInlineEnd: `1px solid ${t.colorBorder}`,
            content: '""'
          },
          "&:after": {
            position: "absolute",
            width: l / 2 * 0.8,
            height: l / 2,
            borderBottom: `1px solid ${t.colorBorder}`,
            content: '""'
          }
        }
      }),
      // >>> Checkbox
      [`${n}-checkbox`]: {
        top: "initial",
        marginInlineEnd: i,
        marginBlockStart: a
      },
      // >>> Title
      // add `${treeCls}-checkbox + span` to cover checkbox `${checkboxCls} + span`
      [`${n}-node-content-wrapper, ${n}-checkbox + span`]: {
        position: "relative",
        zIndex: "auto",
        minHeight: l,
        margin: 0,
        padding: `0 ${t.paddingXS / 2}px`,
        color: "inherit",
        lineHeight: `${l}px`,
        background: "transparent",
        borderRadius: t.borderRadius,
        cursor: "pointer",
        transition: `all ${t.motionDurationMid}, border 0s, line-height 0s, box-shadow 0s`,
        "&:hover": {
          backgroundColor: t.controlItemBgHover
        },
        [`&${n}-node-selected`]: {
          backgroundColor: t.controlItemBgActive
        },
        // Icon
        [`${n}-iconEle`]: {
          display: "inline-block",
          width: l,
          height: l,
          lineHeight: `${l}px`,
          textAlign: "center",
          verticalAlign: "top",
          "&:empty": {
            display: "none"
          }
        }
      },
      // https://github.com/ant-design/ant-design/issues/28217
      [`${n}-unselectable ${n}-node-content-wrapper:hover`]: {
        backgroundColor: "transparent"
      },
      // ==================== Draggable =====================
      [`${n}-node-content-wrapper`]: m({
        lineHeight: `${l}px`,
        userSelect: "none"
      }, Lte(e, t)),
      [`${o}.drop-container`]: {
        "> [draggable]": {
          boxShadow: `0 0 0 2px ${t.colorPrimary}`
        }
      },
      // ==================== Show Line =====================
      "&-show-line": {
        // ================ Indent lines ================
        [`${n}-indent`]: {
          "&-unit": {
            position: "relative",
            height: "100%",
            "&:before": {
              position: "absolute",
              top: 0,
              insetInlineEnd: l / 2,
              bottom: -r,
              borderInlineEnd: `1px solid ${t.colorBorder}`,
              content: '""'
            },
            "&-end": {
              "&:before": {
                display: "none"
              }
            }
          }
        },
        // ============== Cover Background ==============
        [`${n}-switcher`]: {
          background: "transparent",
          "&-line-icon": {
            // https://github.com/ant-design/ant-design/issues/32813
            verticalAlign: "-0.15em"
          }
        }
      },
      [`${o}-leaf-last`]: {
        [`${n}-switcher`]: {
          "&-leaf-line": {
            "&:before": {
              top: "auto !important",
              bottom: "auto !important",
              height: `${l / 2}px !important`
            }
          }
        }
      }
    })
  };
}, Hte = (e) => {
  const {
    treeCls: t,
    treeNodeCls: n,
    treeNodePadding: o
  } = e;
  return {
    [`${t}${t}-directory`]: {
      // ================== TreeNode ==================
      [n]: {
        position: "relative",
        // Hover color
        "&:before": {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          bottom: o,
          insetInlineStart: 0,
          transition: `background-color ${e.motionDurationMid}`,
          content: '""',
          pointerEvents: "none"
        },
        "&:hover": {
          "&:before": {
            background: e.controlItemBgHover
          }
        },
        // Elements
        "> *": {
          zIndex: 1
        },
        // >>> Switcher
        [`${t}-switcher`]: {
          transition: `color ${e.motionDurationMid}`
        },
        // >>> Title
        [`${t}-node-content-wrapper`]: {
          borderRadius: 0,
          userSelect: "none",
          "&:hover": {
            background: "transparent"
          },
          [`&${t}-node-selected`]: {
            color: e.colorTextLightSolid,
            background: "transparent"
          }
        },
        // ============= Selected =============
        "&-selected": {
          "\n            &:hover::before,\n            &::before\n          ": {
            background: e.colorPrimary
          },
          // >>> Switcher
          [`${t}-switcher`]: {
            color: e.colorTextLightSolid
          },
          // >>> Title
          [`${t}-node-content-wrapper`]: {
            color: e.colorTextLightSolid,
            background: "transparent"
          }
        }
      }
    }
  };
}, N6 = (e, t) => {
  const n = `.${e}`, o = `${n}-treenode`, r = t.paddingXS / 2, l = t.controlHeightSM, a = He(t, {
    treeCls: n,
    treeNodeCls: o,
    treeNodePadding: r,
    treeTitleHeight: l
  });
  return [
    // Basic
    zte(e, a),
    // Directory
    Hte(a)
  ];
}, jte = Xe("Tree", (e, t) => {
  let {
    prefixCls: n
  } = t;
  return [{
    [e.componentCls]: mp(`${n}-checkbox`, e)
  }, N6(n, e), cc(e)];
}), R6 = () => {
  const e = cP();
  return m(m({}, e), {
    showLine: je([Boolean, Object]),
    /** 是否支持多选 */
    multiple: ve(),
    /** 是否自动展开父节点 */
    autoExpandParent: ve(),
    /** checkable状态下节点选择完全受控（父子节点选中状态不再关联）*/
    checkStrictly: ve(),
    /** 是否支持选中 */
    checkable: ve(),
    /** 是否禁用树 */
    disabled: ve(),
    /** 默认展开所有树节点 */
    defaultExpandAll: ve(),
    /** 默认展开对应树节点 */
    defaultExpandParent: ve(),
    /** 默认展开指定的树节点 */
    defaultExpandedKeys: vt(),
    /** （受控）展开指定的树节点 */
    expandedKeys: vt(),
    /** （受控）选中复选框的树节点 */
    checkedKeys: je([Array, Object]),
    /** 默认选中复选框的树节点 */
    defaultCheckedKeys: vt(),
    /** （受控）设置选中的树节点 */
    selectedKeys: vt(),
    /** 默认选中的树节点 */
    defaultSelectedKeys: vt(),
    selectable: ve(),
    loadedKeys: vt(),
    draggable: ve(),
    showIcon: ve(),
    icon: le(),
    switcherIcon: V.any,
    prefixCls: String,
    /**
     * @default{title,key,children}
     * deprecated, please use `fieldNames` instead
     * 替换treeNode中 title,key,children字段为treeData中对应的字段
     */
    replaceFields: Re(),
    blockNode: ve(),
    openAnimation: V.any,
    onDoubleclick: e.onDblclick,
    "onUpdate:selectedKeys": le(),
    "onUpdate:checkedKeys": le(),
    "onUpdate:expandedKeys": le()
  });
}, ju = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATree",
  inheritAttrs: !1,
  props: Qe(R6(), {
    checkable: !1,
    selectable: !0,
    showIcon: !1,
    blockNode: !1
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      emit: r,
      slots: l
    } = t;
    ct(!(e.treeData === void 0 && l.default), "`children` of Tree is deprecated. Please use `treeData` instead.");
    const {
      prefixCls: a,
      direction: i,
      virtual: s
    } = Ie("tree", e), [c, u] = jte(a), d = Y();
    o({
      treeRef: d,
      onNodeExpand: function() {
        var b;
        (b = d.value) === null || b === void 0 || b.onNodeExpand(...arguments);
      },
      scrollTo: (b) => {
        var y;
        (y = d.value) === null || y === void 0 || y.scrollTo(b);
      },
      selectedKeys: P(() => {
        var b;
        return (b = d.value) === null || b === void 0 ? void 0 : b.selectedKeys;
      }),
      checkedKeys: P(() => {
        var b;
        return (b = d.value) === null || b === void 0 ? void 0 : b.checkedKeys;
      }),
      halfCheckedKeys: P(() => {
        var b;
        return (b = d.value) === null || b === void 0 ? void 0 : b.halfCheckedKeys;
      }),
      loadedKeys: P(() => {
        var b;
        return (b = d.value) === null || b === void 0 ? void 0 : b.loadedKeys;
      }),
      loadingKeys: P(() => {
        var b;
        return (b = d.value) === null || b === void 0 ? void 0 : b.loadingKeys;
      }),
      expandedKeys: P(() => {
        var b;
        return (b = d.value) === null || b === void 0 ? void 0 : b.expandedKeys;
      })
    }), Le(() => {
      nt(e.replaceFields === void 0, "Tree", "`replaceFields` is deprecated, please use fieldNames instead");
    });
    const v = (b, y) => {
      r("update:checkedKeys", b), r("check", b, y);
    }, h = (b, y) => {
      r("update:expandedKeys", b), r("expand", b, y);
    }, g = (b, y) => {
      r("update:selectedKeys", b), r("select", b, y);
    };
    return () => {
      const {
        showIcon: b,
        showLine: y,
        switcherIcon: S = l.switcherIcon,
        icon: C = l.icon,
        blockNode: w,
        checkable: $,
        selectable: O,
        fieldNames: x = e.replaceFields,
        motion: I = e.openAnimation,
        itemHeight: E = 28,
        onDoubleclick: _,
        onDblclick: M
      } = e, R = m(m(m({}, n), ot(e, ["onUpdate:checkedKeys", "onUpdate:expandedKeys", "onUpdate:selectedKeys", "onDoubleclick"])), {
        showLine: !!y,
        dropIndicatorRender: kte,
        fieldNames: x,
        icon: C,
        itemHeight: E
      }), A = l.default ? Lt(l.default()) : void 0;
      return c(f(A6, D(D({}, R), {}, {
        virtual: s.value,
        motion: I,
        ref: d,
        prefixCls: a.value,
        class: ee({
          [`${a.value}-icon-hide`]: !b,
          [`${a.value}-block-node`]: w,
          [`${a.value}-unselectable`]: !O,
          [`${a.value}-rtl`]: i.value === "rtl"
        }, n.class, u.value),
        direction: i.value,
        checkable: $,
        selectable: O,
        switcherIcon: (z) => D6(a.value, S, z, l.leafIcon, y),
        onCheck: v,
        onExpand: h,
        onSelect: g,
        onDblclick: M || _,
        children: A
      }), m(m({}, l), {
        checkable: () => f("span", {
          class: `${a.value}-checkbox-inner`
        }, null)
      })));
    };
  }
});
var Vte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 444H820V330.4c0-17.7-14.3-32-32-32H473L355.7 186.2a8.15 8.15 0 00-5.5-2.2H96c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h698c13 0 24.8-7.9 29.7-20l134-332c1.5-3.8 2.3-7.9 2.3-12 0-17.7-14.3-32-32-32zM136 256h188.5l119.6 114.4H748V444H238c-13 0-24.8 7.9-29.7 20L136 643.2V256zm635.3 512H159l103.3-256h612.4L771.3 768z" } }] }, name: "folder-open", theme: "outlined" };
function Mw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Wte(e, r, n[r]);
    });
  }
  return e;
}
function Wte(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Ub = function(t, n) {
  var o = Mw({}, t, n.attrs);
  return f(Ge, Mw({}, o, {
    icon: Vte
  }), null);
};
Ub.displayName = "FolderOpenOutlined";
Ub.inheritAttrs = !1;
var Kte = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M880 298.4H521L403.7 186.2a8.15 8.15 0 00-5.5-2.2H144c-17.7 0-32 14.3-32 32v592c0 17.7 14.3 32 32 32h736c17.7 0 32-14.3 32-32V330.4c0-17.7-14.3-32-32-32zM840 768H184V256h188.5l119.6 114.4H840V768z" } }] }, name: "folder", theme: "outlined" };
function _w(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Gte(e, r, n[r]);
    });
  }
  return e;
}
function Gte(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var Yb = function(t, n) {
  var o = _w({}, t, n.attrs);
  return f(Ge, _w({}, o, {
    icon: Kte
  }), null);
};
Yb.displayName = "FolderOutlined";
Yb.inheritAttrs = !1;
var Ar;
(function(e) {
  e[e.None = 0] = "None", e[e.Start = 1] = "Start", e[e.End = 2] = "End";
})(Ar || (Ar = {}));
function qb(e, t, n) {
  function o(r) {
    const l = r[t.key], a = r[t.children];
    n(l, r) !== !1 && qb(a || [], t, n);
  }
  e.forEach(o);
}
function Xte(e) {
  let {
    treeData: t,
    expandedKeys: n,
    startKey: o,
    endKey: r,
    fieldNames: l = {
      title: "title",
      key: "key",
      children: "children"
    }
  } = e;
  const a = [];
  let i = Ar.None;
  if (o && o === r)
    return [o];
  if (!o || !r)
    return [];
  function s(c) {
    return c === o || c === r;
  }
  return qb(t, l, (c) => {
    if (i === Ar.End)
      return !1;
    if (s(c)) {
      if (a.push(c), i === Ar.None)
        i = Ar.Start;
      else if (i === Ar.Start)
        return i = Ar.End, !1;
    } else
      i === Ar.Start && a.push(c);
    return n.includes(c);
  }), a;
}
function Wv(e, t, n) {
  const o = [...t], r = [];
  return qb(e, n, (l, a) => {
    const i = o.indexOf(l);
    return i !== -1 && (r.push(a), o.splice(i, 1)), !!o.length;
  }), r;
}
var Ute = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Yte = () => m(m({}, R6()), {
  expandAction: je([Boolean, String])
});
function qte(e) {
  const {
    isLeaf: t,
    expanded: n
  } = e;
  return t ? f(Tp, null, null) : n ? f(Ub, null, null) : f(Yb, null, null);
}
const Vu = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ADirectoryTree",
  inheritAttrs: !1,
  props: Qe(Yte(), {
    showIcon: !0,
    expandAction: "click"
  }),
  slots: Object,
  // emits: [
  //   'update:selectedKeys',
  //   'update:checkedKeys',
  //   'update:expandedKeys',
  //   'expand',
  //   'select',
  //   'check',
  //   'doubleclick',
  //   'dblclick',
  //   'click',
  // ],
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      emit: r,
      expose: l
    } = t;
    var a;
    const i = Y(e.treeData || dm(Lt((a = o.default) === null || a === void 0 ? void 0 : a.call(o))));
    ie(() => e.treeData, () => {
      i.value = e.treeData;
    }), co(() => {
      rt(() => {
        var E;
        e.treeData === void 0 && o.default && (i.value = dm(Lt((E = o.default) === null || E === void 0 ? void 0 : E.call(o))));
      });
    });
    const s = Y(), c = Y(), u = P(() => sp(e.fieldNames)), d = Y();
    l({
      scrollTo: (E) => {
        var _;
        (_ = d.value) === null || _ === void 0 || _.scrollTo(E);
      },
      selectedKeys: P(() => {
        var E;
        return (E = d.value) === null || E === void 0 ? void 0 : E.selectedKeys;
      }),
      checkedKeys: P(() => {
        var E;
        return (E = d.value) === null || E === void 0 ? void 0 : E.checkedKeys;
      }),
      halfCheckedKeys: P(() => {
        var E;
        return (E = d.value) === null || E === void 0 ? void 0 : E.halfCheckedKeys;
      }),
      loadedKeys: P(() => {
        var E;
        return (E = d.value) === null || E === void 0 ? void 0 : E.loadedKeys;
      }),
      loadingKeys: P(() => {
        var E;
        return (E = d.value) === null || E === void 0 ? void 0 : E.loadingKeys;
      }),
      expandedKeys: P(() => {
        var E;
        return (E = d.value) === null || E === void 0 ? void 0 : E.expandedKeys;
      })
    });
    const v = () => {
      const {
        keyEntities: E
      } = bc(i.value, {
        fieldNames: u.value
      });
      let _;
      return e.defaultExpandAll ? _ = Object.keys(E) : e.defaultExpandParent ? _ = um(e.expandedKeys || e.defaultExpandedKeys || [], E) : _ = e.expandedKeys || e.defaultExpandedKeys, _;
    }, h = Y(e.selectedKeys || e.defaultSelectedKeys || []), g = Y(v());
    ie(() => e.selectedKeys, () => {
      e.selectedKeys !== void 0 && (h.value = e.selectedKeys);
    }, {
      immediate: !0
    }), ie(() => e.expandedKeys, () => {
      e.expandedKeys !== void 0 && (g.value = e.expandedKeys);
    }, {
      immediate: !0
    });
    const y = Hf((E, _) => {
      const {
        isLeaf: M
      } = _;
      M || E.shiftKey || E.metaKey || E.ctrlKey || d.value.onNodeExpand(E, _);
    }, 200, {
      leading: !0
    }), S = (E, _) => {
      e.expandedKeys === void 0 && (g.value = E), r("update:expandedKeys", E), r("expand", E, _);
    }, C = (E, _) => {
      const {
        expandAction: M
      } = e;
      M === "click" && y(E, _), r("click", E, _);
    }, w = (E, _) => {
      const {
        expandAction: M
      } = e;
      (M === "dblclick" || M === "doubleclick") && y(E, _), r("doubleclick", E, _), r("dblclick", E, _);
    }, $ = (E, _) => {
      const {
        multiple: M
      } = e, {
        node: R,
        nativeEvent: A
      } = _, z = R[u.value.key], T = m(m({}, _), {
        selected: !0
      }), N = (A == null ? void 0 : A.ctrlKey) || (A == null ? void 0 : A.metaKey), k = A == null ? void 0 : A.shiftKey;
      let B;
      M && N ? (B = E, s.value = z, c.value = B, T.selectedNodes = Wv(i.value, B, u.value)) : M && k ? (B = Array.from(/* @__PURE__ */ new Set([...c.value || [], ...Xte({
        treeData: i.value,
        expandedKeys: g.value,
        startKey: z,
        endKey: s.value,
        fieldNames: u.value
      })])), T.selectedNodes = Wv(i.value, B, u.value)) : (B = [z], s.value = z, c.value = B, T.selectedNodes = Wv(i.value, B, u.value)), r("update:selectedKeys", B), r("select", B, T), e.selectedKeys === void 0 && (h.value = B);
    }, O = (E, _) => {
      r("update:checkedKeys", E), r("check", E, _);
    }, {
      prefixCls: x,
      direction: I
    } = Ie("tree", e);
    return () => {
      const E = ee(`${x.value}-directory`, {
        [`${x.value}-directory-rtl`]: I.value === "rtl"
      }, n.class), {
        icon: _ = o.icon,
        blockNode: M = !0
      } = e, R = Ute(e, ["icon", "blockNode"]);
      return f(ju, D(D(D({}, n), {}, {
        icon: _ || qte,
        ref: d,
        blockNode: M
      }, R), {}, {
        prefixCls: x.value,
        class: E,
        expandedKeys: g.value,
        selectedKeys: h.value,
        onSelect: $,
        onClick: C,
        onDblclick: w,
        onExpand: S,
        onCheck: O
      }), o);
    };
  }
}), Wu = cm, k6 = m(ju, {
  DirectoryTree: Vu,
  TreeNode: Wu,
  install: (e) => (e.component(ju.name, ju), e.component(Wu.name, Wu), e.component(Vu.name, Vu), e)
});
function Aw(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  const o = /* @__PURE__ */ new Set();
  function r(l, a) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
    const s = o.has(l);
    if (lo(!s, "Warning: There may be circular references"), s)
      return !1;
    if (l === a)
      return !0;
    if (n && i > 1)
      return !1;
    o.add(l);
    const c = i + 1;
    if (Array.isArray(l)) {
      if (!Array.isArray(a) || l.length !== a.length)
        return !1;
      for (let u = 0; u < l.length; u++)
        if (!r(l[u], a[u], c))
          return !1;
      return !0;
    }
    if (l && a && typeof l == "object" && typeof a == "object") {
      const u = Object.keys(l);
      return u.length !== Object.keys(a).length ? !1 : u.every((d) => r(l[d], a[d], c));
    }
    return !1;
  }
  return r(e, t);
}
const {
  SubMenu: Zte,
  Item: Qte
} = en;
function Jte(e) {
  return e.some((t) => {
    let {
      children: n
    } = t;
    return n && n.length > 0;
  });
}
function B6(e, t) {
  return typeof t == "string" || typeof t == "number" ? t == null ? void 0 : t.toString().toLowerCase().includes(e.trim().toLowerCase()) : !1;
}
function F6(e) {
  let {
    filters: t,
    prefixCls: n,
    filteredKeys: o,
    filterMultiple: r,
    searchValue: l,
    filterSearch: a
  } = e;
  return t.map((i, s) => {
    const c = String(i.value);
    if (i.children)
      return f(Zte, {
        key: c || s,
        title: i.text,
        popupClassName: `${n}-dropdown-submenu`
      }, {
        default: () => [F6({
          filters: i.children,
          prefixCls: n,
          filteredKeys: o,
          filterMultiple: r,
          searchValue: l,
          filterSearch: a
        })]
      });
    const u = r ? io : Un, d = f(Qte, {
      key: i.value !== void 0 ? c : s
    }, {
      default: () => [f(u, {
        checked: o.includes(c)
      }, null), f("span", null, [i.text])]
    });
    return l.trim() ? typeof a == "function" ? a(l, i) ? d : void 0 : B6(l, i.text) ? d : void 0 : d;
  });
}
const ene = Z({
  name: "FilterDropdown",
  props: ["tablePrefixCls", "prefixCls", "dropdownPrefixCls", "column", "filterState", "filterMultiple", "filterMode", "filterSearch", "columnKey", "triggerFilter", "locale", "getPopupContainer"],
  setup(e, t) {
    let {
      slots: n
    } = t;
    const o = Lb(), r = P(() => {
      var H;
      return (H = e.filterMode) !== null && H !== void 0 ? H : "menu";
    }), l = P(() => {
      var H;
      return (H = e.filterSearch) !== null && H !== void 0 ? H : !1;
    }), a = P(() => e.column.filterDropdownOpen || e.column.filterDropdownVisible), i = P(() => e.column.onFilterDropdownOpenChange || e.column.onFilterDropdownVisibleChange);
    process.env.NODE_ENV !== "production" && [["filterDropdownVisible", "filterDropdownOpen", e.column.filterDropdownVisible], ["onFilterDropdownVisibleChange", "onFilterDropdownOpenChange", e.column.onFilterDropdownVisibleChange]].forEach((H) => {
      let [K, X, W] = H;
      nt(W == null, "Table", `\`${K}\` is deprecated. Please use \`${X}\` instead.`);
    });
    const s = Q(!1), c = P(() => {
      var H;
      return !!(e.filterState && (!((H = e.filterState.filteredKeys) === null || H === void 0) && H.length || e.filterState.forceFiltered));
    }), u = P(() => {
      var H;
      return Mp((H = e.column) === null || H === void 0 ? void 0 : H.filters);
    }), d = P(() => {
      const {
        filterDropdown: H,
        slots: K = {},
        customFilterDropdown: X
      } = e.column;
      return H || K.filterDropdown && o.value[K.filterDropdown] || X && o.value.customFilterDropdown;
    }), p = P(() => {
      const {
        filterIcon: H,
        slots: K = {}
      } = e.column;
      return H || K.filterIcon && o.value[K.filterIcon] || o.value.customFilterIcon;
    }), v = (H) => {
      var K;
      s.value = H, (K = i.value) === null || K === void 0 || K.call(i, H);
    }, h = P(() => typeof a.value == "boolean" ? a.value : s.value), g = P(() => {
      var H;
      return (H = e.filterState) === null || H === void 0 ? void 0 : H.filteredKeys;
    }), b = Q([]), y = (H) => {
      let {
        selectedKeys: K
      } = H;
      b.value = K;
    }, S = (H, K) => {
      let {
        node: X,
        checked: W
      } = K;
      e.filterMultiple ? y({
        selectedKeys: H
      }) : y({
        selectedKeys: W && X.key ? [X.key] : []
      });
    };
    ie(g, () => {
      s.value && y({
        selectedKeys: g.value || []
      });
    }, {
      immediate: !0
    });
    const C = Q([]), w = Q(), $ = (H) => {
      w.value = setTimeout(() => {
        C.value = H;
      });
    }, O = () => {
      clearTimeout(w.value);
    };
    et(() => {
      clearTimeout(w.value);
    });
    const x = Q(""), I = (H) => {
      const {
        value: K
      } = H.target;
      x.value = K;
    };
    ie(s, () => {
      s.value || (x.value = "");
    });
    const E = (H) => {
      const {
        column: K,
        columnKey: X,
        filterState: W
      } = e, q = H && H.length ? H : null;
      if (q === null && (!W || !W.filteredKeys) || Aw(q, W == null ? void 0 : W.filteredKeys, !0))
        return null;
      e.triggerFilter({
        column: K,
        key: X,
        filteredKeys: q
      });
    }, _ = () => {
      v(!1), E(b.value);
    }, M = function() {
      let {
        confirm: H,
        closeDropdown: K
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        confirm: !1,
        closeDropdown: !1
      };
      H && E([]), K && v(!1), x.value = "", e.column.filterResetToDefaultFilteredValue ? b.value = (e.column.defaultFilteredValue || []).map((X) => String(X)) : b.value = [];
    }, R = function() {
      let {
        closeDropdown: H
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        closeDropdown: !0
      };
      H && v(!1), E(b.value);
    }, A = (H) => {
      H && g.value !== void 0 && (b.value = g.value || []), v(H), !H && !d.value && _();
    }, {
      direction: z
    } = Ie("", e), T = (H) => {
      if (H.target.checked) {
        const K = u.value;
        b.value = K;
      } else
        b.value = [];
    }, N = (H) => {
      let {
        filters: K
      } = H;
      return (K || []).map((X, W) => {
        const q = String(X.value), J = {
          title: X.text,
          key: X.value !== void 0 ? q : W
        };
        return X.children && (J.children = N({
          filters: X.children
        })), J;
      });
    }, k = (H) => {
      var K;
      return m(m({}, H), {
        text: H.title,
        value: H.key,
        children: ((K = H.children) === null || K === void 0 ? void 0 : K.map((X) => k(X))) || []
      });
    }, B = P(() => N({
      filters: e.column.filters
    })), F = P(() => ee({
      [`${e.dropdownPrefixCls}-menu-without-submenu`]: !Jte(e.column.filters || [])
    })), L = () => {
      const H = b.value, {
        column: K,
        locale: X,
        tablePrefixCls: W,
        filterMultiple: q,
        dropdownPrefixCls: J,
        getPopupContainer: ne,
        prefixCls: te
      } = e;
      return (K.filters || []).length === 0 ? f(cl, {
        image: cl.PRESENTED_IMAGE_SIMPLE,
        description: X.filterEmptyText,
        imageStyle: {
          height: 24
        },
        style: {
          margin: 0,
          padding: "16px 0"
        }
      }, null) : r.value === "tree" ? f(Fe, null, [f(hw, {
        filterSearch: l.value,
        value: x.value,
        onChange: I,
        tablePrefixCls: W,
        locale: X
      }, null), f("div", {
        class: `${W}-filter-dropdown-tree`
      }, [q ? f(io, {
        class: `${W}-filter-dropdown-checkall`,
        onChange: T,
        checked: H.length === u.value.length,
        indeterminate: H.length > 0 && H.length < u.value.length
      }, {
        default: () => [X.filterCheckall]
      }) : null, f(k6, {
        checkable: !0,
        selectable: !1,
        blockNode: !0,
        multiple: q,
        checkStrictly: !q,
        class: `${J}-menu`,
        onCheck: S,
        checkedKeys: H,
        selectedKeys: H,
        showIcon: !1,
        treeData: B.value,
        autoExpandParent: !0,
        defaultExpandAll: !0,
        filterTreeNode: x.value.trim() ? (G) => typeof l.value == "function" ? l.value(x.value, k(G)) : B6(x.value, G.title) : void 0
      }, null)])]) : f(Fe, null, [f(hw, {
        filterSearch: l.value,
        value: x.value,
        onChange: I,
        tablePrefixCls: W,
        locale: X
      }, null), f(en, {
        multiple: q,
        prefixCls: `${J}-menu`,
        class: F.value,
        onClick: O,
        onSelect: y,
        onDeselect: y,
        selectedKeys: H,
        getPopupContainer: ne,
        openKeys: C.value,
        onOpenChange: $
      }, {
        default: () => F6({
          filters: K.filters || [],
          filterSearch: l.value,
          prefixCls: te,
          filteredKeys: b.value,
          filterMultiple: q,
          searchValue: x.value
        })
      })]);
    }, j = P(() => {
      const H = b.value;
      return e.column.filterResetToDefaultFilteredValue ? Aw((e.column.defaultFilteredValue || []).map((K) => String(K)), H, !0) : H.length === 0;
    });
    return () => {
      var H;
      const {
        tablePrefixCls: K,
        prefixCls: X,
        column: W,
        dropdownPrefixCls: q,
        locale: J,
        getPopupContainer: ne
      } = e;
      let te;
      typeof d.value == "function" ? te = d.value({
        prefixCls: `${q}-custom`,
        setSelectedKeys: (re) => y({
          selectedKeys: re
        }),
        selectedKeys: b.value,
        confirm: R,
        clearFilters: M,
        filters: W.filters,
        visible: h.value,
        column: W.__originColumn__,
        close: () => {
          v(!1);
        }
      }) : d.value ? te = d.value : te = f(Fe, null, [L(), f("div", {
        class: `${X}-dropdown-btns`
      }, [f(Kt, {
        type: "link",
        size: "small",
        disabled: j.value,
        onClick: () => M()
      }, {
        default: () => [J.filterReset]
      }), f(Kt, {
        type: "primary",
        size: "small",
        onClick: _
      }, {
        default: () => [J.filterConfirm]
      })])]);
      const G = f(Ste, {
        class: `${X}-dropdown`
      }, {
        default: () => [te]
      });
      let U;
      return typeof p.value == "function" ? U = p.value({
        filtered: c.value,
        column: W.__originColumn__
      }) : p.value ? U = p.value : U = f(Wb, null, null), f("div", {
        class: `${X}-column`
      }, [f("span", {
        class: `${K}-column-title`
      }, [(H = n.default) === null || H === void 0 ? void 0 : H.call(n)]), f(er, {
        overlay: G,
        trigger: ["click"],
        open: h.value,
        onOpenChange: A,
        getPopupContainer: ne,
        placement: z.value === "rtl" ? "bottomLeft" : "bottomRight"
      }, {
        default: () => [f("span", {
          role: "button",
          tabindex: -1,
          class: ee(`${X}-trigger`, {
            active: c.value
          }),
          onClick: (re) => {
            re.stopPropagation();
          }
        }, [U])]
      })]);
    };
  }
});
function Hm(e, t, n) {
  let o = [];
  return (e || []).forEach((r, l) => {
    var a, i;
    const s = wc(l, n), c = r.filterDropdown || ((a = r == null ? void 0 : r.slots) === null || a === void 0 ? void 0 : a.filterDropdown) || r.customFilterDropdown;
    if (r.filters || c || "onFilter" in r)
      if ("filteredValue" in r) {
        let u = r.filteredValue;
        c || (u = (i = u == null ? void 0 : u.map(String)) !== null && i !== void 0 ? i : u), o.push({
          column: r,
          key: va(r, s),
          filteredKeys: u,
          forceFiltered: r.filtered
        });
      } else
        o.push({
          column: r,
          key: va(r, s),
          filteredKeys: t && r.defaultFilteredValue ? r.defaultFilteredValue : void 0,
          forceFiltered: r.filtered
        });
    "children" in r && (o = [...o, ...Hm(r.children, t, s)]);
  }), o;
}
function L6(e, t, n, o, r, l, a, i) {
  return n.map((s, c) => {
    var u;
    const d = wc(c, i), {
      filterMultiple: p = !0,
      filterMode: v,
      filterSearch: h
    } = s;
    let g = s;
    const b = s.filterDropdown || ((u = s == null ? void 0 : s.slots) === null || u === void 0 ? void 0 : u.filterDropdown) || s.customFilterDropdown;
    if (g.filters || b) {
      const y = va(g, d), S = o.find((C) => {
        let {
          key: w
        } = C;
        return y === w;
      });
      g = m(m({}, g), {
        title: (C) => f(ene, {
          tablePrefixCls: e,
          prefixCls: `${e}-filter`,
          dropdownPrefixCls: t,
          column: g,
          columnKey: y,
          filterState: S,
          filterMultiple: p,
          filterMode: v,
          filterSearch: h,
          triggerFilter: l,
          locale: r,
          getPopupContainer: a
        }, {
          default: () => [Vb(s.title, C)]
        })
      });
    }
    return "children" in g && (g = m(m({}, g), {
      children: L6(e, t, g.children, o, r, l, a, d)
    })), g;
  });
}
function Mp(e) {
  let t = [];
  return (e || []).forEach((n) => {
    let {
      value: o,
      children: r
    } = n;
    t.push(o), r && (t = [...t, ...Mp(r)]);
  }), t;
}
function Dw(e) {
  const t = {};
  return e.forEach((n) => {
    let {
      key: o,
      filteredKeys: r,
      column: l
    } = n;
    var a;
    const i = l.filterDropdown || ((a = l == null ? void 0 : l.slots) === null || a === void 0 ? void 0 : a.filterDropdown) || l.customFilterDropdown, {
      filters: s
    } = l;
    if (i)
      t[o] = r || null;
    else if (Array.isArray(r)) {
      const c = Mp(s);
      t[o] = c.filter((u) => r.includes(String(u)));
    } else
      t[o] = null;
  }), t;
}
function Nw(e, t) {
  return t.reduce((n, o) => {
    const {
      column: {
        onFilter: r,
        filters: l
      },
      filteredKeys: a
    } = o;
    return r && a && a.length ? n.filter((i) => a.some((s) => {
      const c = Mp(l), u = c.findIndex((p) => String(p) === String(s)), d = u !== -1 ? c[u] : s;
      return r(d, i);
    })) : n;
  }, e);
}
function z6(e) {
  return e.flatMap((t) => "children" in t ? [t, ...z6(t.children || [])] : [t]);
}
function tne(e) {
  let {
    prefixCls: t,
    dropdownPrefixCls: n,
    mergedColumns: o,
    locale: r,
    onFilterChange: l,
    getPopupContainer: a
  } = e;
  const i = P(() => z6(o.value)), [s, c] = Pt(Hm(i.value, !0)), u = P(() => {
    const h = Hm(i.value, !1);
    if (h.length === 0)
      return h;
    let g = !0, b = !0;
    if (h.forEach((y) => {
      let {
        filteredKeys: S
      } = y;
      S !== void 0 ? g = !1 : b = !1;
    }), g) {
      const y = (i.value || []).map((S, C) => va(S, wc(C)));
      return s.value.filter((S) => {
        let {
          key: C
        } = S;
        return y.includes(C);
      }).map((S) => {
        const C = i.value[y.findIndex((w) => w === S.key)];
        return m(m({}, S), {
          column: m(m({}, S.column), C),
          forceFiltered: C.filtered
        });
      });
    }
    return nt(b, "Table", "Columns should all contain `filteredValue` or not contain `filteredValue`."), h;
  }), d = P(() => Dw(u.value)), p = (h) => {
    const g = u.value.filter((b) => {
      let {
        key: y
      } = b;
      return y !== h.key;
    });
    g.push(h), c(g), l(Dw(g), g);
  };
  return [(h) => L6(t.value, n.value, h, u.value, r.value, p, a.value), u, d];
}
function H6(e, t) {
  return e.map((n) => {
    const o = m({}, n);
    return o.title = Vb(o.title, t), "children" in o && (o.children = H6(o.children, t)), o;
  });
}
function nne(e) {
  return [(n) => H6(n, e.value)];
}
function one(e) {
  return function(n) {
    let {
      prefixCls: o,
      onExpand: r,
      record: l,
      expanded: a,
      expandable: i
    } = n;
    const s = `${o}-row-expand-icon`;
    return f("button", {
      type: "button",
      onClick: (c) => {
        r(l, c), c.stopPropagation();
      },
      class: ee(s, {
        [`${s}-spaced`]: !i,
        [`${s}-expanded`]: i && a,
        [`${s}-collapsed`]: i && !a
      }),
      "aria-label": a ? e.collapse : e.expand,
      "aria-expanded": a
    }, null);
  };
}
function j6(e, t) {
  const n = t.value;
  return e.map((o) => {
    var r;
    if (o === Yo || o === pr)
      return o;
    const l = m({}, o), {
      slots: a = {}
    } = l;
    return l.__originColumn__ = o, nt(!("slots" in l), "Table", "`column.slots` is deprecated. Please use `v-slot:headerCell` `v-slot:bodyCell` instead."), Object.keys(a).forEach((i) => {
      const s = a[i];
      l[i] === void 0 && n[s] && (l[i] = n[s]);
    }), t.value.headerCell && !(!((r = o.slots) === null || r === void 0) && r.title) && (l.title = Pf(t.value, "headerCell", {
      title: o.title,
      column: o
    }, () => [o.title])), "children" in l && Array.isArray(l.children) && (l.children = j6(l.children, t)), l;
  });
}
function rne(e) {
  return [(n) => j6(n, e)];
}
const lne = (e) => {
  const {
    componentCls: t
  } = e, n = `${e.lineWidth}px ${e.lineType} ${e.tableBorderColor}`, o = (r, l, a) => ({
    [`&${t}-${r}`]: {
      [`> ${t}-container`]: {
        [`> ${t}-content, > ${t}-body`]: {
          "> table > tbody > tr > td": {
            [`> ${t}-expanded-row-fixed`]: {
              margin: `-${l}px -${a + e.lineWidth}px`
            }
          }
        }
      }
    }
  });
  return {
    [`${t}-wrapper`]: {
      [`${t}${t}-bordered`]: m(m(m({
        // ============================ Title =============================
        [`> ${t}-title`]: {
          border: n,
          borderBottom: 0
        },
        // ============================ Content ============================
        [`> ${t}-container`]: {
          borderInlineStart: n,
          [`
            > ${t}-content,
            > ${t}-header,
            > ${t}-body,
            > ${t}-summary
          `]: {
            "> table": {
              // ============================= Cell =============================
              "\n                > thead > tr > th,\n                > tbody > tr > td,\n                > tfoot > tr > th,\n                > tfoot > tr > td\n              ": {
                borderInlineEnd: n
              },
              // ============================ Header ============================
              "> thead": {
                "> tr:not(:last-child) > th": {
                  borderBottom: n
                },
                "> tr > th::before": {
                  backgroundColor: "transparent !important"
                }
              },
              // Fixed right should provides additional border
              "\n                > thead > tr,\n                > tbody > tr,\n                > tfoot > tr\n              ": {
                [`> ${t}-cell-fix-right-first::after`]: {
                  borderInlineEnd: n
                }
              },
              // ========================== Expandable ==========================
              "> tbody > tr > td": {
                [`> ${t}-expanded-row-fixed`]: {
                  margin: `-${e.tablePaddingVertical}px -${e.tablePaddingHorizontal + e.lineWidth}px`,
                  "&::after": {
                    position: "absolute",
                    top: 0,
                    insetInlineEnd: e.lineWidth,
                    bottom: 0,
                    borderInlineEnd: n,
                    content: '""'
                  }
                }
              }
            }
          },
          [`
            > ${t}-content,
            > ${t}-header
          `]: {
            "> table": {
              borderTop: n
            }
          }
        },
        // ============================ Scroll ============================
        [`&${t}-scroll-horizontal`]: {
          [`> ${t}-container > ${t}-body`]: {
            "> table > tbody": {
              [`
                > tr${t}-expanded-row,
                > tr${t}-placeholder
              `]: {
                "> td": {
                  borderInlineEnd: 0
                }
              }
            }
          }
        }
      }, o("middle", e.tablePaddingVerticalMiddle, e.tablePaddingHorizontalMiddle)), o("small", e.tablePaddingVerticalSmall, e.tablePaddingHorizontalSmall)), {
        // ============================ Footer ============================
        [`> ${t}-footer`]: {
          border: n,
          borderTop: 0
        }
      }),
      // ============================ Nested ============================
      [`${t}-cell`]: {
        [`${t}-container:first-child`]: {
          // :first-child to avoid the case when bordered and title is set
          borderTop: 0
        },
        // https://github.com/ant-design/ant-design/issues/35577
        "&-scrollbar:not([rowspan])": {
          boxShadow: `0 ${e.lineWidth}px 0 ${e.lineWidth}px ${e.tableHeaderBg}`
        }
      }
    }
  };
}, ane = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-wrapper`]: {
      [`${t}-cell-ellipsis`]: m(m({}, tn), {
        wordBreak: "keep-all",
        // Fixed first or last should special process
        [`
          &${t}-cell-fix-left-last,
          &${t}-cell-fix-right-first
        `]: {
          overflow: "visible",
          [`${t}-cell-content`]: {
            display: "block",
            overflow: "hidden",
            textOverflow: "ellipsis"
          }
        },
        [`${t}-column-title`]: {
          overflow: "hidden",
          textOverflow: "ellipsis",
          wordBreak: "keep-all"
        }
      })
    }
  };
}, ine = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-wrapper`]: {
      [`${t}-tbody > tr${t}-placeholder`]: {
        textAlign: "center",
        color: e.colorTextDisabled,
        "&:hover > td": {
          background: e.colorBgContainer
        }
      }
    }
  };
}, sne = (e) => {
  const {
    componentCls: t,
    antCls: n,
    controlInteractiveSize: o,
    motionDurationSlow: r,
    lineWidth: l,
    paddingXS: a,
    lineType: i,
    tableBorderColor: s,
    tableExpandIconBg: c,
    tableExpandColumnWidth: u,
    borderRadius: d,
    fontSize: p,
    fontSizeSM: v,
    lineHeight: h,
    tablePaddingVertical: g,
    tablePaddingHorizontal: b,
    tableExpandedRowBg: y,
    paddingXXS: S
  } = e, C = o / 2 - l, w = C * 2 + l * 3, $ = `${l}px ${i} ${s}`, O = S - l;
  return {
    [`${t}-wrapper`]: {
      [`${t}-expand-icon-col`]: {
        width: u
      },
      [`${t}-row-expand-icon-cell`]: {
        textAlign: "center",
        [`${t}-row-expand-icon`]: {
          display: "inline-flex",
          float: "none",
          verticalAlign: "sub"
        }
      },
      [`${t}-row-indent`]: {
        height: 1,
        float: "left"
      },
      [`${t}-row-expand-icon`]: m(m({}, wf(e)), {
        position: "relative",
        float: "left",
        boxSizing: "border-box",
        width: w,
        height: w,
        padding: 0,
        color: "inherit",
        lineHeight: `${w}px`,
        background: c,
        border: $,
        borderRadius: d,
        transform: `scale(${o / w})`,
        transition: `all ${r}`,
        userSelect: "none",
        "&:focus, &:hover, &:active": {
          borderColor: "currentcolor"
        },
        "&::before, &::after": {
          position: "absolute",
          background: "currentcolor",
          transition: `transform ${r} ease-out`,
          content: '""'
        },
        "&::before": {
          top: C,
          insetInlineEnd: O,
          insetInlineStart: O,
          height: l
        },
        "&::after": {
          top: O,
          bottom: O,
          insetInlineStart: C,
          width: l,
          transform: "rotate(90deg)"
        },
        // Motion effect
        "&-collapsed::before": {
          transform: "rotate(-180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        },
        "&-spaced": {
          "&::before, &::after": {
            display: "none",
            content: "none"
          },
          background: "transparent",
          border: 0,
          visibility: "hidden"
        }
      }),
      [`${t}-row-indent + ${t}-row-expand-icon`]: {
        marginTop: (p * h - l * 3) / 2 - Math.ceil((v * 1.4 - l * 3) / 2),
        marginInlineEnd: a
      },
      [`tr${t}-expanded-row`]: {
        "&, &:hover": {
          "> td": {
            background: y
          }
        },
        // https://github.com/ant-design/ant-design/issues/25573
        [`${n}-descriptions-view`]: {
          display: "flex",
          table: {
            flex: "auto",
            width: "auto"
          }
        }
      },
      // With fixed
      [`${t}-expanded-row-fixed`]: {
        position: "relative",
        margin: `-${g}px -${b}px`,
        padding: `${g}px ${b}px`
      }
    }
  };
}, cne = (e) => {
  const {
    componentCls: t,
    antCls: n,
    iconCls: o,
    tableFilterDropdownWidth: r,
    tableFilterDropdownSearchWidth: l,
    paddingXXS: a,
    paddingXS: i,
    colorText: s,
    lineWidth: c,
    lineType: u,
    tableBorderColor: d,
    tableHeaderIconColor: p,
    fontSizeSM: v,
    tablePaddingHorizontal: h,
    borderRadius: g,
    motionDurationSlow: b,
    colorTextDescription: y,
    colorPrimary: S,
    tableHeaderFilterActiveBg: C,
    colorTextDisabled: w,
    tableFilterDropdownBg: $,
    tableFilterDropdownHeight: O,
    controlItemBgHover: x,
    controlItemBgActive: I,
    boxShadowSecondary: E
  } = e, _ = `${n}-dropdown`, M = `${t}-filter-dropdown`, R = `${n}-tree`, A = `${c}px ${u} ${d}`;
  return [
    {
      [`${t}-wrapper`]: {
        [`${t}-filter-column`]: {
          display: "flex",
          justifyContent: "space-between"
        },
        [`${t}-filter-trigger`]: {
          position: "relative",
          display: "flex",
          alignItems: "center",
          marginBlock: -a,
          marginInline: `${a}px ${-h / 2}px`,
          padding: `0 ${a}px`,
          color: p,
          fontSize: v,
          borderRadius: g,
          cursor: "pointer",
          transition: `all ${b}`,
          "&:hover": {
            color: y,
            background: C
          },
          "&.active": {
            color: S
          }
        }
      }
    },
    {
      // Dropdown
      [`${n}-dropdown`]: {
        [M]: m(m({}, qe(e)), {
          minWidth: r,
          backgroundColor: $,
          borderRadius: g,
          boxShadow: E,
          // Reset menu
          [`${_}-menu`]: {
            // https://github.com/ant-design/ant-design/issues/4916
            // https://github.com/ant-design/ant-design/issues/19542
            maxHeight: O,
            overflowX: "hidden",
            border: 0,
            boxShadow: "none",
            "&:empty::after": {
              display: "block",
              padding: `${i}px 0`,
              color: w,
              fontSize: v,
              textAlign: "center",
              content: '"Not Found"'
            }
          },
          [`${M}-tree`]: {
            paddingBlock: `${i}px 0`,
            paddingInline: i,
            [R]: {
              padding: 0
            },
            [`${R}-treenode ${R}-node-content-wrapper:hover`]: {
              backgroundColor: x
            },
            [`${R}-treenode-checkbox-checked ${R}-node-content-wrapper`]: {
              "&, &:hover": {
                backgroundColor: I
              }
            }
          },
          [`${M}-search`]: {
            padding: i,
            borderBottom: A,
            "&-input": {
              input: {
                minWidth: l
              },
              [o]: {
                color: w
              }
            }
          },
          [`${M}-checkall`]: {
            width: "100%",
            marginBottom: a,
            marginInlineStart: a
          },
          // Operation
          [`${M}-btns`]: {
            display: "flex",
            justifyContent: "space-between",
            padding: `${i - c}px ${i}px`,
            overflow: "hidden",
            backgroundColor: "inherit",
            borderTop: A
          }
        })
      }
    },
    // Dropdown Menu & SubMenu
    {
      // submenu of table filter dropdown
      [`${n}-dropdown ${M}, ${M}-submenu`]: {
        // Checkbox
        [`${n}-checkbox-wrapper + span`]: {
          paddingInlineStart: i,
          color: s
        },
        "> ul": {
          maxHeight: "calc(100vh - 130px)",
          overflowX: "hidden",
          overflowY: "auto"
        }
      }
    }
  ];
}, une = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    colorSplit: o,
    motionDurationSlow: r,
    zIndexTableFixed: l,
    tableBg: a,
    zIndexTableSticky: i
  } = e, s = o;
  return {
    [`${t}-wrapper`]: {
      [`
        ${t}-cell-fix-left,
        ${t}-cell-fix-right
      `]: {
        position: "sticky !important",
        zIndex: l,
        background: a
      },
      [`
        ${t}-cell-fix-left-first::after,
        ${t}-cell-fix-left-last::after
      `]: {
        position: "absolute",
        top: 0,
        right: {
          _skip_check_: !0,
          value: 0
        },
        bottom: -n,
        width: 30,
        transform: "translateX(100%)",
        transition: `box-shadow ${r}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${t}-cell-fix-left-all::after`]: {
        display: "none"
      },
      [`
        ${t}-cell-fix-right-first::after,
        ${t}-cell-fix-right-last::after
      `]: {
        position: "absolute",
        top: 0,
        bottom: -n,
        left: {
          _skip_check_: !0,
          value: 0
        },
        width: 30,
        transform: "translateX(-100%)",
        transition: `box-shadow ${r}`,
        content: '""',
        pointerEvents: "none"
      },
      [`${t}-container`]: {
        "&::before, &::after": {
          position: "absolute",
          top: 0,
          bottom: 0,
          zIndex: i + 1,
          width: 30,
          transition: `box-shadow ${r}`,
          content: '""',
          pointerEvents: "none"
        },
        "&::before": {
          insetInlineStart: 0
        },
        "&::after": {
          insetInlineEnd: 0
        }
      },
      [`${t}-ping-left`]: {
        [`&:not(${t}-has-fix-left) ${t}-container`]: {
          position: "relative",
          "&::before": {
            boxShadow: `inset 10px 0 8px -8px ${s}`
          }
        },
        [`
          ${t}-cell-fix-left-first::after,
          ${t}-cell-fix-left-last::after
        `]: {
          boxShadow: `inset 10px 0 8px -8px ${s}`
        },
        [`${t}-cell-fix-left-last::before`]: {
          backgroundColor: "transparent !important"
        }
      },
      [`${t}-ping-right`]: {
        [`&:not(${t}-has-fix-right) ${t}-container`]: {
          position: "relative",
          "&::after": {
            boxShadow: `inset -10px 0 8px -8px ${s}`
          }
        },
        [`
          ${t}-cell-fix-right-first::after,
          ${t}-cell-fix-right-last::after
        `]: {
          boxShadow: `inset -10px 0 8px -8px ${s}`
        }
      }
    }
  };
}, dne = (e) => {
  const {
    componentCls: t,
    antCls: n
  } = e;
  return {
    [`${t}-wrapper`]: {
      // ========================== Pagination ==========================
      [`${t}-pagination${n}-pagination`]: {
        margin: `${e.margin}px 0`
      },
      [`${t}-pagination`]: {
        display: "flex",
        flexWrap: "wrap",
        rowGap: e.paddingXS,
        "> *": {
          flex: "none"
        },
        "&-left": {
          justifyContent: "flex-start"
        },
        "&-center": {
          justifyContent: "center"
        },
        "&-right": {
          justifyContent: "flex-end"
        }
      }
    }
  };
}, fne = (e) => {
  const {
    componentCls: t,
    tableRadius: n
  } = e;
  return {
    [`${t}-wrapper`]: {
      [t]: {
        // https://github.com/ant-design/ant-design/issues/39115#issuecomment-1362314574
        [`${t}-title, ${t}-header`]: {
          borderRadius: `${n}px ${n}px 0 0`
        },
        [`${t}-title + ${t}-container`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0,
          table: {
            borderRadius: 0,
            "> thead > tr:first-child": {
              "th:first-child": {
                borderRadius: 0
              },
              "th:last-child": {
                borderRadius: 0
              }
            }
          }
        },
        "&-container": {
          borderStartStartRadius: n,
          borderStartEndRadius: n,
          "table > thead > tr:first-child": {
            "> *:first-child": {
              borderStartStartRadius: n
            },
            "> *:last-child": {
              borderStartEndRadius: n
            }
          }
        },
        "&-footer": {
          borderRadius: `0 0 ${n}px ${n}px`
        }
      }
    }
  };
}, pne = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-wrapper-rtl`]: {
      direction: "rtl",
      table: {
        direction: "rtl"
      },
      [`${t}-pagination-left`]: {
        justifyContent: "flex-end"
      },
      [`${t}-pagination-right`]: {
        justifyContent: "flex-start"
      },
      [`${t}-row-expand-icon`]: {
        "&::after": {
          transform: "rotate(-90deg)"
        },
        "&-collapsed::before": {
          transform: "rotate(180deg)"
        },
        "&-collapsed::after": {
          transform: "rotate(0deg)"
        }
      }
    }
  };
}, vne = (e) => {
  const {
    componentCls: t,
    antCls: n,
    iconCls: o,
    fontSizeIcon: r,
    paddingXS: l,
    tableHeaderIconColor: a,
    tableHeaderIconColorHover: i
  } = e;
  return {
    [`${t}-wrapper`]: {
      // ========================== Selections ==========================
      [`${t}-selection-col`]: {
        width: e.tableSelectionColumnWidth
      },
      [`${t}-bordered ${t}-selection-col`]: {
        width: e.tableSelectionColumnWidth + l * 2
      },
      [`
        table tr th${t}-selection-column,
        table tr td${t}-selection-column
      `]: {
        paddingInlineEnd: e.paddingXS,
        paddingInlineStart: e.paddingXS,
        textAlign: "center",
        [`${n}-radio-wrapper`]: {
          marginInlineEnd: 0
        }
      },
      [`table tr th${t}-selection-column${t}-cell-fix-left`]: {
        zIndex: e.zIndexTableFixed + 1
      },
      [`table tr th${t}-selection-column::after`]: {
        backgroundColor: "transparent !important"
      },
      [`${t}-selection`]: {
        position: "relative",
        display: "inline-flex",
        flexDirection: "column"
      },
      [`${t}-selection-extra`]: {
        position: "absolute",
        top: 0,
        zIndex: 1,
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        marginInlineStart: "100%",
        paddingInlineStart: `${e.tablePaddingHorizontal / 4}px`,
        [o]: {
          color: a,
          fontSize: r,
          verticalAlign: "baseline",
          "&:hover": {
            color: i
          }
        }
      }
    }
  };
}, gne = (e) => {
  const {
    componentCls: t
  } = e, n = (o, r, l, a) => ({
    [`${t}${t}-${o}`]: {
      fontSize: a,
      [`
        ${t}-title,
        ${t}-footer,
        ${t}-thead > tr > th,
        ${t}-tbody > tr > td,
        tfoot > tr > th,
        tfoot > tr > td
      `]: {
        padding: `${r}px ${l}px`
      },
      [`${t}-filter-trigger`]: {
        marginInlineEnd: `-${l / 2}px`
      },
      [`${t}-expanded-row-fixed`]: {
        margin: `-${r}px -${l}px`
      },
      [`${t}-tbody`]: {
        // ========================= Nest Table ===========================
        [`${t}-wrapper:only-child ${t}`]: {
          marginBlock: `-${r}px`,
          marginInline: `${e.tableExpandColumnWidth - l}px -${l}px`
        }
      },
      // https://github.com/ant-design/ant-design/issues/35167
      [`${t}-selection-column`]: {
        paddingInlineStart: `${l / 4}px`
      }
    }
  });
  return {
    [`${t}-wrapper`]: m(m({}, n("middle", e.tablePaddingVerticalMiddle, e.tablePaddingHorizontalMiddle, e.tableFontSizeMiddle)), n("small", e.tablePaddingVerticalSmall, e.tablePaddingHorizontalSmall, e.tableFontSizeSmall))
  };
}, mne = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-wrapper ${t}-resize-handle`]: {
      position: "absolute",
      top: 0,
      height: "100% !important",
      bottom: 0,
      left: " auto !important",
      right: " -8px",
      cursor: "col-resize",
      touchAction: "none",
      userSelect: "auto",
      width: "16px",
      zIndex: 1,
      "&-line": {
        display: "block",
        width: "1px",
        marginLeft: "7px",
        height: "100% !important",
        backgroundColor: e.colorPrimary,
        opacity: 0
      },
      "&:hover &-line": {
        opacity: 1
      }
    },
    [`${t}-wrapper  ${t}-resize-handle.dragging`]: {
      overflow: "hidden",
      [`${t}-resize-handle-line`]: {
        opacity: 1
      },
      "&:before": {
        position: "absolute",
        top: 0,
        bottom: 0,
        content: '" "',
        width: "200vw",
        transform: "translateX(-50%)",
        opacity: 0
      }
    }
  };
}, hne = (e) => {
  const {
    componentCls: t,
    marginXXS: n,
    fontSizeIcon: o,
    tableHeaderIconColor: r,
    tableHeaderIconColorHover: l
  } = e;
  return {
    [`${t}-wrapper`]: {
      [`${t}-thead th${t}-column-has-sorters`]: {
        outline: "none",
        cursor: "pointer",
        transition: `all ${e.motionDurationSlow}`,
        "&:hover": {
          background: e.tableHeaderSortHoverBg,
          "&::before": {
            backgroundColor: "transparent !important"
          }
        },
        "&:focus-visible": {
          color: e.colorPrimary
        },
        // https://github.com/ant-design/ant-design/issues/30969
        [`
          &${t}-cell-fix-left:hover,
          &${t}-cell-fix-right:hover
        `]: {
          background: e.tableFixedHeaderSortActiveBg
        }
      },
      [`${t}-thead th${t}-column-sort`]: {
        background: e.tableHeaderSortBg,
        "&::before": {
          backgroundColor: "transparent !important"
        }
      },
      [`td${t}-column-sort`]: {
        background: e.tableBodySortBg
      },
      [`${t}-column-title`]: {
        position: "relative",
        zIndex: 1,
        flex: 1
      },
      [`${t}-column-sorters`]: {
        display: "flex",
        flex: "auto",
        alignItems: "center",
        justifyContent: "space-between",
        "&::after": {
          position: "absolute",
          inset: 0,
          width: "100%",
          height: "100%",
          content: '""'
        }
      },
      [`${t}-column-sorter`]: {
        marginInlineStart: n,
        color: r,
        fontSize: 0,
        transition: `color ${e.motionDurationSlow}`,
        "&-inner": {
          display: "inline-flex",
          flexDirection: "column",
          alignItems: "center"
        },
        "&-up, &-down": {
          fontSize: o,
          "&.active": {
            color: e.colorPrimary
          }
        },
        [`${t}-column-sorter-up + ${t}-column-sorter-down`]: {
          marginTop: "-0.3em"
        }
      },
      [`${t}-column-sorters:hover ${t}-column-sorter`]: {
        color: l
      }
    }
  };
}, bne = (e) => {
  const {
    componentCls: t,
    opacityLoading: n,
    tableScrollThumbBg: o,
    tableScrollThumbBgHover: r,
    tableScrollThumbSize: l,
    tableScrollBg: a,
    zIndexTableSticky: i
  } = e, s = `${e.lineWidth}px ${e.lineType} ${e.tableBorderColor}`;
  return {
    [`${t}-wrapper`]: {
      [`${t}-sticky`]: {
        "&-holder": {
          position: "sticky",
          zIndex: i,
          background: e.colorBgContainer
        },
        "&-scroll": {
          position: "sticky",
          bottom: 0,
          height: `${l}px !important`,
          zIndex: i,
          display: "flex",
          alignItems: "center",
          background: a,
          borderTop: s,
          opacity: n,
          "&:hover": {
            transformOrigin: "center bottom"
          },
          // fake scrollbar style of sticky
          "&-bar": {
            height: l,
            backgroundColor: o,
            borderRadius: 100,
            transition: `all ${e.motionDurationSlow}, transform none`,
            position: "absolute",
            bottom: 0,
            "&:hover, &-active": {
              backgroundColor: r
            }
          }
        }
      }
    }
  };
}, Rw = (e) => {
  const {
    componentCls: t,
    lineWidth: n,
    tableBorderColor: o
  } = e, r = `${n}px ${e.lineType} ${o}`;
  return {
    [`${t}-wrapper`]: {
      [`${t}-summary`]: {
        position: "relative",
        zIndex: e.zIndexTableFixed,
        background: e.tableBg,
        "> tr": {
          "> th, > td": {
            borderBottom: r
          }
        }
      },
      [`div${t}-summary`]: {
        boxShadow: `0 -${n}px 0 ${o}`
      }
    }
  };
}, yne = (e) => {
  const {
    componentCls: t,
    fontWeightStrong: n,
    tablePaddingVertical: o,
    tablePaddingHorizontal: r,
    lineWidth: l,
    lineType: a,
    tableBorderColor: i,
    tableFontSize: s,
    tableBg: c,
    tableRadius: u,
    tableHeaderTextColor: d,
    motionDurationMid: p,
    tableHeaderBg: v,
    tableHeaderCellSplitColor: h,
    tableRowHoverBg: g,
    tableSelectedRowBg: b,
    tableSelectedRowHoverBg: y,
    tableFooterTextColor: S,
    tableFooterBg: C,
    paddingContentVerticalLG: w
  } = e, $ = `${l}px ${a} ${i}`;
  return {
    [`${t}-wrapper`]: m(m({
      clear: "both",
      maxWidth: "100%"
    }, nr()), {
      [t]: m(m({}, qe(e)), {
        fontSize: s,
        background: c,
        borderRadius: `${u}px ${u}px 0 0`
      }),
      // https://github.com/ant-design/ant-design/issues/17611
      table: {
        width: "100%",
        textAlign: "start",
        borderRadius: `${u}px ${u}px 0 0`,
        borderCollapse: "separate",
        borderSpacing: 0
      },
      // ============================= Cell =============================
      [`
          ${t}-thead > tr > th,
          ${t}-tbody > tr > td,
          tfoot > tr > th,
          tfoot > tr > td
        `]: {
        position: "relative",
        padding: `${w}px ${r}px`,
        overflowWrap: "break-word"
      },
      // ============================ Title =============================
      [`${t}-title`]: {
        padding: `${o}px ${r}px`
      },
      // ============================ Header ============================
      [`${t}-thead`]: {
        "\n          > tr > th,\n          > tr > td\n        ": {
          position: "relative",
          color: d,
          fontWeight: n,
          textAlign: "start",
          background: v,
          borderBottom: $,
          transition: `background ${p} ease`,
          "&[colspan]:not([colspan='1'])": {
            textAlign: "center"
          },
          [`&:not(:last-child):not(${t}-selection-column):not(${t}-row-expand-icon-cell):not([colspan])::before`]: {
            position: "absolute",
            top: "50%",
            insetInlineEnd: 0,
            width: 1,
            height: "1.6em",
            backgroundColor: h,
            transform: "translateY(-50%)",
            transition: `background-color ${p}`,
            content: '""'
          }
        },
        "> tr:not(:last-child) > th[colspan]": {
          borderBottom: 0
        }
      },
      // ============================ Body ============================
      // Borderless Table has unique hover style, which would be implemented with `borderTop`.
      [`${t}:not(${t}-bordered)`]: {
        [`${t}-tbody`]: {
          "> tr": {
            "> td": {
              borderTop: $,
              borderBottom: "transparent"
            },
            "&:last-child > td": {
              borderBottom: $
            },
            [`&:first-child > td,
              &${t}-measure-row + tr > td`]: {
              borderTop: "none",
              borderTopColor: "transparent"
            }
          }
        }
      },
      // Bordered Table remains simple `borderBottom`.
      // Ref issue: https://github.com/ant-design/ant-design/issues/38724
      [`${t}${t}-bordered`]: {
        [`${t}-tbody`]: {
          "> tr": {
            "> td": {
              borderBottom: $
            }
          }
        }
      },
      [`${t}-tbody`]: {
        "> tr": {
          "> td": {
            transition: `background ${p}, border-color ${p}`,
            // ========================= Nest Table ===========================
            [`
              > ${t}-wrapper:only-child,
              > ${t}-expanded-row-fixed > ${t}-wrapper:only-child
            `]: {
              [t]: {
                marginBlock: `-${o}px`,
                marginInline: `${e.tableExpandColumnWidth - r}px -${r}px`,
                [`${t}-tbody > tr:last-child > td`]: {
                  borderBottom: 0,
                  "&:first-child, &:last-child": {
                    borderRadius: 0
                  }
                }
              }
            }
          },
          [`
            &${t}-row:hover > td,
            > td${t}-cell-row-hover
          `]: {
            background: g
          },
          [`&${t}-row-selected`]: {
            "> td": {
              background: b
            },
            "&:hover > td": {
              background: y
            }
          }
        }
      },
      // ============================ Footer ============================
      [`${t}-footer`]: {
        padding: `${o}px ${r}px`,
        color: S,
        background: C
      }
    })
  };
}, Sne = Xe("Table", (e) => {
  const {
    controlItemBgActive: t,
    controlItemBgActiveHover: n,
    colorTextPlaceholder: o,
    colorTextHeading: r,
    colorSplit: l,
    colorBorderSecondary: a,
    fontSize: i,
    padding: s,
    paddingXS: c,
    paddingSM: u,
    controlHeight: d,
    colorFillAlter: p,
    colorIcon: v,
    colorIconHover: h,
    opacityLoading: g,
    colorBgContainer: b,
    borderRadiusLG: y,
    colorFillContent: S,
    colorFillSecondary: C,
    controlInteractiveSize: w
  } = e, $ = new Ct(v), O = new Ct(h), x = t, I = 2, E = new Ct(C).onBackground(b).toHexString(), _ = new Ct(S).onBackground(b).toHexString(), M = new Ct(p).onBackground(b).toHexString(), R = He(e, {
    tableFontSize: i,
    tableBg: b,
    tableRadius: y,
    tablePaddingVertical: s,
    tablePaddingHorizontal: s,
    tablePaddingVerticalMiddle: u,
    tablePaddingHorizontalMiddle: c,
    tablePaddingVerticalSmall: c,
    tablePaddingHorizontalSmall: c,
    tableBorderColor: a,
    tableHeaderTextColor: r,
    tableHeaderBg: M,
    tableFooterTextColor: r,
    tableFooterBg: M,
    tableHeaderCellSplitColor: a,
    tableHeaderSortBg: E,
    tableHeaderSortHoverBg: _,
    tableHeaderIconColor: $.clone().setAlpha($.getAlpha() * g).toRgbString(),
    tableHeaderIconColorHover: O.clone().setAlpha(O.getAlpha() * g).toRgbString(),
    tableBodySortBg: M,
    tableFixedHeaderSortActiveBg: E,
    tableHeaderFilterActiveBg: S,
    tableFilterDropdownBg: b,
    tableRowHoverBg: M,
    tableSelectedRowBg: x,
    tableSelectedRowHoverBg: n,
    zIndexTableFixed: I,
    zIndexTableSticky: I + 1,
    tableFontSizeMiddle: i,
    tableFontSizeSmall: i,
    tableSelectionColumnWidth: d,
    tableExpandIconBg: b,
    tableExpandColumnWidth: w + 2 * e.padding,
    tableExpandedRowBg: p,
    // Dropdown
    tableFilterDropdownWidth: 120,
    tableFilterDropdownHeight: 264,
    tableFilterDropdownSearchWidth: 140,
    // Virtual Scroll Bar
    tableScrollThumbSize: 8,
    tableScrollThumbBg: o,
    tableScrollThumbBgHover: r,
    tableScrollBg: l
  });
  return [yne(R), dne(R), Rw(R), hne(R), cne(R), lne(R), fne(R), sne(R), Rw(R), ine(R), vne(R), une(R), bne(R), ane(R), gne(R), mne(R), pne(R)];
}), Cne = [], V6 = () => ({
  prefixCls: ke(),
  columns: vt(),
  rowKey: je([String, Function]),
  tableLayout: ke(),
  rowClassName: je([String, Function]),
  title: le(),
  footer: le(),
  id: ke(),
  showHeader: ve(),
  components: Re(),
  customRow: le(),
  customHeaderRow: le(),
  direction: ke(),
  expandFixed: je([Boolean, String]),
  expandColumnWidth: Number,
  expandedRowKeys: vt(),
  defaultExpandedRowKeys: vt(),
  expandedRowRender: le(),
  expandRowByClick: ve(),
  expandIcon: le(),
  onExpand: le(),
  onExpandedRowsChange: le(),
  "onUpdate:expandedRowKeys": le(),
  defaultExpandAllRows: ve(),
  indentSize: Number,
  /** @deprecated Please use `EXPAND_COLUMN` in `columns` directly */
  expandIconColumnIndex: Number,
  showExpandColumn: ve(),
  expandedRowClassName: le(),
  childrenColumnName: ke(),
  rowExpandable: le(),
  sticky: je([Boolean, Object]),
  dropdownPrefixCls: String,
  dataSource: vt(),
  pagination: je([Boolean, Object]),
  loading: je([Boolean, Object]),
  size: ke(),
  bordered: ve(),
  locale: Re(),
  onChange: le(),
  onResizeColumn: le(),
  rowSelection: Re(),
  getPopupContainer: le(),
  scroll: Re(),
  sortDirections: vt(),
  showSorterTooltip: je([Boolean, Object], !0),
  transformCellText: le()
}), $ne = Z({
  name: "InternalTable",
  inheritAttrs: !1,
  props: Qe(m(m({}, V6()), {
    contextSlots: Re()
  }), {
    rowKey: "key"
  }),
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r,
      emit: l
    } = t;
    nt(!(typeof e.rowKey == "function" && e.rowKey.length > 1), "Table", "`index` parameter of `rowKey` function is deprecated. There is no guarantee that it will work as expected."), vee(P(() => e.contextSlots)), gee({
      onResizeColumn: (fe, be) => {
        l("resizeColumn", fe, be);
      }
    });
    const a = ki(), i = P(() => {
      const fe = new Set(Object.keys(a.value).filter((be) => a.value[be]));
      return e.columns.filter((be) => !be.responsive || be.responsive.some((ue) => fe.has(ue)));
    }), {
      size: s,
      renderEmpty: c,
      direction: u,
      prefixCls: d,
      configProvider: p
    } = Ie("table", e), [v, h] = Sne(d), g = P(() => {
      var fe;
      return e.transformCellText || ((fe = p.transformCellText) === null || fe === void 0 ? void 0 : fe.value);
    }), [b] = jo("Table", Zn.Table, Te(e, "locale")), y = P(() => e.dataSource || Cne), S = P(() => p.getPrefixCls("dropdown", e.dropdownPrefixCls)), C = P(() => e.childrenColumnName || "children"), w = P(() => y.value.some((fe) => fe == null ? void 0 : fe[C.value]) ? "nest" : e.expandedRowRender ? "row" : null), $ = xt({
      body: null
    }), O = (fe) => {
      m($, fe);
    }, x = P(() => typeof e.rowKey == "function" ? e.rowKey : (fe) => fe == null ? void 0 : fe[e.rowKey]), [I] = ite(y, C, x), E = {}, _ = function(fe, be) {
      let ue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      const {
        pagination: de,
        scroll: Se,
        onChange: xe
      } = e, he = m(m({}, E), fe);
      ue && (E.resetPagination(), he.pagination.current && (he.pagination.current = 1), de && de.onChange && de.onChange(1, he.pagination.pageSize)), Se && Se.scrollToFirstRowOnChange !== !1 && $.body && mh(0, {
        getContainer: () => $.body
      }), xe == null || xe(he.pagination, he.filters, he.sorter, {
        currentDataSource: Nw(Lm(y.value, he.sorterStates, C.value), he.filterStates),
        action: be
      });
    }, M = (fe, be) => {
      _({
        sorter: fe,
        sorterStates: be
      }, "sort", !1);
    }, [R, A, z, T] = mte({
      prefixCls: d,
      mergedColumns: i,
      onSorterChange: M,
      sortDirections: P(() => e.sortDirections || ["ascend", "descend"]),
      tableLocale: b,
      showSorterTooltip: Te(e, "showSorterTooltip")
    }), N = P(() => Lm(y.value, A.value, C.value)), k = (fe, be) => {
      _({
        filters: fe,
        filterStates: be
      }, "filter", !0);
    }, [B, F, L] = tne({
      prefixCls: d,
      locale: b,
      dropdownPrefixCls: S,
      mergedColumns: i,
      onFilterChange: k,
      getPopupContainer: Te(e, "getPopupContainer")
    }), j = P(() => Nw(N.value, F.value)), [H] = rne(Te(e, "contextSlots")), K = P(() => {
      const fe = {}, be = L.value;
      return Object.keys(be).forEach((ue) => {
        be[ue] !== null && (fe[ue] = be[ue]);
      }), m(m({}, z.value), {
        filters: fe
      });
    }), [X] = nne(K), W = (fe, be) => {
      _({
        pagination: m(m({}, E.pagination), {
          current: fe,
          pageSize: be
        })
      }, "paginate");
    }, [q, J] = ate(P(() => j.value.length), Te(e, "pagination"), W);
    Le(() => {
      E.sorter = T.value, E.sorterStates = A.value, E.filters = L.value, E.filterStates = F.value, E.pagination = e.pagination === !1 ? {} : lte(q.value, e.pagination), E.resetPagination = J;
    });
    const ne = P(() => {
      if (e.pagination === !1 || !q.value.pageSize)
        return j.value;
      const {
        current: fe = 1,
        total: be,
        pageSize: ue = Nm
      } = q.value;
      return nt(fe > 0, "Table", "`current` should be positive number."), j.value.length < be ? j.value.length > ue ? j.value.slice((fe - 1) * ue, fe * ue) : j.value : j.value.slice((fe - 1) * ue, fe * ue);
    });
    Le(() => {
      rt(() => {
        const {
          total: fe,
          pageSize: be = Nm
        } = q.value;
        j.value.length < fe && j.value.length > be && nt(!1, "Table", "`dataSource` length is less than `pagination.total` but large than `pagination.pageSize`. Please make sure your config correct data with async mode.");
      });
    }, {
      flush: "post"
    });
    const te = P(() => e.showExpandColumn === !1 ? -1 : w.value === "nest" && e.expandIconColumnIndex === void 0 ? e.rowSelection ? 1 : 0 : e.expandIconColumnIndex > 0 && e.rowSelection ? e.expandIconColumnIndex - 1 : e.expandIconColumnIndex), G = Y();
    ie(() => e.rowSelection, () => {
      G.value = e.rowSelection ? m({}, e.rowSelection) : e.rowSelection;
    }, {
      deep: !0,
      immediate: !0
    });
    const [U, re] = cte(G, {
      prefixCls: d,
      data: j,
      pageData: ne,
      getRowKey: x,
      getRecordByKey: I,
      expandType: w,
      childrenColumnName: C,
      locale: b,
      getPopupContainer: P(() => e.getPopupContainer)
    }), se = (fe, be, ue) => {
      let de;
      const {
        rowClassName: Se
      } = e;
      return typeof Se == "function" ? de = ee(Se(fe, be, ue)) : de = ee(Se), ee({
        [`${d.value}-row-selected`]: re.value.has(x.value(fe, be))
      }, de);
    };
    r({
      selectedKeySet: re
    });
    const me = P(() => typeof e.indentSize == "number" ? e.indentSize : 15), Ce = (fe) => X(U(B(R(H(fe)))));
    return () => {
      var fe;
      const {
        expandIcon: be = o.expandIcon || one(b.value),
        pagination: ue,
        loading: de,
        bordered: Se
      } = e;
      let xe, he;
      if (ue !== !1 && (!((fe = q.value) === null || fe === void 0) && fe.total)) {
        let oe;
        q.value.size ? oe = q.value.size : oe = s.value === "small" || s.value === "middle" ? "small" : void 0;
        const pe = (ze) => f(xp, D(D({}, q.value), {}, {
          class: [`${d.value}-pagination ${d.value}-pagination-${ze}`, q.value.class],
          size: oe
        }), null), Pe = u.value === "rtl" ? "left" : "right", {
          position: Ee
        } = q.value;
        if (Ee !== null && Array.isArray(Ee)) {
          const ze = Ee.find(($e) => $e.includes("top")), ge = Ee.find(($e) => $e.includes("bottom")), ye = Ee.every(($e) => `${$e}` == "none");
          !ze && !ge && !ye && (he = pe(Pe)), ze && (xe = pe(ze.toLowerCase().replace("top", ""))), ge && (he = pe(ge.toLowerCase().replace("bottom", "")));
        } else
          he = pe(Pe);
      }
      let we;
      typeof de == "boolean" ? we = {
        spinning: de
      } : typeof de == "object" && (we = m({
        spinning: !0
      }, de));
      const Me = ee(`${d.value}-wrapper`, {
        [`${d.value}-wrapper-rtl`]: u.value === "rtl"
      }, n.class, h.value), ae = ot(e, ["columns"]);
      return v(f("div", {
        class: Me,
        style: n.style
      }, [f(br, D({
        spinning: !1
      }, we), {
        default: () => [xe, f(ote, D(D(D({}, n), ae), {}, {
          expandedRowKeys: e.expandedRowKeys,
          defaultExpandedRowKeys: e.defaultExpandedRowKeys,
          expandIconColumnIndex: te.value,
          indentSize: me.value,
          expandIcon: be,
          columns: i.value,
          direction: u.value,
          prefixCls: d.value,
          class: ee({
            [`${d.value}-middle`]: s.value === "middle",
            [`${d.value}-small`]: s.value === "small",
            [`${d.value}-bordered`]: Se,
            [`${d.value}-empty`]: y.value.length === 0
          }),
          data: ne.value,
          rowKey: x.value,
          rowClassName: se,
          internalHooks: Dm,
          internalRefs: $,
          onUpdateInternalRefs: O,
          transformColumns: Ce,
          transformCellText: g.value
        }), m(m({}, o), {
          emptyText: () => {
            var oe, pe;
            return ((oe = o.emptyText) === null || oe === void 0 ? void 0 : oe.call(o)) || ((pe = e.locale) === null || pe === void 0 ? void 0 : pe.emptyText) || c("Table");
          }
        })), he]
      })]));
    };
  }
}), Kv = Z({
  name: "ATable",
  inheritAttrs: !1,
  props: Qe(V6(), {
    rowKey: "key"
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r
    } = t;
    const l = Y();
    return r({
      table: l
    }), () => {
      var a;
      const i = e.columns || T6((a = o.default) === null || a === void 0 ? void 0 : a.call(o));
      return f($ne, D(D(D({
        ref: l
      }, n), e), {}, {
        columns: i || [],
        expandedRowRender: o.expandedRowRender || e.expandedRowRender,
        contextSlots: m({}, o)
      }), o);
    };
  }
}), Ku = Z({
  name: "ATableColumn",
  slots: Object,
  render() {
    return null;
  }
}), Gu = Z({
  name: "ATableColumnGroup",
  slots: Object,
  __ANT_TABLE_COLUMN_GROUP: !0,
  render() {
    return null;
  }
}), of = Kee, rf = Uee, Xu = m(Yee, {
  Cell: rf,
  Row: of,
  name: "ATableSummary"
}), Zb = m(Kv, {
  SELECTION_ALL: Rm,
  SELECTION_INVERT: km,
  SELECTION_NONE: Bm,
  SELECTION_COLUMN: Yo,
  EXPAND_COLUMN: pr,
  Column: Ku,
  ColumnGroup: Gu,
  Summary: Xu,
  install: (e) => (e.component(Xu.name, Xu), e.component(rf.name, rf), e.component(of.name, of), e.component(Kv.name, Kv), e.component(Ku.name, Ku), e.component(Gu.name, Gu), e)
}), wne = {
  prefixCls: String,
  placeholder: String,
  value: String,
  handleClear: Function,
  disabled: {
    type: Boolean,
    default: void 0
  },
  onChange: Function
}, xne = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Search",
  inheritAttrs: !1,
  props: Qe(wne, {
    placeholder: ""
  }),
  emits: ["change"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    const o = (r) => {
      var l;
      n("change", r), r.target.value === "" && ((l = e.handleClear) === null || l === void 0 || l.call(e));
    };
    return () => {
      const {
        placeholder: r,
        value: l,
        prefixCls: a,
        disabled: i
      } = e;
      return f(fn, {
        placeholder: r,
        class: a,
        value: l,
        onChange: o,
        disabled: i,
        allowClear: !0
      }, {
        prefix: () => f(_i, null, null)
      });
    };
  }
});
var One = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M360 184h-8c4.4 0 8-3.6 8-8v8h304v-8c0 4.4 3.6 8 8 8h-8v72h72v-80c0-35.3-28.7-64-64-64H352c-35.3 0-64 28.7-64 64v80h72v-72zm504 72H160c-17.7 0-32 14.3-32 32v32c0 4.4 3.6 8 8 8h60.4l24.7 523c1.6 34.1 29.8 61 63.9 61h454c34.2 0 62.3-26.8 63.9-61l24.7-523H888c4.4 0 8-3.6 8-8v-32c0-17.7-14.3-32-32-32zM731.3 840H292.7l-24.2-512h487l-24.2 512z" } }] }, name: "delete", theme: "outlined" };
function kw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Pne(e, r, n[r]);
    });
  }
  return e;
}
function Pne(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var _p = function(t, n) {
  var o = kw({}, t, n.attrs);
  return f(Ge, kw({}, o, {
    icon: One
  }), null);
};
_p.displayName = "DeleteOutlined";
_p.inheritAttrs = !1;
function Ine() {
}
const Ene = {
  renderedText: V.any,
  renderedEl: V.any,
  item: V.any,
  checked: ve(),
  prefixCls: String,
  disabled: ve(),
  showRemove: ve(),
  onClick: Function,
  onRemove: Function
}, Tne = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: !1,
  props: Ene,
  emits: ["click", "remove"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    return () => {
      const {
        renderedText: o,
        renderedEl: r,
        item: l,
        checked: a,
        disabled: i,
        prefixCls: s,
        showRemove: c
      } = e, u = ee({
        [`${s}-content-item`]: !0,
        [`${s}-content-item-disabled`]: i || l.disabled
      });
      let d;
      return (typeof o == "string" || typeof o == "number") && (d = String(o)), f(ma, {
        componentName: "Transfer",
        defaultLocale: Zn.Transfer
      }, {
        default: (p) => {
          const v = f("span", {
            class: `${s}-content-item-text`
          }, [r]);
          return c ? f("li", {
            class: u,
            title: d
          }, [v, f(ef, {
            disabled: i || l.disabled,
            class: `${s}-content-item-remove`,
            "aria-label": p.remove,
            onClick: () => {
              n("remove", l);
            }
          }, {
            default: () => [f(_p, null, null)]
          })]) : f("li", {
            class: u,
            title: d,
            onClick: i || l.disabled ? Ine : () => {
              n("click", l);
            }
          }, [f(io, {
            class: `${s}-checkbox`,
            checked: a,
            disabled: i || l.disabled
          }, null), v]);
        }
      });
    };
  }
}), Mne = {
  prefixCls: String,
  filteredRenderItems: V.array.def([]),
  selectedKeys: V.array,
  disabled: ve(),
  showRemove: ve(),
  pagination: V.any,
  onItemSelect: Function,
  onScroll: Function,
  onItemRemove: Function
};
function _ne(e) {
  if (!e)
    return null;
  const t = {
    pageSize: 10,
    simple: !0,
    showSizeChanger: !1,
    showLessItems: !1
  };
  return typeof e == "object" ? m(m({}, t), e) : t;
}
const Ane = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ListBody",
  inheritAttrs: !1,
  props: Mne,
  emits: ["itemSelect", "itemRemove", "scroll"],
  setup(e, t) {
    let {
      emit: n,
      expose: o
    } = t;
    const r = Y(1), l = (d) => {
      const {
        selectedKeys: p
      } = e, v = p.indexOf(d.key) >= 0;
      n("itemSelect", d.key, !v);
    }, a = (d) => {
      n("itemRemove", [d.key]);
    }, i = (d) => {
      n("scroll", d);
    }, s = P(() => _ne(e.pagination));
    ie([s, () => e.filteredRenderItems], () => {
      if (s.value) {
        const d = Math.ceil(e.filteredRenderItems.length / s.value.pageSize);
        r.value = Math.min(r.value, d);
      }
    }, {
      immediate: !0
    });
    const c = P(() => {
      const {
        filteredRenderItems: d
      } = e;
      let p = d;
      return s.value && (p = d.slice((r.value - 1) * s.value.pageSize, r.value * s.value.pageSize)), p;
    }), u = (d) => {
      r.value = d;
    };
    return o({
      items: c
    }), () => {
      const {
        prefixCls: d,
        filteredRenderItems: p,
        selectedKeys: v,
        disabled: h,
        showRemove: g
      } = e;
      let b = null;
      s.value && (b = f(xp, {
        simple: s.value.simple,
        showSizeChanger: s.value.showSizeChanger,
        showLessItems: s.value.showLessItems,
        size: "small",
        disabled: h,
        class: `${d}-pagination`,
        total: p.length,
        pageSize: s.value.pageSize,
        current: r.value,
        onChange: u
      }, null));
      const y = c.value.map((S) => {
        let {
          renderedEl: C,
          renderedText: w,
          item: $
        } = S;
        const {
          disabled: O
        } = $, x = v.indexOf($.key) >= 0;
        return f(Tne, {
          disabled: h || O,
          key: $.key,
          item: $,
          renderedText: w,
          renderedEl: C,
          checked: x,
          prefixCls: d,
          onClick: l,
          onRemove: a,
          showRemove: g
        }, null);
      });
      return f(Fe, null, [f("ul", {
        class: ee(`${d}-content`, {
          [`${d}-content-show-remove`]: g
        }),
        onScroll: i
      }, [y]), b]);
    };
  }
}), jm = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((n, o) => {
    t.set(n, o);
  }), t;
}, Dne = (e) => {
  const t = /* @__PURE__ */ new Map();
  return e.forEach((n, o) => {
    let {
      disabled: r,
      key: l
    } = n;
    r && t.set(l, o);
  }), t;
}, Nne = () => null;
function Rne(e) {
  return !!(e && !Gt(e) && Object.prototype.toString.call(e) === "[object Object]");
}
function ru(e) {
  return e.filter((t) => !t.disabled).map((t) => t.key);
}
const kne = {
  prefixCls: String,
  dataSource: vt([]),
  filter: String,
  filterOption: Function,
  checkedKeys: V.arrayOf(V.string),
  handleFilter: Function,
  handleClear: Function,
  renderItem: Function,
  showSearch: ve(!1),
  searchPlaceholder: String,
  notFoundContent: V.any,
  itemUnit: String,
  itemsUnit: String,
  renderList: V.any,
  disabled: ve(),
  direction: ke(),
  showSelectAll: ve(),
  remove: String,
  selectAll: String,
  selectCurrent: String,
  selectInvert: String,
  removeAll: String,
  removeCurrent: String,
  selectAllLabel: V.any,
  showRemove: ve(),
  pagination: V.any,
  onItemSelect: Function,
  onItemSelectAll: Function,
  onItemRemove: Function,
  onScroll: Function
}, Bw = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TransferList",
  inheritAttrs: !1,
  props: kne,
  // emits: ['scroll', 'itemSelectAll', 'itemRemove', 'itemSelect'],
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const r = Y(""), l = Y(), a = Y(), i = ($, O) => {
      let x = $ ? $(O) : null;
      const I = !!x && Lt(x).length > 0;
      return I || (x = f(Ane, D(D({}, O), {}, {
        ref: a
      }), null)), {
        customize: I,
        bodyContent: x
      };
    }, s = ($) => {
      const {
        renderItem: O = Nne
      } = e, x = O($), I = Rne(x);
      return {
        renderedText: I ? x.value : x,
        renderedEl: I ? x.label : x,
        item: $
      };
    }, c = Y([]), u = Y([]);
    Le(() => {
      const $ = [], O = [];
      e.dataSource.forEach((x) => {
        const I = s(x), {
          renderedText: E
        } = I;
        if (r.value && r.value.trim() && !y(E, x))
          return null;
        $.push(x), O.push(I);
      }), c.value = $, u.value = O;
    });
    const d = P(() => {
      const {
        checkedKeys: $
      } = e;
      if ($.length === 0)
        return "none";
      const O = jm($);
      return c.value.every((x) => O.has(x.key) || !!x.disabled) ? "all" : "part";
    }), p = P(() => ru(c.value)), v = ($, O) => Array.from(/* @__PURE__ */ new Set([...$, ...e.checkedKeys])).filter((x) => O.indexOf(x) === -1), h = ($) => {
      let {
        disabled: O,
        prefixCls: x
      } = $;
      var I;
      const E = d.value === "all";
      return f(io, {
        disabled: ((I = e.dataSource) === null || I === void 0 ? void 0 : I.length) === 0 || O,
        checked: E,
        indeterminate: d.value === "part",
        class: `${x}-checkbox`,
        onChange: () => {
          const M = p.value;
          e.onItemSelectAll(v(E ? [] : M, E ? e.checkedKeys : []));
        }
      }, null);
    }, g = ($) => {
      var O;
      const {
        target: {
          value: x
        }
      } = $;
      r.value = x, (O = e.handleFilter) === null || O === void 0 || O.call(e, $);
    }, b = ($) => {
      var O;
      r.value = "", (O = e.handleClear) === null || O === void 0 || O.call(e, $);
    }, y = ($, O) => {
      const {
        filterOption: x
      } = e;
      return x ? x(r.value, O) : $.includes(r.value);
    }, S = ($, O) => {
      const {
        itemsUnit: x,
        itemUnit: I,
        selectAllLabel: E
      } = e;
      if (E)
        return typeof E == "function" ? E({
          selectedCount: $,
          totalCount: O
        }) : E;
      const _ = O > 1 ? x : I;
      return f(Fe, null, [($ > 0 ? `${$}/` : "") + O, Ot(" "), _]);
    }, C = P(() => Array.isArray(e.notFoundContent) ? e.notFoundContent[e.direction === "left" ? 0 : 1] : e.notFoundContent), w = ($, O, x, I, E, _) => {
      const M = E ? f("div", {
        class: `${$}-body-search-wrapper`
      }, [f(xne, {
        prefixCls: `${$}-search`,
        onChange: g,
        handleClear: b,
        placeholder: O,
        value: r.value,
        disabled: _
      }, null)]) : null;
      let R;
      const {
        onEvents: A
      } = rh(n), {
        bodyContent: z,
        customize: T
      } = i(I, m(m(m({}, e), {
        filteredItems: c.value,
        filteredRenderItems: u.value,
        selectedKeys: x
      }), A));
      return T ? R = f("div", {
        class: `${$}-body-customize-wrapper`
      }, [z]) : R = c.value.length ? z : f("div", {
        class: `${$}-body-not-found`
      }, [C.value]), f("div", {
        class: E ? `${$}-body ${$}-body-with-search` : `${$}-body`,
        ref: l
      }, [M, R]);
    };
    return () => {
      var $, O;
      const {
        prefixCls: x,
        checkedKeys: I,
        disabled: E,
        showSearch: _,
        searchPlaceholder: M,
        selectAll: R,
        selectCurrent: A,
        selectInvert: z,
        removeAll: T,
        removeCurrent: N,
        renderList: k,
        onItemSelectAll: B,
        onItemRemove: F,
        showSelectAll: L = !0,
        showRemove: j,
        pagination: H
      } = e, K = ($ = o.footer) === null || $ === void 0 ? void 0 : $.call(o, m({}, e)), X = ee(x, {
        [`${x}-with-pagination`]: !!H,
        [`${x}-with-footer`]: !!K
      }), W = w(x, M, I, k, _, E), q = K ? f("div", {
        class: `${x}-footer`
      }, [K]) : null, J = !j && !H && h({
        disabled: E,
        prefixCls: x
      });
      let ne = null;
      j ? ne = f(en, null, {
        default: () => [H && f(en.Item, {
          key: "removeCurrent",
          onClick: () => {
            const G = ru((a.value.items || []).map((U) => U.item));
            F == null || F(G);
          }
        }, {
          default: () => [N]
        }), f(en.Item, {
          key: "removeAll",
          onClick: () => {
            F == null || F(p.value);
          }
        }, {
          default: () => [T]
        })]
      }) : ne = f(en, null, {
        default: () => [f(en.Item, {
          key: "selectAll",
          onClick: () => {
            const G = p.value;
            B(v(G, []));
          }
        }, {
          default: () => [R]
        }), H && f(en.Item, {
          onClick: () => {
            const G = ru((a.value.items || []).map((U) => U.item));
            B(v(G, []));
          }
        }, {
          default: () => [A]
        }), f(en.Item, {
          key: "selectInvert",
          onClick: () => {
            let G;
            H ? G = ru((a.value.items || []).map((me) => me.item)) : G = p.value;
            const U = new Set(I), re = [], se = [];
            G.forEach((me) => {
              U.has(me) ? se.push(me) : re.push(me);
            }), B(v(re, se));
          }
        }, {
          default: () => [z]
        })]
      });
      const te = f(er, {
        class: `${x}-header-dropdown`,
        overlay: ne,
        disabled: E
      }, {
        default: () => [f(Or, null, null)]
      });
      return f("div", {
        class: X,
        style: n.style
      }, [f("div", {
        class: `${x}-header`
      }, [L ? f(Fe, null, [J, te]) : null, f("span", {
        class: `${x}-header-selected`
      }, [f("span", null, [S(I.length, c.value.length)]), f("span", {
        class: `${x}-header-title`
      }, [(O = o.titleText) === null || O === void 0 ? void 0 : O.call(o)])])]), W, q]);
    };
  }
});
function Fw() {
}
const Qb = (e) => {
  const {
    disabled: t,
    moveToLeft: n = Fw,
    moveToRight: o = Fw,
    leftArrowText: r = "",
    rightArrowText: l = "",
    leftActive: a,
    rightActive: i,
    class: s,
    style: c,
    direction: u,
    oneWay: d
  } = e;
  return f("div", {
    class: s,
    style: c
  }, [f(Kt, {
    type: "primary",
    size: "small",
    disabled: t || !i,
    onClick: o,
    icon: u !== "rtl" ? f(Po, null, null) : f(wr, null, null)
  }, {
    default: () => [l]
  }), !d && f(Kt, {
    type: "primary",
    size: "small",
    disabled: t || !a,
    onClick: n,
    icon: u !== "rtl" ? f(wr, null, null) : f(Po, null, null)
  }, {
    default: () => [r]
  })]);
};
Qb.displayName = "Operation";
Qb.inheritAttrs = !1;
const Bne = (e) => {
  const {
    antCls: t,
    componentCls: n,
    listHeight: o,
    controlHeightLG: r,
    marginXXS: l,
    margin: a
  } = e, i = `${t}-table`, s = `${t}-input`;
  return {
    [`${n}-customize-list`]: {
      [`${n}-list`]: {
        flex: "1 1 50%",
        width: "auto",
        height: "auto",
        minHeight: o
      },
      // =================== Hook Components ===================
      [`${i}-wrapper`]: {
        [`${i}-small`]: {
          border: 0,
          borderRadius: 0,
          [`${i}-selection-column`]: {
            width: r,
            minWidth: r
          }
        },
        [`${i}-pagination${i}-pagination`]: {
          margin: `${a}px 0 ${l}px`
        }
      },
      [`${s}[disabled]`]: {
        backgroundColor: "transparent"
      }
    }
  };
}, Lw = (e, t) => {
  const {
    componentCls: n,
    colorBorder: o
  } = e;
  return {
    [`${n}-list`]: {
      borderColor: t,
      "&-search:not([disabled])": {
        borderColor: o
      }
    }
  };
}, Fne = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-status-error`]: m({}, Lw(e, e.colorError)),
    [`${t}-status-warning`]: m({}, Lw(e, e.colorWarning))
  };
}, Lne = (e) => {
  const {
    componentCls: t,
    colorBorder: n,
    colorSplit: o,
    lineWidth: r,
    transferItemHeight: l,
    transferHeaderHeight: a,
    transferHeaderVerticalPadding: i,
    transferItemPaddingVertical: s,
    controlItemBgActive: c,
    controlItemBgActiveHover: u,
    colorTextDisabled: d,
    listHeight: p,
    listWidth: v,
    listWidthLG: h,
    fontSizeIcon: g,
    marginXS: b,
    paddingSM: y,
    lineType: S,
    iconCls: C,
    motionDurationSlow: w
  } = e;
  return {
    display: "flex",
    flexDirection: "column",
    width: v,
    height: p,
    border: `${r}px ${S} ${n}`,
    borderRadius: e.borderRadiusLG,
    "&-with-pagination": {
      width: h,
      height: "auto"
    },
    "&-search": {
      [`${C}-search`]: {
        color: d
      }
    },
    "&-header": {
      display: "flex",
      flex: "none",
      alignItems: "center",
      height: a,
      // border-top is on the transfer dom. We should minus 1px for this
      padding: `${i - r}px ${y}px ${i}px`,
      color: e.colorText,
      background: e.colorBgContainer,
      borderBottom: `${r}px ${S} ${o}`,
      borderRadius: `${e.borderRadiusLG}px ${e.borderRadiusLG}px 0 0`,
      "> *:not(:last-child)": {
        marginInlineEnd: 4
        // This is magic and fixed number, DO NOT use token since it may change.
      },
      "> *": {
        flex: "none"
      },
      "&-title": m(m({}, tn), {
        flex: "auto",
        textAlign: "end"
      }),
      "&-dropdown": m(m({}, ha()), {
        fontSize: g,
        transform: "translateY(10%)",
        cursor: "pointer",
        "&[disabled]": {
          cursor: "not-allowed"
        }
      })
    },
    "&-body": {
      display: "flex",
      flex: "auto",
      flexDirection: "column",
      overflow: "hidden",
      fontSize: e.fontSize,
      "&-search-wrapper": {
        position: "relative",
        flex: "none",
        padding: y
      }
    },
    "&-content": {
      flex: "auto",
      margin: 0,
      padding: 0,
      overflow: "auto",
      listStyle: "none",
      "&-item": {
        display: "flex",
        alignItems: "center",
        minHeight: l,
        padding: `${s}px ${y}px`,
        transition: `all ${w}`,
        "> *:not(:last-child)": {
          marginInlineEnd: b
        },
        "> *": {
          flex: "none"
        },
        "&-text": m(m({}, tn), {
          flex: "auto"
        }),
        "&-remove": {
          position: "relative",
          color: n,
          cursor: "pointer",
          transition: `all ${w}`,
          "&:hover": {
            color: e.colorLinkHover
          },
          "&::after": {
            position: "absolute",
            insert: `-${s}px -50%`,
            content: '""'
          }
        },
        [`&:not(${t}-list-content-item-disabled)`]: {
          "&:hover": {
            backgroundColor: e.controlItemBgHover,
            cursor: "pointer"
          },
          [`&${t}-list-content-item-checked:hover`]: {
            backgroundColor: u
          }
        },
        "&-checked": {
          backgroundColor: c
        },
        "&-disabled": {
          color: d,
          cursor: "not-allowed"
        }
      },
      // Do not change hover style when `oneWay` mode
      [`&-show-remove ${t}-list-content-item:not(${t}-list-content-item-disabled):hover`]: {
        background: "transparent",
        cursor: "default"
      }
    },
    "&-pagination": {
      padding: `${e.paddingXS}px 0`,
      textAlign: "end",
      borderTop: `${r}px ${S} ${o}`
    },
    "&-body-not-found": {
      flex: "none",
      width: "100%",
      margin: "auto 0",
      color: d,
      textAlign: "center"
    },
    "&-footer": {
      borderTop: `${r}px ${S} ${o}`
    },
    "&-checkbox": {
      lineHeight: 1
    }
  };
}, zne = (e) => {
  const {
    antCls: t,
    iconCls: n,
    componentCls: o,
    transferHeaderHeight: r,
    marginXS: l,
    marginXXS: a,
    fontSizeIcon: i,
    fontSize: s,
    lineHeight: c
  } = e;
  return {
    [o]: m(m({}, qe(e)), {
      position: "relative",
      display: "flex",
      alignItems: "stretch",
      [`${o}-disabled`]: {
        [`${o}-list`]: {
          background: e.colorBgContainerDisabled
        }
      },
      [`${o}-list`]: Lne(e),
      [`${o}-operation`]: {
        display: "flex",
        flex: "none",
        flexDirection: "column",
        alignSelf: "center",
        margin: `0 ${l}px`,
        verticalAlign: "middle",
        [`${t}-btn`]: {
          display: "block",
          "&:first-child": {
            marginBottom: a
          },
          [n]: {
            fontSize: i
          }
        }
      },
      [`${t}-empty-image`]: {
        maxHeight: r / 2 - Math.round(s * c)
      }
    })
  };
}, Hne = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl"
    }
  };
}, jne = Xe("Transfer", (e) => {
  const {
    fontSize: t,
    lineHeight: n,
    lineWidth: o,
    controlHeightLG: r,
    controlHeight: l
  } = e, a = Math.round(t * n), i = r, s = l, c = He(e, {
    transferItemHeight: s,
    transferHeaderHeight: i,
    transferHeaderVerticalPadding: Math.ceil((i - o - a) / 2),
    transferItemPaddingVertical: (s - a) / 2
  });
  return [zne(c), Bne(c), Fne(c), Hne(c)];
}, {
  listWidth: 180,
  listHeight: 200,
  listWidthLG: 250
}), Vne = () => ({
  id: String,
  prefixCls: String,
  dataSource: vt([]),
  disabled: ve(),
  targetKeys: vt(),
  selectedKeys: vt(),
  render: le(),
  listStyle: je([Function, Object], () => ({})),
  operationStyle: Re(void 0),
  titles: vt(),
  operations: vt(),
  showSearch: ve(!1),
  filterOption: le(),
  searchPlaceholder: String,
  notFoundContent: V.any,
  locale: Re(),
  rowKey: le(),
  showSelectAll: ve(),
  selectAllLabels: vt(),
  children: le(),
  oneWay: ve(),
  pagination: je([Object, Boolean]),
  status: ke(),
  onChange: le(),
  onSelectChange: le(),
  onSearch: le(),
  onScroll: le(),
  "onUpdate:targetKeys": le(),
  "onUpdate:selectedKeys": le()
}), Wne = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATransfer",
  inheritAttrs: !1,
  props: Vne(),
  slots: Object,
  // emits: ['update:targetKeys', 'update:selectedKeys', 'change', 'search', 'scroll', 'selectChange'],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      slots: r,
      expose: l
    } = t;
    const {
      configProvider: a,
      prefixCls: i,
      direction: s
    } = Ie("transfer", e), [c, u] = jne(i), d = Y([]), p = Y([]), v = sn(), h = Sn.useInject(), g = P(() => ar(h.status, e.status));
    ie(() => e.selectedKeys, () => {
      var W, q;
      d.value = ((W = e.selectedKeys) === null || W === void 0 ? void 0 : W.filter((J) => e.targetKeys.indexOf(J) === -1)) || [], p.value = ((q = e.selectedKeys) === null || q === void 0 ? void 0 : q.filter((J) => e.targetKeys.indexOf(J) > -1)) || [];
    }, {
      immediate: !0
    });
    const b = (W, q) => {
      const J = {
        notFoundContent: q("Transfer")
      }, ne = an(r, e, "notFoundContent");
      return ne && (J.notFoundContent = ne), e.searchPlaceholder !== void 0 && (J.searchPlaceholder = e.searchPlaceholder), m(m(m({}, W), J), e.locale);
    }, y = (W) => {
      const {
        targetKeys: q = [],
        dataSource: J = []
      } = e, ne = W === "right" ? d.value : p.value, te = Dne(J), G = ne.filter((me) => !te.has(me)), U = jm(G), re = W === "right" ? G.concat(q) : q.filter((me) => !U.has(me)), se = W === "right" ? "left" : "right";
      W === "right" ? d.value = [] : p.value = [], n("update:targetKeys", re), x(se, []), n("change", re, W, G), v.onFieldChange();
    }, S = () => {
      y("left");
    }, C = () => {
      y("right");
    }, w = (W, q) => {
      x(W, q);
    }, $ = (W) => w("left", W), O = (W) => w("right", W), x = (W, q) => {
      W === "left" ? (e.selectedKeys || (d.value = q), n("update:selectedKeys", [...q, ...p.value]), n("selectChange", q, Yt(p.value))) : (e.selectedKeys || (p.value = q), n("update:selectedKeys", [...q, ...d.value]), n("selectChange", Yt(d.value), q));
    }, I = (W, q) => {
      const J = q.target.value;
      n("search", W, J);
    }, E = (W) => {
      I("left", W);
    }, _ = (W) => {
      I("right", W);
    }, M = (W) => {
      n("search", W, "");
    }, R = () => {
      M("left");
    }, A = () => {
      M("right");
    }, z = (W, q, J) => {
      const ne = W === "left" ? [...d.value] : [...p.value], te = ne.indexOf(q);
      te > -1 && ne.splice(te, 1), J && ne.push(q), x(W, ne);
    }, T = (W, q) => z("left", W, q), N = (W, q) => z("right", W, q), k = (W) => {
      const {
        targetKeys: q = []
      } = e, J = q.filter((ne) => !W.includes(ne));
      n("update:targetKeys", J), n("change", J, "left", [...W]);
    }, B = (W, q) => {
      n("scroll", W, q);
    }, F = (W) => {
      B("left", W);
    }, L = (W) => {
      B("right", W);
    }, j = (W, q) => typeof W == "function" ? W({
      direction: q
    }) : W, H = Y([]), K = Y([]);
    Le(() => {
      const {
        dataSource: W,
        rowKey: q,
        targetKeys: J = []
      } = e, ne = [], te = new Array(J.length), G = jm(J);
      W.forEach((U) => {
        q && (U.key = q(U)), G.has(U.key) ? te[G.get(U.key)] = U : ne.push(U);
      }), H.value = ne, K.value = te;
    }), l({
      handleSelectChange: x
    });
    const X = (W) => {
      var q, J, ne, te, G, U;
      const {
        disabled: re,
        operations: se = [],
        showSearch: me,
        listStyle: Ce,
        operationStyle: fe,
        filterOption: be,
        showSelectAll: ue,
        selectAllLabels: de = [],
        oneWay: Se,
        pagination: xe,
        id: he = v.id.value
      } = e, {
        class: we,
        style: Me
      } = o, ae = r.children, oe = !ae && xe, pe = a.renderEmpty, Pe = b(W, pe), {
        footer: Ee
      } = r, ze = e.render || r.render, ge = p.value.length > 0, ye = d.value.length > 0, $e = ee(i.value, we, {
        [`${i.value}-disabled`]: re,
        [`${i.value}-customize-list`]: !!ae,
        [`${i.value}-rtl`]: s.value === "rtl"
      }, Fn(i.value, g.value, h.hasFeedback), u.value), Ae = e.titles, Ve = (ne = (q = Ae && Ae[0]) !== null && q !== void 0 ? q : (J = r.leftTitle) === null || J === void 0 ? void 0 : J.call(r)) !== null && ne !== void 0 ? ne : (Pe.titles || ["", ""])[0], De = (U = (te = Ae && Ae[1]) !== null && te !== void 0 ? te : (G = r.rightTitle) === null || G === void 0 ? void 0 : G.call(r)) !== null && U !== void 0 ? U : (Pe.titles || ["", ""])[1];
      return f("div", D(D({}, o), {}, {
        class: $e,
        style: Me,
        id: he
      }), [f(Bw, D({
        key: "leftList",
        prefixCls: `${i.value}-list`,
        dataSource: H.value,
        filterOption: be,
        style: j(Ce, "left"),
        checkedKeys: d.value,
        handleFilter: E,
        handleClear: R,
        onItemSelect: T,
        onItemSelectAll: $,
        renderItem: ze,
        showSearch: me,
        renderList: ae,
        onScroll: F,
        disabled: re,
        direction: s.value === "rtl" ? "right" : "left",
        showSelectAll: ue,
        selectAllLabel: de[0] || r.leftSelectAllLabel,
        pagination: oe
      }, Pe), {
        titleText: () => Ve,
        footer: Ee
      }), f(Qb, {
        key: "operation",
        class: `${i.value}-operation`,
        rightActive: ye,
        rightArrowText: se[0],
        moveToRight: C,
        leftActive: ge,
        leftArrowText: se[1],
        moveToLeft: S,
        style: fe,
        disabled: re,
        direction: s.value,
        oneWay: Se
      }, null), f(Bw, D({
        key: "rightList",
        prefixCls: `${i.value}-list`,
        dataSource: K.value,
        filterOption: be,
        style: j(Ce, "right"),
        checkedKeys: p.value,
        handleFilter: _,
        handleClear: A,
        onItemSelect: N,
        onItemSelectAll: O,
        onItemRemove: k,
        renderItem: ze,
        showSearch: me,
        renderList: ae,
        onScroll: L,
        disabled: re,
        direction: s.value === "rtl" ? "left" : "right",
        showSelectAll: ue,
        selectAllLabel: de[1] || r.rightSelectAllLabel,
        showRemove: Se,
        pagination: oe
      }, Pe), {
        titleText: () => De,
        footer: Ee
      })]);
    };
    return () => c(f(ma, {
      componentName: "Transfer",
      defaultLocale: Zn.Transfer,
      children: X
    }, null));
  }
}), Kne = kt(Wne);
function W6(e) {
  return Array.isArray(e) ? e : e !== void 0 ? [e] : [];
}
function Gne(e) {
  const {
    label: t,
    value: n,
    children: o
  } = e || {}, r = n || "value";
  return {
    _title: t ? [t] : ["title", "label"],
    value: r,
    key: r,
    children: o || "children"
  };
}
function Vm(e) {
  return e.disabled || e.disableCheckbox || e.checkable === !1;
}
function Xne(e, t) {
  const n = [];
  function o(r) {
    r.forEach((l) => {
      n.push(l[t.value]);
      const a = l[t.children];
      a && o(a);
    });
  }
  return o(e), n;
}
function Wm(e) {
  return e == null;
}
const K6 = Symbol("TreeSelectContextPropsKey");
function Une(e) {
  return Je(K6, e);
}
function Yne() {
  return tt(K6, {});
}
const qne = {
  width: 0,
  height: 0,
  display: "flex",
  overflow: "hidden",
  opacity: 0,
  border: 0,
  padding: 0,
  margin: 0
}, Zne = Z({
  compatConfig: {
    MODE: 3
  },
  name: "OptionList",
  inheritAttrs: !1,
  setup(e, t) {
    let {
      slots: n,
      expose: o
    } = t;
    const r = ac(), l = Rf(), a = Yne(), i = Y(), s = zh(() => a.treeData, [() => r.open, () => a.treeData], ($) => $[0]), c = P(() => {
      const {
        checkable: $,
        halfCheckedKeys: O,
        checkedKeys: x
      } = l;
      return $ ? {
        checked: x,
        halfChecked: O
      } : null;
    });
    ie(() => r.open, () => {
      rt(() => {
        var $;
        r.open && !r.multiple && l.checkedKeys.length && (($ = i.value) === null || $ === void 0 || $.scrollTo({
          key: l.checkedKeys[0]
        }));
      });
    }, {
      immediate: !0,
      flush: "post"
    });
    const u = P(() => String(r.searchValue).toLowerCase()), d = ($) => u.value ? String($[l.treeNodeFilterProp]).toLowerCase().includes(u.value) : !1, p = Q(l.treeDefaultExpandedKeys), v = Q(null);
    ie(() => r.searchValue, () => {
      r.searchValue && (v.value = Xne(Yt(a.treeData), Yt(a.fieldNames)));
    }, {
      immediate: !0
    });
    const h = P(() => l.treeExpandedKeys ? l.treeExpandedKeys.slice() : r.searchValue ? v.value : p.value), g = ($) => {
      var O;
      p.value = $, v.value = $, (O = l.onTreeExpand) === null || O === void 0 || O.call(l, $);
    }, b = ($) => {
      $.preventDefault();
    }, y = ($, O) => {
      let {
        node: x
      } = O;
      var I, E;
      const {
        checkable: _,
        checkedKeys: M
      } = l;
      _ && Vm(x) || ((I = a.onSelect) === null || I === void 0 || I.call(a, x.key, {
        selected: !M.includes(x.key)
      }), r.multiple || (E = r.toggleOpen) === null || E === void 0 || E.call(r, !1));
    }, S = Y(null), C = P(() => l.keyEntities[S.value]), w = ($) => {
      S.value = $;
    };
    return o({
      scrollTo: function() {
        for (var $, O, x = arguments.length, I = new Array(x), E = 0; E < x; E++)
          I[E] = arguments[E];
        return (O = ($ = i.value) === null || $ === void 0 ? void 0 : $.scrollTo) === null || O === void 0 ? void 0 : O.call($, ...I);
      },
      onKeydown: ($) => {
        var O;
        const {
          which: x
        } = $;
        switch (x) {
          case ce.UP:
          case ce.DOWN:
          case ce.LEFT:
          case ce.RIGHT:
            (O = i.value) === null || O === void 0 || O.onKeydown($);
            break;
          case ce.ENTER: {
            if (C.value) {
              const {
                selectable: I,
                value: E
              } = C.value.node || {};
              I !== !1 && y(null, {
                node: {
                  key: S.value
                },
                selected: !l.checkedKeys.includes(E)
              });
            }
            break;
          }
          case ce.ESC:
            r.toggleOpen(!1);
        }
      },
      onKeyup: () => {
      }
    }), () => {
      var $;
      const {
        prefixCls: O,
        multiple: x,
        searchValue: I,
        open: E,
        notFoundContent: _ = ($ = n.notFoundContent) === null || $ === void 0 ? void 0 : $.call(n)
      } = r, {
        listHeight: M,
        listItemHeight: R,
        virtual: A,
        dropdownMatchSelectWidth: z,
        treeExpandAction: T
      } = a, {
        checkable: N,
        treeDefaultExpandAll: k,
        treeIcon: B,
        showTreeIcon: F,
        switcherIcon: L,
        treeLine: j,
        loadData: H,
        treeLoadedKeys: K,
        treeMotion: X,
        onTreeLoad: W,
        checkedKeys: q
      } = l;
      if (s.value.length === 0)
        return f("div", {
          role: "listbox",
          class: `${O}-empty`,
          onMousedown: b
        }, [_]);
      const J = {
        fieldNames: a.fieldNames
      };
      return K && (J.loadedKeys = K), h.value && (J.expandedKeys = h.value), f("div", {
        onMousedown: b
      }, [C.value && E && f("span", {
        style: qne,
        "aria-live": "assertive"
      }, [C.value.node.value]), f(A6, D(D({
        ref: i,
        focusable: !1,
        prefixCls: `${O}-tree`,
        treeData: s.value,
        height: M,
        itemHeight: R,
        virtual: A !== !1 && z !== !1,
        multiple: x,
        icon: B,
        showIcon: F,
        switcherIcon: L,
        showLine: j,
        loadData: I ? null : H,
        motion: X,
        activeKey: S.value,
        checkable: N,
        checkStrictly: !0,
        checkedKeys: c.value,
        selectedKeys: N ? [] : q,
        defaultExpandAll: k
      }, J), {}, {
        onActiveChange: w,
        onSelect: y,
        onCheck: y,
        onExpand: g,
        onLoad: W,
        filterTreeNode: d,
        expandAction: T
      }), m(m({}, n), {
        checkable: l.customSlots.treeCheckable
      }))]);
    };
  }
}), Qne = "SHOW_ALL", G6 = "SHOW_PARENT", Jb = "SHOW_CHILD";
function zw(e, t, n, o) {
  const r = new Set(e);
  return t === Jb ? e.filter((l) => {
    const a = n[l];
    return !(a && a.children && a.children.some((i) => {
      let {
        node: s
      } = i;
      return r.has(s[o.value]);
    }) && a.children.every((i) => {
      let {
        node: s
      } = i;
      return Vm(s) || r.has(s[o.value]);
    }));
  }) : t === G6 ? e.filter((l) => {
    const a = n[l], i = a ? a.parent : null;
    return !(i && !Vm(i.node) && r.has(i.key));
  }) : e;
}
const Li = () => null;
Li.inheritAttrs = !1;
Li.displayName = "ATreeSelectNode";
Li.isTreeSelectNode = !0;
var Jne = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function eoe(e) {
  return e && e.type && e.type.isTreeSelectNode;
}
function toe(e) {
  function t() {
    let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return Lt(n).map((o) => {
      var r, l, a;
      if (!eoe(o))
        return ct(!o, "TreeSelect/TreeSelectNode can only accept TreeSelectNode as children."), null;
      const i = o.children || {}, s = o.key, c = {};
      for (const [x, I] of Object.entries(o.props))
        c[Oi(x)] = I;
      const {
        isLeaf: u,
        checkable: d,
        selectable: p,
        disabled: v,
        disableCheckbox: h
      } = c, g = {
        isLeaf: u || u === "" || void 0,
        checkable: d || d === "" || void 0,
        selectable: p || p === "" || void 0,
        disabled: v || v === "" || void 0,
        disableCheckbox: h || h === "" || void 0
      }, b = m(m({}, c), g), {
        title: y = (r = i.title) === null || r === void 0 ? void 0 : r.call(i, b),
        switcherIcon: S = (l = i.switcherIcon) === null || l === void 0 ? void 0 : l.call(i, b)
      } = c, C = Jne(c, ["title", "switcherIcon"]), w = (a = i.default) === null || a === void 0 ? void 0 : a.call(i), $ = m(m(m({}, C), {
        title: y,
        switcherIcon: S,
        key: s,
        isLeaf: u
      }), g), O = t(w);
      return O.length && ($.children = O), $;
    });
  }
  return t(e);
}
function Km(e) {
  if (!e)
    return e;
  const t = m({}, e);
  return "props" in t || Object.defineProperty(t, "props", {
    get() {
      return ct(!1, "New `vc-tree-select` not support return node instance as argument anymore. Please consider to remove `props` access."), t;
    }
  }), t;
}
function noe(e, t, n, o, r, l) {
  let a = null, i = null;
  function s() {
    function c(u) {
      let d = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "0", p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
      return u.map((v, h) => {
        const g = `${d}-${h}`, b = v[l.value], y = n.includes(b), S = c(v[l.children] || [], g, y), C = f(Li, v, {
          default: () => [S.map((w) => w.node)]
        });
        if (t === b && (a = C), y) {
          const w = {
            pos: g,
            node: C,
            children: S
          };
          return p || i.push(w), w;
        }
        return null;
      }).filter((v) => v);
    }
    i || (i = [], c(o), i.sort((u, d) => {
      let {
        node: {
          props: {
            value: p
          }
        }
      } = u, {
        node: {
          props: {
            value: v
          }
        }
      } = d;
      const h = n.indexOf(p), g = n.indexOf(v);
      return h - g;
    }));
  }
  Object.defineProperty(e, "triggerNode", {
    get() {
      return ct(!1, "`triggerNode` is deprecated. Please consider decoupling data with node."), s(), a;
    }
  }), Object.defineProperty(e, "allCheckedNodes", {
    get() {
      return ct(!1, "`allCheckedNodes` is deprecated. Please consider decoupling data with node."), s(), r ? i : i.map((c) => {
        let {
          node: u
        } = c;
        return u;
      });
    }
  });
}
function ooe(e, t) {
  let {
    id: n,
    pId: o,
    rootPId: r
  } = t;
  const l = {}, a = [];
  return e.map((s) => {
    const c = m({}, s), u = c[n];
    return l[u] = c, c.key = c.key || u, c;
  }).forEach((s) => {
    const c = s[o], u = l[c];
    u && (u.children = u.children || [], u.children.push(s)), (c === r || !u && r === null) && a.push(s);
  }), a;
}
function roe(e, t, n) {
  const o = Q();
  return ie([n, e, t], () => {
    const r = n.value;
    e.value ? o.value = n.value ? ooe(Yt(e.value), m({
      id: "id",
      pId: "pId",
      rootPId: null
    }, r !== !0 ? r : {})) : Yt(e.value).slice() : o.value = toe(Yt(t.value));
  }, {
    immediate: !0,
    deep: !0
  }), o;
}
const loe = (e) => {
  const t = Q({
    valueLabels: /* @__PURE__ */ new Map()
  }), n = Q();
  return ie(e, () => {
    n.value = Yt(e.value);
  }, {
    immediate: !0
  }), [P(() => {
    const {
      valueLabels: r
    } = t.value, l = /* @__PURE__ */ new Map(), a = n.value.map((i) => {
      var s;
      const {
        value: c
      } = i, u = (s = i.label) !== null && s !== void 0 ? s : r.get(c);
      return l.set(c, u), m(m({}, i), {
        label: u
      });
    });
    return t.value.valueLabels = l, a;
  })];
}, aoe = (e, t) => {
  const n = Q(/* @__PURE__ */ new Map()), o = Q({});
  return Le(() => {
    const r = t.value, l = bc(e.value, {
      fieldNames: r,
      initWrapper: (a) => m(m({}, a), {
        valueEntities: /* @__PURE__ */ new Map()
      }),
      processEntity: (a, i) => {
        const s = a.node[r.value];
        if (process.env.NODE_ENV !== "production") {
          const c = a.node.key;
          ct(!Wm(s), "TreeNode `value` is invalidate: undefined"), ct(!i.valueEntities.has(s), `Same \`value\` exist in the tree: ${s}`), ct(!c || String(c) === String(s), `\`key\` or \`value\` with TreeNode must be the same or you can remove one of them. key: ${c}, value: ${s}.`);
        }
        i.valueEntities.set(s, a);
      }
    });
    n.value = l.valueEntities, o.value = l.keyEntities;
  }), {
    valueEntities: n,
    keyEntities: o
  };
}, ioe = (e, t, n, o, r, l) => {
  const a = Q([]), i = Q([]);
  return Le(() => {
    let s = e.value.map((d) => {
      let {
        value: p
      } = d;
      return p;
    }), c = t.value.map((d) => {
      let {
        value: p
      } = d;
      return p;
    });
    const u = s.filter((d) => !o.value[d]);
    n.value && ({
      checkedKeys: s,
      halfCheckedKeys: c
    } = Bo(s, !0, o.value, r.value, l.value)), a.value = Array.from(/* @__PURE__ */ new Set([...u, ...s])), i.value = c;
  }), [a, i];
}, soe = (e, t, n) => {
  let {
    treeNodeFilterProp: o,
    filterTreeNode: r,
    fieldNames: l
  } = n;
  return P(() => {
    const {
      children: a
    } = l.value, i = t.value, s = o == null ? void 0 : o.value;
    if (!i || r.value === !1)
      return e.value;
    let c;
    if (typeof r.value == "function")
      c = r.value;
    else {
      const d = i.toUpperCase();
      c = (p, v) => {
        const h = v[s];
        return String(h).toUpperCase().includes(d);
      };
    }
    function u(d) {
      let p = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
      const v = [];
      for (let h = 0, g = d.length; h < g; h++) {
        const b = d[h], y = b[a], S = p || c(i, Km(b)), C = u(y || [], S);
        (S || C.length) && v.push(m(m({}, b), {
          [a]: C
        }));
      }
      return v;
    }
    return u(e.value);
  });
};
function coe(e) {
  const {
    searchPlaceholder: t,
    treeCheckStrictly: n,
    treeCheckable: o,
    labelInValue: r,
    value: l,
    multiple: a
  } = e;
  ct(!t, "`searchPlaceholder` has been removed, please use `placeholder` instead"), n && r === !1 && ct(!1, "`treeCheckStrictly` will force set `labelInValue` to `true`."), (r || n) && ct(W6(l).every((i) => i && typeof i == "object" && "value" in i), "Invalid prop `value` supplied to `TreeSelect`. You should use { label: string, value: string | number } or [{ label: string, value: string | number }] instead."), n || a || o ? ct(!l || Array.isArray(l), "`value` should be an array when `TreeSelect` is checkable or multiple.") : ct(!Array.isArray(l), "`value` should not be array when `TreeSelect` is single mode.");
}
function X6() {
  return m(m({}, ot(kf(), ["mode"])), {
    prefixCls: String,
    id: String,
    value: {
      type: [String, Number, Object, Array]
    },
    defaultValue: {
      type: [String, Number, Object, Array]
    },
    onChange: {
      type: Function
    },
    searchValue: String,
    /** @deprecated Use `searchValue` instead */
    inputValue: String,
    onSearch: {
      type: Function
    },
    autoClearSearchValue: {
      type: Boolean,
      default: void 0
    },
    filterTreeNode: {
      type: [Boolean, Function],
      default: void 0
    },
    treeNodeFilterProp: String,
    // >>> Select
    onSelect: Function,
    onDeselect: Function,
    showCheckedStrategy: {
      type: String
    },
    treeNodeLabelProp: String,
    fieldNames: {
      type: Object
    },
    // >>> Mode
    multiple: {
      type: Boolean,
      default: void 0
    },
    treeCheckable: {
      type: Boolean,
      default: void 0
    },
    treeCheckStrictly: {
      type: Boolean,
      default: void 0
    },
    labelInValue: {
      type: Boolean,
      default: void 0
    },
    // >>> Data
    treeData: {
      type: Array
    },
    treeDataSimpleMode: {
      type: [Boolean, Object],
      default: void 0
    },
    loadData: {
      type: Function
    },
    treeLoadedKeys: {
      type: Array
    },
    onTreeLoad: {
      type: Function
    },
    // >>> Expanded
    treeDefaultExpandAll: {
      type: Boolean,
      default: void 0
    },
    treeExpandedKeys: {
      type: Array
    },
    treeDefaultExpandedKeys: {
      type: Array
    },
    onTreeExpand: {
      type: Function
    },
    // >>> Options
    virtual: {
      type: Boolean,
      default: void 0
    },
    listHeight: Number,
    listItemHeight: Number,
    onDropdownVisibleChange: {
      type: Function
    },
    // >>> Tree
    treeLine: {
      type: [Boolean, Object],
      default: void 0
    },
    treeIcon: V.any,
    showTreeIcon: {
      type: Boolean,
      default: void 0
    },
    switcherIcon: V.any,
    treeMotion: V.any,
    children: Array,
    treeExpandAction: String,
    showArrow: {
      type: Boolean,
      default: void 0
    },
    showSearch: {
      type: Boolean,
      default: void 0
    },
    open: {
      type: Boolean,
      default: void 0
    },
    defaultOpen: {
      type: Boolean,
      default: void 0
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    placeholder: V.any,
    maxTagPlaceholder: {
      type: Function
    },
    dropdownPopupAlign: V.any,
    customSlots: Object
  });
}
function uoe(e) {
  return !e || typeof e != "object";
}
const doe = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TreeSelect",
  inheritAttrs: !1,
  props: Qe(X6(), {
    treeNodeFilterProp: "value",
    autoClearSearchValue: !0,
    showCheckedStrategy: Jb,
    listHeight: 200,
    listItemHeight: 20,
    prefixCls: "vc-tree-select"
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o,
      slots: r
    } = t;
    const l = jh(Te(e, "id")), a = P(() => e.treeCheckable && !e.treeCheckStrictly), i = P(() => e.treeCheckable || e.treeCheckStrictly), s = P(() => e.treeCheckStrictly || e.labelInValue), c = P(() => i.value || e.multiple);
    process.env.NODE_ENV !== "production" && Le(() => {
      coe(e);
    });
    const u = P(() => Gne(e.fieldNames)), [d, p] = Rt("", {
      value: P(() => e.searchValue !== void 0 ? e.searchValue : e.inputValue),
      postState: (he) => he || ""
    }), v = (he) => {
      var we;
      p(he), (we = e.onSearch) === null || we === void 0 || we.call(e, he);
    }, h = roe(Te(e, "treeData"), Te(e, "children"), Te(e, "treeDataSimpleMode")), {
      keyEntities: g,
      valueEntities: b
    } = aoe(h, u), y = (he) => {
      const we = [], Me = [];
      return he.forEach((ae) => {
        b.value.has(ae) ? Me.push(ae) : we.push(ae);
      }), {
        missingRawValues: we,
        existRawValues: Me
      };
    }, S = soe(h, d, {
      fieldNames: u,
      treeNodeFilterProp: Te(e, "treeNodeFilterProp"),
      filterTreeNode: Te(e, "filterTreeNode")
    }), C = (he) => {
      if (he) {
        if (e.treeNodeLabelProp)
          return he[e.treeNodeLabelProp];
        const {
          _title: we
        } = u.value;
        for (let Me = 0; Me < we.length; Me += 1) {
          const ae = he[we[Me]];
          if (ae !== void 0)
            return ae;
        }
      }
    }, w = (he) => W6(he).map((Me) => uoe(Me) ? {
      value: Me
    } : Me), $ = (he) => w(he).map((Me) => {
      let {
        label: ae
      } = Me;
      const {
        value: oe,
        halfChecked: pe
      } = Me;
      let Pe;
      const Ee = b.value.get(oe);
      return Ee && (ae = ae ?? C(Ee.node), Pe = Ee.node.disabled), {
        label: ae,
        value: oe,
        halfChecked: pe,
        disabled: Pe
      };
    }), [O, x] = Rt(e.defaultValue, {
      value: Te(e, "value")
    }), I = P(() => w(O.value)), E = Q([]), _ = Q([]);
    Le(() => {
      const he = [], we = [];
      I.value.forEach((Me) => {
        Me.halfChecked ? we.push(Me) : he.push(Me);
      }), E.value = he, _.value = we;
    });
    const M = P(() => E.value.map((he) => he.value)), {
      maxLevel: R,
      levelEntities: A
    } = fp(g), [z, T] = ioe(E, _, a, g, R, A), N = P(() => {
      const Me = zw(z.value, e.showCheckedStrategy, g.value, u.value).map((pe) => {
        var Pe, Ee, ze;
        return (ze = (Ee = (Pe = g.value[pe]) === null || Pe === void 0 ? void 0 : Pe.node) === null || Ee === void 0 ? void 0 : Ee[u.value.value]) !== null && ze !== void 0 ? ze : pe;
      }).map((pe) => {
        const Pe = E.value.find((Ee) => Ee.value === pe);
        return {
          value: pe,
          label: Pe == null ? void 0 : Pe.label
        };
      }), ae = $(Me), oe = ae[0];
      return !c.value && oe && Wm(oe.value) && Wm(oe.label) ? [] : ae.map((pe) => {
        var Pe;
        return m(m({}, pe), {
          label: (Pe = pe.label) !== null && Pe !== void 0 ? Pe : pe.value
        });
      });
    }), [k] = loe(N), B = (he, we, Me) => {
      const ae = $(he);
      if (x(ae), e.autoClearSearchValue && p(""), e.onChange) {
        let oe = he;
        a.value && (oe = zw(he, e.showCheckedStrategy, g.value, u.value).map((Ve) => {
          const De = b.value.get(Ve);
          return De ? De.node[u.value.value] : Ve;
        }));
        const {
          triggerValue: pe,
          selected: Pe
        } = we || {
          triggerValue: void 0,
          selected: void 0
        };
        let Ee = oe;
        if (e.treeCheckStrictly) {
          const Ae = _.value.filter((Ve) => !oe.includes(Ve.value));
          Ee = [...Ee, ...Ae];
        }
        const ze = $(Ee), ge = {
          // [Legacy] Always return as array contains label & value
          preValue: E.value,
          triggerValue: pe
        };
        let ye = !0;
        (e.treeCheckStrictly || Me === "selection" && !Pe) && (ye = !1), noe(ge, pe, he, h.value, ye, u.value), i.value ? ge.checked = Pe : ge.selected = Pe;
        const $e = s.value ? ze : ze.map((Ae) => Ae.value);
        e.onChange(c.value ? $e : $e[0], s.value ? null : ze.map((Ae) => Ae.label), ge);
      }
    }, F = (he, we) => {
      let {
        selected: Me,
        source: ae
      } = we;
      var oe, pe, Pe;
      const Ee = Yt(g.value), ze = Yt(b.value), ge = Ee[he], ye = ge == null ? void 0 : ge.node, $e = (oe = ye == null ? void 0 : ye[u.value.value]) !== null && oe !== void 0 ? oe : he;
      if (!c.value)
        B([$e], {
          selected: !0,
          triggerValue: $e
        }, "option");
      else {
        let Ae = Me ? [...M.value, $e] : z.value.filter((Ve) => Ve !== $e);
        if (a.value) {
          const {
            missingRawValues: Ve,
            existRawValues: De
          } = y(Ae), We = De.map((gt) => ze.get(gt).key);
          let at;
          Me ? {
            checkedKeys: at
          } = Bo(We, !0, Ee, R.value, A.value) : {
            checkedKeys: at
          } = Bo(We, {
            checked: !1,
            halfCheckedKeys: T.value
          }, Ee, R.value, A.value), Ae = [...Ve, ...at.map((gt) => Ee[gt].node[u.value.value])];
        }
        B(Ae, {
          selected: Me,
          triggerValue: $e
        }, ae || "option");
      }
      Me || !c.value ? (pe = e.onSelect) === null || pe === void 0 || pe.call(e, $e, Km(ye)) : (Pe = e.onDeselect) === null || Pe === void 0 || Pe.call(e, $e, Km(ye));
    }, L = (he) => {
      if (e.onDropdownVisibleChange) {
        const we = {};
        Object.defineProperty(we, "documentClickClose", {
          get() {
            return ct(!1, "Second param of `onDropdownVisibleChange` has been removed."), !1;
          }
        }), e.onDropdownVisibleChange(he, we);
      }
    }, j = (he, we) => {
      const Me = he.map((ae) => ae.value);
      if (we.type === "clear") {
        B(Me, {}, "selection");
        return;
      }
      we.values.length && F(we.values[0].value, {
        selected: !1,
        source: "selection"
      });
    }, {
      treeNodeFilterProp: H,
      // Data
      loadData: K,
      treeLoadedKeys: X,
      onTreeLoad: W,
      // Expanded
      treeDefaultExpandAll: q,
      treeExpandedKeys: J,
      treeDefaultExpandedKeys: ne,
      onTreeExpand: te,
      // Options
      virtual: G,
      listHeight: U,
      listItemHeight: re,
      // Tree
      treeLine: se,
      treeIcon: me,
      showTreeIcon: Ce,
      switcherIcon: fe,
      treeMotion: be,
      customSlots: ue,
      dropdownMatchSelectWidth: de,
      treeExpandAction: Se
    } = Qo(e);
    yD(bd({
      checkable: i,
      loadData: K,
      treeLoadedKeys: X,
      onTreeLoad: W,
      checkedKeys: z,
      halfCheckedKeys: T,
      treeDefaultExpandAll: q,
      treeExpandedKeys: J,
      treeDefaultExpandedKeys: ne,
      onTreeExpand: te,
      treeIcon: me,
      treeMotion: be,
      showTreeIcon: Ce,
      switcherIcon: fe,
      treeLine: se,
      treeNodeFilterProp: H,
      keyEntities: g,
      customSlots: ue
    })), Une(bd({
      virtual: G,
      listHeight: U,
      listItemHeight: re,
      treeData: S,
      fieldNames: u,
      onSelect: F,
      dropdownMatchSelectWidth: de,
      treeExpandAction: Se
    }));
    const xe = Y();
    return o({
      focus() {
        var he;
        (he = xe.value) === null || he === void 0 || he.focus();
      },
      blur() {
        var he;
        (he = xe.value) === null || he === void 0 || he.blur();
      },
      scrollTo(he) {
        var we;
        (we = xe.value) === null || we === void 0 || we.scrollTo(he);
      }
    }), () => {
      var he;
      const we = ot(e, [
        "id",
        "prefixCls",
        "customSlots",
        // Value
        "value",
        "defaultValue",
        "onChange",
        "onSelect",
        "onDeselect",
        // Search
        "searchValue",
        "inputValue",
        "onSearch",
        "autoClearSearchValue",
        "filterTreeNode",
        "treeNodeFilterProp",
        // Selector
        "showCheckedStrategy",
        "treeNodeLabelProp",
        //  Mode
        "multiple",
        "treeCheckable",
        "treeCheckStrictly",
        "labelInValue",
        // FieldNames
        "fieldNames",
        // Data
        "treeDataSimpleMode",
        "treeData",
        "children",
        "loadData",
        "treeLoadedKeys",
        "onTreeLoad",
        // Expanded
        "treeDefaultExpandAll",
        "treeExpandedKeys",
        "treeDefaultExpandedKeys",
        "onTreeExpand",
        // Options
        "virtual",
        "listHeight",
        "listItemHeight",
        "onDropdownVisibleChange",
        // Tree
        "treeLine",
        "treeIcon",
        "showTreeIcon",
        "switcherIcon",
        "treeMotion"
      ]);
      return f(Lh, D(D(D({
        ref: xe
      }, n), we), {}, {
        id: l,
        prefixCls: e.prefixCls,
        mode: c.value ? "multiple" : void 0,
        displayValues: k.value,
        onDisplayValuesChange: j,
        searchValue: d.value,
        onSearch: v,
        OptionList: Zne,
        emptyOptions: !h.value.length,
        onDropdownVisibleChange: L,
        tagRender: e.tagRender || r.tagRender,
        dropdownMatchSelectWidth: (he = e.dropdownMatchSelectWidth) !== null && he !== void 0 ? he : !0
      }), r);
    };
  }
}), foe = (e) => {
  const {
    componentCls: t,
    treePrefixCls: n,
    colorBgElevated: o
  } = e, r = `.${n}`;
  return [
    // ======================================================
    // ==                     Dropdown                     ==
    // ======================================================
    {
      [`${t}-dropdown`]: [
        {
          padding: `${e.paddingXS}px ${e.paddingXS / 2}px`
        },
        // ====================== Tree ======================
        N6(n, He(e, {
          colorBgContainer: o
        })),
        {
          [r]: {
            borderRadius: 0,
            "&-list-holder-inner": {
              alignItems: "stretch",
              [`${r}-treenode`]: {
                [`${r}-node-content-wrapper`]: {
                  flex: "auto"
                }
              }
            }
          }
        },
        // ==================== Checkbox ====================
        mp(`${n}-checkbox`, e),
        // ====================== RTL =======================
        {
          "&-rtl": {
            direction: "rtl",
            [`${r}-switcher${r}-switcher_close`]: {
              [`${r}-switcher-icon svg`]: {
                transform: "rotate(90deg)"
              }
            }
          }
        }
      ]
    }
  ];
};
function poe(e, t) {
  return Xe("TreeSelect", (n) => {
    const o = He(n, {
      treePrefixCls: t.value
    });
    return [foe(o)];
  })(e);
}
const Hw = (e, t, n) => n !== void 0 ? n : `${e}-${t}`;
function voe() {
  return m(m({}, ot(X6(), ["showTreeIcon", "treeMotion", "inputIcon", "getInputElement", "treeLine", "customSlots"])), {
    suffixIcon: V.any,
    size: ke(),
    bordered: ve(),
    treeLine: je([Boolean, Object]),
    replaceFields: Re(),
    placement: ke(),
    status: ke(),
    popupClassName: String,
    /** @deprecated Please use `popupClassName` instead */
    dropdownClassName: String,
    "onUpdate:value": le(),
    "onUpdate:treeExpandedKeys": le(),
    "onUpdate:searchValue": le()
  });
}
const Gv = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATreeSelect",
  inheritAttrs: !1,
  props: Qe(voe(), {
    choiceTransitionName: "",
    listHeight: 256,
    treeIcon: !1,
    listItemHeight: 26,
    bordered: !0
  }),
  slots: Object,
  setup(e, t) {
    let {
      attrs: n,
      slots: o,
      expose: r,
      emit: l
    } = t;
    ct(!(e.treeData === void 0 && o.default), "`children` of TreeSelect is deprecated. Please use `treeData` instead."), nt(e.multiple !== !1 || !e.treeCheckable, "TreeSelect", "`multiple` will always be `true` when `treeCheckable` is true"), nt(e.replaceFields === void 0, "TreeSelect", "`replaceFields` is deprecated, please use fieldNames instead"), nt(!e.dropdownClassName, "TreeSelect", "`dropdownClassName` is deprecated. Please use `popupClassName` instead.");
    const a = sn(), i = Sn.useInject(), s = P(() => ar(i.status, e.status)), {
      prefixCls: c,
      renderEmpty: u,
      direction: d,
      virtual: p,
      dropdownMatchSelectWidth: v,
      size: h,
      getPopupContainer: g,
      getPrefixCls: b,
      disabled: y
    } = Ie("select", e), {
      compactSize: S,
      compactItemClassnames: C
    } = Ol(c, d), w = P(() => S.value || h.value), $ = so(), O = P(() => {
      var X;
      return (X = y.value) !== null && X !== void 0 ? X : $.value;
    }), x = P(() => b()), I = P(() => e.placement !== void 0 ? e.placement : d.value === "rtl" ? "bottomRight" : "bottomLeft"), E = P(() => Hw(x.value, Nh(I.value), e.transitionName)), _ = P(() => Hw(x.value, "", e.choiceTransitionName)), M = P(() => b("select-tree", e.prefixCls)), R = P(() => b("tree-select", e.prefixCls)), [A, z] = i0(c), [T] = poe(R, M), N = P(() => ee(e.popupClassName || e.dropdownClassName, `${R.value}-dropdown`, {
      [`${R.value}-dropdown-rtl`]: d.value === "rtl"
    }, z.value)), k = P(() => !!(e.treeCheckable || e.multiple)), B = P(() => e.showArrow !== void 0 ? e.showArrow : e.loading || !k.value), F = Y();
    r({
      focus() {
        var X, W;
        (W = (X = F.value).focus) === null || W === void 0 || W.call(X);
      },
      blur() {
        var X, W;
        (W = (X = F.value).blur) === null || W === void 0 || W.call(X);
      }
    });
    const L = function() {
      for (var X = arguments.length, W = new Array(X), q = 0; q < X; q++)
        W[q] = arguments[q];
      l("update:value", W[0]), l("change", ...W), a.onFieldChange();
    }, j = (X) => {
      l("update:treeExpandedKeys", X), l("treeExpand", X);
    }, H = (X) => {
      l("update:searchValue", X), l("search", X);
    }, K = (X) => {
      l("blur", X), a.onFieldBlur();
    };
    return () => {
      var X, W, q;
      const {
        notFoundContent: J = (X = o.notFoundContent) === null || X === void 0 ? void 0 : X.call(o),
        prefixCls: ne,
        bordered: te,
        listHeight: G,
        listItemHeight: U,
        multiple: re,
        treeIcon: se,
        treeLine: me,
        showArrow: Ce,
        switcherIcon: fe = (W = o.switcherIcon) === null || W === void 0 ? void 0 : W.call(o),
        fieldNames: be = e.replaceFields,
        id: ue = a.id.value,
        placeholder: de = (q = o.placeholder) === null || q === void 0 ? void 0 : q.call(o)
      } = e, {
        isFormItemInput: Se,
        hasFeedback: xe,
        feedbackIcon: he
      } = i, {
        suffixIcon: we,
        removeIcon: Me,
        clearIcon: ae
      } = Uh(m(m({}, e), {
        multiple: k.value,
        showArrow: B.value,
        hasFeedback: xe,
        feedbackIcon: he,
        prefixCls: c.value
      }), o);
      let oe;
      J !== void 0 ? oe = J : oe = u("Select");
      const pe = ot(e, ["suffixIcon", "itemIcon", "removeIcon", "clearIcon", "switcherIcon", "bordered", "status", "onUpdate:value", "onUpdate:treeExpandedKeys", "onUpdate:searchValue"]), Pe = ee(!ne && R.value, {
        [`${c.value}-lg`]: w.value === "large",
        [`${c.value}-sm`]: w.value === "small",
        [`${c.value}-rtl`]: d.value === "rtl",
        [`${c.value}-borderless`]: !te,
        [`${c.value}-in-form-item`]: Se
      }, Fn(c.value, s.value, xe), C.value, n.class, z.value), Ee = {};
      return e.treeData === void 0 && o.default && (Ee.children = It(o.default())), A(T(f(doe, D(D(D(D({}, n), pe), {}, {
        disabled: O.value,
        virtual: p.value,
        dropdownMatchSelectWidth: v.value,
        id: ue,
        fieldNames: be,
        ref: F,
        prefixCls: c.value,
        class: Pe,
        listHeight: G,
        listItemHeight: U,
        treeLine: !!me,
        inputIcon: we,
        multiple: re,
        removeIcon: Me,
        clearIcon: ae,
        switcherIcon: (ze) => D6(M.value, fe, ze, o.leafIcon, me),
        showTreeIcon: se,
        notFoundContent: oe,
        getPopupContainer: g == null ? void 0 : g.value,
        treeMotion: null,
        dropdownClassName: N.value,
        choiceTransitionName: _.value,
        onChange: L,
        onBlur: K,
        onSearch: H,
        onTreeExpand: j
      }, Ee), {}, {
        transitionName: E.value,
        customSlots: m(m({}, o), {
          treeCheckable: () => f("span", {
            class: `${c.value}-tree-checkbox-inner`
          }, null)
        }),
        maxTagPlaceholder: e.maxTagPlaceholder || o.maxTagPlaceholder,
        placement: I.value,
        showArrow: xe || Ce,
        placeholder: de
      }), m(m({}, o), {
        treeCheckable: () => f("span", {
          class: `${c.value}-tree-checkbox-inner`
        }, null)
      }))));
    };
  }
}), Gm = Li, goe = m(Gv, {
  TreeNode: Li,
  SHOW_ALL: Qne,
  SHOW_PARENT: G6,
  SHOW_CHILD: Jb,
  install: (e) => (e.component(Gv.name, Gv), e.component(Gm.displayName, Gm), e)
}), Xv = () => ({
  format: String,
  showNow: ve(),
  showHour: ve(),
  showMinute: ve(),
  showSecond: ve(),
  use12Hours: ve(),
  hourStep: Number,
  minuteStep: Number,
  secondStep: Number,
  hideDisabledOptions: ve(),
  popupClassName: String,
  status: ke()
});
function moe(e) {
  const t = sI(e, m(m({}, Xv()), {
    order: {
      type: Boolean,
      default: !0
    }
  })), {
    TimePicker: n,
    RangePicker: o
  } = t, r = Z({
    name: "ATimePicker",
    inheritAttrs: !1,
    props: m(m(m(m({}, Xd()), lI()), Xv()), {
      addon: {
        type: Function
      }
    }),
    slots: Object,
    setup(a, i) {
      let {
        slots: s,
        expose: c,
        emit: u,
        attrs: d
      } = i;
      const p = a, v = sn();
      nt(!(s.addon || p.addon), "TimePicker", "`addon` is deprecated. Please use `v-slot:renderExtraFooter` instead.");
      const h = Y();
      c({
        focus: () => {
          var w;
          (w = h.value) === null || w === void 0 || w.focus();
        },
        blur: () => {
          var w;
          (w = h.value) === null || w === void 0 || w.blur();
        }
      });
      const g = (w, $) => {
        u("update:value", w), u("change", w, $), v.onFieldChange();
      }, b = (w) => {
        u("update:open", w), u("openChange", w);
      }, y = (w) => {
        u("focus", w);
      }, S = (w) => {
        u("blur", w), v.onFieldBlur();
      }, C = (w) => {
        u("ok", w);
      };
      return () => {
        const {
          id: w = v.id.value
        } = p;
        return f(n, D(D(D({}, d), ot(p, ["onUpdate:value", "onUpdate:open"])), {}, {
          id: w,
          dropdownClassName: p.popupClassName,
          mode: void 0,
          ref: h,
          renderExtraFooter: p.addon || s.addon || p.renderExtraFooter || s.renderExtraFooter,
          onChange: g,
          onOpenChange: b,
          onFocus: y,
          onBlur: S,
          onOk: C
        }), s);
      };
    }
  }), l = Z({
    name: "ATimeRangePicker",
    inheritAttrs: !1,
    props: m(m(m(m({}, Xd()), aI()), Xv()), {
      order: {
        type: Boolean,
        default: !0
      }
    }),
    slots: Object,
    setup(a, i) {
      let {
        slots: s,
        expose: c,
        emit: u,
        attrs: d
      } = i;
      const p = a, v = Y(), h = sn();
      c({
        focus: () => {
          var O;
          (O = v.value) === null || O === void 0 || O.focus();
        },
        blur: () => {
          var O;
          (O = v.value) === null || O === void 0 || O.blur();
        }
      });
      const g = (O, x) => {
        u("update:value", O), u("change", O, x), h.onFieldChange();
      }, b = (O) => {
        u("update:open", O), u("openChange", O);
      }, y = (O) => {
        u("focus", O);
      }, S = (O) => {
        u("blur", O), h.onFieldBlur();
      }, C = (O, x) => {
        u("panelChange", O, x);
      }, w = (O) => {
        u("ok", O);
      }, $ = (O, x, I) => {
        u("calendarChange", O, x, I);
      };
      return () => {
        const {
          id: O = h.id.value
        } = p;
        return f(o, D(D(D({}, d), ot(p, ["onUpdate:open", "onUpdate:value"])), {}, {
          id: O,
          dropdownClassName: p.popupClassName,
          picker: "time",
          mode: void 0,
          ref: v,
          onChange: g,
          onOpenChange: b,
          onFocus: y,
          onBlur: S,
          onPanelChange: C,
          onOk: w,
          onCalendarChange: $
        }), s);
      };
    }
  });
  return {
    TimePicker: r,
    TimeRangePicker: l
  };
}
const {
  TimePicker: lu,
  TimeRangePicker: Uu
} = moe(C0), hoe = m(lu, {
  TimePicker: lu,
  TimeRangePicker: Uu,
  install: (e) => (e.component(lu.name, lu), e.component(Uu.name, Uu), e)
}), boe = () => ({
  prefixCls: String,
  color: String,
  dot: V.any,
  pending: ve(),
  position: V.oneOf(Mn("left", "right", "")).def(""),
  label: V.any
}), tc = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATimelineItem",
  props: Qe(boe(), {
    color: "blue",
    pending: !1
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = Ie("timeline", e), r = P(() => ({
      [`${o.value}-item`]: !0,
      [`${o.value}-item-pending`]: e.pending
    })), l = P(() => /blue|red|green|gray/.test(e.color || "") ? void 0 : e.color || "blue"), a = P(() => ({
      [`${o.value}-item-head`]: !0,
      [`${o.value}-item-head-${e.color || "blue"}`]: !l.value
    }));
    return () => {
      var i, s, c;
      const {
        label: u = (i = n.label) === null || i === void 0 ? void 0 : i.call(n),
        dot: d = (s = n.dot) === null || s === void 0 ? void 0 : s.call(n)
      } = e;
      return f("li", {
        class: r.value
      }, [u && f("div", {
        class: `${o.value}-item-label`
      }, [u]), f("div", {
        class: `${o.value}-item-tail`
      }, null), f("div", {
        class: [a.value, !!d && `${o.value}-item-head-custom`],
        style: {
          borderColor: l.value,
          color: l.value
        }
      }, [d]), f("div", {
        class: `${o.value}-item-content`
      }, [(c = n.default) === null || c === void 0 ? void 0 : c.call(n)])]);
    };
  }
}), yoe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      margin: 0,
      padding: 0,
      listStyle: "none",
      [`${t}-item`]: {
        position: "relative",
        margin: 0,
        paddingBottom: e.timeLineItemPaddingBottom,
        fontSize: e.fontSize,
        listStyle: "none",
        "&-tail": {
          position: "absolute",
          insetBlockStart: e.timeLineItemHeadSize,
          insetInlineStart: (e.timeLineItemHeadSize - e.timeLineItemTailWidth) / 2,
          height: `calc(100% - ${e.timeLineItemHeadSize}px)`,
          borderInlineStart: `${e.timeLineItemTailWidth}px ${e.lineType} ${e.colorSplit}`
        },
        "&-pending": {
          [`${t}-item-head`]: {
            fontSize: e.fontSizeSM,
            backgroundColor: "transparent"
          },
          [`${t}-item-tail`]: {
            display: "none"
          }
        },
        "&-head": {
          position: "absolute",
          width: e.timeLineItemHeadSize,
          height: e.timeLineItemHeadSize,
          backgroundColor: e.colorBgContainer,
          border: `${e.timeLineHeadBorderWidth}px ${e.lineType} transparent`,
          borderRadius: "50%",
          "&-blue": {
            color: e.colorPrimary,
            borderColor: e.colorPrimary
          },
          "&-red": {
            color: e.colorError,
            borderColor: e.colorError
          },
          "&-green": {
            color: e.colorSuccess,
            borderColor: e.colorSuccess
          },
          "&-gray": {
            color: e.colorTextDisabled,
            borderColor: e.colorTextDisabled
          }
        },
        "&-head-custom": {
          position: "absolute",
          insetBlockStart: e.timeLineItemHeadSize / 2,
          insetInlineStart: e.timeLineItemHeadSize / 2,
          width: "auto",
          height: "auto",
          marginBlockStart: 0,
          paddingBlock: e.timeLineItemCustomHeadPaddingVertical,
          lineHeight: 1,
          textAlign: "center",
          border: 0,
          borderRadius: 0,
          transform: "translate(-50%, -50%)"
        },
        "&-content": {
          position: "relative",
          insetBlockStart: -(e.fontSize * e.lineHeight - e.fontSize) + e.lineWidth,
          marginInlineStart: e.margin + e.timeLineItemHeadSize,
          marginInlineEnd: 0,
          marginBlockStart: 0,
          marginBlockEnd: 0,
          wordBreak: "break-word"
        },
        "&-last": {
          [`> ${t}-item-tail`]: {
            display: "none"
          },
          [`> ${t}-item-content`]: {
            minHeight: e.controlHeightLG * 1.2
          }
        }
      },
      [`&${t}-alternate,
        &${t}-right,
        &${t}-label`]: {
        [`${t}-item`]: {
          "&-tail, &-head, &-head-custom": {
            insetInlineStart: "50%"
          },
          "&-head": {
            marginInlineStart: `-${e.marginXXS}px`,
            "&-custom": {
              marginInlineStart: e.timeLineItemTailWidth / 2
            }
          },
          "&-left": {
            [`${t}-item-content`]: {
              insetInlineStart: `calc(50% - ${e.marginXXS}px)`,
              width: `calc(50% - ${e.marginSM}px)`,
              textAlign: "start"
            }
          },
          "&-right": {
            [`${t}-item-content`]: {
              width: `calc(50% - ${e.marginSM}px)`,
              margin: 0,
              textAlign: "end"
            }
          }
        }
      },
      [`&${t}-right`]: {
        [`${t}-item-right`]: {
          [`${t}-item-tail,
            ${t}-item-head,
            ${t}-item-head-custom`]: {
            insetInlineStart: `calc(100% - ${(e.timeLineItemHeadSize + e.timeLineItemTailWidth) / 2}px)`
          },
          [`${t}-item-content`]: {
            width: `calc(100% - ${e.timeLineItemHeadSize + e.marginXS}px)`
          }
        }
      },
      [`&${t}-pending
        ${t}-item-last
        ${t}-item-tail`]: {
        display: "block",
        height: `calc(100% - ${e.margin}px)`,
        borderInlineStart: `${e.timeLineItemTailWidth}px dotted ${e.colorSplit}`
      },
      [`&${t}-reverse
        ${t}-item-last
        ${t}-item-tail`]: {
        display: "none"
      },
      [`&${t}-reverse ${t}-item-pending`]: {
        [`${t}-item-tail`]: {
          insetBlockStart: e.margin,
          display: "block",
          height: `calc(100% - ${e.margin}px)`,
          borderInlineStart: `${e.timeLineItemTailWidth}px dotted ${e.colorSplit}`
        },
        [`${t}-item-content`]: {
          minHeight: e.controlHeightLG * 1.2
        }
      },
      [`&${t}-label`]: {
        [`${t}-item-label`]: {
          position: "absolute",
          insetBlockStart: -(e.fontSize * e.lineHeight - e.fontSize) + e.timeLineItemTailWidth,
          width: `calc(50% - ${e.marginSM}px)`,
          textAlign: "end"
        },
        [`${t}-item-right`]: {
          [`${t}-item-label`]: {
            insetInlineStart: `calc(50% + ${e.marginSM}px)`,
            width: `calc(50% - ${e.marginSM}px)`,
            textAlign: "start"
          }
        }
      },
      // ====================== RTL =======================
      "&-rtl": {
        direction: "rtl",
        [`${t}-item-head-custom`]: {
          transform: "translate(50%, -50%)"
        }
      }
    })
  };
}, Soe = Xe("Timeline", (e) => {
  const t = He(e, {
    timeLineItemPaddingBottom: e.padding * 1.25,
    timeLineItemHeadSize: 10,
    timeLineItemCustomHeadPaddingVertical: e.paddingXXS,
    timeLinePaddingInlineEnd: 2,
    timeLineItemTailWidth: e.lineWidthBold,
    timeLineHeadBorderWidth: e.wireframe ? e.lineWidthBold : e.lineWidth * 3
  });
  return [yoe(t)];
}), Coe = () => ({
  prefixCls: String,
  /** 指定最后一个幽灵节点是否存在或内容 */
  pending: V.any,
  pendingDot: V.any,
  reverse: ve(),
  mode: V.oneOf(Mn("left", "alternate", "right", ""))
}), Os = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ATimeline",
  inheritAttrs: !1,
  props: Qe(Coe(), {
    reverse: !1,
    mode: ""
  }),
  slots: Object,
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("timeline", e), [a, i] = Soe(r), s = (c, u) => {
      const d = c.props || {};
      return e.mode === "alternate" ? d.position === "right" ? `${r.value}-item-right` : d.position === "left" ? `${r.value}-item-left` : u % 2 === 0 ? `${r.value}-item-left` : `${r.value}-item-right` : e.mode === "left" ? `${r.value}-item-left` : e.mode === "right" ? `${r.value}-item-right` : d.position === "right" ? `${r.value}-item-right` : "";
    };
    return () => {
      var c, u, d;
      const {
        pending: p = (c = n.pending) === null || c === void 0 ? void 0 : c.call(n),
        pendingDot: v = (u = n.pendingDot) === null || u === void 0 ? void 0 : u.call(n),
        reverse: h,
        mode: g
      } = e, b = typeof p == "boolean" ? null : p, y = Lt((d = n.default) === null || d === void 0 ? void 0 : d.call(n)), S = p ? f(tc, {
        pending: !!p,
        dot: v || f(Qn, null, null)
      }, {
        default: () => [b]
      }) : null;
      S && y.push(S);
      const C = h ? y.reverse() : y, w = C.length, $ = `${r.value}-item-last`, O = C.map((E, _) => {
        const M = _ === w - 2 ? $ : "", R = _ === w - 1 ? $ : "";
        return tr(E, {
          class: ee([!h && p ? M : R, s(E, _)])
        });
      }), x = C.some((E) => {
        var _, M;
        return !!(!((_ = E.props) === null || _ === void 0) && _.label || !((M = E.children) === null || M === void 0) && M.label);
      }), I = ee(r.value, {
        [`${r.value}-pending`]: !!p,
        [`${r.value}-reverse`]: !!h,
        [`${r.value}-${g}`]: !!g && !x,
        [`${r.value}-label`]: x,
        [`${r.value}-rtl`]: l.value === "rtl"
      }, o.class, i.value);
      return a(f("ul", D(D({}, o), {}, {
        class: I
      }), [O]));
    };
  }
});
Os.Item = tc;
Os.install = function(e) {
  return e.component(Os.name, Os), e.component(tc.name, tc), e;
};
var $oe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M864 170h-60c-4.4 0-8 3.6-8 8v518H310v-73c0-6.7-7.8-10.5-13-6.3l-141.9 112a8 8 0 000 12.6l141.9 112c5.3 4.2 13 .4 13-6.3v-75h498c35.3 0 64-28.7 64-64V178c0-4.4-3.6-8-8-8z" } }] }, name: "enter", theme: "outlined" };
function jw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      woe(e, r, n[r]);
    });
  }
  return e;
}
function woe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ey = function(t, n) {
  var o = jw({}, t, n.attrs);
  return f(Ge, jw({}, o, {
    icon: $oe
  }), null);
};
ey.displayName = "EnterOutlined";
ey.inheritAttrs = !1;
const xoe = (e, t, n, o) => {
  const {
    sizeMarginHeadingVerticalEnd: r,
    fontWeightStrong: l
  } = o;
  return {
    marginBottom: r,
    color: n,
    fontWeight: l,
    fontSize: e,
    lineHeight: t
  };
}, Ooe = (e) => {
  const t = [1, 2, 3, 4, 5], n = {};
  return t.forEach((o) => {
    n[`
      h${o}&,
      div&-h${o},
      div&-h${o} > textarea,
      h${o}
    `] = xoe(e[`fontSizeHeading${o}`], e[`lineHeightHeading${o}`], e.colorTextHeading, e);
  }), n;
}, Poe = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    "a&, a": m(m({}, wf(e)), {
      textDecoration: e.linkDecoration,
      "&:active, &:hover": {
        textDecoration: e.linkHoverDecoration
      },
      [`&[disabled], &${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        "&:active, &:hover": {
          color: e.colorTextDisabled
        },
        "&:active": {
          pointerEvents: "none"
        }
      }
    })
  };
}, Ioe = () => ({
  code: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.2em 0.1em",
    fontSize: "85%",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3
  },
  kbd: {
    margin: "0 0.2em",
    paddingInline: "0.4em",
    paddingBlock: "0.15em 0.1em",
    fontSize: "90%",
    background: "rgba(150, 150, 150, 0.06)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderBottomWidth: 2,
    borderRadius: 3
  },
  mark: {
    padding: 0,
    // FIXME hardcode in v4
    backgroundColor: y5[2]
  },
  "u, ins": {
    textDecoration: "underline",
    textDecorationSkipInk: "auto"
  },
  "s, del": {
    textDecoration: "line-through"
  },
  strong: {
    fontWeight: 600
  },
  // list
  "ul, ol": {
    marginInline: 0,
    marginBlock: "0 1em",
    padding: 0,
    li: {
      marginInline: "20px 0",
      marginBlock: 0,
      paddingInline: "4px 0",
      paddingBlock: 0
    }
  },
  ul: {
    listStyleType: "circle",
    ul: {
      listStyleType: "disc"
    }
  },
  ol: {
    listStyleType: "decimal"
  },
  // pre & block
  "pre, blockquote": {
    margin: "1em 0"
  },
  pre: {
    padding: "0.4em 0.6em",
    whiteSpace: "pre-wrap",
    wordWrap: "break-word",
    background: "rgba(150, 150, 150, 0.1)",
    border: "1px solid rgba(100, 100, 100, 0.2)",
    borderRadius: 3,
    // Compatible for marked
    code: {
      display: "inline",
      margin: 0,
      padding: 0,
      fontSize: "inherit",
      fontFamily: "inherit",
      background: "transparent",
      border: 0
    }
  },
  blockquote: {
    paddingInline: "0.6em 0",
    paddingBlock: 0,
    borderInlineStart: "4px solid rgba(100, 100, 100, 0.2)",
    opacity: 0.85
  }
}), Eoe = (e) => {
  const {
    componentCls: t
  } = e, o = Pa(e).inputPaddingVertical + 1;
  return {
    "&-edit-content": {
      position: "relative",
      "div&": {
        insetInlineStart: -e.paddingSM,
        marginTop: -o,
        marginBottom: `calc(1em - ${o}px)`
      },
      [`${t}-edit-content-confirm`]: {
        position: "absolute",
        insetInlineEnd: e.marginXS + 2,
        insetBlockEnd: e.marginXS,
        color: e.colorTextDescription,
        // default style
        fontWeight: "normal",
        fontSize: e.fontSize,
        fontStyle: "normal",
        pointerEvents: "none"
      },
      textarea: {
        margin: "0!important",
        // Fix Editable Textarea flash in Firefox
        MozTransition: "none",
        height: "1em"
      }
    }
  };
}, Toe = (e) => ({
  "&-copy-success": {
    "\n    &,\n    &:hover,\n    &:focus": {
      color: e.colorSuccess
    }
  }
}), Moe = () => ({
  "\n  a&-ellipsis,\n  span&-ellipsis\n  ": {
    display: "inline-block",
    maxWidth: "100%"
  },
  "&-single-line": {
    whiteSpace: "nowrap"
  },
  "&-ellipsis-single-line": {
    overflow: "hidden",
    textOverflow: "ellipsis",
    // https://blog.csdn.net/iefreer/article/details/50421025
    "a&, span&": {
      verticalAlign: "bottom"
    }
  },
  "&-ellipsis-multiple-line": {
    display: "-webkit-box",
    overflow: "hidden",
    WebkitLineClamp: 3,
    WebkitBoxOrient: "vertical"
  }
}), _oe = (e) => {
  const {
    componentCls: t,
    sizeMarginHeadingVerticalStart: n
  } = e;
  return {
    [t]: m(m(m(m(m(m(m(m(m({
      color: e.colorText,
      wordBreak: "break-word",
      lineHeight: e.lineHeight,
      [`&${t}-secondary`]: {
        color: e.colorTextDescription
      },
      [`&${t}-success`]: {
        color: e.colorSuccess
      },
      [`&${t}-warning`]: {
        color: e.colorWarning
      },
      [`&${t}-danger`]: {
        color: e.colorError,
        "a&:active, a&:focus": {
          color: e.colorErrorActive
        },
        "a&:hover": {
          color: e.colorErrorHover
        }
      },
      [`&${t}-disabled`]: {
        color: e.colorTextDisabled,
        cursor: "not-allowed",
        userSelect: "none"
      },
      "\n        div&,\n        p\n      ": {
        marginBottom: "1em"
      }
    }, Ooe(e)), {
      [`
      & + h1${t},
      & + h2${t},
      & + h3${t},
      & + h4${t},
      & + h5${t}
      `]: {
        marginTop: n
      },
      "\n      div,\n      ul,\n      li,\n      p,\n      h1,\n      h2,\n      h3,\n      h4,\n      h5": {
        "\n        + h1,\n        + h2,\n        + h3,\n        + h4,\n        + h5\n        ": {
          marginTop: n
        }
      }
    }), Ioe()), Poe(e)), {
      // Operation
      [`
        ${t}-expand,
        ${t}-edit,
        ${t}-copy
      `]: m(m({}, wf(e)), {
        marginInlineStart: e.marginXXS
      })
    }), Eoe(e)), Toe(e)), Moe()), {
      "&-rtl": {
        direction: "rtl"
      }
    })
  };
}, U6 = Xe("Typography", (e) => [_oe(e)], {
  sizeMarginHeadingVerticalStart: "1.2em",
  sizeMarginHeadingVerticalEnd: "0.5em"
}), Aoe = () => ({
  prefixCls: String,
  value: String,
  maxlength: Number,
  autoSize: {
    type: [Boolean, Object]
  },
  onSave: Function,
  onCancel: Function,
  onEnd: Function,
  onChange: Function,
  originContent: String,
  direction: String,
  component: String
}), Doe = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Editable",
  inheritAttrs: !1,
  props: Aoe(),
  // emits: ['save', 'cancel', 'end', 'change'],
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: r
    } = t;
    const {
      prefixCls: l
    } = Qo(e), a = xt({
      current: e.value || "",
      lastKeyCode: void 0,
      inComposition: !1,
      cancelFlag: !1
    });
    ie(() => e.value, (S) => {
      a.current = S;
    });
    const i = Y();
    Ke(() => {
      var S;
      if (i.value) {
        const C = (S = i.value) === null || S === void 0 ? void 0 : S.resizableTextArea, w = C == null ? void 0 : C.textArea;
        w.focus();
        const {
          length: $
        } = w.value;
        w.setSelectionRange($, $);
      }
    });
    function s(S) {
      i.value = S;
    }
    function c(S) {
      let {
        target: {
          value: C
        }
      } = S;
      a.current = C.replace(/[\r\n]/g, ""), n("change", a.current);
    }
    function u() {
      a.inComposition = !0;
    }
    function d() {
      a.inComposition = !1;
    }
    function p(S) {
      const {
        keyCode: C
      } = S;
      C === ce.ENTER && S.preventDefault(), !a.inComposition && (a.lastKeyCode = C);
    }
    function v(S) {
      const {
        keyCode: C,
        ctrlKey: w,
        altKey: $,
        metaKey: O,
        shiftKey: x
      } = S;
      a.lastKeyCode === C && !a.inComposition && !w && !$ && !O && !x && (C === ce.ENTER ? (g(), n("end")) : C === ce.ESC && (a.current = e.originContent, n("cancel")));
    }
    function h() {
      g();
    }
    function g() {
      n("save", a.current.trim());
    }
    const [b, y] = U6(l);
    return () => {
      const S = ee({
        [`${l.value}`]: !0,
        [`${l.value}-edit-content`]: !0,
        [`${l.value}-rtl`]: e.direction === "rtl",
        [e.component ? `${l.value}-${e.component}` : ""]: !0
      }, r.class, y.value);
      return b(f("div", D(D({}, r), {}, {
        class: S
      }), [f(bb, {
        ref: s,
        maxlength: e.maxlength,
        value: a.current,
        onChange: c,
        onKeydown: p,
        onKeyup: v,
        onCompositionstart: u,
        onCompositionend: d,
        onBlur: h,
        rows: 1,
        autoSize: e.autoSize === void 0 || e.autoSize
      }, null), o.enterIcon ? o.enterIcon({
        className: `${e.prefixCls}-edit-content-confirm`
      }) : f(ey, {
        class: `${e.prefixCls}-edit-content-confirm`
      }, null)]));
    };
  }
}), Noe = 3, Roe = 8;
let oo;
const Uv = {
  padding: 0,
  margin: 0,
  display: "inline",
  lineHeight: "inherit"
};
function Y6(e, t) {
  e.setAttribute("aria-hidden", "true");
  const n = window.getComputedStyle(t), o = lD(n);
  e.setAttribute("style", o), e.style.position = "fixed", e.style.left = "0", e.style.height = "auto", e.style.minHeight = "auto", e.style.maxHeight = "auto", e.style.paddingTop = "0", e.style.paddingBottom = "0", e.style.borderTopWidth = "0", e.style.borderBottomWidth = "0", e.style.top = "-999999px", e.style.zIndex = "-1000", e.style.textOverflow = "clip", e.style.whiteSpace = "normal", e.style.webkitLineClamp = "none";
}
function koe(e) {
  const t = document.createElement("div");
  Y6(t, e), t.appendChild(document.createTextNode("text")), document.body.appendChild(t);
  const n = t.getBoundingClientRect().height;
  return document.body.removeChild(t), n;
}
const Boe = (e, t, n, o, r) => {
  oo || (oo = document.createElement("div"), oo.setAttribute("aria-hidden", "true"), document.body.appendChild(oo));
  const {
    rows: l,
    suffix: a = ""
  } = t, i = koe(e), s = Math.round(i * l * 100) / 100;
  Y6(oo, e);
  const c = sT({
    render() {
      return f("div", {
        style: Uv
      }, [f("span", {
        style: Uv
      }, [n, a]), f("span", {
        style: Uv
      }, [o])]);
    }
  });
  c.mount(oo);
  function u() {
    return Math.round(oo.getBoundingClientRect().height * 100) / 100 - 0.1 <= s;
  }
  if (u())
    return c.unmount(), {
      content: n,
      text: oo.innerHTML,
      ellipsis: !1
    };
  const d = Array.prototype.slice.apply(oo.childNodes[0].childNodes[0].cloneNode(!0).childNodes).filter((C) => {
    let {
      nodeType: w,
      data: $
    } = C;
    return w !== Roe && $ !== "";
  }), p = Array.prototype.slice.apply(oo.childNodes[0].childNodes[1].cloneNode(!0).childNodes);
  c.unmount();
  const v = [];
  oo.innerHTML = "";
  const h = document.createElement("span");
  oo.appendChild(h);
  const g = document.createTextNode(r + a);
  h.appendChild(g), p.forEach((C) => {
    oo.appendChild(C);
  });
  function b(C) {
    h.insertBefore(C, g);
  }
  function y(C, w) {
    let $ = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, O = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : w.length, x = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    const I = Math.floor(($ + O) / 2), E = w.slice(0, I);
    if (C.textContent = E, $ >= O - 1)
      for (let _ = O; _ >= $; _ -= 1) {
        const M = w.slice(0, _);
        if (C.textContent = M, u() || !M)
          return _ === w.length ? {
            finished: !1,
            vNode: w
          } : {
            finished: !0,
            vNode: M
          };
      }
    return u() ? y(C, w, I, O, I) : y(C, w, $, I, x);
  }
  function S(C) {
    if (C.nodeType === Noe) {
      const $ = C.textContent || "", O = document.createTextNode($);
      return b(O), y(O, $);
    }
    return {
      finished: !1,
      vNode: null
    };
  }
  return d.some((C) => {
    const {
      finished: w,
      vNode: $
    } = S(C);
    return $ && v.push($), w;
  }), {
    content: v,
    text: oo.innerHTML,
    ellipsis: !0
  };
};
var Foe = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Loe = () => ({
  prefixCls: String,
  direction: String,
  // Form Internal use
  component: String
}), ao = Z({
  name: "ATypography",
  inheritAttrs: !1,
  props: Loe(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      prefixCls: r,
      direction: l
    } = Ie("typography", e), [a, i] = U6(r);
    return () => {
      var s;
      const c = m(m({}, e), o), {
        prefixCls: u,
        direction: d,
        component: p = "article"
      } = c, v = Foe(c, ["prefixCls", "direction", "component"]);
      return a(f(p, D(D({}, v), {}, {
        class: ee(r.value, {
          [`${r.value}-rtl`]: l.value === "rtl"
        }, o.class, i.value)
      }), {
        default: () => [(s = n.default) === null || s === void 0 ? void 0 : s.call(n)]
      }));
    };
  }
}), zoe = () => {
  const e = document.getSelection();
  if (!e.rangeCount)
    return function() {
    };
  let t = document.activeElement;
  const n = [];
  for (let o = 0; o < e.rangeCount; o++)
    n.push(e.getRangeAt(o));
  switch (t.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      t.blur();
      break;
    default:
      t = null;
      break;
  }
  return e.removeAllRanges(), function() {
    e.type === "Caret" && e.removeAllRanges(), e.rangeCount || n.forEach(function(o) {
      e.addRange(o);
    }), t && t.focus();
  };
}, Vw = {
  "text/plain": "Text",
  "text/html": "Url",
  default: "Text"
}, Hoe = "Copy to clipboard: #{key}, Enter";
function joe(e) {
  const t = (/mac os x/i.test(navigator.userAgent) ? "⌘" : "Ctrl") + "+C";
  return e.replace(/#{\s*key\s*}/g, t);
}
function Voe(e, t) {
  let n, o, r, l, a, i = !1;
  t || (t = {});
  const s = t.debug || !1;
  try {
    if (o = zoe(), r = document.createRange(), l = document.getSelection(), a = document.createElement("span"), a.textContent = e, a.style.all = "unset", a.style.position = "fixed", a.style.top = 0, a.style.clip = "rect(0, 0, 0, 0)", a.style.whiteSpace = "pre", a.style.webkitUserSelect = "text", a.style.MozUserSelect = "text", a.style.msUserSelect = "text", a.style.userSelect = "text", a.addEventListener("copy", function(u) {
      if (u.stopPropagation(), t.format)
        if (u.preventDefault(), typeof u.clipboardData > "u") {
          s && console.warn("unable to use e.clipboardData"), s && console.warn("trying IE specific stuff"), window.clipboardData.clearData();
          const d = Vw[t.format] || Vw.default;
          window.clipboardData.setData(d, e);
        } else
          u.clipboardData.clearData(), u.clipboardData.setData(t.format, e);
      t.onCopy && (u.preventDefault(), t.onCopy(u.clipboardData));
    }), document.body.appendChild(a), r.selectNodeContents(a), l.addRange(r), !document.execCommand("copy"))
      throw new Error("copy command was unsuccessful");
    i = !0;
  } catch (c) {
    s && console.error("unable to copy using execCommand: ", c), s && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(t.format || "text", e), t.onCopy && t.onCopy(window.clipboardData), i = !0;
    } catch (u) {
      s && console.error("unable to copy using clipboardData: ", u), s && console.error("falling back to prompt"), n = joe("message" in t ? t.message : Hoe), window.prompt(n, e);
    }
  } finally {
    l && (typeof l.removeRange == "function" ? l.removeRange(r) : l.removeAllRanges()), a && document.body.removeChild(a), o();
  }
  return i;
}
var Woe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M832 64H296c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h496v688c0 4.4 3.6 8 8 8h56c4.4 0 8-3.6 8-8V96c0-17.7-14.3-32-32-32zM704 192H192c-17.7 0-32 14.3-32 32v530.7c0 8.5 3.4 16.6 9.4 22.6l173.3 173.3c2.2 2.2 4.7 4 7.4 5.5v1.9h4.2c3.5 1.3 7.2 2 11 2H704c17.7 0 32-14.3 32-32V224c0-17.7-14.3-32-32-32zM350 856.2L263.9 770H350v86.2zM664 888H414V746c0-22.1-17.9-40-40-40H232V264h432v624z" } }] }, name: "copy", theme: "outlined" };
function Ww(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Koe(e, r, n[r]);
    });
  }
  return e;
}
function Koe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ty = function(t, n) {
  var o = Ww({}, t, n.attrs);
  return f(Ge, Ww({}, o, {
    icon: Woe
  }), null);
};
ty.displayName = "CopyOutlined";
ty.inheritAttrs = !1;
var Goe = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M257.7 752c2 0 4-.2 6-.5L431.9 722c2-.4 3.9-1.3 5.3-2.8l423.9-423.9a9.96 9.96 0 000-14.1L694.9 114.9c-1.9-1.9-4.4-2.9-7.1-2.9s-5.2 1-7.1 2.9L256.8 538.8c-1.5 1.5-2.4 3.3-2.8 5.3l-29.5 168.2a33.5 33.5 0 009.4 29.8c6.6 6.4 14.9 9.9 23.8 9.9zm67.4-174.4L687.8 215l73.3 73.3-362.7 362.6-88.9 15.7 15.6-89zM880 836H144c-17.7 0-32 14.3-32 32v36c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-36c0-17.7-14.3-32-32-32z" } }] }, name: "edit", theme: "outlined" };
function Kw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Xoe(e, r, n[r]);
    });
  }
  return e;
}
function Xoe(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ny = function(t, n) {
  var o = Kw({}, t, n.attrs);
  return f(Ge, Kw({}, o, {
    icon: Goe
  }), null);
};
ny.displayName = "EditOutlined";
ny.inheritAttrs = !1;
var Uoe = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Yoe = ob("webkitLineClamp"), qoe = ob("textOverflow"), Gw = "...", xc = () => ({
  editable: {
    type: [Boolean, Object],
    default: void 0
  },
  copyable: {
    type: [Boolean, Object],
    default: void 0
  },
  prefixCls: String,
  component: String,
  type: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  ellipsis: {
    type: [Boolean, Object],
    default: void 0
  },
  code: {
    type: Boolean,
    default: void 0
  },
  mark: {
    type: Boolean,
    default: void 0
  },
  underline: {
    type: Boolean,
    default: void 0
  },
  delete: {
    type: Boolean,
    default: void 0
  },
  strong: {
    type: Boolean,
    default: void 0
  },
  keyboard: {
    type: Boolean,
    default: void 0
  },
  content: String,
  "onUpdate:content": Function
}), Oc = Z({
  compatConfig: {
    MODE: 3
  },
  name: "TypographyBase",
  inheritAttrs: !1,
  props: xc(),
  // emits: ['update:content'],
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      emit: r
    } = t;
    const {
      prefixCls: l,
      direction: a
    } = Ie("typography", e), i = xt({
      copied: !1,
      ellipsisText: "",
      ellipsisContent: null,
      isEllipsis: !1,
      expanded: !1,
      clientRendered: !1,
      //locale
      expandStr: "",
      copyStr: "",
      copiedStr: "",
      editStr: "",
      copyId: void 0,
      rafId: void 0,
      prevProps: void 0,
      originContent: ""
    }), s = Y(), c = Y(), u = P(() => {
      const T = e.ellipsis;
      return T ? m({
        rows: 1,
        expandable: !1
      }, typeof T == "object" ? T : null) : {};
    });
    Ke(() => {
      i.clientRendered = !0, I();
    }), et(() => {
      clearTimeout(i.copyId), Ze.cancel(i.rafId);
    }), ie([() => u.value.rows, () => e.content], () => {
      rt(() => {
        O();
      });
    }, {
      flush: "post",
      deep: !0
    }), Le(() => {
      e.content === void 0 && (Mt(!e.editable, "Typography", "When `editable` is enabled, please use `content` instead of children"), Mt(!e.ellipsis, "Typography", "When `ellipsis` is enabled, please use `content` instead of children"));
    });
    function d() {
      var T;
      return e.ellipsis || e.editable ? e.content : (T = qn(s.value)) === null || T === void 0 ? void 0 : T.innerText;
    }
    function p(T) {
      const {
        onExpand: N
      } = u.value;
      i.expanded = !0, N == null || N(T);
    }
    function v(T) {
      T.preventDefault(), i.originContent = e.content, $(!0);
    }
    function h(T) {
      g(T), $(!1);
    }
    function g(T) {
      const {
        onChange: N
      } = S.value;
      T !== e.content && (r("update:content", T), N == null || N(T));
    }
    function b() {
      var T, N;
      (N = (T = S.value).onCancel) === null || N === void 0 || N.call(T), $(!1);
    }
    function y(T) {
      T.preventDefault(), T.stopPropagation();
      const {
        copyable: N
      } = e, k = m({}, typeof N == "object" ? N : null);
      k.text === void 0 && (k.text = d()), Voe(k.text || ""), i.copied = !0, rt(() => {
        k.onCopy && k.onCopy(T), i.copyId = setTimeout(() => {
          i.copied = !1;
        }, 3e3);
      });
    }
    const S = P(() => {
      const T = e.editable;
      return T ? m({}, typeof T == "object" ? T : null) : {
        editing: !1
      };
    }), [C, w] = Rt(!1, {
      value: P(() => S.value.editing)
    });
    function $(T) {
      const {
        onStart: N
      } = S.value;
      T && N && N(), w(T);
    }
    ie(C, (T) => {
      var N;
      T || (N = c.value) === null || N === void 0 || N.focus();
    }, {
      flush: "post"
    });
    function O(T) {
      if (T) {
        const {
          width: N,
          height: k
        } = T;
        if (!N || !k)
          return;
      }
      Ze.cancel(i.rafId), i.rafId = Ze(() => {
        I();
      });
    }
    const x = P(() => {
      const {
        rows: T,
        expandable: N,
        suffix: k,
        onEllipsis: B,
        tooltip: F
      } = u.value;
      return k || F || e.editable || e.copyable || N || B ? !1 : T === 1 ? qoe : Yoe;
    }), I = () => {
      const {
        ellipsisText: T,
        isEllipsis: N
      } = i, {
        rows: k,
        suffix: B,
        onEllipsis: F
      } = u.value;
      if (!k || k < 0 || !qn(s.value) || i.expanded || e.content === void 0 || x.value)
        return;
      const {
        content: L,
        text: j,
        ellipsis: H
      } = Boe(qn(s.value), {
        rows: k,
        suffix: B
      }, e.content, z(!0), Gw);
      (T !== j || i.isEllipsis !== H) && (i.ellipsisText = j, i.ellipsisContent = L, i.isEllipsis = H, N !== H && F && F(H));
    };
    function E(T, N) {
      let {
        mark: k,
        code: B,
        underline: F,
        delete: L,
        strong: j,
        keyboard: H
      } = T, K = N;
      function X(W, q) {
        if (!W)
          return;
        const J = /* @__PURE__ */ function() {
          return K;
        }();
        K = f(q, null, {
          default: () => [J]
        });
      }
      return X(j, "strong"), X(F, "u"), X(L, "del"), X(B, "code"), X(k, "mark"), X(H, "kbd"), K;
    }
    function _(T) {
      const {
        expandable: N,
        symbol: k
      } = u.value;
      if (!N || !T && (i.expanded || !i.isEllipsis))
        return null;
      const B = (n.ellipsisSymbol ? n.ellipsisSymbol() : k) || i.expandStr;
      return f("a", {
        key: "expand",
        class: `${l.value}-expand`,
        onClick: p,
        "aria-label": i.expandStr
      }, [B]);
    }
    function M() {
      if (!e.editable)
        return;
      const {
        tooltip: T,
        triggerType: N = ["icon"]
      } = e.editable, k = n.editableIcon ? n.editableIcon() : f(ny, {
        role: "button"
      }, null), B = n.editableTooltip ? n.editableTooltip() : i.editStr, F = typeof B == "string" ? B : "";
      return N.indexOf("icon") !== -1 ? f(Ln, {
        key: "edit",
        title: T === !1 ? "" : B
      }, {
        default: () => [f(ef, {
          ref: c,
          class: `${l.value}-edit`,
          onClick: v,
          "aria-label": F
        }, {
          default: () => [k]
        })]
      }) : null;
    }
    function R() {
      if (!e.copyable)
        return;
      const {
        tooltip: T
      } = e.copyable, N = i.copied ? i.copiedStr : i.copyStr, k = n.copyableTooltip ? n.copyableTooltip({
        copied: i.copied
      }) : N, B = typeof k == "string" ? k : "", F = i.copied ? f(Mi, null, null) : f(ty, null, null), L = n.copyableIcon ? n.copyableIcon({
        copied: !!i.copied
      }) : F;
      return f(Ln, {
        key: "copy",
        title: T === !1 ? "" : k
      }, {
        default: () => [f(ef, {
          class: [`${l.value}-copy`, {
            [`${l.value}-copy-success`]: i.copied
          }],
          onClick: y,
          "aria-label": B
        }, {
          default: () => [L]
        })]
      });
    }
    function A() {
      const {
        class: T,
        style: N
      } = o, {
        maxlength: k,
        autoSize: B,
        onEnd: F
      } = S.value;
      return f(Doe, {
        class: T,
        style: N,
        prefixCls: l.value,
        value: e.content,
        originContent: i.originContent,
        maxlength: k,
        autoSize: B,
        onSave: h,
        onChange: g,
        onCancel: b,
        onEnd: F,
        direction: a.value,
        component: e.component
      }, {
        enterIcon: n.editableEnterIcon
      });
    }
    function z(T) {
      return [_(T), M(), R()].filter((N) => N);
    }
    return () => {
      var T;
      const {
        triggerType: N = ["icon"]
      } = S.value, k = e.ellipsis || e.editable ? e.content !== void 0 ? e.content : (T = n.default) === null || T === void 0 ? void 0 : T.call(n) : n.default ? n.default() : e.content;
      return C.value ? A() : f(ma, {
        componentName: "Text",
        children: (B) => {
          const F = m(m({}, e), o), {
            type: L,
            disabled: j,
            content: H,
            class: K,
            style: X
          } = F, W = Uoe(F, ["type", "disabled", "content", "class", "style"]), {
            rows: q,
            suffix: J,
            tooltip: ne
          } = u.value, {
            edit: te,
            copy: G,
            copied: U,
            expand: re
          } = B;
          i.editStr = te, i.copyStr = G, i.copiedStr = U, i.expandStr = re;
          const se = ot(W, ["prefixCls", "editable", "copyable", "ellipsis", "mark", "code", "delete", "underline", "strong", "keyboard", "onUpdate:content"]), me = x.value, Ce = q === 1 && me, fe = q && q > 1 && me;
          let be = k, ue;
          if (q && i.isEllipsis && !i.expanded && !me) {
            const {
              title: xe
            } = W;
            let he = xe || "";
            !xe && (typeof k == "string" || typeof k == "number") && (he = String(k)), he = he == null ? void 0 : he.slice(String(i.ellipsisContent || "").length), be = f(Fe, null, [Yt(i.ellipsisContent), f("span", {
              title: he,
              "aria-hidden": "true"
            }, [Gw]), J]);
          } else
            be = f(Fe, null, [k, J]);
          be = E(e, be);
          const de = ne && q && i.isEllipsis && !i.expanded && !me, Se = n.ellipsisTooltip ? n.ellipsisTooltip() : ne;
          return f(Fo, {
            onResize: O,
            disabled: !q
          }, {
            default: () => [f(ao, D({
              ref: s,
              class: [{
                [`${l.value}-${L}`]: L,
                [`${l.value}-disabled`]: j,
                [`${l.value}-ellipsis`]: q,
                [`${l.value}-single-line`]: q === 1 && !i.isEllipsis,
                [`${l.value}-ellipsis-single-line`]: Ce,
                [`${l.value}-ellipsis-multiple-line`]: fe
              }, K],
              style: m(m({}, X), {
                WebkitLineClamp: fe ? q : void 0
              }),
              "aria-label": ue,
              direction: a.value,
              onClick: N.indexOf("text") !== -1 ? v : () => {
              }
            }, se), {
              default: () => [de ? f(Ln, {
                title: ne === !0 ? k : Se
              }, {
                default: () => [f("span", null, [be])]
              }) : be, z()]
            })]
          });
        }
      }, null);
    };
  }
});
var Zoe = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Qoe = () => ot(m(m({}, xc()), {
  ellipsis: {
    type: Boolean,
    default: void 0
  }
}), ["component"]), zi = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  const r = m(m({}, e), o), {
    ellipsis: l,
    rel: a
  } = r, i = Zoe(r, ["ellipsis", "rel"]);
  Mt(typeof l != "object", "Typography.Link", "`ellipsis` only supports boolean value.");
  const s = m(m({}, i), {
    rel: a === void 0 && i.target === "_blank" ? "noopener noreferrer" : a,
    ellipsis: !!l,
    component: "a"
  });
  return delete s.navigate, f(Oc, s, n);
};
zi.displayName = "ATypographyLink";
zi.inheritAttrs = !1;
zi.props = Qoe();
const Joe = () => ot(xc(), ["component"]), Hi = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  const r = m(m(m({}, e), {
    component: "div"
  }), o);
  return f(Oc, r, n);
};
Hi.displayName = "ATypographyParagraph";
Hi.inheritAttrs = !1;
Hi.props = Joe();
const ere = () => m(m({}, ot(xc(), ["component"])), {
  ellipsis: {
    type: [Boolean, Object],
    default: void 0
  }
}), ji = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  const {
    ellipsis: r
  } = e;
  Mt(typeof r != "object" || !r || !("expandable" in r) && !("rows" in r), "Typography.Text", "`ellipsis` do not support `expandable` or `rows` props.");
  const l = m(m(m({}, e), {
    ellipsis: r && typeof r == "object" ? ot(r, ["expandable", "rows"]) : r,
    component: "span"
  }), o);
  return f(Oc, l, n);
};
ji.displayName = "ATypographyText";
ji.inheritAttrs = !1;
ji.props = ere();
var tre = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const nre = QT(1, 2, 3, 4, 5), ore = () => m(m({}, ot(xc(), ["component", "strong"])), {
  level: Number
}), Vi = (e, t) => {
  let {
    slots: n,
    attrs: o
  } = t;
  const {
    level: r = 1
  } = e, l = tre(e, ["level"]);
  let a;
  nre.includes(r) ? a = `h${r}` : (Mt(!1, "Typography", "Title only accept `1 | 2 | 3 | 4 | 5` as `level` value."), a = "h1");
  const i = m(m(m({}, l), {
    component: a
  }), o);
  return f(Oc, i, n);
};
Vi.displayName = "ATypographyTitle";
Vi.inheritAttrs = !1;
Vi.props = ore();
ao.Text = ji;
ao.Title = Vi;
ao.Paragraph = Hi;
ao.Link = zi;
ao.Base = Oc;
ao.install = function(e) {
  return e.component(ao.name, ao), e.component(ao.Text.displayName, ji), e.component(ao.Title.displayName, Vi), e.component(ao.Paragraph.displayName, Hi), e.component(ao.Link.displayName, zi), e;
};
function rre(e, t) {
  const n = `cannot ${e.method} ${e.action} ${t.status}'`, o = new Error(n);
  return o.status = t.status, o.method = e.method, o.url = e.action, o;
}
function Xw(e) {
  const t = e.responseText || e.response;
  if (!t)
    return t;
  try {
    return JSON.parse(t);
  } catch {
    return t;
  }
}
function lre(e) {
  const t = new XMLHttpRequest();
  e.onProgress && t.upload && (t.upload.onprogress = function(l) {
    l.total > 0 && (l.percent = l.loaded / l.total * 100), e.onProgress(l);
  });
  const n = new FormData();
  e.data && Object.keys(e.data).forEach((r) => {
    const l = e.data[r];
    if (Array.isArray(l)) {
      l.forEach((a) => {
        n.append(`${r}[]`, a);
      });
      return;
    }
    n.append(r, l);
  }), e.file instanceof Blob ? n.append(e.filename, e.file, e.file.name) : n.append(e.filename, e.file), t.onerror = function(l) {
    e.onError(l);
  }, t.onload = function() {
    return t.status < 200 || t.status >= 300 ? e.onError(rre(e, t), Xw(t)) : e.onSuccess(Xw(t), t);
  }, t.open(e.method, e.action, !0), e.withCredentials && "withCredentials" in t && (t.withCredentials = !0);
  const o = e.headers || {};
  return o["X-Requested-With"] !== null && t.setRequestHeader("X-Requested-With", "XMLHttpRequest"), Object.keys(o).forEach((r) => {
    o[r] !== null && t.setRequestHeader(r, o[r]);
  }), t.send(n), {
    abort() {
      t.abort();
    }
  };
}
const are = +/* @__PURE__ */ new Date();
let ire = 0;
function Yv() {
  return `vc-upload-${are}-${++ire}`;
}
const qv = (e, t) => {
  if (e && t) {
    const n = Array.isArray(t) ? t : t.split(","), o = e.name || "", r = e.type || "", l = r.replace(/\/.*$/, "");
    return n.some((a) => {
      const i = a.trim();
      if (/^\*(\/\*)?$/.test(a))
        return !0;
      if (i.charAt(0) === ".") {
        const s = o.toLowerCase(), c = i.toLowerCase();
        let u = [c];
        return (c === ".jpg" || c === ".jpeg") && (u = [".jpg", ".jpeg"]), u.some((d) => s.endsWith(d));
      }
      return /\/\*$/.test(i) ? l === i.replace(/\/.*$/, "") : r === i ? !0 : /^\w+$/.test(i) ? (ct(!1, `Upload takes an invalidate 'accept' type '${i}'.Skip for check.`), !0) : !1;
    });
  }
  return !0;
};
function sre(e, t) {
  const n = e.createReader();
  let o = [];
  function r() {
    n.readEntries((l) => {
      const a = Array.prototype.slice.apply(l);
      o = o.concat(a), !a.length ? t(o) : r();
    });
  }
  r();
}
const cre = (e, t, n) => {
  const o = (r, l) => {
    r.path = l || "", r.isFile ? r.file((a) => {
      n(a) && (r.fullPath && !a.webkitRelativePath && (Object.defineProperties(a, {
        webkitRelativePath: {
          writable: !0
        }
      }), a.webkitRelativePath = r.fullPath.replace(/^\//, ""), Object.defineProperties(a, {
        webkitRelativePath: {
          writable: !1
        }
      })), t([a]));
    }) : r.isDirectory && sre(r, (a) => {
      a.forEach((i) => {
        o(i, `${l}${r.name}/`);
      });
    });
  };
  e.forEach((r) => {
    o(r.webkitGetAsEntry());
  });
}, q6 = () => ({
  capture: [Boolean, String],
  multipart: {
    type: Boolean,
    default: void 0
  },
  name: String,
  disabled: {
    type: Boolean,
    default: void 0
  },
  componentTag: String,
  action: [String, Function],
  method: String,
  directory: {
    type: Boolean,
    default: void 0
  },
  data: [Object, Function],
  headers: Object,
  accept: String,
  multiple: {
    type: Boolean,
    default: void 0
  },
  onBatchStart: Function,
  onReject: Function,
  onStart: Function,
  onError: Function,
  onSuccess: Function,
  onProgress: Function,
  beforeUpload: Function,
  customRequest: Function,
  withCredentials: {
    type: Boolean,
    default: void 0
  },
  openFileDialogOnClick: {
    type: Boolean,
    default: void 0
  },
  prefixCls: String,
  id: String,
  onMouseenter: Function,
  onMouseleave: Function,
  onClick: Function
});
var ure = function(e, t, n, o) {
  function r(l) {
    return l instanceof n ? l : new n(function(a) {
      a(l);
    });
  }
  return new (n || (n = Promise))(function(l, a) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (d) {
        a(d);
      }
    }
    function s(u) {
      try {
        c(o.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? l(u.value) : r(u.value).then(i, s);
    }
    c((o = o.apply(e, t || [])).next());
  });
}, dre = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const fre = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AjaxUploader",
  inheritAttrs: !1,
  props: q6(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const l = Y(Yv()), a = {}, i = Y();
    let s = !1;
    const c = (S, C) => ure(this, void 0, void 0, function* () {
      const {
        beforeUpload: w
      } = e;
      let $ = S;
      if (w) {
        try {
          $ = yield w(S, C);
        } catch {
          $ = !1;
        }
        if ($ === !1)
          return {
            origin: S,
            parsedFile: null,
            action: null,
            data: null
          };
      }
      const {
        action: O
      } = e;
      let x;
      typeof O == "function" ? x = yield O(S) : x = O;
      const {
        data: I
      } = e;
      let E;
      typeof I == "function" ? E = yield I(S) : E = I;
      const _ = (
        // string type is from legacy `transformFile`.
        // Not sure if this will work since no related test case works with it
        (typeof $ == "object" || typeof $ == "string") && $ ? $ : S
      );
      let M;
      _ instanceof File ? M = _ : M = new File([_], S.name, {
        type: S.type
      });
      const R = M;
      return R.uid = S.uid, {
        origin: S,
        data: E,
        parsedFile: R,
        action: x
      };
    }), u = (S) => {
      let {
        data: C,
        origin: w,
        action: $,
        parsedFile: O
      } = S;
      if (!s)
        return;
      const {
        onStart: x,
        customRequest: I,
        name: E,
        headers: _,
        withCredentials: M,
        method: R
      } = e, {
        uid: A
      } = w, z = I || lre, T = {
        action: $,
        filename: E,
        data: C,
        file: O,
        headers: _,
        withCredentials: M,
        method: R || "post",
        onProgress: (N) => {
          const {
            onProgress: k
          } = e;
          k == null || k(N, O);
        },
        onSuccess: (N, k) => {
          const {
            onSuccess: B
          } = e;
          B == null || B(N, O, k), delete a[A];
        },
        onError: (N, k) => {
          const {
            onError: B
          } = e;
          B == null || B(N, k, O), delete a[A];
        }
      };
      x(w), a[A] = z(T);
    }, d = () => {
      l.value = Yv();
    }, p = (S) => {
      if (S) {
        const C = S.uid ? S.uid : S;
        a[C] && a[C].abort && a[C].abort(), delete a[C];
      } else
        Object.keys(a).forEach((C) => {
          a[C] && a[C].abort && a[C].abort(), delete a[C];
        });
    };
    Ke(() => {
      s = !0;
    }), et(() => {
      s = !1, p();
    });
    const v = (S) => {
      const C = [...S], w = C.map(($) => ($.uid = Yv(), c($, C)));
      Promise.all(w).then(($) => {
        const {
          onBatchStart: O
        } = e;
        O == null || O($.map((x) => {
          let {
            origin: I,
            parsedFile: E
          } = x;
          return {
            file: I,
            parsedFile: E
          };
        })), $.filter((x) => x.parsedFile !== null).forEach((x) => {
          u(x);
        });
      });
    }, h = (S) => {
      const {
        accept: C,
        directory: w
      } = e, {
        files: $
      } = S.target, O = [...$].filter((x) => !w || qv(x, C));
      v(O), d();
    }, g = (S) => {
      const C = i.value;
      if (!C)
        return;
      const {
        onClick: w
      } = e;
      C.click(), w && w(S);
    }, b = (S) => {
      S.key === "Enter" && g(S);
    }, y = (S) => {
      const {
        multiple: C
      } = e;
      if (S.preventDefault(), S.type !== "dragover")
        if (e.directory)
          cre(Array.prototype.slice.call(S.dataTransfer.items), v, (w) => qv(w, e.accept));
        else {
          const w = FB(Array.prototype.slice.call(S.dataTransfer.files), (x) => qv(x, e.accept));
          let $ = w[0];
          const O = w[1];
          C === !1 && ($ = $.slice(0, 1)), v($), O.length && e.onReject && e.onReject(O);
        }
    };
    return r({
      abort: p
    }), () => {
      var S;
      const {
        componentTag: C,
        prefixCls: w,
        disabled: $,
        id: O,
        multiple: x,
        accept: I,
        capture: E,
        directory: _,
        openFileDialogOnClick: M,
        onMouseenter: R,
        onMouseleave: A
      } = e, z = dre(e, ["componentTag", "prefixCls", "disabled", "id", "multiple", "accept", "capture", "directory", "openFileDialogOnClick", "onMouseenter", "onMouseleave"]), T = {
        [w]: !0,
        [`${w}-disabled`]: $,
        [o.class]: !!o.class
      }, N = _ ? {
        directory: "directory",
        webkitdirectory: "webkitdirectory"
      } : {};
      return f(C, D(D({}, $ ? {} : {
        onClick: M ? g : () => {
        },
        onKeydown: M ? b : () => {
        },
        onMouseenter: R,
        onMouseleave: A,
        onDrop: y,
        onDragover: y,
        tabindex: "0"
      }), {}, {
        class: T,
        role: "button",
        style: o.style
      }), {
        default: () => [f("input", D(D(D({}, wl(z, {
          aria: !0,
          data: !0
        })), {}, {
          id: O,
          type: "file",
          ref: i,
          onClick: (B) => B.stopPropagation(),
          onCancel: (B) => B.stopPropagation(),
          key: l.value,
          style: {
            display: "none"
          },
          accept: I
        }, N), {}, {
          multiple: x,
          onChange: h
        }, E != null ? {
          capture: E
        } : {}), null), (S = n.default) === null || S === void 0 ? void 0 : S.call(n)]
      });
    };
  }
});
function Zv() {
}
const Uw = Z({
  compatConfig: {
    MODE: 3
  },
  name: "Upload",
  inheritAttrs: !1,
  props: Qe(q6(), {
    componentTag: "span",
    prefixCls: "rc-upload",
    data: {},
    headers: {},
    name: "file",
    multipart: !1,
    onStart: Zv,
    onError: Zv,
    onSuccess: Zv,
    multiple: !1,
    beforeUpload: null,
    customRequest: null,
    withCredentials: !1,
    openFileDialogOnClick: !0
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const l = Y();
    return r({
      abort: (i) => {
        var s;
        (s = l.value) === null || s === void 0 || s.abort(i);
      }
    }), () => f(fre, D(D(D({}, e), o), {}, {
      ref: l
    }), n);
  }
});
var pre = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M779.3 196.6c-94.2-94.2-247.6-94.2-341.7 0l-261 260.8c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l261-260.8c32.4-32.4 75.5-50.2 121.3-50.2s88.9 17.8 121.2 50.2c32.4 32.4 50.2 75.5 50.2 121.2 0 45.8-17.8 88.8-50.2 121.2l-266 265.9-43.1 43.1c-40.3 40.3-105.8 40.3-146.1 0-19.5-19.5-30.2-45.4-30.2-73s10.7-53.5 30.2-73l263.9-263.8c6.7-6.6 15.5-10.3 24.9-10.3h.1c9.4 0 18.1 3.7 24.7 10.3 6.7 6.7 10.3 15.5 10.3 24.9 0 9.3-3.7 18.1-10.3 24.7L372.4 653c-1.7 1.7-2.6 4-2.6 6.4s.9 4.7 2.6 6.4l36.9 36.9a9 9 0 0012.7 0l215.6-215.6c19.9-19.9 30.8-46.3 30.8-74.4s-11-54.6-30.8-74.4c-41.1-41.1-107.9-41-149 0L463 364 224.8 602.1A172.22 172.22 0 00174 724.8c0 46.3 18.1 89.8 50.8 122.5 33.9 33.8 78.3 50.7 122.7 50.7 44.4 0 88.8-16.9 122.6-50.7l309.2-309C824.8 492.7 850 432 850 367.5c.1-64.6-25.1-125.3-70.7-170.9z" } }] }, name: "paper-clip", theme: "outlined" };
function Yw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      vre(e, r, n[r]);
    });
  }
  return e;
}
function vre(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var oy = function(t, n) {
  var o = Yw({}, t, n.attrs);
  return f(Ge, Yw({}, o, {
    icon: pre
  }), null);
};
oy.displayName = "PaperClipOutlined";
oy.inheritAttrs = !1;
var gre = { icon: function(t, n) {
  return { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M928 160H96c-17.7 0-32 14.3-32 32v640c0 17.7 14.3 32 32 32h832c17.7 0 32-14.3 32-32V192c0-17.7-14.3-32-32-32zm-40 632H136v-39.9l138.5-164.3 150.1 178L658.1 489 888 761.6V792zm0-129.8L664.2 396.8c-3.2-3.8-9-3.8-12.2 0L424.6 666.4l-144-170.7c-3.2-3.8-9-3.8-12.2 0L136 652.7V232h752v430.2z", fill: t } }, { tag: "path", attrs: { d: "M424.6 765.8l-150.1-178L136 752.1V792h752v-30.4L658.1 489z", fill: n } }, { tag: "path", attrs: { d: "M136 652.7l132.4-157c3.2-3.8 9-3.8 12.2 0l144 170.7L652 396.8c3.2-3.8 9-3.8 12.2 0L888 662.2V232H136v420.7zM304 280a88 88 0 110 176 88 88 0 010-176z", fill: n } }, { tag: "path", attrs: { d: "M276 368a28 28 0 1056 0 28 28 0 10-56 0z", fill: n } }, { tag: "path", attrs: { d: "M304 456a88 88 0 100-176 88 88 0 000 176zm0-116c15.5 0 28 12.5 28 28s-12.5 28-28 28-28-12.5-28-28 12.5-28 28-28z", fill: t } }] };
}, name: "picture", theme: "twotone" };
function qw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      mre(e, r, n[r]);
    });
  }
  return e;
}
function mre(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ry = function(t, n) {
  var o = qw({}, t, n.attrs);
  return f(Ge, qw({}, o, {
    icon: gre
  }), null);
};
ry.displayName = "PictureTwoTone";
ry.inheritAttrs = !1;
var hre = { icon: function(t, n) {
  return { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M534 352V136H232v752h560V394H576a42 42 0 01-42-42z", fill: n } }, { tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM602 137.8L790.2 326H602V137.8zM792 888H232V136h302v216a42 42 0 0042 42h216v494z", fill: t } }] };
}, name: "file", theme: "twotone" };
function Zw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      bre(e, r, n[r]);
    });
  }
  return e;
}
function bre(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ly = function(t, n) {
  var o = Zw({}, t, n.attrs);
  return f(Ge, Zw({}, o, {
    icon: hre
  }), null);
};
ly.displayName = "FileTwoTone";
ly.inheritAttrs = !1;
function Z6() {
  return {
    capture: je([Boolean, String]),
    type: ke(),
    name: String,
    defaultFileList: vt(),
    fileList: vt(),
    action: je([String, Function]),
    directory: ve(),
    data: je([Object, Function]),
    method: ke(),
    headers: Re(),
    showUploadList: je([Boolean, Object]),
    multiple: ve(),
    accept: String,
    beforeUpload: le(),
    onChange: le(),
    "onUpdate:fileList": le(),
    onDrop: le(),
    listType: ke(),
    onPreview: le(),
    onDownload: le(),
    onReject: le(),
    onRemove: le(),
    /** @deprecated Please use `onRemove` directly */
    remove: le(),
    supportServerRender: ve(),
    disabled: ve(),
    prefixCls: String,
    customRequest: le(),
    withCredentials: ve(),
    openFileDialogOnClick: ve(),
    locale: Re(),
    id: String,
    previewFile: le(),
    /** @deprecated Please use `beforeUpload` directly */
    transformFile: le(),
    iconRender: le(),
    isImageUrl: le(),
    progress: Re(),
    itemRender: le(),
    /** Config max count of `fileList`. Will replace current one when `maxCount` is 1 */
    maxCount: Number,
    height: je([Number, String]),
    removeIcon: le(),
    downloadIcon: le(),
    previewIcon: le()
  };
}
function yre() {
  return {
    listType: ke(),
    onPreview: le(),
    onDownload: le(),
    onRemove: le(),
    items: vt(),
    progress: Re(),
    prefixCls: ke(),
    showRemoveIcon: ve(),
    showDownloadIcon: ve(),
    showPreviewIcon: ve(),
    removeIcon: le(),
    downloadIcon: le(),
    previewIcon: le(),
    locale: Re(void 0),
    previewFile: le(),
    iconRender: le(),
    isImageUrl: le(),
    appendAction: le(),
    appendActionVisible: ve(),
    itemRender: le()
  };
}
function au(e) {
  return m(m({}, e), {
    lastModified: e.lastModified,
    lastModifiedDate: e.lastModifiedDate,
    name: e.name,
    size: e.size,
    type: e.type,
    uid: e.uid,
    percent: 0,
    originFileObj: e
  });
}
function iu(e, t) {
  const n = [...t], o = n.findIndex((r) => {
    let {
      uid: l
    } = r;
    return l === e.uid;
  });
  return o === -1 ? n.push(e) : n[o] = e, n;
}
function Qv(e, t) {
  const n = e.uid !== void 0 ? "uid" : "name";
  return t.filter((o) => o[n] === e[n])[0];
}
function Sre(e, t) {
  const n = e.uid !== void 0 ? "uid" : "name", o = t.filter((r) => r[n] !== e[n]);
  return o.length === t.length ? null : o;
}
const Cre = function() {
  const t = (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "").split("/"), o = t[t.length - 1].split(/#|\?/)[0];
  return (/\.[^./\\]*$/.exec(o) || [""])[0];
}, Q6 = (e) => e.indexOf("image/") === 0, $re = (e) => {
  if (e.type && !e.thumbUrl)
    return Q6(e.type);
  const t = e.thumbUrl || e.url || "", n = Cre(t);
  return /^data:image\//.test(t) || /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i.test(n) ? !0 : !(/^data:/.test(t) || n);
}, ll = 200;
function wre(e) {
  return new Promise((t) => {
    if (!e.type || !Q6(e.type)) {
      t("");
      return;
    }
    const n = document.createElement("canvas");
    n.width = ll, n.height = ll, n.style.cssText = `position: fixed; left: 0; top: 0; width: ${ll}px; height: ${ll}px; z-index: 9999; display: none;`, document.body.appendChild(n);
    const o = n.getContext("2d"), r = new Image();
    if (r.onload = () => {
      const {
        width: l,
        height: a
      } = r;
      let i = ll, s = ll, c = 0, u = 0;
      l > a ? (s = a * (ll / l), u = -(s - i) / 2) : (i = l * (ll / a), c = -(i - s) / 2), o.drawImage(r, c, u, i, s);
      const d = n.toDataURL();
      document.body.removeChild(n), t(d);
    }, r.crossOrigin = "anonymous", e.type.startsWith("image/svg+xml")) {
      const l = new FileReader();
      l.addEventListener("load", () => {
        l.result && (r.src = l.result);
      }), l.readAsDataURL(e);
    } else
      r.src = window.URL.createObjectURL(e);
  });
}
var xre = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M505.7 661a8 8 0 0012.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" } }] }, name: "download", theme: "outlined" };
function Qw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Ore(e, r, n[r]);
    });
  }
  return e;
}
function Ore(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var ay = function(t, n) {
  var o = Qw({}, t, n.attrs);
  return f(Ge, Qw({}, o, {
    icon: xre
  }), null);
};
ay.displayName = "DownloadOutlined";
ay.inheritAttrs = !1;
const Pre = () => ({
  prefixCls: String,
  locale: Re(void 0),
  file: Re(),
  items: vt(),
  listType: ke(),
  isImgUrl: le(),
  showRemoveIcon: ve(),
  showDownloadIcon: ve(),
  showPreviewIcon: ve(),
  removeIcon: le(),
  downloadIcon: le(),
  previewIcon: le(),
  iconRender: le(),
  actionIconRender: le(),
  itemRender: le(),
  onPreview: le(),
  onClose: le(),
  onDownload: le(),
  progress: Re()
}), Ire = Z({
  compatConfig: {
    MODE: 3
  },
  name: "ListItem",
  inheritAttrs: !1,
  props: Pre(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    var r;
    const l = Q(!1), a = Q();
    Ke(() => {
      a.value = setTimeout(() => {
        l.value = !0;
      }, 300);
    }), et(() => {
      clearTimeout(a.value);
    });
    const i = Q((r = e.file) === null || r === void 0 ? void 0 : r.status);
    ie(() => {
      var u;
      return (u = e.file) === null || u === void 0 ? void 0 : u.status;
    }, (u) => {
      u !== "removed" && (i.value = u);
    });
    const {
      rootPrefixCls: s
    } = Ie("upload", e), c = P(() => Ho(`${s.value}-fade`));
    return () => {
      var u, d;
      const {
        prefixCls: p,
        locale: v,
        listType: h,
        file: g,
        items: b,
        progress: y,
        iconRender: S = n.iconRender,
        actionIconRender: C = n.actionIconRender,
        itemRender: w = n.itemRender,
        isImgUrl: $,
        showPreviewIcon: O,
        showRemoveIcon: x,
        showDownloadIcon: I,
        previewIcon: E = n.previewIcon,
        removeIcon: _ = n.removeIcon,
        downloadIcon: M = n.downloadIcon,
        onPreview: R,
        onDownload: A,
        onClose: z
      } = e, {
        class: T,
        style: N
      } = o, k = S({
        file: g
      });
      let B = f("div", {
        class: `${p}-text-icon`
      }, [k]);
      if (h === "picture" || h === "picture-card")
        if (i.value === "uploading" || !g.thumbUrl && !g.url) {
          const se = {
            [`${p}-list-item-thumbnail`]: !0,
            [`${p}-list-item-file`]: i.value !== "uploading"
          };
          B = f("div", {
            class: se
          }, [k]);
        } else {
          const se = $ != null && $(g) ? f("img", {
            src: g.thumbUrl || g.url,
            alt: g.name,
            class: `${p}-list-item-image`,
            crossorigin: g.crossOrigin
          }, null) : k, me = {
            [`${p}-list-item-thumbnail`]: !0,
            [`${p}-list-item-file`]: $ && !$(g)
          };
          B = f("a", {
            class: me,
            onClick: (Ce) => R(g, Ce),
            href: g.url || g.thumbUrl,
            target: "_blank",
            rel: "noopener noreferrer"
          }, [se]);
        }
      const F = {
        [`${p}-list-item`]: !0,
        [`${p}-list-item-${i.value}`]: !0
      }, L = typeof g.linkProps == "string" ? JSON.parse(g.linkProps) : g.linkProps, j = x ? C({
        customIcon: _ ? _({
          file: g
        }) : f(_p, null, null),
        callback: () => z(g),
        prefixCls: p,
        title: v.removeFile
      }) : null, H = I && i.value === "done" ? C({
        customIcon: M ? M({
          file: g
        }) : f(ay, null, null),
        callback: () => A(g),
        prefixCls: p,
        title: v.downloadFile
      }) : null, K = h !== "picture-card" && f("span", {
        key: "download-delete",
        class: [`${p}-list-item-actions`, {
          picture: h === "picture"
        }]
      }, [H, j]), X = `${p}-list-item-name`, W = g.url ? [f("a", D(D({
        key: "view",
        target: "_blank",
        rel: "noopener noreferrer",
        class: X,
        title: g.name
      }, L), {}, {
        href: g.url,
        onClick: (se) => R(g, se)
      }), [g.name]), K] : [f("span", {
        key: "view",
        class: X,
        onClick: (se) => R(g, se),
        title: g.name
      }, [g.name]), K], q = {
        pointerEvents: "none",
        opacity: 0.5
      }, J = O ? f("a", {
        href: g.url || g.thumbUrl,
        target: "_blank",
        rel: "noopener noreferrer",
        style: g.url || g.thumbUrl ? void 0 : q,
        onClick: (se) => R(g, se),
        title: v.previewFile
      }, [E ? E({
        file: g
      }) : f(Sc, null, null)]) : null, ne = h === "picture-card" && i.value !== "uploading" && f("span", {
        class: `${p}-list-item-actions`
      }, [J, i.value === "done" && H, j]), te = f("div", {
        class: F
      }, [B, W, ne, l.value && f(yn, c.value, {
        default: () => [Tn(f("div", {
          class: `${p}-list-item-progress`
        }, ["percent" in g ? f(Nb, D(D({}, y), {}, {
          type: "line",
          percent: g.percent
        }), null) : null]), [[Hn, i.value === "uploading"]])]
      })]), G = {
        [`${p}-list-item-container`]: !0,
        [`${T}`]: !!T
      }, U = g.response && typeof g.response == "string" ? g.response : ((u = g.error) === null || u === void 0 ? void 0 : u.statusText) || ((d = g.error) === null || d === void 0 ? void 0 : d.message) || v.uploadError, re = i.value === "error" ? f(Ln, {
        title: U,
        getPopupContainer: (se) => se.parentNode
      }, {
        default: () => [te]
      }) : te;
      return f("div", {
        class: G,
        style: N
      }, [w ? w({
        originNode: re,
        file: g,
        fileList: b,
        actions: {
          download: A.bind(null, g),
          preview: R.bind(null, g),
          remove: z.bind(null, g)
        }
      }) : re]);
    };
  }
}), Ere = (e, t) => {
  let {
    slots: n
  } = t;
  var o;
  return Lt((o = n.default) === null || o === void 0 ? void 0 : o.call(n))[0];
}, Tre = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadList",
  props: Qe(yre(), {
    listType: "text",
    progress: {
      strokeWidth: 2,
      showInfo: !1
    },
    showRemoveIcon: !0,
    showDownloadIcon: !1,
    showPreviewIcon: !0,
    previewFile: wre,
    isImageUrl: $re,
    items: [],
    appendActionVisible: !0
  }),
  setup(e, t) {
    let {
      slots: n,
      expose: o
    } = t;
    const r = Q(!1);
    Ke(() => {
      r.value == !0;
    });
    const l = Q([]);
    ie(() => e.items, function() {
      let g = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      l.value = g.slice();
    }, {
      immediate: !0,
      deep: !0
    }), Le(() => {
      if (e.listType !== "picture" && e.listType !== "picture-card")
        return;
      let g = !1;
      (e.items || []).forEach((b, y) => {
        typeof document > "u" || typeof window > "u" || !window.FileReader || !window.File || !(b.originFileObj instanceof File || b.originFileObj instanceof Blob) || b.thumbUrl !== void 0 || (b.thumbUrl = "", e.previewFile && e.previewFile(b.originFileObj).then((S) => {
          const C = S || "";
          C !== b.thumbUrl && (l.value[y].thumbUrl = C, g = !0);
        }));
      }), g && Rx(l);
    });
    const a = (g, b) => {
      if (e.onPreview)
        return b == null || b.preventDefault(), e.onPreview(g);
    }, i = (g) => {
      typeof e.onDownload == "function" ? e.onDownload(g) : g.url && window.open(g.url);
    }, s = (g) => {
      var b;
      (b = e.onRemove) === null || b === void 0 || b.call(e, g);
    }, c = (g) => {
      let {
        file: b
      } = g;
      const y = e.iconRender || n.iconRender;
      if (y)
        return y({
          file: b,
          listType: e.listType
        });
      const S = b.status === "uploading", C = e.isImageUrl && e.isImageUrl(b) ? f(ry, null, null) : f(ly, null, null);
      let w = S ? f(Qn, null, null) : f(oy, null, null);
      return e.listType === "picture" ? w = S ? f(Qn, null, null) : C : e.listType === "picture-card" && (w = S ? e.locale.uploading : C), w;
    }, u = (g) => {
      const {
        customIcon: b,
        callback: y,
        prefixCls: S,
        title: C
      } = g, w = {
        type: "text",
        size: "small",
        title: C,
        onClick: () => {
          y();
        },
        class: `${S}-list-item-action`
      };
      return Gt(b) ? f(Kt, w, {
        icon: () => b
      }) : f(Kt, w, {
        default: () => [f("span", null, [b])]
      });
    };
    o({
      handlePreview: a,
      handleDownload: i
    });
    const {
      prefixCls: d,
      rootPrefixCls: p
    } = Ie("upload", e), v = P(() => ({
      [`${d.value}-list`]: !0,
      [`${d.value}-list-${e.listType}`]: !0
    })), h = P(() => {
      const g = m({}, dc(`${p.value}-motion-collapse`));
      delete g.onAfterAppear, delete g.onAfterEnter, delete g.onAfterLeave;
      const b = m(m({}, Nf(`${d.value}-${e.listType === "picture-card" ? "animate-inline" : "animate"}`)), {
        class: v.value,
        appear: r.value
      });
      return e.listType !== "picture-card" ? m(m({}, g), b) : b;
    });
    return () => {
      const {
        listType: g,
        locale: b,
        isImageUrl: y,
        showPreviewIcon: S,
        showRemoveIcon: C,
        showDownloadIcon: w,
        removeIcon: $,
        previewIcon: O,
        downloadIcon: x,
        progress: I,
        appendAction: E,
        itemRender: _,
        appendActionVisible: M
      } = e, R = E == null ? void 0 : E(), A = l.value;
      return f(gf, D(D({}, h.value), {}, {
        tag: "div"
      }), {
        default: () => [A.map((z) => {
          const {
            uid: T
          } = z;
          return f(Ire, {
            key: T,
            locale: b,
            prefixCls: d.value,
            file: z,
            items: A,
            progress: I,
            listType: g,
            isImgUrl: y,
            showPreviewIcon: S,
            showRemoveIcon: C,
            showDownloadIcon: w,
            onPreview: a,
            onDownload: i,
            onClose: s,
            removeIcon: $,
            previewIcon: O,
            downloadIcon: x,
            itemRender: _
          }, m(m({}, n), {
            iconRender: c,
            actionIconRender: u
          }));
        }), E ? Tn(f(Ere, {
          key: "__ant_upload_appendAction"
        }, {
          default: () => R
        }), [[Hn, !!M]]) : null]
      });
    };
  }
}), Mre = (e) => {
  const {
    componentCls: t,
    iconCls: n
  } = e;
  return {
    [`${t}-wrapper`]: {
      [`${t}-drag`]: {
        position: "relative",
        width: "100%",
        height: "100%",
        textAlign: "center",
        background: e.colorFillAlter,
        border: `${e.lineWidth}px dashed ${e.colorBorder}`,
        borderRadius: e.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${e.motionDurationSlow}`,
        [t]: {
          padding: `${e.padding}px 0`
        },
        [`${t}-btn`]: {
          display: "table",
          width: "100%",
          height: "100%",
          outline: "none"
        },
        [`${t}-drag-container`]: {
          display: "table-cell",
          verticalAlign: "middle"
        },
        [`&:not(${t}-disabled):hover`]: {
          borderColor: e.colorPrimaryHover
        },
        [`p${t}-drag-icon`]: {
          marginBottom: e.margin,
          [n]: {
            color: e.colorPrimary,
            fontSize: e.uploadThumbnailSize
          }
        },
        [`p${t}-text`]: {
          margin: `0 0 ${e.marginXXS}px`,
          color: e.colorTextHeading,
          fontSize: e.fontSizeLG
        },
        [`p${t}-hint`]: {
          color: e.colorTextDescription,
          fontSize: e.fontSize
        },
        // ===================== Disabled =====================
        [`&${t}-disabled`]: {
          cursor: "not-allowed",
          [`p${t}-drag-icon ${n},
            p${t}-text,
            p${t}-hint
          `]: {
            color: e.colorTextDisabled
          }
        }
      }
    }
  };
}, _re = (e) => {
  const {
    componentCls: t,
    antCls: n,
    iconCls: o,
    fontSize: r,
    lineHeight: l
  } = e, a = `${t}-list-item`, i = `${a}-actions`, s = `${a}-action`, c = Math.round(r * l);
  return {
    [`${t}-wrapper`]: {
      [`${t}-list`]: m(m({}, nr()), {
        lineHeight: e.lineHeight,
        [a]: {
          position: "relative",
          height: e.lineHeight * r,
          marginTop: e.marginXS,
          fontSize: r,
          display: "flex",
          alignItems: "center",
          transition: `background-color ${e.motionDurationSlow}`,
          "&:hover": {
            backgroundColor: e.controlItemBgHover
          },
          [`${a}-name`]: m(m({}, tn), {
            padding: `0 ${e.paddingXS}px`,
            lineHeight: l,
            flex: "auto",
            transition: `all ${e.motionDurationSlow}`
          }),
          [i]: {
            [s]: {
              opacity: 0
            },
            [`${s}${n}-btn-sm`]: {
              height: c,
              border: 0,
              lineHeight: 1,
              // FIXME: should not override small button
              "> span": {
                transform: "scale(1)"
              }
            },
            [`
              ${s}:focus,
              &.picture ${s}
            `]: {
              opacity: 1
            },
            [o]: {
              color: e.colorTextDescription,
              transition: `all ${e.motionDurationSlow}`
            },
            [`&:hover ${o}`]: {
              color: e.colorText
            }
          },
          [`${t}-icon ${o}`]: {
            color: e.colorTextDescription,
            fontSize: r
          },
          [`${a}-progress`]: {
            position: "absolute",
            bottom: -e.uploadProgressOffset,
            width: "100%",
            paddingInlineStart: r + e.paddingXS,
            fontSize: r,
            lineHeight: 0,
            pointerEvents: "none",
            "> div": {
              margin: 0
            }
          }
        },
        [`${a}:hover ${s}`]: {
          opacity: 1,
          color: e.colorText
        },
        [`${a}-error`]: {
          color: e.colorError,
          [`${a}-name, ${t}-icon ${o}`]: {
            color: e.colorError
          },
          [i]: {
            [`${o}, ${o}:hover`]: {
              color: e.colorError
            },
            [s]: {
              opacity: 1
            }
          }
        },
        [`${t}-list-item-container`]: {
          transition: `opacity ${e.motionDurationSlow}, height ${e.motionDurationSlow}`,
          // For smooth removing animation
          "&::before": {
            display: "table",
            width: 0,
            height: 0,
            content: '""'
          }
        }
      })
    }
  };
}, Jw = new lt("uploadAnimateInlineIn", {
  from: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
}), ex = new lt("uploadAnimateInlineOut", {
  to: {
    width: 0,
    height: 0,
    margin: 0,
    padding: 0,
    opacity: 0
  }
}), Are = (e) => {
  const {
    componentCls: t
  } = e, n = `${t}-animate-inline`;
  return [{
    [`${t}-wrapper`]: {
      [`${n}-appear, ${n}-enter, ${n}-leave`]: {
        animationDuration: e.motionDurationSlow,
        animationTimingFunction: e.motionEaseInOutCirc,
        animationFillMode: "forwards"
      },
      [`${n}-appear, ${n}-enter`]: {
        animationName: Jw
      },
      [`${n}-leave`]: {
        animationName: ex
      }
    }
  }, Jw, ex];
}, Dre = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    uploadThumbnailSize: o,
    uploadProgressOffset: r
  } = e, l = `${t}-list`, a = `${l}-item`;
  return {
    [`${t}-wrapper`]: {
      // ${listCls} 增加优先级
      [`${l}${l}-picture, ${l}${l}-picture-card`]: {
        [a]: {
          position: "relative",
          height: o + e.lineWidth * 2 + e.paddingXS * 2,
          padding: e.paddingXS,
          border: `${e.lineWidth}px ${e.lineType} ${e.colorBorder}`,
          borderRadius: e.borderRadiusLG,
          "&:hover": {
            background: "transparent"
          },
          [`${a}-thumbnail`]: m(m({}, tn), {
            width: o,
            height: o,
            lineHeight: `${o + e.paddingSM}px`,
            textAlign: "center",
            flex: "none",
            [n]: {
              fontSize: e.fontSizeHeading2,
              color: e.colorPrimary
            },
            img: {
              display: "block",
              width: "100%",
              height: "100%",
              overflow: "hidden"
            }
          }),
          [`${a}-progress`]: {
            bottom: r,
            width: `calc(100% - ${e.paddingSM * 2}px)`,
            marginTop: 0,
            paddingInlineStart: o + e.paddingXS
          }
        },
        [`${a}-error`]: {
          borderColor: e.colorError,
          // Adjust the color of the error icon : https://github.com/ant-design/ant-design/pull/24160
          [`${a}-thumbnail ${n}`]: {
            "svg path[fill='#e6f7ff']": {
              fill: e.colorErrorBg
            },
            "svg path[fill='#1890ff']": {
              fill: e.colorError
            }
          }
        },
        [`${a}-uploading`]: {
          borderStyle: "dashed",
          [`${a}-name`]: {
            marginBottom: r
          }
        }
      }
    }
  };
}, Nre = (e) => {
  const {
    componentCls: t,
    iconCls: n,
    fontSizeLG: o,
    colorTextLightSolid: r
  } = e, l = `${t}-list`, a = `${l}-item`, i = e.uploadPicCardSize;
  return {
    [`${t}-wrapper${t}-picture-card-wrapper`]: m(m({}, nr()), {
      display: "inline-block",
      width: "100%",
      [`${t}${t}-select`]: {
        width: i,
        height: i,
        marginInlineEnd: e.marginXS,
        marginBottom: e.marginXS,
        textAlign: "center",
        verticalAlign: "top",
        backgroundColor: e.colorFillAlter,
        border: `${e.lineWidth}px dashed ${e.colorBorder}`,
        borderRadius: e.borderRadiusLG,
        cursor: "pointer",
        transition: `border-color ${e.motionDurationSlow}`,
        [`> ${t}`]: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          height: "100%",
          textAlign: "center"
        },
        [`&:not(${t}-disabled):hover`]: {
          borderColor: e.colorPrimary
        }
      },
      // list
      [`${l}${l}-picture-card`]: {
        [`${l}-item-container`]: {
          display: "inline-block",
          width: i,
          height: i,
          marginBlock: `0 ${e.marginXS}px`,
          marginInline: `0 ${e.marginXS}px`,
          verticalAlign: "top"
        },
        "&::after": {
          display: "none"
        },
        [a]: {
          height: "100%",
          margin: 0,
          "&::before": {
            position: "absolute",
            zIndex: 1,
            width: `calc(100% - ${e.paddingXS * 2}px)`,
            height: `calc(100% - ${e.paddingXS * 2}px)`,
            backgroundColor: e.colorBgMask,
            opacity: 0,
            transition: `all ${e.motionDurationSlow}`,
            content: '" "'
          }
        },
        [`${a}:hover`]: {
          [`&::before, ${a}-actions`]: {
            opacity: 1
          }
        },
        [`${a}-actions`]: {
          position: "absolute",
          insetInlineStart: 0,
          zIndex: 10,
          width: "100%",
          whiteSpace: "nowrap",
          textAlign: "center",
          opacity: 0,
          transition: `all ${e.motionDurationSlow}`,
          [`${n}-eye, ${n}-download, ${n}-delete`]: {
            zIndex: 10,
            width: o,
            margin: `0 ${e.marginXXS}px`,
            fontSize: o,
            cursor: "pointer",
            transition: `all ${e.motionDurationSlow}`
          }
        },
        [`${a}-actions, ${a}-actions:hover`]: {
          [`${n}-eye, ${n}-download, ${n}-delete`]: {
            color: new Ct(r).setAlpha(0.65).toRgbString(),
            "&:hover": {
              color: r
            }
          }
        },
        [`${a}-thumbnail, ${a}-thumbnail img`]: {
          position: "static",
          display: "block",
          width: "100%",
          height: "100%",
          objectFit: "contain"
        },
        [`${a}-name`]: {
          display: "none",
          textAlign: "center"
        },
        [`${a}-file + ${a}-name`]: {
          position: "absolute",
          bottom: e.margin,
          display: "block",
          width: `calc(100% - ${e.paddingXS * 2}px)`
        },
        [`${a}-uploading`]: {
          [`&${a}`]: {
            backgroundColor: e.colorFillAlter
          },
          [`&::before, ${n}-eye, ${n}-download, ${n}-delete`]: {
            display: "none"
          }
        },
        [`${a}-progress`]: {
          bottom: e.marginXL,
          width: `calc(100% - ${e.paddingXS * 2}px)`,
          paddingInlineStart: 0
        }
      }
    })
  };
}, Rre = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [`${t}-rtl`]: {
      direction: "rtl"
    }
  };
}, kre = (e) => {
  const {
    componentCls: t,
    colorTextDisabled: n
  } = e;
  return {
    [`${t}-wrapper`]: m(m({}, qe(e)), {
      [t]: {
        outline: 0,
        "input[type='file']": {
          cursor: "pointer"
        }
      },
      [`${t}-select`]: {
        display: "inline-block"
      },
      [`${t}-disabled`]: {
        color: n,
        cursor: "not-allowed"
      }
    })
  };
}, Bre = Xe("Upload", (e) => {
  const {
    fontSizeHeading3: t,
    fontSize: n,
    lineHeight: o,
    lineWidth: r,
    controlHeightLG: l
  } = e, a = Math.round(n * o), i = He(e, {
    uploadThumbnailSize: t * 2,
    uploadProgressOffset: a / 2 + r,
    uploadPicCardSize: l * 2.55
  });
  return [kre(i), Mre(i), Dre(i), Nre(i), _re(i), Are(i), Rre(i), cc(i)];
});
var Fre = function(e, t, n, o) {
  function r(l) {
    return l instanceof n ? l : new n(function(a) {
      a(l);
    });
  }
  return new (n || (n = Promise))(function(l, a) {
    function i(u) {
      try {
        c(o.next(u));
      } catch (d) {
        a(d);
      }
    }
    function s(u) {
      try {
        c(o.throw(u));
      } catch (d) {
        a(d);
      }
    }
    function c(u) {
      u.done ? l(u.value) : r(u.value).then(i, s);
    }
    c((o = o.apply(e, t || [])).next());
  });
}, Lre = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const ls = `__LIST_IGNORE_${Date.now()}__`, Yu = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AUpload",
  inheritAttrs: !1,
  props: Qe(Z6(), {
    type: "select",
    multiple: !1,
    action: "",
    data: {},
    accept: "",
    showUploadList: !0,
    listType: "text",
    supportServerRender: !0
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o,
      expose: r
    } = t;
    const l = sn(), {
      prefixCls: a,
      direction: i,
      disabled: s
    } = Ie("upload", e), [c, u] = Bre(a), d = so(), p = P(() => {
      var M;
      return (M = s.value) !== null && M !== void 0 ? M : d.value;
    }), [v, h] = Rt(e.defaultFileList || [], {
      value: Te(e, "fileList"),
      postState: (M) => {
        const R = Date.now();
        return (M ?? []).map((A, z) => (!A.uid && !Object.isFrozen(A) && (A.uid = `__AUTO__${R}_${z}__`), A));
      }
    }), g = Y("drop"), b = Y(null);
    Ke(() => {
      nt(e.fileList !== void 0 || o.value === void 0, "Upload", "`value` is not a valid prop, do you mean `fileList`?"), nt(e.transformFile === void 0, "Upload", "`transformFile` is deprecated. Please use `beforeUpload` directly."), nt(e.remove === void 0, "Upload", "`remove` props is deprecated. Please use `remove` event.");
    });
    const y = (M, R, A) => {
      var z, T;
      let N = [...R];
      e.maxCount === 1 ? N = N.slice(-1) : e.maxCount && (N = N.slice(0, e.maxCount)), h(N);
      const k = {
        file: M,
        fileList: N
      };
      A && (k.event = A), (z = e["onUpdate:fileList"]) === null || z === void 0 || z.call(e, k.fileList), (T = e.onChange) === null || T === void 0 || T.call(e, k), l.onFieldChange();
    }, S = (M, R) => Fre(this, void 0, void 0, function* () {
      const {
        beforeUpload: A,
        transformFile: z
      } = e;
      let T = M;
      if (A) {
        const N = yield A(M, R);
        if (N === !1)
          return !1;
        if (delete M[ls], N === ls)
          return Object.defineProperty(M, ls, {
            value: !0,
            configurable: !0
          }), !1;
        typeof N == "object" && N && (T = N);
      }
      return z && (T = yield z(T)), T;
    }), C = (M) => {
      const R = M.filter((T) => !T.file[ls]);
      if (!R.length)
        return;
      const A = R.map((T) => au(T.file));
      let z = [...v.value];
      A.forEach((T) => {
        z = iu(T, z);
      }), A.forEach((T, N) => {
        let k = T;
        if (R[N].parsedFile)
          T.status = "uploading";
        else {
          const {
            originFileObj: B
          } = T;
          let F;
          try {
            F = new File([B], B.name, {
              type: B.type
            });
          } catch {
            F = new Blob([B], {
              type: B.type
            }), F.name = B.name, F.lastModifiedDate = /* @__PURE__ */ new Date(), F.lastModified = (/* @__PURE__ */ new Date()).getTime();
          }
          F.uid = T.uid, k = F;
        }
        y(k, z);
      });
    }, w = (M, R, A) => {
      try {
        typeof M == "string" && (M = JSON.parse(M));
      } catch {
      }
      if (!Qv(R, v.value))
        return;
      const z = au(R);
      z.status = "done", z.percent = 100, z.response = M, z.xhr = A;
      const T = iu(z, v.value);
      y(z, T);
    }, $ = (M, R) => {
      if (!Qv(R, v.value))
        return;
      const A = au(R);
      A.status = "uploading", A.percent = M.percent;
      const z = iu(A, v.value);
      y(A, z, M);
    }, O = (M, R, A) => {
      if (!Qv(A, v.value))
        return;
      const z = au(A);
      z.error = M, z.response = R, z.status = "error";
      const T = iu(z, v.value);
      y(z, T);
    }, x = (M) => {
      let R;
      const A = e.onRemove || e.remove;
      Promise.resolve(typeof A == "function" ? A(M) : A).then((z) => {
        var T, N;
        if (z === !1)
          return;
        const k = Sre(M, v.value);
        k && (R = m(m({}, M), {
          status: "removed"
        }), (T = v.value) === null || T === void 0 || T.forEach((B) => {
          const F = R.uid !== void 0 ? "uid" : "name";
          B[F] === R[F] && !Object.isFrozen(B) && (B.status = "removed");
        }), (N = b.value) === null || N === void 0 || N.abort(R), y(R, k));
      });
    }, I = (M) => {
      var R;
      g.value = M.type, M.type === "drop" && ((R = e.onDrop) === null || R === void 0 || R.call(e, M));
    };
    r({
      onBatchStart: C,
      onSuccess: w,
      onProgress: $,
      onError: O,
      fileList: v,
      upload: b
    });
    const [E] = jo("Upload", Zn.Upload, P(() => e.locale)), _ = (M, R) => {
      const {
        removeIcon: A,
        previewIcon: z,
        downloadIcon: T,
        previewFile: N,
        onPreview: k,
        onDownload: B,
        isImageUrl: F,
        progress: L,
        itemRender: j,
        iconRender: H,
        showUploadList: K
      } = e, {
        showDownloadIcon: X,
        showPreviewIcon: W,
        showRemoveIcon: q
      } = typeof K == "boolean" ? {} : K;
      return K ? f(Tre, {
        prefixCls: a.value,
        listType: e.listType,
        items: v.value,
        previewFile: N,
        onPreview: k,
        onDownload: B,
        onRemove: x,
        showRemoveIcon: !p.value && q,
        showPreviewIcon: W,
        showDownloadIcon: X,
        removeIcon: A,
        previewIcon: z,
        downloadIcon: T,
        iconRender: H,
        locale: E.value,
        isImageUrl: F,
        progress: L,
        itemRender: j,
        appendActionVisible: R,
        appendAction: M
      }, m({}, n)) : M == null ? void 0 : M();
    };
    return () => {
      var M, R, A;
      const {
        listType: z,
        type: T
      } = e, {
        class: N,
        style: k
      } = o, B = Lre(o, ["class", "style"]), F = m(m(m({
        onBatchStart: C,
        onError: O,
        onProgress: $,
        onSuccess: w
      }, B), e), {
        id: (M = e.id) !== null && M !== void 0 ? M : l.id.value,
        prefixCls: a.value,
        beforeUpload: S,
        onChange: void 0,
        disabled: p.value
      });
      delete F.remove, (!n.default || p.value) && delete F.id;
      const L = {
        [`${a.value}-rtl`]: i.value === "rtl"
      };
      if (T === "drag") {
        const X = ee(a.value, {
          [`${a.value}-drag`]: !0,
          [`${a.value}-drag-uploading`]: v.value.some((W) => W.status === "uploading"),
          [`${a.value}-drag-hover`]: g.value === "dragover",
          [`${a.value}-disabled`]: p.value,
          [`${a.value}-rtl`]: i.value === "rtl"
        }, o.class, u.value);
        return c(f("span", D(D({}, o), {}, {
          class: ee(`${a.value}-wrapper`, L, N, u.value)
        }), [f("div", {
          class: X,
          onDrop: I,
          onDragover: I,
          onDragleave: I,
          style: o.style
        }, [f(Uw, D(D({}, F), {}, {
          ref: b,
          class: `${a.value}-btn`
        }), D({
          default: () => [f("div", {
            class: `${a.value}-drag-container`
          }, [(R = n.default) === null || R === void 0 ? void 0 : R.call(n)])]
        }, n))]), _()]));
      }
      const j = ee(a.value, {
        [`${a.value}-select`]: !0,
        [`${a.value}-select-${z}`]: !0,
        [`${a.value}-disabled`]: p.value,
        [`${a.value}-rtl`]: i.value === "rtl"
      }), H = It((A = n.default) === null || A === void 0 ? void 0 : A.call(n)), K = (X) => f("div", {
        class: j,
        style: X
      }, [f(Uw, D(D({}, F), {}, {
        ref: b
      }), n)]);
      return c(z === "picture-card" ? f("span", D(D({}, o), {}, {
        class: ee(`${a.value}-wrapper`, `${a.value}-picture-card-wrapper`, L, o.class, u.value)
      }), [_(K, !!(H && H.length))]) : f("span", D(D({}, o), {}, {
        class: ee(`${a.value}-wrapper`, L, o.class, u.value)
      }), [K(H && H.length ? void 0 : {
        display: "none"
      }), _()]));
    };
  }
});
var tx = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const qu = Z({
  compatConfig: {
    MODE: 3
  },
  name: "AUploadDragger",
  inheritAttrs: !1,
  props: Z6(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    return () => {
      const {
        height: r
      } = e, l = tx(e, ["height"]), {
        style: a
      } = o, i = tx(o, ["style"]), s = m(m(m({}, l), i), {
        type: "drag",
        style: m(m({}, a), {
          height: typeof r == "number" ? `${r}px` : r
        })
      });
      return f(Yu, s, n);
    };
  }
}), zre = qu, J6 = m(Yu, {
  Dragger: qu,
  LIST_IGNORE: ls,
  install(e) {
    return e.component(Yu.name, Yu), e.component(qu.name, qu), e;
  }
});
function Hre(e) {
  return e.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function jre(e) {
  return Object.keys(e).map((t) => `${Hre(t)}: ${e[t]};`).join(" ");
}
function nx() {
  return window.devicePixelRatio || 1;
}
function Jv(e, t, n, o) {
  e.translate(t, n), e.rotate(Math.PI / 180 * Number(o)), e.translate(-t, -n);
}
const Vre = (e, t) => {
  let n = !1;
  return e.removedNodes.length && (n = Array.from(e.removedNodes).some((o) => o === t)), e.type === "attributes" && e.target === t && (n = !0), n;
};
var Wre = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
function Kre(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  const {
    window: o = P3
  } = n, r = Wre(n, ["window"]);
  let l;
  const a = x3(() => o && "MutationObserver" in o), i = () => {
    l && (l.disconnect(), l = void 0);
  }, s = ie(() => H0(e), (u) => {
    i(), a.value && o && u && (l = new MutationObserver(t), l.observe(u, r));
  }, {
    immediate: !0
  }), c = () => {
    i(), s();
  };
  return w3(c), {
    isSupported: a,
    stop: c
  };
}
const eg = 2, ox = 3, Gre = () => ({
  zIndex: Number,
  rotate: Number,
  width: Number,
  height: Number,
  image: String,
  content: je([String, Array]),
  font: Re(),
  rootClassName: String,
  gap: vt(),
  offset: vt()
}), Xre = Z({
  name: "AWatermark",
  inheritAttrs: !1,
  props: Qe(Gre(), {
    zIndex: 9,
    rotate: -22,
    font: {},
    gap: [100, 100]
  }),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const [, r] = qr(), l = Q(), a = Q(), i = Q(!1), s = P(() => {
      var _, M;
      return (M = (_ = e.gap) === null || _ === void 0 ? void 0 : _[0]) !== null && M !== void 0 ? M : 100;
    }), c = P(() => {
      var _, M;
      return (M = (_ = e.gap) === null || _ === void 0 ? void 0 : _[1]) !== null && M !== void 0 ? M : 100;
    }), u = P(() => s.value / 2), d = P(() => c.value / 2), p = P(() => {
      var _, M;
      return (M = (_ = e.offset) === null || _ === void 0 ? void 0 : _[0]) !== null && M !== void 0 ? M : u.value;
    }), v = P(() => {
      var _, M;
      return (M = (_ = e.offset) === null || _ === void 0 ? void 0 : _[1]) !== null && M !== void 0 ? M : d.value;
    }), h = P(() => {
      var _, M;
      return (M = (_ = e.font) === null || _ === void 0 ? void 0 : _.fontSize) !== null && M !== void 0 ? M : r.value.fontSizeLG;
    }), g = P(() => {
      var _, M;
      return (M = (_ = e.font) === null || _ === void 0 ? void 0 : _.fontWeight) !== null && M !== void 0 ? M : "normal";
    }), b = P(() => {
      var _, M;
      return (M = (_ = e.font) === null || _ === void 0 ? void 0 : _.fontStyle) !== null && M !== void 0 ? M : "normal";
    }), y = P(() => {
      var _, M;
      return (M = (_ = e.font) === null || _ === void 0 ? void 0 : _.fontFamily) !== null && M !== void 0 ? M : "sans-serif";
    }), S = P(() => {
      var _, M;
      return (M = (_ = e.font) === null || _ === void 0 ? void 0 : _.color) !== null && M !== void 0 ? M : r.value.colorFill;
    }), C = P(() => {
      var _;
      const M = {
        zIndex: (_ = e.zIndex) !== null && _ !== void 0 ? _ : 9,
        position: "absolute",
        left: 0,
        top: 0,
        width: "100%",
        height: "100%",
        pointerEvents: "none",
        backgroundRepeat: "repeat"
      };
      let R = p.value - u.value, A = v.value - d.value;
      return R > 0 && (M.left = `${R}px`, M.width = `calc(100% - ${R}px)`, R = 0), A > 0 && (M.top = `${A}px`, M.height = `calc(100% - ${A}px)`, A = 0), M.backgroundPosition = `${R}px ${A}px`, M;
    }), w = () => {
      a.value && (a.value.remove(), a.value = void 0);
    }, $ = (_, M) => {
      var R;
      l.value && a.value && (i.value = !0, a.value.setAttribute("style", jre(m(m({}, C.value), {
        backgroundImage: `url('${_}')`,
        backgroundSize: `${(s.value + M) * eg}px`
      }))), (R = l.value) === null || R === void 0 || R.append(a.value), setTimeout(() => {
        i.value = !1;
      }));
    }, O = (_) => {
      let M = 120, R = 64;
      const A = e.content, z = e.image, T = e.width, N = e.height;
      if (!z && _.measureText) {
        _.font = `${Number(h.value)}px ${y.value}`;
        const k = Array.isArray(A) ? A : [A], B = k.map((F) => _.measureText(F).width);
        M = Math.ceil(Math.max(...B)), R = Number(h.value) * k.length + (k.length - 1) * ox;
      }
      return [T ?? M, N ?? R];
    }, x = (_, M, R, A, z) => {
      const T = nx(), N = e.content, k = Number(h.value) * T;
      _.font = `${b.value} normal ${g.value} ${k}px/${z}px ${y.value}`, _.fillStyle = S.value, _.textAlign = "center", _.textBaseline = "top", _.translate(A / 2, 0);
      const B = Array.isArray(N) ? N : [N];
      B == null || B.forEach((F, L) => {
        _.fillText(F ?? "", M, R + L * (k + ox * T));
      });
    }, I = () => {
      var _;
      const M = document.createElement("canvas"), R = M.getContext("2d"), A = e.image, z = (_ = e.rotate) !== null && _ !== void 0 ? _ : -22;
      if (R) {
        a.value || (a.value = document.createElement("div"));
        const T = nx(), [N, k] = O(R), B = (s.value + N) * T, F = (c.value + k) * T;
        M.setAttribute("width", `${B * eg}px`), M.setAttribute("height", `${F * eg}px`);
        const L = s.value * T / 2, j = c.value * T / 2, H = N * T, K = k * T, X = (H + s.value * T) / 2, W = (K + c.value * T) / 2, q = L + B, J = j + F, ne = X + B, te = W + F;
        if (R.save(), Jv(R, X, W, z), A) {
          const G = new Image();
          G.onload = () => {
            R.drawImage(G, L, j, H, K), R.restore(), Jv(R, ne, te, z), R.drawImage(G, q, J, H, K), $(M.toDataURL(), N);
          }, G.crossOrigin = "anonymous", G.referrerPolicy = "no-referrer", G.src = A;
        } else
          x(R, L, j, H, K), R.restore(), Jv(R, ne, te, z), x(R, q, J, H, K), $(M.toDataURL(), N);
      }
    };
    return Ke(() => {
      I();
    }), ie(() => [e, r.value.colorFill, r.value.fontSizeLG], () => {
      I();
    }, {
      deep: !0,
      flush: "post"
    }), et(() => {
      w();
    }), Kre(l, (_) => {
      i.value || _.forEach((M) => {
        Vre(M, a.value) && (w(), I());
      });
    }, {
      attributes: !0,
      subtree: !0,
      childList: !0,
      attributeFilter: ["style", "class"]
    }), () => {
      var _;
      return f("div", D(D({}, o), {}, {
        ref: l,
        class: [o.class, e.rootClassName],
        style: [{
          position: "relative"
        }, o.style]
      }), [(_ = n.default) === null || _ === void 0 ? void 0 : _.call(n)]);
    };
  }
}), Ure = kt(Xre);
function rx(e, t) {
  return {
    [`${e}, ${e}:hover, ${e}:focus`]: {
      color: t.colorTextDisabled,
      cursor: "not-allowed"
    }
  };
}
function lx(e) {
  return {
    backgroundColor: e.bgColorSelected,
    boxShadow: e.boxShadow
  };
}
const Yre = m({
  overflow: "hidden"
}, tn), qre = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: m(m(m(m(m({}, qe(e)), {
      display: "inline-block",
      padding: e.segmentedContainerPadding,
      color: e.labelColor,
      backgroundColor: e.bgColor,
      borderRadius: e.borderRadius,
      transition: `all ${e.motionDurationMid} ${e.motionEaseInOut}`,
      [`${t}-group`]: {
        position: "relative",
        display: "flex",
        alignItems: "stretch",
        justifyItems: "flex-start",
        width: "100%"
      },
      // RTL styles
      [`&${t}-rtl`]: {
        direction: "rtl"
      },
      // block styles
      [`&${t}-block`]: {
        display: "flex"
      },
      [`&${t}-block ${t}-item`]: {
        flex: 1,
        minWidth: 0
      },
      // item styles
      [`${t}-item`]: {
        position: "relative",
        textAlign: "center",
        cursor: "pointer",
        transition: `color ${e.motionDurationMid} ${e.motionEaseInOut}`,
        borderRadius: e.borderRadiusSM,
        "&-selected": m(m({}, lx(e)), {
          color: e.labelColorHover
        }),
        "&::after": {
          content: '""',
          position: "absolute",
          width: "100%",
          height: "100%",
          top: 0,
          insetInlineStart: 0,
          borderRadius: "inherit",
          transition: `background-color ${e.motionDurationMid}`,
          pointerEvents: "none"
        },
        [`&:hover:not(${t}-item-selected):not(${t}-item-disabled)`]: {
          color: e.labelColorHover,
          "&::after": {
            backgroundColor: e.bgColorHover
          }
        },
        "&-label": m({
          minHeight: e.controlHeight - e.segmentedContainerPadding * 2,
          lineHeight: `${e.controlHeight - e.segmentedContainerPadding * 2}px`,
          padding: `0 ${e.segmentedPaddingHorizontal}px`
        }, Yre),
        // syntactic sugar to add `icon` for Segmented Item
        "&-icon + *": {
          marginInlineStart: e.marginSM / 2
        },
        "&-input": {
          position: "absolute",
          insetBlockStart: 0,
          insetInlineStart: 0,
          width: 0,
          height: 0,
          opacity: 0,
          pointerEvents: "none"
        }
      },
      // thumb styles
      [`${t}-thumb`]: m(m({}, lx(e)), {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        width: 0,
        height: "100%",
        padding: `${e.paddingXXS}px 0`,
        borderRadius: e.borderRadiusSM,
        [`& ~ ${t}-item:not(${t}-item-selected):not(${t}-item-disabled)::after`]: {
          backgroundColor: "transparent"
        }
      }),
      // size styles
      [`&${t}-lg`]: {
        borderRadius: e.borderRadiusLG,
        [`${t}-item-label`]: {
          minHeight: e.controlHeightLG - e.segmentedContainerPadding * 2,
          lineHeight: `${e.controlHeightLG - e.segmentedContainerPadding * 2}px`,
          padding: `0 ${e.segmentedPaddingHorizontal}px`,
          fontSize: e.fontSizeLG
        },
        [`${t}-item, ${t}-thumb`]: {
          borderRadius: e.borderRadius
        }
      },
      [`&${t}-sm`]: {
        borderRadius: e.borderRadiusSM,
        [`${t}-item-label`]: {
          minHeight: e.controlHeightSM - e.segmentedContainerPadding * 2,
          lineHeight: `${e.controlHeightSM - e.segmentedContainerPadding * 2}px`,
          padding: `0 ${e.segmentedPaddingHorizontalSM}px`
        },
        [`${t}-item, ${t}-thumb`]: {
          borderRadius: e.borderRadiusXS
        }
      }
    }), rx(`&-disabled ${t}-item`, e)), rx(`${t}-item-disabled`, e)), {
      // transition effect when `appear-active`
      [`${t}-thumb-motion-appear-active`]: {
        transition: `transform ${e.motionDurationSlow} ${e.motionEaseInOut}, width ${e.motionDurationSlow} ${e.motionEaseInOut}`,
        willChange: "transform, width"
      }
    })
  };
}, Zre = Xe("Segmented", (e) => {
  const {
    lineWidthBold: t,
    lineWidth: n,
    colorTextLabel: o,
    colorText: r,
    colorFillSecondary: l,
    colorBgLayout: a,
    colorBgElevated: i
  } = e, s = He(e, {
    segmentedPaddingHorizontal: e.controlPaddingHorizontal - n,
    segmentedPaddingHorizontalSM: e.controlPaddingHorizontalSM - n,
    segmentedContainerPadding: t,
    labelColor: o,
    labelColorHover: r,
    bgColor: a,
    bgColorHover: l,
    bgColorSelected: i
  });
  return [qre(s)];
}), ax = (e) => e ? {
  left: e.offsetLeft,
  right: e.parentElement.clientWidth - e.clientWidth - e.offsetLeft,
  width: e.clientWidth
} : null, Ra = (e) => e !== void 0 ? `${e}px` : void 0, Qre = Z({
  props: {
    value: _t(),
    getValueIndex: _t(),
    prefixCls: _t(),
    motionName: _t(),
    onMotionStart: _t(),
    onMotionEnd: _t(),
    direction: _t(),
    containerRef: _t()
  },
  emits: ["motionStart", "motionEnd"],
  setup(e, t) {
    let {
      emit: n
    } = t;
    const o = Y(), r = (h) => {
      var g;
      const b = e.getValueIndex(h), y = (g = e.containerRef.value) === null || g === void 0 ? void 0 : g.querySelectorAll(`.${e.prefixCls}-item`)[b];
      return (y == null ? void 0 : y.offsetParent) && y;
    }, l = Y(null), a = Y(null);
    ie(() => e.value, (h, g) => {
      const b = r(g), y = r(h), S = ax(b), C = ax(y);
      l.value = S, a.value = C, n(b && y ? "motionStart" : "motionEnd");
    }, {
      flush: "post"
    });
    const i = P(() => {
      var h, g;
      return e.direction === "rtl" ? Ra(-((h = l.value) === null || h === void 0 ? void 0 : h.right)) : Ra((g = l.value) === null || g === void 0 ? void 0 : g.left);
    }), s = P(() => {
      var h, g;
      return e.direction === "rtl" ? Ra(-((h = a.value) === null || h === void 0 ? void 0 : h.right)) : Ra((g = a.value) === null || g === void 0 ? void 0 : g.left);
    });
    let c;
    const u = (h) => {
      clearTimeout(c), rt(() => {
        h && (h.style.transform = "translateX(var(--thumb-start-left))", h.style.width = "var(--thumb-start-width)");
      });
    }, d = (h) => {
      c = setTimeout(() => {
        h && (Dd(h, `${e.motionName}-appear-active`), h.style.transform = "translateX(var(--thumb-active-left))", h.style.width = "var(--thumb-active-width)");
      });
    }, p = (h) => {
      l.value = null, a.value = null, h && (h.style.transform = null, h.style.width = null, Nd(h, `${e.motionName}-appear-active`)), n("motionEnd");
    }, v = P(() => {
      var h, g;
      return {
        "--thumb-start-left": i.value,
        "--thumb-start-width": Ra((h = l.value) === null || h === void 0 ? void 0 : h.width),
        "--thumb-active-left": s.value,
        "--thumb-active-width": Ra((g = a.value) === null || g === void 0 ? void 0 : g.width)
      };
    });
    return et(() => {
      clearTimeout(c);
    }), () => {
      const h = {
        ref: o,
        style: v.value,
        class: [`${e.prefixCls}-thumb`]
      };
      return process.env.NODE_ENV === "test" && (h["data-test-style"] = JSON.stringify(v.value)), f(yn, {
        appear: !0,
        onBeforeEnter: u,
        onEnter: d,
        onAfterEnter: p
      }, {
        default: () => [!l.value || !a.value ? null : f("div", h, null)]
      });
    };
  }
});
function Jre(e) {
  return e.map((t) => typeof t == "object" && t !== null ? t : {
    label: t == null ? void 0 : t.toString(),
    title: t == null ? void 0 : t.toString(),
    value: t
  });
}
const ele = () => ({
  prefixCls: String,
  options: vt(),
  block: ve(),
  disabled: ve(),
  size: ke(),
  value: m(m({}, je([String, Number])), {
    required: !0
  }),
  motionName: String,
  onChange: le(),
  "onUpdate:value": le()
}), eE = (e, t) => {
  let {
    slots: n,
    emit: o
  } = t;
  const {
    value: r,
    disabled: l,
    payload: a,
    title: i,
    prefixCls: s,
    label: c = n.label,
    checked: u,
    className: d
  } = e, p = (v) => {
    l || o("change", v, r);
  };
  return f("label", {
    class: ee({
      [`${s}-item-disabled`]: l
    }, d)
  }, [f("input", {
    class: `${s}-item-input`,
    type: "radio",
    disabled: l,
    checked: u,
    onChange: p
  }, null), f("div", {
    class: `${s}-item-label`,
    title: typeof i == "string" ? i : ""
  }, [typeof c == "function" ? c({
    value: r,
    disabled: l,
    payload: a,
    title: i
  }) : c ?? r])]);
};
eE.inheritAttrs = !1;
const tle = Z({
  name: "ASegmented",
  inheritAttrs: !1,
  props: Qe(ele(), {
    options: [],
    motionName: "thumb-motion"
  }),
  slots: Object,
  setup(e, t) {
    let {
      emit: n,
      slots: o,
      attrs: r
    } = t;
    const {
      prefixCls: l,
      direction: a,
      size: i
    } = Ie("segmented", e), [s, c] = Zre(l), u = Q(), d = Q(!1), p = P(() => Jre(e.options)), v = (h, g) => {
      e.disabled || (n("update:value", g), n("change", g));
    };
    return () => {
      const h = l.value;
      return s(f("div", D(D({}, r), {}, {
        class: ee(h, {
          [c.value]: !0,
          [`${h}-block`]: e.block,
          [`${h}-disabled`]: e.disabled,
          [`${h}-lg`]: i.value == "large",
          [`${h}-sm`]: i.value == "small",
          [`${h}-rtl`]: a.value === "rtl"
        }, r.class),
        ref: u
      }), [f("div", {
        class: `${h}-group`
      }, [f(Qre, {
        containerRef: u,
        prefixCls: h,
        value: e.value,
        motionName: `${h}-${e.motionName}`,
        direction: a.value,
        getValueIndex: (g) => p.value.findIndex((b) => b.value === g),
        onMotionStart: () => {
          d.value = !0;
        },
        onMotionEnd: () => {
          d.value = !1;
        }
      }, null), p.value.map((g) => f(eE, D(D({
        key: g.value,
        prefixCls: h,
        checked: g.value === e.value,
        onChange: v
      }, g), {}, {
        className: ee(g.className, `${h}-item`, {
          [`${h}-item-selected`]: g.value === e.value && !d.value
        }),
        disabled: !!e.disabled || !!g.disabled
      }), o))])]));
    };
  }
}), nle = kt(tle), ole = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: m(m({}, qe(e)), {
      display: "flex",
      justifyContent: "center",
      alignItems: "center",
      padding: e.paddingSM,
      backgroundColor: e.colorWhite,
      borderRadius: e.borderRadiusLG,
      border: `${e.lineWidth}px ${e.lineType} ${e.colorSplit}`,
      position: "relative",
      width: "100%",
      height: "100%",
      overflow: "hidden",
      [`& > ${t}-mask`]: {
        position: "absolute",
        insetBlockStart: 0,
        insetInlineStart: 0,
        zIndex: 10,
        display: "flex",
        flexDirection: "column",
        justifyContent: "center",
        alignItems: "center",
        width: "100%",
        height: "100%",
        color: e.colorText,
        lineHeight: e.lineHeight,
        background: e.QRCodeMaskBackgroundColor,
        textAlign: "center",
        [`& > ${t}-expired , & > ${t}-scanned`]: {
          color: e.QRCodeTextColor
        }
      },
      "&-icon": {
        marginBlockEnd: e.marginXS,
        fontSize: e.controlHeight
      }
    }),
    [`${t}-borderless`]: {
      borderColor: "transparent"
    }
  };
}, rle = Xe("QRCode", (e) => ole(He(e, {
  QRCodeTextColor: "rgba(0, 0, 0, 0.88)",
  QRCodeMaskBackgroundColor: "rgba(255, 255, 255, 0.96)"
})));
var lle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M862 465.3h-81c-4.6 0-9 2-12.1 5.5L550 723.1V160c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v563.1L255.1 470.8c-3-3.5-7.4-5.5-12.1-5.5h-81c-6.8 0-10.5 8.1-6 13.2L487.9 861a31.96 31.96 0 0048.3 0L868 478.5c4.5-5.2.8-13.2-6-13.2z" } }] }, name: "arrow-down", theme: "outlined" };
function ix(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      ale(e, r, n[r]);
    });
  }
  return e;
}
function ale(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var iy = function(t, n) {
  var o = ix({}, t, n.attrs);
  return f(Ge, ix({}, o, {
    icon: lle
  }), null);
};
iy.displayName = "ArrowDownOutlined";
iy.inheritAttrs = !1;
var ile = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M842 454c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8 0 140.3-113.7 254-254 254S258 594.3 258 454c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8 0 168.7 126.6 307.9 290 327.6V884H326.7c-13.7 0-24.7 14.3-24.7 32v36c0 4.4 2.8 8 6.2 8h407.6c3.4 0 6.2-3.6 6.2-8v-36c0-17.7-11-32-24.7-32H548V782.1c165.3-18 294-158 294-328.1zM512 624c93.9 0 170-75.2 170-168V232c0-92.8-76.1-168-170-168s-170 75.2-170 168v224c0 92.8 76.1 168 170 168zm-94-392c0-50.6 41.9-92 94-92s94 41.4 94 92v224c0 50.6-41.9 92-94 92s-94-41.4-94-92V232z" } }] }, name: "audio", theme: "outlined" };
function sx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      sle(e, r, n[r]);
    });
  }
  return e;
}
function sle(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var sy = function(t, n) {
  var o = sx({}, t, n.attrs);
  return f(Ge, sx({}, o, {
    icon: ile
  }), null);
};
sy.displayName = "AudioOutlined";
sy.inheritAttrs = !1;
var cle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "defs", attrs: {}, children: [{ tag: "style", attrs: {} }] }, { tag: "path", attrs: { d: "M326 664H104c-8.8 0-16 7.2-16 16v48c0 8.8 7.2 16 16 16h174v176c0 8.8 7.2 16 16 16h48c8.8 0 16-7.2 16-16V696c0-17.7-14.3-32-32-32zm16-576h-48c-8.8 0-16 7.2-16 16v176H104c-8.8 0-16 7.2-16 16v48c0 8.8 7.2 16 16 16h222c17.7 0 32-14.3 32-32V104c0-8.8-7.2-16-16-16zm578 576H698c-17.7 0-32 14.3-32 32v224c0 8.8 7.2 16 16 16h48c8.8 0 16-7.2 16-16V744h174c8.8 0 16-7.2 16-16v-48c0-8.8-7.2-16-16-16zm0-384H746V104c0-8.8-7.2-16-16-16h-48c-8.8 0-16 7.2-16 16v224c0 17.7 14.3 32 32 32h222c8.8 0 16-7.2 16-16v-48c0-8.8-7.2-16-16-16z" } }] }, name: "compress", theme: "outlined" };
function cx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      ule(e, r, n[r]);
    });
  }
  return e;
}
function ule(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var cy = function(t, n) {
  var o = cx({}, t, n.attrs);
  return f(Ge, cx({}, o, {
    icon: cle
  }), null);
};
cy.displayName = "CompressOutlined";
cy.inheritAttrs = !1;
var dle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.3 506.3L781.7 405.6a7.23 7.23 0 00-11.7 5.7V476H548V254h64.8c6 0 9.4-7 5.7-11.7L517.7 114.7a7.14 7.14 0 00-11.3 0L405.6 242.3a7.23 7.23 0 005.7 11.7H476v222H254v-64.8c0-6-7-9.4-11.7-5.7L114.7 506.3a7.14 7.14 0 000 11.3l127.5 100.8c4.7 3.7 11.7.4 11.7-5.7V548h222v222h-64.8c-6 0-9.4 7-5.7 11.7l100.8 127.5c2.9 3.7 8.5 3.7 11.3 0l100.8-127.5c3.7-4.7.4-11.7-5.7-11.7H548V548h222v64.8c0 6 7 9.4 11.7 5.7l127.5-100.8a7.3 7.3 0 00.1-11.4z" } }] }, name: "drag", theme: "outlined" };
function ux(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      fle(e, r, n[r]);
    });
  }
  return e;
}
function fle(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var uy = function(t, n) {
  var o = ux({}, t, n.attrs);
  return f(Ge, ux({}, o, {
    icon: dle
  }), null);
};
uy.displayName = "DragOutlined";
uy.inheritAttrs = !1;
var ple = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M531.3 574.4l.3-1.4c5.8-23.9 13.1-53.7 7.4-80.7-3.8-21.3-19.5-29.6-32.9-30.2-15.8-.7-29.9 8.3-33.4 21.4-6.6 24-.7 56.8 10.1 98.6-13.6 32.4-35.3 79.5-51.2 107.5-29.6 15.3-69.3 38.9-75.2 68.7-1.2 5.5.2 12.5 3.5 18.8 3.7 7 9.6 12.4 16.5 15 3 1.1 6.6 2 10.8 2 17.6 0 46.1-14.2 84.1-79.4 5.8-1.9 11.8-3.9 17.6-5.9 27.2-9.2 55.4-18.8 80.9-23.1 28.2 15.1 60.3 24.8 82.1 24.8 21.6 0 30.1-12.8 33.3-20.5 5.6-13.5 2.9-30.5-6.2-39.6-13.2-13-45.3-16.4-95.3-10.2-24.6-15-40.7-35.4-52.4-65.8zM421.6 726.3c-13.9 20.2-24.4 30.3-30.1 34.7 6.7-12.3 19.8-25.3 30.1-34.7zm87.6-235.5c5.2 8.9 4.5 35.8.5 49.4-4.9-19.9-5.6-48.1-2.7-51.4.8.1 1.5.7 2.2 2zm-1.6 120.5c10.7 18.5 24.2 34.4 39.1 46.2-21.6 4.9-41.3 13-58.9 20.2-4.2 1.7-8.3 3.4-12.3 5 13.3-24.1 24.4-51.4 32.1-71.4zm155.6 65.5c.1.2.2.5-.4.9h-.2l-.2.3c-.8.5-9 5.3-44.3-8.6 40.6-1.9 45 7.3 45.1 7.4zm191.4-388.2L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494z" } }] }, name: "file-pdf", theme: "outlined" };
function dx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      vle(e, r, n[r]);
    });
  }
  return e;
}
function vle(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var dy = function(t, n) {
  var o = dx({}, t, n.attrs);
  return f(Ge, dx({}, o, {
    icon: ple
  }), null);
};
dy.displayName = "FilePdfOutlined";
dy.inheritAttrs = !1;
var gle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM528.1 472h-32.2c-5.5 0-10.3 3.7-11.6 9.1L434.6 680l-46.1-198.7c-1.3-5.4-6.1-9.3-11.7-9.3h-35.4a12.02 12.02 0 00-11.6 15.1l74.2 276c1.4 5.2 6.2 8.9 11.6 8.9h32c5.4 0 10.2-3.6 11.6-8.9l52.8-197 52.8 197c1.4 5.2 6.2 8.9 11.6 8.9h31.8c5.4 0 10.2-3.6 11.6-8.9l74.4-276a12.04 12.04 0 00-11.6-15.1H647c-5.6 0-10.4 3.9-11.7 9.3l-45.8 199.1-49.8-199.3c-1.3-5.4-6.1-9.1-11.6-9.1z" } }] }, name: "file-word", theme: "outlined" };
function fx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      mle(e, r, n[r]);
    });
  }
  return e;
}
function mle(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var fy = function(t, n) {
  var o = fx({}, t, n.attrs);
  return f(Ge, fx({}, o, {
    icon: gle
  }), null);
};
fy.displayName = "FileWordOutlined";
fy.inheritAttrs = !1;
var hle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M909.1 209.3l-56.4 44.1C775.8 155.1 656.2 92 521.9 92 290 92 102.3 279.5 102 511.5 101.7 743.7 289.8 932 521.9 932c181.3 0 335.8-115 394.6-276.1 1.5-4.2-.7-8.9-4.9-10.3l-56.7-19.5a8 8 0 00-10.1 4.8c-1.8 5-3.8 10-5.9 14.9-17.3 41-42.1 77.8-73.7 109.4A344.77 344.77 0 01655.9 829c-42.3 17.9-87.4 27-133.8 27-46.5 0-91.5-9.1-133.8-27A341.5 341.5 0 01279 755.2a342.16 342.16 0 01-73.7-109.4c-17.9-42.4-27-87.4-27-133.9s9.1-91.5 27-133.9c17.3-41 42.1-77.8 73.7-109.4 31.6-31.6 68.4-56.4 109.3-73.8 42.3-17.9 87.4-27 133.8-27 46.5 0 91.5 9.1 133.8 27a341.5 341.5 0 01109.3 73.8c9.9 9.9 19.2 20.4 27.8 31.4l-60.2 47a8 8 0 003 14.1l175.6 43c5 1.2 9.9-2.6 9.9-7.7l.8-180.9c-.1-6.6-7.8-10.3-13-6.2z" } }] }, name: "reload", theme: "outlined" };
function px(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      ble(e, r, n[r]);
    });
  }
  return e;
}
function ble(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var py = function(t, n) {
  var o = px({}, t, n.attrs);
  return f(Ge, px({}, o, {
    icon: hle
  }), null);
};
py.displayName = "ReloadOutlined";
py.inheritAttrs = !1;
var yle = { icon: { tag: "svg", attrs: { viewBox: "64 64 896 896", focusable: "false" }, children: [{ tag: "path", attrs: { d: "M912 302.3L784 376V224c0-35.3-28.7-64-64-64H128c-35.3 0-64 28.7-64 64v576c0 35.3 28.7 64 64 64h592c35.3 0 64-28.7 64-64V648l128 73.7c21.3 12.3 48-3.1 48-27.6V330c0-24.6-26.7-40-48-27.7zM712 792H136V232h576v560zm176-167l-104-59.8V458.9L888 399v226zM208 360h112c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H208c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8z" } }] }, name: "video-camera", theme: "outlined" };
function vx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? Object(arguments[t]) : {}, o = Object.keys(n);
    typeof Object.getOwnPropertySymbols == "function" && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function(r) {
      return Object.getOwnPropertyDescriptor(n, r).enumerable;
    }))), o.forEach(function(r) {
      Sle(e, r, n[r]);
    });
  }
  return e;
}
function Sle(e, t, n) {
  return t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
var vy = function(t, n) {
  var o = vx({}, t, n.attrs);
  return f(Ge, vx({}, o, {
    icon: yle
  }), null);
};
vy.displayName = "VideoCameraOutlined";
vy.inheritAttrs = !1;
const gy = () => ({
  size: {
    type: Number,
    default: 160
  },
  value: {
    type: String,
    required: !0
  },
  type: ke("canvas"),
  color: String,
  bgColor: String,
  includeMargin: Boolean,
  imageSettings: Re()
}), Cle = () => m(m({}, gy()), {
  errorLevel: ke("M"),
  icon: String,
  iconSize: {
    type: Number,
    default: 40
  },
  status: ke("active"),
  bordered: {
    type: Boolean,
    default: !0
  }
});
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */
var ko;
(function(e) {
  class t {
    /*-- Static factory functions (high level) --*/
    // Returns a QR Code representing the given Unicode text string at the given error correction level.
    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
    // ecl argument if it can be done without increasing the version.
    static encodeText(i, s) {
      const c = e.QrSegment.makeSegments(i);
      return t.encodeSegments(c, s);
    }
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
    static encodeBinary(i, s) {
      const c = e.QrSegment.makeBytes(i);
      return t.encodeSegments([c], s);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
    static encodeSegments(i, s) {
      let c = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1, u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 40, d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1, p = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : !0;
      if (!(t.MIN_VERSION <= c && c <= u && u <= t.MAX_VERSION) || d < -1 || d > 7)
        throw new RangeError("Invalid value");
      let v, h;
      for (v = c; ; v++) {
        const S = t.getNumDataCodewords(v, s) * 8, C = l.getTotalBits(i, v);
        if (C <= S) {
          h = C;
          break;
        }
        if (v >= u)
          throw new RangeError("Data too long");
      }
      for (const S of [t.Ecc.MEDIUM, t.Ecc.QUARTILE, t.Ecc.HIGH])
        p && h <= t.getNumDataCodewords(v, S) * 8 && (s = S);
      const g = [];
      for (const S of i) {
        n(S.mode.modeBits, 4, g), n(S.numChars, S.mode.numCharCountBits(v), g);
        for (const C of S.getData())
          g.push(C);
      }
      r(g.length == h);
      const b = t.getNumDataCodewords(v, s) * 8;
      r(g.length <= b), n(0, Math.min(4, b - g.length), g), n(0, (8 - g.length % 8) % 8, g), r(g.length % 8 == 0);
      for (let S = 236; g.length < b; S ^= 253)
        n(S, 8, g);
      const y = [];
      for (; y.length * 8 < g.length; )
        y.push(0);
      return g.forEach((S, C) => y[C >>> 3] |= S << 7 - (C & 7)), new t(v, s, y, d);
    }
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code with the given version number,
    // error correction level, data codeword bytes, and mask number.
    // This is a low-level API that most users should not use directly.
    // A mid-level API is the encodeSegments() function.
    constructor(i, s, c, u) {
      if (this.version = i, this.errorCorrectionLevel = s, this.modules = [], this.isFunction = [], i < t.MIN_VERSION || i > t.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (u < -1 || u > 7)
        throw new RangeError("Mask value out of range");
      this.size = i * 4 + 17;
      const d = [];
      for (let v = 0; v < this.size; v++)
        d.push(!1);
      for (let v = 0; v < this.size; v++)
        this.modules.push(d.slice()), this.isFunction.push(d.slice());
      this.drawFunctionPatterns();
      const p = this.addEccAndInterleave(c);
      if (this.drawCodewords(p), u == -1) {
        let v = 1e9;
        for (let h = 0; h < 8; h++) {
          this.applyMask(h), this.drawFormatBits(h);
          const g = this.getPenaltyScore();
          g < v && (u = h, v = g), this.applyMask(h);
        }
      }
      r(0 <= u && u <= 7), this.mask = u, this.applyMask(u), this.drawFormatBits(u), this.isFunction = [];
    }
    /*-- Accessor methods --*/
    // Returns the color of the module (pixel) at the given coordinates, which is false
    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
    // If the given coordinates are out of bounds, then false (light) is returned.
    getModule(i, s) {
      return 0 <= i && i < this.size && 0 <= s && s < this.size && this.modules[s][i];
    }
    // Modified to expose modules for easy access
    getModules() {
      return this.modules;
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
    drawFunctionPatterns() {
      for (let c = 0; c < this.size; c++)
        this.setFunctionModule(6, c, c % 2 == 0), this.setFunctionModule(c, 6, c % 2 == 0);
      this.drawFinderPattern(3, 3), this.drawFinderPattern(this.size - 4, 3), this.drawFinderPattern(3, this.size - 4);
      const i = this.getAlignmentPatternPositions(), s = i.length;
      for (let c = 0; c < s; c++)
        for (let u = 0; u < s; u++)
          c == 0 && u == 0 || c == 0 && u == s - 1 || c == s - 1 && u == 0 || this.drawAlignmentPattern(i[c], i[u]);
      this.drawFormatBits(0), this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
    drawFormatBits(i) {
      const s = this.errorCorrectionLevel.formatBits << 3 | i;
      let c = s;
      for (let d = 0; d < 10; d++)
        c = c << 1 ^ (c >>> 9) * 1335;
      const u = (s << 10 | c) ^ 21522;
      r(u >>> 15 == 0);
      for (let d = 0; d <= 5; d++)
        this.setFunctionModule(8, d, o(u, d));
      this.setFunctionModule(8, 7, o(u, 6)), this.setFunctionModule(8, 8, o(u, 7)), this.setFunctionModule(7, 8, o(u, 8));
      for (let d = 9; d < 15; d++)
        this.setFunctionModule(14 - d, 8, o(u, d));
      for (let d = 0; d < 8; d++)
        this.setFunctionModule(this.size - 1 - d, 8, o(u, d));
      for (let d = 8; d < 15; d++)
        this.setFunctionModule(8, this.size - 15 + d, o(u, d));
      this.setFunctionModule(8, this.size - 8, !0);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
    drawVersion() {
      if (this.version < 7)
        return;
      let i = this.version;
      for (let c = 0; c < 12; c++)
        i = i << 1 ^ (i >>> 11) * 7973;
      const s = this.version << 12 | i;
      r(s >>> 18 == 0);
      for (let c = 0; c < 18; c++) {
        const u = o(s, c), d = this.size - 11 + c % 3, p = Math.floor(c / 3);
        this.setFunctionModule(d, p, u), this.setFunctionModule(p, d, u);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
    drawFinderPattern(i, s) {
      for (let c = -4; c <= 4; c++)
        for (let u = -4; u <= 4; u++) {
          const d = Math.max(Math.abs(u), Math.abs(c)), p = i + u, v = s + c;
          0 <= p && p < this.size && 0 <= v && v < this.size && this.setFunctionModule(p, v, d != 2 && d != 4);
        }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
    drawAlignmentPattern(i, s) {
      for (let c = -2; c <= 2; c++)
        for (let u = -2; u <= 2; u++)
          this.setFunctionModule(i + u, s + c, Math.max(Math.abs(u), Math.abs(c)) != 1);
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
    setFunctionModule(i, s, c) {
      this.modules[s][i] = c, this.isFunction[s][i] = !0;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
    addEccAndInterleave(i) {
      const s = this.version, c = this.errorCorrectionLevel;
      if (i.length != t.getNumDataCodewords(s, c))
        throw new RangeError("Invalid argument");
      const u = t.NUM_ERROR_CORRECTION_BLOCKS[c.ordinal][s], d = t.ECC_CODEWORDS_PER_BLOCK[c.ordinal][s], p = Math.floor(t.getNumRawDataModules(s) / 8), v = u - p % u, h = Math.floor(p / u), g = [], b = t.reedSolomonComputeDivisor(d);
      for (let S = 0, C = 0; S < u; S++) {
        const w = i.slice(C, C + h - d + (S < v ? 0 : 1));
        C += w.length;
        const $ = t.reedSolomonComputeRemainder(w, b);
        S < v && w.push(0), g.push(w.concat($));
      }
      const y = [];
      for (let S = 0; S < g[0].length; S++)
        g.forEach((C, w) => {
          (S != h - d || w >= v) && y.push(C[S]);
        });
      return r(y.length == p), y;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
    drawCodewords(i) {
      if (i.length != Math.floor(t.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let s = 0;
      for (let c = this.size - 1; c >= 1; c -= 2) {
        c == 6 && (c = 5);
        for (let u = 0; u < this.size; u++)
          for (let d = 0; d < 2; d++) {
            const p = c - d, h = (c + 1 & 2) == 0 ? this.size - 1 - u : u;
            !this.isFunction[h][p] && s < i.length * 8 && (this.modules[h][p] = o(i[s >>> 3], 7 - (s & 7)), s++);
          }
      }
      r(s == i.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
    applyMask(i) {
      if (i < 0 || i > 7)
        throw new RangeError("Mask value out of range");
      for (let s = 0; s < this.size; s++)
        for (let c = 0; c < this.size; c++) {
          let u;
          switch (i) {
            case 0:
              u = (c + s) % 2 == 0;
              break;
            case 1:
              u = s % 2 == 0;
              break;
            case 2:
              u = c % 3 == 0;
              break;
            case 3:
              u = (c + s) % 3 == 0;
              break;
            case 4:
              u = (Math.floor(c / 3) + Math.floor(s / 2)) % 2 == 0;
              break;
            case 5:
              u = c * s % 2 + c * s % 3 == 0;
              break;
            case 6:
              u = (c * s % 2 + c * s % 3) % 2 == 0;
              break;
            case 7:
              u = ((c + s) % 2 + c * s % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          !this.isFunction[s][c] && u && (this.modules[s][c] = !this.modules[s][c]);
        }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
    getPenaltyScore() {
      let i = 0;
      for (let d = 0; d < this.size; d++) {
        let p = !1, v = 0;
        const h = [0, 0, 0, 0, 0, 0, 0];
        for (let g = 0; g < this.size; g++)
          this.modules[d][g] == p ? (v++, v == 5 ? i += t.PENALTY_N1 : v > 5 && i++) : (this.finderPenaltyAddHistory(v, h), p || (i += this.finderPenaltyCountPatterns(h) * t.PENALTY_N3), p = this.modules[d][g], v = 1);
        i += this.finderPenaltyTerminateAndCount(p, v, h) * t.PENALTY_N3;
      }
      for (let d = 0; d < this.size; d++) {
        let p = !1, v = 0;
        const h = [0, 0, 0, 0, 0, 0, 0];
        for (let g = 0; g < this.size; g++)
          this.modules[g][d] == p ? (v++, v == 5 ? i += t.PENALTY_N1 : v > 5 && i++) : (this.finderPenaltyAddHistory(v, h), p || (i += this.finderPenaltyCountPatterns(h) * t.PENALTY_N3), p = this.modules[g][d], v = 1);
        i += this.finderPenaltyTerminateAndCount(p, v, h) * t.PENALTY_N3;
      }
      for (let d = 0; d < this.size - 1; d++)
        for (let p = 0; p < this.size - 1; p++) {
          const v = this.modules[d][p];
          v == this.modules[d][p + 1] && v == this.modules[d + 1][p] && v == this.modules[d + 1][p + 1] && (i += t.PENALTY_N2);
        }
      let s = 0;
      for (const d of this.modules)
        s = d.reduce((p, v) => p + (v ? 1 : 0), s);
      const c = this.size * this.size, u = Math.ceil(Math.abs(s * 20 - c * 10) / c) - 1;
      return r(0 <= u && u <= 9), i += u * t.PENALTY_N4, r(0 <= i && i <= 2568888), i;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of integers.
    getAlignmentPatternPositions() {
      if (this.version == 1)
        return [];
      {
        const i = Math.floor(this.version / 7) + 2, s = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (i * 2 - 2)) * 2, c = [6];
        for (let u = this.size - 7; c.length < i; u -= s)
          c.splice(1, 0, u);
        return c;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
    static getNumRawDataModules(i) {
      if (i < t.MIN_VERSION || i > t.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let s = (16 * i + 128) * i + 64;
      if (i >= 2) {
        const c = Math.floor(i / 7) + 2;
        s -= (25 * c - 10) * c - 55, i >= 7 && (s -= 36);
      }
      return r(208 <= s && s <= 29648), s;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
    static getNumDataCodewords(i, s) {
      return Math.floor(t.getNumRawDataModules(i) / 8) - t.ECC_CODEWORDS_PER_BLOCK[s.ordinal][i] * t.NUM_ERROR_CORRECTION_BLOCKS[s.ordinal][i];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
    static reedSolomonComputeDivisor(i) {
      if (i < 1 || i > 255)
        throw new RangeError("Degree out of range");
      const s = [];
      for (let u = 0; u < i - 1; u++)
        s.push(0);
      s.push(1);
      let c = 1;
      for (let u = 0; u < i; u++) {
        for (let d = 0; d < s.length; d++)
          s[d] = t.reedSolomonMultiply(s[d], c), d + 1 < s.length && (s[d] ^= s[d + 1]);
        c = t.reedSolomonMultiply(c, 2);
      }
      return s;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
    static reedSolomonComputeRemainder(i, s) {
      const c = s.map((u) => 0);
      for (const u of i) {
        const d = u ^ c.shift();
        c.push(0), s.forEach((p, v) => c[v] ^= t.reedSolomonMultiply(p, d));
      }
      return c;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
    static reedSolomonMultiply(i, s) {
      if (i >>> 8 || s >>> 8)
        throw new RangeError("Byte out of range");
      let c = 0;
      for (let u = 7; u >= 0; u--)
        c = c << 1 ^ (c >>> 7) * 285, c ^= (s >>> u & 1) * i;
      return r(c >>> 8 == 0), c;
    }
    // Can only be called immediately after a light run is added, and
    // returns either 0, 1, or 2. A helper function for getPenaltyScore().
    finderPenaltyCountPatterns(i) {
      const s = i[1];
      r(s <= this.size * 3);
      const c = s > 0 && i[2] == s && i[3] == s * 3 && i[4] == s && i[5] == s;
      return (c && i[0] >= s * 4 && i[6] >= s ? 1 : 0) + (c && i[6] >= s * 4 && i[0] >= s ? 1 : 0);
    }
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
    finderPenaltyTerminateAndCount(i, s, c) {
      return i && (this.finderPenaltyAddHistory(s, c), s = 0), s += this.size, this.finderPenaltyAddHistory(s, c), this.finderPenaltyCountPatterns(c);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
    finderPenaltyAddHistory(i, s) {
      s[0] == 0 && (i += this.size), s.pop(), s.unshift(i);
    }
  }
  t.MIN_VERSION = 1, t.MAX_VERSION = 40, t.PENALTY_N1 = 3, t.PENALTY_N2 = 3, t.PENALTY_N3 = 40, t.PENALTY_N4 = 10, t.ECC_CODEWORDS_PER_BLOCK = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
    // High
  ], t.NUM_ERROR_CORRECTION_BLOCKS = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
    // High
  ], e.QrCode = t;
  function n(a, i, s) {
    if (i < 0 || i > 31 || a >>> i)
      throw new RangeError("Value out of range");
    for (let c = i - 1; c >= 0; c--)
      s.push(a >>> c & 1);
  }
  function o(a, i) {
    return (a >>> i & 1) != 0;
  }
  function r(a) {
    if (!a)
      throw new Error("Assertion error");
  }
  class l {
    /*-- Static factory functions (mid level) --*/
    // Returns a segment representing the given binary data encoded in
    // byte mode. All input byte arrays are acceptable. Any text string
    // can be converted to UTF-8 bytes and encoded as a byte mode segment.
    static makeBytes(i) {
      const s = [];
      for (const c of i)
        n(c, 8, s);
      return new l(l.Mode.BYTE, i.length, s);
    }
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
    static makeNumeric(i) {
      if (!l.isNumeric(i))
        throw new RangeError("String contains non-numeric characters");
      const s = [];
      for (let c = 0; c < i.length; ) {
        const u = Math.min(i.length - c, 3);
        n(parseInt(i.substring(c, c + u), 10), u * 3 + 1, s), c += u;
      }
      return new l(l.Mode.NUMERIC, i.length, s);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static makeAlphanumeric(i) {
      if (!l.isAlphanumeric(i))
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      const s = [];
      let c;
      for (c = 0; c + 2 <= i.length; c += 2) {
        let u = l.ALPHANUMERIC_CHARSET.indexOf(i.charAt(c)) * 45;
        u += l.ALPHANUMERIC_CHARSET.indexOf(i.charAt(c + 1)), n(u, 11, s);
      }
      return c < i.length && n(l.ALPHANUMERIC_CHARSET.indexOf(i.charAt(c)), 6, s), new l(l.Mode.ALPHANUMERIC, i.length, s);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
    static makeSegments(i) {
      return i == "" ? [] : l.isNumeric(i) ? [l.makeNumeric(i)] : l.isAlphanumeric(i) ? [l.makeAlphanumeric(i)] : [l.makeBytes(l.toUtf8ByteArray(i))];
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
    static makeEci(i) {
      const s = [];
      if (i < 0)
        throw new RangeError("ECI assignment value out of range");
      if (i < 128)
        n(i, 8, s);
      else if (i < 16384)
        n(2, 2, s), n(i, 14, s);
      else if (i < 1e6)
        n(6, 3, s), n(i, 21, s);
      else
        throw new RangeError("ECI assignment value out of range");
      return new l(l.Mode.ECI, 0, s);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
    static isNumeric(i) {
      return l.NUMERIC_REGEX.test(i);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static isAlphanumeric(i) {
      return l.ALPHANUMERIC_REGEX.test(i);
    }
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code segment with the given attributes and data.
    // The character count (numChars) must agree with the mode and the bit buffer length,
    // but the constraint isn't checked. The given bit buffer is cloned and stored.
    constructor(i, s, c) {
      if (this.mode = i, this.numChars = s, this.bitData = c, s < 0)
        throw new RangeError("Invalid argument");
      this.bitData = c.slice();
    }
    /*-- Methods --*/
    // Returns a new copy of the data bits of this segment.
    getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
    static getTotalBits(i, s) {
      let c = 0;
      for (const u of i) {
        const d = u.mode.numCharCountBits(s);
        if (u.numChars >= 1 << d)
          return 1 / 0;
        c += 4 + d + u.bitData.length;
      }
      return c;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
    static toUtf8ByteArray(i) {
      i = encodeURI(i);
      const s = [];
      for (let c = 0; c < i.length; c++)
        i.charAt(c) != "%" ? s.push(i.charCodeAt(c)) : (s.push(parseInt(i.substring(c + 1, c + 3), 16)), c += 2);
      return s;
    }
  }
  l.NUMERIC_REGEX = /^[0-9]*$/, l.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/, l.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:", e.QrSegment = l;
})(ko || (ko = {}));
(function(e) {
  (function(t) {
    class n {
      /*-- Constructor and fields --*/
      constructor(r, l) {
        this.ordinal = r, this.formatBits = l;
      }
    }
    n.LOW = new n(0, 1), n.MEDIUM = new n(1, 0), n.QUARTILE = new n(2, 3), n.HIGH = new n(3, 2), t.Ecc = n;
  })(e.QrCode || (e.QrCode = {}));
})(ko || (ko = {}));
(function(e) {
  (function(t) {
    class n {
      /*-- Constructor and fields --*/
      constructor(r, l) {
        this.modeBits = r, this.numBitsCharCount = l;
      }
      /*-- Method --*/
      // (Package-private) Returns the bit width of the character count field for a segment in
      // this mode in a QR Code at the given version number. The result is in the range [0, 16].
      numCharCountBits(r) {
        return this.numBitsCharCount[Math.floor((r + 7) / 17)];
      }
    }
    n.NUMERIC = new n(1, [10, 12, 14]), n.ALPHANUMERIC = new n(2, [9, 11, 13]), n.BYTE = new n(4, [8, 16, 16]), n.KANJI = new n(8, [8, 10, 12]), n.ECI = new n(7, [0, 0, 0]), t.Mode = n;
  })(e.QrSegment || (e.QrSegment = {}));
})(ko || (ko = {}));
const tE = {
  L: ko.QrCode.Ecc.LOW,
  M: ko.QrCode.Ecc.MEDIUM,
  Q: ko.QrCode.Ecc.QUARTILE,
  H: ko.QrCode.Ecc.HIGH
}, Xm = 128, nE = "L", oE = "#FFFFFF", rE = "#000000", lE = !1, $le = 4, wle = 0, xle = 0.1;
function aE(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  const n = [];
  return e.forEach(function(o, r) {
    let l = null;
    o.forEach(function(a, i) {
      if (!a && l !== null) {
        n.push(`M${l + t} ${r + t}h${i - l}v1H${l + t}z`), l = null;
        return;
      }
      if (i === o.length - 1) {
        if (!a)
          return;
        l === null ? n.push(`M${i + t},${r + t} h1v1H${i + t}z`) : n.push(`M${l + t},${r + t} h${i + 1 - l}v1H${l + t}z`);
        return;
      }
      a && l === null && (l = i);
    });
  }), n.join("");
}
function iE(e, t) {
  return e.slice().map((n, o) => o < t.y || o >= t.y + t.h ? n : n.map((r, l) => l < t.x || l >= t.x + t.w ? r : !1));
}
function sE(e, t, n, o) {
  if (o == null)
    return null;
  const r = e.length + n * 2, l = Math.floor(t * xle), a = r / t, i = (o.width || l) * a, s = (o.height || l) * a, c = o.x == null ? e.length / 2 - i / 2 : o.x * a, u = o.y == null ? e.length / 2 - s / 2 : o.y * a;
  let d = null;
  if (o.excavate) {
    const p = Math.floor(c), v = Math.floor(u), h = Math.ceil(i + c - p), g = Math.ceil(s + u - v);
    d = {
      x: p,
      y: v,
      w: h,
      h: g
    };
  }
  return {
    x: c,
    y: u,
    h: s,
    w: i,
    excavation: d
  };
}
function cE(e, t) {
  return t != null ? Math.floor(t) : e ? $le : wle;
}
const Ole = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch {
    return !1;
  }
  return !0;
}(), Ple = Z({
  name: "QRCodeCanvas",
  inheritAttrs: !1,
  props: m(m({}, gy()), {
    level: String,
    bgColor: String,
    fgColor: String,
    marginSize: Number
  }),
  setup(e, t) {
    let {
      attrs: n,
      expose: o
    } = t;
    const r = P(() => {
      var s;
      return (s = e.imageSettings) === null || s === void 0 ? void 0 : s.src;
    }), l = Q(null), a = Q(null), i = Q(!1);
    return o({
      toDataURL: (s, c) => {
        var u;
        return (u = l.value) === null || u === void 0 ? void 0 : u.toDataURL(s, c);
      }
    }), Le(() => {
      const {
        value: s,
        size: c = Xm,
        level: u = nE,
        bgColor: d = oE,
        fgColor: p = rE,
        includeMargin: v = lE,
        marginSize: h,
        imageSettings: g
      } = e;
      if (l.value != null) {
        const b = l.value, y = b.getContext("2d");
        if (!y)
          return;
        let S = ko.QrCode.encodeText(s, tE[u]).getModules();
        const C = cE(v, h), w = S.length + C * 2, $ = sE(S, c, C, g), O = a.value, x = i.value && $ != null && O !== null && O.complete && O.naturalHeight !== 0 && O.naturalWidth !== 0;
        x && $.excavation != null && (S = iE(S, $.excavation));
        const I = window.devicePixelRatio || 1;
        b.height = b.width = c * I;
        const E = c / w * I;
        y.scale(E, E), y.fillStyle = d, y.fillRect(0, 0, w, w), y.fillStyle = p, Ole ? y.fill(new Path2D(aE(S, C))) : S.forEach(function(_, M) {
          _.forEach(function(R, A) {
            R && y.fillRect(A + C, M + C, 1, 1);
          });
        }), x && y.drawImage(O, $.x + C, $.y + C, $.w, $.h);
      }
    }, {
      flush: "post"
    }), ie(r, () => {
      i.value = !1;
    }), () => {
      var s;
      const c = (s = e.size) !== null && s !== void 0 ? s : Xm, u = {
        height: `${c}px`,
        width: `${c}px`
      };
      let d = null;
      return r.value != null && (d = f("img", {
        src: r.value,
        key: r.value,
        style: {
          display: "none"
        },
        onLoad: () => {
          i.value = !0;
        },
        ref: a
      }, null)), f(Fe, null, [f("canvas", D(D({}, n), {}, {
        style: [u, n.style],
        ref: l
      }), null), d]);
    };
  }
}), Ile = Z({
  name: "QRCodeSVG",
  inheritAttrs: !1,
  props: m(m({}, gy()), {
    color: String,
    level: String,
    bgColor: String,
    fgColor: String,
    marginSize: Number,
    title: String
  }),
  setup(e) {
    let t = null, n = null, o = null, r = null, l = null, a = null;
    return Le(() => {
      const {
        value: i,
        size: s = Xm,
        level: c = nE,
        includeMargin: u = lE,
        marginSize: d,
        imageSettings: p
      } = e;
      t = ko.QrCode.encodeText(i, tE[c]).getModules(), n = cE(u, d), o = t.length + n * 2, r = sE(t, s, n, p), p != null && r != null && (r.excavation != null && (t = iE(t, r.excavation)), a = f("image", {
        "xlink:href": p.src,
        height: r.h,
        width: r.w,
        x: r.x + n,
        y: r.y + n,
        preserveAspectRatio: "none"
      }, null)), l = aE(t, n);
    }), () => {
      const i = e.bgColor && oE, s = e.fgColor && rE;
      return f("svg", {
        height: e.size,
        width: e.size,
        viewBox: `0 0 ${o} ${o}`
      }, [!!e.title && f("title", null, [e.title]), f("path", {
        fill: i,
        d: `M0,0 h${o}v${o}H0z`,
        "shape-rendering": "crispEdges"
      }, null), f("path", {
        fill: s,
        d: l,
        "shape-rendering": "crispEdges"
      }, null), a]);
    };
  }
}), Ele = Z({
  name: "AQrcode",
  inheritAttrs: !1,
  props: Cle(),
  emits: ["refresh"],
  setup(e, t) {
    let {
      emit: n,
      attrs: o,
      expose: r
    } = t;
    process.env.NODE_ENV !== "production" && Mt(!(e.icon && e.errorLevel === "L"), "QRCode", "ErrorLevel `L` is not recommended to be used with `icon`, for scanning result would be affected by low level.");
    const [l] = jo("QRCode"), {
      prefixCls: a
    } = Ie("qrcode", e), [i, s] = rle(a), [, c] = qr(), u = Y();
    r({
      toDataURL: (p, v) => {
        var h;
        return (h = u.value) === null || h === void 0 ? void 0 : h.toDataURL(p, v);
      }
    });
    const d = P(() => {
      const {
        value: p,
        icon: v = "",
        size: h = 160,
        iconSize: g = 40,
        color: b = c.value.colorText,
        bgColor: y = "transparent",
        errorLevel: S = "M"
      } = e, C = {
        src: v,
        x: void 0,
        y: void 0,
        height: g,
        width: g,
        excavate: !0
      };
      return {
        value: p,
        size: h - (c.value.paddingSM + c.value.lineWidth) * 2,
        level: S,
        bgColor: y,
        fgColor: b,
        imageSettings: v ? C : void 0
      };
    });
    return () => {
      const p = a.value;
      return i(f("div", D(D({}, o), {}, {
        style: [o.style, {
          width: `${e.size}px`,
          height: `${e.size}px`,
          backgroundColor: d.value.bgColor
        }],
        class: [s.value, p, {
          [`${p}-borderless`]: !e.bordered
        }]
      }), [e.status !== "active" && f("div", {
        class: `${p}-mask`
      }, [e.status === "loading" && f(br, null, null), e.status === "expired" && f(Fe, null, [f("p", {
        class: `${p}-expired`
      }, [l.value.expired]), f(Kt, {
        type: "link",
        onClick: (v) => n("refresh", v)
      }, {
        default: () => [l.value.refresh],
        icon: () => f(py, null, null)
      })]), e.status === "scanned" && f("p", {
        class: `${p}-scanned`
      }, [l.value.scanned])]), e.type === "canvas" ? f(Ple, D({
        ref: u
      }, d.value), null) : f(Ile, d.value, null)]));
    };
  }
}), Tle = kt(Ele);
function Mle(e) {
  const t = window.innerWidth || document.documentElement.clientWidth, n = window.innerHeight || document.documentElement.clientHeight, {
    top: o,
    right: r,
    bottom: l,
    left: a
  } = e.getBoundingClientRect();
  return o >= 0 && a >= 0 && r <= t && l <= n;
}
function _le(e, t, n, o) {
  const [r, l] = Pt(void 0);
  Le(() => {
    const u = typeof e.value == "function" ? e.value() : e.value;
    l(u || null);
  }, {
    flush: "post"
  });
  const [a, i] = Pt(null), s = () => {
    if (!t.value) {
      i(null);
      return;
    }
    if (r.value) {
      !Mle(r.value) && t.value && r.value.scrollIntoView(o.value);
      const {
        left: u,
        top: d,
        width: p,
        height: v
      } = r.value.getBoundingClientRect(), h = {
        left: u,
        top: d,
        width: p,
        height: v,
        radius: 0
      };
      JSON.stringify(a.value) !== JSON.stringify(h) && i(h);
    } else
      i(null);
  };
  return Ke(() => {
    ie([t, r], () => {
      s();
    }, {
      flush: "post",
      immediate: !0
    }), window.addEventListener("resize", s);
  }), et(() => {
    window.removeEventListener("resize", s);
  }), [P(() => {
    var u, d;
    if (!a.value)
      return a.value;
    const p = ((u = n.value) === null || u === void 0 ? void 0 : u.offset) || 6, v = ((d = n.value) === null || d === void 0 ? void 0 : d.radius) || 2;
    return {
      left: a.value.left - p,
      top: a.value.top - p,
      width: a.value.width + p * 2,
      height: a.value.height + p * 2,
      radius: v
    };
  }), r];
}
const Ale = () => ({
  arrow: je([Boolean, Object]),
  target: je([String, Function, Object]),
  title: je([String, Object]),
  description: je([String, Object]),
  placement: ke(),
  mask: je([Object, Boolean], !0),
  className: {
    type: String
  },
  style: Re(),
  scrollIntoViewOptions: je([Boolean, Object])
}), my = () => m(m({}, Ale()), {
  prefixCls: {
    type: String
  },
  total: {
    type: Number
  },
  current: {
    type: Number
  },
  onClose: le(),
  onFinish: le(),
  renderPanel: le(),
  onPrev: le(),
  onNext: le()
}), Dle = Z({
  name: "DefaultPanel",
  inheritAttrs: !1,
  props: my(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => {
      const {
        prefixCls: o,
        current: r,
        total: l,
        title: a,
        description: i,
        onClose: s,
        onPrev: c,
        onNext: u,
        onFinish: d
      } = e;
      return f("div", D(D({}, n), {}, {
        class: ee(`${o}-content`, n.class)
      }), [f("div", {
        class: `${o}-inner`
      }, [f("button", {
        type: "button",
        onClick: s,
        "aria-label": "Close",
        class: `${o}-close`
      }, [f("span", {
        class: `${o}-close-x`
      }, [Ot("×")])]), f("div", {
        class: `${o}-header`
      }, [f("div", {
        class: `${o}-title`
      }, [a])]), f("div", {
        class: `${o}-description`
      }, [i]), f("div", {
        class: `${o}-footer`
      }, [f("div", {
        class: `${o}-sliders`
      }, [l > 1 ? [...Array.from({
        length: l
      }).keys()].map((p, v) => f("span", {
        key: p,
        class: v === r ? "active" : ""
      }, null)) : null]), f("div", {
        class: `${o}-buttons`
      }, [r !== 0 ? f("button", {
        class: `${o}-prev-btn`,
        onClick: c
      }, [Ot("Prev")]) : null, r === l - 1 ? f("button", {
        class: `${o}-finish-btn`,
        onClick: d
      }, [Ot("Finish")]) : f("button", {
        class: `${o}-next-btn`,
        onClick: u
      }, [Ot("Next")])])])])]);
    };
  }
}), Nle = Z({
  name: "TourStep",
  inheritAttrs: !1,
  props: my(),
  setup(e, t) {
    let {
      attrs: n
    } = t;
    return () => {
      const {
        current: o,
        renderPanel: r
      } = e;
      return f(Fe, null, [typeof r == "function" ? r(m(m({}, n), e), o) : f(Dle, D(D({}, n), e), null)]);
    };
  }
});
let gx = 0;
const Rle = process.env.NODE_ENV !== "test" && jn();
function kle() {
  let e;
  return Rle ? (e = gx, gx += 1) : e = "TEST_OR_SSR", e;
}
function Ble() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Y("");
  const t = `vc_unique_${kle()}`;
  return e.value || t;
}
const su = {
  fill: "transparent",
  "pointer-events": "auto"
}, Fle = Z({
  name: "TourMask",
  props: {
    prefixCls: {
      type: String
    },
    pos: Re(),
    rootClassName: {
      type: String
    },
    showMask: ve(),
    fill: {
      type: String,
      default: "rgba(0,0,0,0.5)"
    },
    open: ve(),
    animated: je([Boolean, Object]),
    zIndex: {
      type: Number
    }
  },
  setup(e, t) {
    let {
      attrs: n
    } = t;
    const o = Ble();
    return () => {
      const {
        prefixCls: r,
        open: l,
        rootClassName: a,
        pos: i,
        showMask: s,
        fill: c,
        animated: u,
        zIndex: d
      } = e, p = `${r}-mask-${o}`, v = typeof u == "object" ? u == null ? void 0 : u.placeholder : u;
      return f(lc, {
        visible: l,
        autoLock: !0
      }, {
        default: () => l && f("div", D(D({}, n), {}, {
          class: ee(`${r}-mask`, a, n.class),
          style: [{
            position: "fixed",
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
            zIndex: d,
            pointerEvents: "none"
          }, n.style]
        }), [s ? f("svg", {
          style: {
            width: "100%",
            height: "100%"
          }
        }, [f("defs", null, [f("mask", {
          id: p
        }, [f("rect", {
          x: "0",
          y: "0",
          width: "100vw",
          height: "100vh",
          fill: "white"
        }, null), i && f("rect", {
          x: i.left,
          y: i.top,
          rx: i.radius,
          width: i.width,
          height: i.height,
          fill: "black",
          class: v ? `${r}-placeholder-animated` : ""
        }, null)])]), f("rect", {
          x: "0",
          y: "0",
          width: "100%",
          height: "100%",
          fill: c,
          mask: `url(#${p})`
        }, null), i && f(Fe, null, [f("rect", D(D({}, su), {}, {
          x: "0",
          y: "0",
          width: "100%",
          height: i.top
        }), null), f("rect", D(D({}, su), {}, {
          x: "0",
          y: "0",
          width: i.left,
          height: "100%"
        }), null), f("rect", D(D({}, su), {}, {
          x: "0",
          y: i.top + i.height,
          width: "100%",
          height: `calc(100vh - ${i.top + i.height}px)`
        }), null), f("rect", D(D({}, su), {}, {
          x: i.left + i.width,
          y: "0",
          width: `calc(100vw - ${i.left + i.width}px)`,
          height: "100%"
        }), null)])]) : null])
      });
    };
  }
}), Lle = [0, 0], mx = {
  left: {
    points: ["cr", "cl"],
    offset: [-8, 0]
  },
  right: {
    points: ["cl", "cr"],
    offset: [8, 0]
  },
  top: {
    points: ["bc", "tc"],
    offset: [0, -8]
  },
  bottom: {
    points: ["tc", "bc"],
    offset: [0, 8]
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -8]
  },
  leftTop: {
    points: ["tr", "tl"],
    offset: [-8, 0]
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -8]
  },
  rightTop: {
    points: ["tl", "tr"],
    offset: [8, 0]
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 8]
  },
  rightBottom: {
    points: ["bl", "br"],
    offset: [8, 0]
  },
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 8]
  },
  leftBottom: {
    points: ["br", "bl"],
    offset: [-8, 0]
  }
};
function uE() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1;
  const t = {};
  return Object.keys(mx).forEach((n) => {
    t[n] = m(m({}, mx[n]), {
      autoArrow: e,
      targetOffset: Lle
    });
  }), t;
}
uE();
var zle = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const tg = {
  left: "50%",
  top: "50%",
  width: "1px",
  height: "1px"
}, dE = () => {
  const {
    builtinPlacements: e,
    popupAlign: t
  } = e4();
  return {
    builtinPlacements: e,
    popupAlign: t,
    steps: vt(),
    open: ve(),
    defaultCurrent: {
      type: Number
    },
    current: {
      type: Number
    },
    onChange: le(),
    onClose: le(),
    onFinish: le(),
    mask: je([Boolean, Object], !0),
    arrow: je([Boolean, Object], !0),
    rootClassName: {
      type: String
    },
    placement: ke("bottom"),
    prefixCls: {
      type: String,
      default: "rc-tour"
    },
    renderPanel: le(),
    gap: Re(),
    animated: je([Boolean, Object]),
    scrollIntoViewOptions: je([Boolean, Object], !0),
    zIndex: {
      type: Number,
      default: 1001
    }
  };
}, Hle = Z({
  name: "Tour",
  inheritAttrs: !1,
  props: Qe(dE(), {}),
  setup(e) {
    const {
      defaultCurrent: t,
      placement: n,
      mask: o,
      scrollIntoViewOptions: r,
      open: l,
      gap: a,
      arrow: i
    } = Qo(e), s = Y(), [c, u] = Rt(0, {
      value: P(() => e.current),
      defaultValue: t.value
    }), [d, p] = Rt(void 0, {
      value: P(() => e.open),
      postState: (x) => c.value < 0 || c.value >= e.steps.length ? !1 : x ?? !0
    }), v = Q(d.value);
    Le(() => {
      d.value && !v.value && u(0), v.value = d.value;
    });
    const h = P(() => e.steps[c.value] || {}), g = P(() => {
      var x;
      return (x = h.value.placement) !== null && x !== void 0 ? x : n.value;
    }), b = P(() => {
      var x;
      return d.value && ((x = h.value.mask) !== null && x !== void 0 ? x : o.value);
    }), y = P(() => {
      var x;
      return (x = h.value.scrollIntoViewOptions) !== null && x !== void 0 ? x : r.value;
    }), [S, C] = _le(P(() => h.value.target), l, a, y), w = P(() => C.value ? typeof h.value.arrow > "u" ? i.value : h.value.arrow : !1), $ = P(() => typeof w.value == "object" ? w.value.pointAtCenter : !1);
    ie($, () => {
      var x;
      (x = s.value) === null || x === void 0 || x.forcePopupAlign();
    }), ie(c, () => {
      var x;
      (x = s.value) === null || x === void 0 || x.forcePopupAlign();
    });
    const O = (x) => {
      var I;
      u(x), (I = e.onChange) === null || I === void 0 || I.call(e, x);
    };
    return () => {
      var x;
      const {
        prefixCls: I,
        steps: E,
        onClose: _,
        onFinish: M,
        rootClassName: R,
        renderPanel: A,
        animated: z,
        zIndex: T
      } = e, N = zle(e, ["prefixCls", "steps", "onClose", "onFinish", "rootClassName", "renderPanel", "animated", "zIndex"]);
      if (C.value === void 0)
        return null;
      const k = () => {
        p(!1), _ == null || _(c.value);
      }, B = typeof b.value == "boolean" ? b.value : !!b.value, F = typeof b.value == "boolean" ? void 0 : b.value, L = () => C.value || document.body, j = () => f(Nle, D({
        arrow: w.value,
        key: "content",
        prefixCls: I,
        total: E.length,
        renderPanel: A,
        onPrev: () => {
          O(c.value - 1);
        },
        onNext: () => {
          O(c.value + 1);
        },
        onClose: k,
        current: c.value,
        onFinish: () => {
          k(), M == null || M();
        }
      }, h.value), null), H = P(() => {
        const K = S.value || tg, X = {};
        return Object.keys(K).forEach((W) => {
          typeof K[W] == "number" ? X[W] = `${K[W]}px` : X[W] = K[W];
        }), X;
      });
      return d.value ? f(Fe, null, [f(Fle, {
        zIndex: T,
        prefixCls: I,
        pos: S.value,
        showMask: B,
        style: F == null ? void 0 : F.style,
        fill: F == null ? void 0 : F.color,
        open: d.value,
        animated: z,
        rootClassName: R
      }, null), f($a, D(D({}, N), {}, {
        arrow: !!N.arrow,
        builtinPlacements: h.value.target ? (x = N.builtinPlacements) !== null && x !== void 0 ? x : uE($.value) : void 0,
        ref: s,
        popupStyle: h.value.target ? h.value.style : m(m({}, h.value.style), {
          position: "fixed",
          left: tg.left,
          top: tg.top,
          transform: "translate(-50%, -50%)"
        }),
        popupPlacement: g.value,
        popupVisible: d.value,
        popupClassName: ee(R, h.value.className),
        prefixCls: I,
        popup: j,
        forceRender: !1,
        destroyPopupOnHide: !0,
        zIndex: T,
        mask: !1,
        getTriggerDOMNode: L
      }), {
        default: () => [f(lc, {
          visible: d.value,
          autoLock: !0
        }, {
          default: () => [f("div", {
            class: ee(R, `${I}-target-placeholder`),
            style: m(m({}, H.value), {
              position: "fixed",
              pointerEvents: "none"
            })
          }, null)]
        })]
      })]) : null;
    };
  }
}), jle = () => m(m({}, dE()), {
  steps: {
    type: Array
  },
  prefixCls: {
    type: String
  },
  current: {
    type: Number
  },
  type: {
    type: String
  },
  "onUpdate:current": Function
}), Vle = () => m(m({}, my()), {
  cover: {
    type: Object
  },
  nextButtonProps: {
    type: Object
  },
  prevButtonProps: {
    type: Object
  },
  current: {
    type: Number
  },
  type: {
    type: String
  }
}), Wle = Z({
  name: "ATourPanel",
  inheritAttrs: !1,
  props: Vle(),
  setup(e, t) {
    let {
      attrs: n,
      slots: o
    } = t;
    const {
      current: r,
      total: l
    } = Qo(e), a = P(() => r.value === l.value - 1), i = (c) => {
      var u;
      const d = e.prevButtonProps;
      (u = e.onPrev) === null || u === void 0 || u.call(e, c), typeof (d == null ? void 0 : d.onClick) == "function" && (d == null || d.onClick());
    }, s = (c) => {
      var u, d;
      const p = e.nextButtonProps;
      a.value ? (u = e.onFinish) === null || u === void 0 || u.call(e, c) : (d = e.onNext) === null || d === void 0 || d.call(e, c), typeof (p == null ? void 0 : p.onClick) == "function" && (p == null || p.onClick());
    };
    return () => {
      const {
        prefixCls: c,
        title: u,
        onClose: d,
        cover: p,
        description: v,
        type: h,
        arrow: g
      } = e, b = e.prevButtonProps, y = e.nextButtonProps;
      let S;
      u && (S = f("div", {
        class: `${c}-header`
      }, [f("div", {
        class: `${c}-title`
      }, [u])]));
      let C;
      v && (C = f("div", {
        class: `${c}-description`
      }, [v]));
      let w;
      p && (w = f("div", {
        class: `${c}-cover`
      }, [p]));
      let $;
      o.indicatorsRender ? $ = o.indicatorsRender({
        current: r.value,
        total: l
      }) : $ = [...Array.from({
        length: l.value
      }).keys()].map((I, E) => f("span", {
        key: I,
        class: ee(E === r.value && `${c}-indicator-active`, `${c}-indicator`)
      }, null));
      const O = h === "primary" ? "default" : "primary", x = {
        type: "default",
        ghost: h === "primary"
      };
      return f(ma, {
        componentName: "Tour",
        defaultLocale: Zn.Tour
      }, {
        default: (I) => {
          var E;
          return f("div", D(D({}, n), {}, {
            class: ee(h === "primary" ? `${c}-primary` : "", n.class, `${c}-content`)
          }), [g && f("div", {
            class: `${c}-arrow`,
            key: "arrow"
          }, null), f("div", {
            class: `${c}-inner`
          }, [f(Kn, {
            class: `${c}-close`,
            onClick: d
          }, null), w, S, C, f("div", {
            class: `${c}-footer`
          }, [l.value > 1 && f("div", {
            class: `${c}-indicators`
          }, [$]), f("div", {
            class: `${c}-buttons`
          }, [r.value !== 0 ? f(Kt, D(D(D({}, x), b), {}, {
            onClick: i,
            size: "small",
            class: ee(`${c}-prev-btn`, b == null ? void 0 : b.className)
          }), {
            default: () => [vg(b == null ? void 0 : b.children) ? b.children() : (E = b == null ? void 0 : b.children) !== null && E !== void 0 ? E : I.Previous]
          }) : null, f(Kt, D(D({
            type: O
          }, y), {}, {
            onClick: s,
            size: "small",
            class: ee(`${c}-next-btn`, y == null ? void 0 : y.className)
          }), {
            default: () => [vg(y == null ? void 0 : y.children) ? y == null ? void 0 : y.children() : a.value ? I.Finish : I.Next]
          })])])])]);
        }
      });
    };
  }
}), Kle = (e) => {
  let {
    defaultType: t,
    steps: n,
    current: o,
    defaultCurrent: r
  } = e;
  const l = Y(r == null ? void 0 : r.value), a = P(() => o == null ? void 0 : o.value);
  ie(a, (u) => {
    l.value = u ?? (r == null ? void 0 : r.value);
  }, {
    immediate: !0
  });
  const i = (u) => {
    l.value = u;
  }, s = P(() => {
    var u, d;
    return typeof l.value == "number" ? n && ((d = (u = n.value) === null || u === void 0 ? void 0 : u[l.value]) === null || d === void 0 ? void 0 : d.type) : t == null ? void 0 : t.value;
  });
  return {
    currentMergedType: P(() => {
      var u;
      return (u = s.value) !== null && u !== void 0 ? u : t == null ? void 0 : t.value;
    }),
    updateInnerCurrent: i
  };
}, Gle = (e) => {
  const {
    componentCls: t,
    lineHeight: n,
    padding: o,
    paddingXS: r,
    borderRadius: l,
    borderRadiusXS: a,
    colorPrimary: i,
    colorText: s,
    colorFill: c,
    indicatorHeight: u,
    indicatorWidth: d,
    boxShadowTertiary: p,
    tourZIndexPopup: v,
    fontSize: h,
    colorBgContainer: g,
    fontWeightStrong: b,
    marginXS: y,
    colorTextLightSolid: S,
    tourBorderRadius: C,
    colorWhite: w,
    colorBgTextHover: $,
    tourCloseSize: O,
    motionDurationSlow: x,
    antCls: I
  } = e;
  return [
    {
      [t]: m(m({}, qe(e)), {
        color: s,
        position: "absolute",
        zIndex: v,
        display: "block",
        visibility: "visible",
        fontSize: h,
        lineHeight: n,
        width: 520,
        "--antd-arrow-background-color": g,
        "&-pure": {
          maxWidth: "100%",
          position: "relative"
        },
        [`&${t}-hidden`]: {
          display: "none"
        },
        // ============================= panel content ============================
        [`${t}-content`]: {
          position: "relative"
        },
        [`${t}-inner`]: {
          textAlign: "start",
          textDecoration: "none",
          borderRadius: C,
          boxShadow: p,
          position: "relative",
          backgroundColor: g,
          border: "none",
          backgroundClip: "padding-box",
          [`${t}-close`]: {
            position: "absolute",
            top: o,
            insetInlineEnd: o,
            color: e.colorIcon,
            outline: "none",
            width: O,
            height: O,
            borderRadius: e.borderRadiusSM,
            transition: `background-color ${e.motionDurationMid}, color ${e.motionDurationMid}`,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            "&:hover": {
              color: e.colorIconHover,
              backgroundColor: e.wireframe ? "transparent" : e.colorFillContent
            }
          },
          [`${t}-cover`]: {
            textAlign: "center",
            padding: `${o + O + r}px ${o}px 0`,
            img: {
              width: "100%"
            }
          },
          [`${t}-header`]: {
            padding: `${o}px ${o}px ${r}px`,
            [`${t}-title`]: {
              lineHeight: n,
              fontSize: h,
              fontWeight: b
            }
          },
          [`${t}-description`]: {
            padding: `0 ${o}px`,
            lineHeight: n,
            wordWrap: "break-word"
          },
          [`${t}-footer`]: {
            padding: `${r}px ${o}px ${o}px`,
            textAlign: "end",
            borderRadius: `0 0 ${a}px ${a}px`,
            display: "flex",
            [`${t}-indicators`]: {
              display: "inline-block",
              [`${t}-indicator`]: {
                width: d,
                height: u,
                display: "inline-block",
                borderRadius: "50%",
                background: c,
                "&:not(:last-child)": {
                  marginInlineEnd: u
                },
                "&-active": {
                  background: i
                }
              }
            },
            [`${t}-buttons`]: {
              marginInlineStart: "auto",
              [`${I}-btn`]: {
                marginInlineStart: y
              }
            }
          }
        },
        // =============================  primary type  ===========================
        // `$` for panel, `&$` for pure panel
        [`${t}-primary, &${t}-primary`]: {
          "--antd-arrow-background-color": i,
          [`${t}-inner`]: {
            color: S,
            textAlign: "start",
            textDecoration: "none",
            backgroundColor: i,
            borderRadius: l,
            boxShadow: p,
            [`${t}-close`]: {
              color: S
            },
            [`${t}-indicators`]: {
              [`${t}-indicator`]: {
                background: new Ct(S).setAlpha(0.15).toRgbString(),
                "&-active": {
                  background: S
                }
              }
            },
            [`${t}-prev-btn`]: {
              color: S,
              borderColor: new Ct(S).setAlpha(0.15).toRgbString(),
              backgroundColor: i,
              "&:hover": {
                backgroundColor: new Ct(S).setAlpha(0.15).toRgbString(),
                borderColor: "transparent"
              }
            },
            [`${t}-next-btn`]: {
              color: i,
              borderColor: "transparent",
              background: w,
              "&:hover": {
                background: new Ct($).onBackground(w).toRgbString()
              }
            }
          }
        }
      }),
      // ============================= mask ===========================
      [`${t}-mask`]: {
        [`${t}-placeholder-animated`]: {
          transition: `all ${x}`
        }
      },
      // =========== Limit left and right placement radius ==============
      [["&-placement-left", "&-placement-leftTop", "&-placement-leftBottom", "&-placement-right", "&-placement-rightTop", "&-placement-rightBottom"].join(",")]: {
        [`${t}-inner`]: {
          borderRadius: Math.min(C, d0)
        }
      }
    },
    // ============================= Arrow ===========================
    f0(e, {
      colorBg: "var(--antd-arrow-background-color)",
      contentRadius: C,
      limitVerticalRadius: !0
    })
  ];
}, Xle = Xe("Tour", (e) => {
  const {
    borderRadiusLG: t,
    fontSize: n,
    lineHeight: o
  } = e, r = He(e, {
    tourZIndexPopup: e.zIndexPopupBase + 70,
    indicatorWidth: 6,
    indicatorHeight: 6,
    tourBorderRadius: t,
    tourCloseSize: n * o
  });
  return [Gle(r)];
});
var Ule = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const Yle = Z({
  name: "ATour",
  inheritAttrs: !1,
  props: jle(),
  setup(e, t) {
    let {
      attrs: n,
      emit: o,
      slots: r
    } = t;
    const {
      current: l,
      type: a,
      steps: i,
      defaultCurrent: s
    } = Qo(e), {
      prefixCls: c,
      direction: u
    } = Ie("tour", e), [d, p] = Xle(c), {
      currentMergedType: v,
      updateInnerCurrent: h
    } = Kle({
      defaultType: a,
      steps: i,
      current: l,
      defaultCurrent: s
    });
    return () => {
      const {
        steps: g,
        current: b,
        type: y,
        rootClassName: S
      } = e, C = Ule(e, ["steps", "current", "type", "rootClassName"]), w = ee({
        [`${c.value}-primary`]: v.value === "primary",
        [`${c.value}-rtl`]: u.value === "rtl"
      }, p.value, S), $ = (I, E) => f(Wle, D(D({}, I), {}, {
        type: y,
        current: E
      }), {
        indicatorsRender: r.indicatorsRender
      }), O = (I) => {
        h(I), o("update:current", I), o("change", I);
      }, x = P(() => u0({
        arrowPointAtCenter: !0,
        autoAdjustOverflow: !0
      }));
      return d(f(Hle, D(D(D({}, n), C), {}, {
        rootClassName: w,
        prefixCls: c.value,
        current: b,
        defaultCurrent: e.defaultCurrent,
        animated: !0,
        renderPanel: $,
        onChange: O,
        steps: g,
        builtinPlacements: x.value
      }), null));
    };
  }
}), qle = kt(Yle), fE = Symbol("appConfigContext"), Zle = (e) => Je(fE, e), Qle = () => tt(fE, {}), pE = Symbol("appContext"), Jle = (e) => Je(pE, e), eae = xt({
  message: {},
  notification: {},
  modal: {}
}), tae = () => tt(pE, eae), nae = (e) => {
  const {
    componentCls: t,
    colorText: n,
    fontSize: o,
    lineHeight: r,
    fontFamily: l
  } = e;
  return {
    [t]: {
      color: n,
      fontSize: o,
      lineHeight: r,
      fontFamily: l
    }
  };
}, oae = Xe("App", (e) => [nae(e)]), rae = () => ({
  rootClassName: String,
  message: Re(),
  notification: Re()
}), lae = () => tae(), Ps = Z({
  name: "AApp",
  props: Qe(rae(), {}),
  setup(e, t) {
    let {
      slots: n
    } = t;
    const {
      prefixCls: o
    } = Ie("app", e), [r, l] = oae(o), a = P(() => ee(l.value, o.value, e.rootClassName)), i = Qle(), s = P(() => ({
      message: m(m({}, i.message), e.message),
      notification: m(m({}, i.notification), e.notification)
    }));
    Zle(s.value);
    const [c, u] = RP(s.value.message), [d, p] = UP(s.value.notification), [v, h] = QI(), g = P(() => ({
      message: c,
      notification: d,
      modal: v
    }));
    return Jle(g.value), () => {
      var b;
      return r(f("div", {
        class: a.value
      }, [h(), u(), p(), (b = n.default) === null || b === void 0 ? void 0 : b.call(n)]));
    };
  }
});
Ps.useApp = lae;
Ps.install = function(e) {
  e.component(Ps.name, Ps);
};
const vE = ["wrap", "nowrap", "wrap-reverse"], gE = ["flex-start", "flex-end", "start", "end", "center", "space-between", "space-around", "space-evenly", "stretch", "normal", "left", "right"], mE = ["center", "start", "end", "flex-start", "flex-end", "self-start", "self-end", "baseline", "normal", "stretch"], aae = (e, t) => {
  const n = {};
  return vE.forEach((o) => {
    n[`${e}-wrap-${o}`] = t.wrap === o;
  }), n;
}, iae = (e, t) => {
  const n = {};
  return mE.forEach((o) => {
    n[`${e}-align-${o}`] = t.align === o;
  }), n[`${e}-align-stretch`] = !t.align && !!t.vertical, n;
}, sae = (e, t) => {
  const n = {};
  return gE.forEach((o) => {
    n[`${e}-justify-${o}`] = t.justify === o;
  }), n;
};
function cae(e, t) {
  return ee(m(m(m({}, aae(e, t)), iae(e, t)), sae(e, t)));
}
const uae = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      display: "flex",
      "&-vertical": {
        flexDirection: "column"
      },
      "&-rtl": {
        direction: "rtl"
      },
      "&:empty": {
        display: "none"
      }
    }
  };
}, dae = (e) => {
  const {
    componentCls: t
  } = e;
  return {
    [t]: {
      "&-gap-small": {
        gap: e.flexGapSM
      },
      "&-gap-middle": {
        gap: e.flexGap
      },
      "&-gap-large": {
        gap: e.flexGapLG
      }
    }
  };
}, fae = (e) => {
  const {
    componentCls: t
  } = e, n = {};
  return vE.forEach((o) => {
    n[`${t}-wrap-${o}`] = {
      flexWrap: o
    };
  }), n;
}, pae = (e) => {
  const {
    componentCls: t
  } = e, n = {};
  return mE.forEach((o) => {
    n[`${t}-align-${o}`] = {
      alignItems: o
    };
  }), n;
}, vae = (e) => {
  const {
    componentCls: t
  } = e, n = {};
  return gE.forEach((o) => {
    n[`${t}-justify-${o}`] = {
      justifyContent: o
    };
  }), n;
}, gae = Xe("Flex", (e) => {
  const t = He(e, {
    flexGapSM: e.paddingXS,
    flexGap: e.padding,
    flexGapLG: e.paddingLG
  });
  return [uae(t), dae(t), fae(t), pae(t), vae(t)];
});
function hx(e) {
  return ["small", "middle", "large"].includes(e);
}
const mae = () => ({
  prefixCls: ke(),
  vertical: ve(),
  wrap: ke(),
  justify: ke(),
  align: ke(),
  flex: je([Number, String]),
  gap: je([Number, String]),
  component: _t()
});
var hae = function(e, t) {
  var n = {};
  for (var o in e)
    Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
};
const bae = Z({
  name: "AFlex",
  inheritAttrs: !1,
  props: mae(),
  setup(e, t) {
    let {
      slots: n,
      attrs: o
    } = t;
    const {
      flex: r,
      direction: l
    } = oc(), {
      prefixCls: a
    } = Ie("flex", e), [i, s] = gae(a), c = P(() => {
      var u;
      return [a.value, s.value, cae(a.value, e), {
        [`${a.value}-rtl`]: l.value === "rtl",
        [`${a.value}-gap-${e.gap}`]: hx(e.gap),
        [`${a.value}-vertical`]: (u = e.vertical) !== null && u !== void 0 ? u : r == null ? void 0 : r.value.vertical
      }];
    });
    return () => {
      var u;
      const {
        flex: d,
        gap: p,
        component: v = "div"
      } = e, h = hae(e, ["flex", "gap", "component"]), g = {};
      return d && (g.flex = d), p && !hx(p) && (g.gap = `${p}px`), i(f(v, D({
        class: [o.class, c.value],
        style: [o.style, g]
      }, ot(h, ["justify", "wrap", "align", "vertical"])), {
        default: () => [(u = n.default) === null || u === void 0 ? void 0 : u.call(n)]
      }));
    };
  }
}), yae = kt(bae), Sae = {
  Affix: F2,
  Anchor: Wl,
  AnchorLink: hh,
  AutoComplete: kF,
  AutoCompleteOptGroup: RF,
  AutoCompleteOption: NF,
  Alert: iL,
  Avatar: ea,
  AvatarGroup: Od,
  Badge: hs,
  BadgeRibbon: Pd,
  Breadcrumb: ta,
  BreadcrumbItem: Xs,
  BreadcrumbSeparator: Rd,
  Button: Kt,
  ButtonGroup: _d,
  Calendar: zj,
  Card: ai,
  CardGrid: zd,
  CardMeta: Ld,
  Collapse: ys,
  CollapsePanel: Hd,
  Carousel: OW,
  Cascader: Vd,
  Checkbox: io,
  CheckboxGroup: Wd,
  Col: WG,
  Comment: YG,
  ConfigProvider: oa,
  DatePicker: uU,
  MonthPicker: Mu,
  WeekPicker: Tu,
  RangePicker: Au,
  QuarterPicker: _u,
  Descriptions: Va,
  DescriptionsItem: cI,
  Divider: wU,
  Dropdown: er,
  DropdownButton: Gs,
  Drawer: pI,
  Empty: cl,
  FloatButton: bl,
  FloatButtonGroup: Yd,
  BackTop: qd,
  Form: kr,
  // FormItem,
  FormItemRest: Si,
  Grid: VG,
  Input: fn,
  InputGroup: SI,
  InputPassword: wI,
  InputSearch: CI,
  Textarea: bb,
  Image: Gl,
  ImagePreviewGroup: DI,
  InputNumber: gq,
  Layout: Eq,
  LayoutHeader: xq,
  LayoutSider: Pq,
  LayoutFooter: Oq,
  LayoutContent: Iq,
  List: al,
  ListItem: FI,
  ListItemMeta: kI,
  message: xn,
  Menu: en,
  MenuDivider: Ys,
  MenuItem: hr,
  MenuItemGroup: Us,
  SubMenu: fa,
  Mentions: NZ,
  MentionsOption: Lu,
  Modal: zn,
  Statistic: Br,
  StatisticCountdown: qZ,
  notification: pa,
  PageHeader: uQ,
  Pagination: xp,
  Popconfirm: mQ,
  Popover: p0,
  Progress: Nb,
  Radio: Un,
  RadioButton: Bd,
  RadioGroup: j0,
  Rate: oJ,
  Result: la,
  Row: yJ,
  Select: bn,
  SelectOptGroup: _F,
  SelectOption: MF,
  Skeleton: Nn,
  SkeletonButton: U0,
  SkeletonAvatar: Z0,
  SkeletonInput: Y0,
  SkeletonImage: q0,
  SkeletonTitle: rp,
  Slider: kJ,
  Space: ui,
  Compact: wd,
  Spin: br,
  Steps: eee,
  Step: zu,
  Switch: uee,
  Table: Zb,
  TableColumn: Ku,
  TableColumnGroup: Gu,
  TableSummary: Xu,
  TableSummaryRow: of,
  TableSummaryCell: rf,
  Transfer: Kne,
  Tree: k6,
  TreeNode: Wu,
  DirectoryTree: Vu,
  TreeSelect: goe,
  TreeSelectNode: Gm,
  Tabs: na,
  TabPane: Fd,
  Tag: ci,
  CheckableTag: Gd,
  TimePicker: hoe,
  TimeRangePicker: Uu,
  Timeline: Os,
  TimelineItem: tc,
  Tooltip: Ln,
  Typography: ao,
  TypographyLink: zi,
  TypographyParagraph: Hi,
  TypographyText: ji,
  TypographyTitle: Vi,
  Upload: J6,
  UploadDragger: zre,
  LocaleProvider: AP,
  Watermark: Ure,
  Segmented: nle,
  QRCode: Tle,
  Tour: qle,
  App: Ps,
  Flex: yae
}, Cae = {}, $ae = {
  ...Cae
}, wae = Object.values($ae), xae = {
  value: {
    required: !0,
    type: [String, Number, Array],
    default() {
      return [];
    }
  },
  arraySplit: {
    required: !1,
    default: ","
  }
}, Oae = Z({
  inheritAttrs: !1,
  props: xae,
  emits: wae
}), _n = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [o, r] of t)
    n[o] = r;
  return n;
}, Pae = { class: "des-color" };
function Iae(e, t, n, o, r, l) {
  const a = st("m-tooltip");
  return Ne(), Et(a, null, {
    title: pt(() => [
      Ot(dn(e.value ? e.value : "-"), 1)
    ]),
    default: pt(() => [
      rn("span", Pae, dn(e.value ? e.value : "-"), 1)
    ]),
    _: 1
  });
}
const Eae = /* @__PURE__ */ _n(Oae, [["render", Iae], ["__scopeId", "data-v-37663f9f"]]), Tae = {
  small: "small",
  // 小尺寸
  middle: "middle",
  // 中尺寸
  large: "large"
  // 大尺寸
}, Pc = {
  normal: "normal",
  // 白色背景，黑色文字，主要用于取消等无操作按钮
  fail: "fail",
  // 红色背景，主要用于拒绝
  success: "success"
  // 蓝色背景，主要用于通过或者是主按钮
}, Mae = {}, _ae = {
  type: "type",
  danger: "danger"
}, Aae = {}, Dae = {}, Nae = {
  ...Dae
}, Rae = Object.values(Nae), kae = {
  // 类型
  mode: {
    required: !1,
    type: String,
    default() {
      return Pc.normal;
    }
  }
};
function Bae() {
  function e(t) {
    const { style: n, ...o } = t;
    delete o.class;
    for (const r of Object.values(_ae))
      delete o[r];
    return Object.assign(
      _e(o),
      _e(Mae),
      _e(o)
    );
  }
  return {
    getProps: e
  };
}
function Fae() {
  function e(t) {
    const { ...n } = t;
    for (const o of Object.values(Aae))
      delete n[o];
    return n;
  }
  return {
    getSlots: e
  };
}
const Lae = Z({
  components: {
    aButton: Kt
  },
  inheritAttrs: !1,
  props: kae,
  emits: Rae,
  setup(e, { expose: t }) {
    const { getProps: n } = Bae(), { getSlots: o } = Fae();
    return t({}), {
      MODE: Pc,
      SIZE: Tae,
      getProps: n,
      getSlots: o
    };
  }
});
function zae(e, t, n, o, r, l) {
  const a = st("a-button");
  return Ne(), Et(a, Ft({
    class: ["m-button", e.$attrs.class]
  }, e.getProps(e.$attrs), {
    style: e.$attrs.style,
    type: e.mode === e.MODE.success ? "primary" : "default",
    danger: e.mode === e.MODE.fail
  }), Sr({ _: 2 }, [
    ln(e.getSlots(e.$slots), (i, s) => ({
      name: s,
      fn: pt((c) => [
        Bn(e.$slots, s, Ft(c, { key: s }), void 0, !0)
      ])
    }))
  ]), 1040, ["class", "style", "type", "danger"]);
}
const Hae = /* @__PURE__ */ _n(Lae, [["render", zae], ["__scopeId", "data-v-bad60a70"]]), jae = {
  showSearch: !0,
  // 当当选的时候，需要配置此项才能搜索。多选自带搜索
  // 不自定义搜索函数，是按照value进行搜索的
  // ！这里需要注意，如果option中的文字字段不是label，要手动传入filterOption，否则搜索会报错
  filterOption: function(e, t) {
    return t.label.includes(e);
  }
}, Vae = {}, Wae = {}, Kae = {}, lf = {
  ...Kae,
  updateValue: "update:value"
}, Gae = Object.values(lf), Xae = {
  mode: {
    required: !1,
    type: String
  },
  value: {
    required: !1,
    type: [Number, String, Array]
  },
  options: {
    required: !1,
    type: Array
  },
  fieldNames: {
    required: !1,
    type: Object
  },
  // 多选时，是否开启全选功能
  enableSelectAll: {
    required: !1,
    type: Boolean,
    default() {
      return !0;
    }
  }
};
function Uae() {
  function e(t) {
    const { style: n, ...o } = t;
    delete o.class;
    for (const r of Object.values(Vae))
      delete o[r];
    return Object.assign(
      _e(o),
      _e(jae),
      _e(o)
    );
  }
  return {
    getProps: e
  };
}
function Yae() {
  function e(t) {
    const { ...n } = t;
    for (const o of Object.values(Wae))
      delete n[o];
    return n;
  }
  return {
    getSlots: e
  };
}
function qae(e, t) {
  return e.value && e.value[t] || t;
}
function Zae(e, t, n, o, r) {
  function l(u, d = []) {
    return u.forEach((p) => {
      d.push(p[qae(o, "value")]);
    }), d;
  }
  const a = P(() => ["multiple", "tags"].includes(e.value)), i = P(() => {
    if (!a.value)
      return !1;
    const u = l(n.value);
    return t.value.length === u.length;
  }), s = P(() => {
    if (!a.value)
      return !1;
    const u = l(n.value);
    return t.value.length > 0 && t.value.length < u.length;
  });
  function c() {
    if (!a)
      return !1;
    const u = l(n.value);
    i.value ? r(lf.updateValue, []) : r(lf.updateValue, u);
  }
  return {
    isMultipleRef: a,
    checkboxValueCp: i,
    checkboxIndeterminateCp: s,
    handleCheckAllChange: c
  };
}
const Qae = Z({
  components: {
    aFormItemRest: Si,
    aSelect: bn,
    aCheckbox: io,
    aTooltip: Ln
  },
  inheritAttrs: !1,
  props: Xae,
  emits: Gae,
  setup(e, { emit: t, expose: n }) {
    const { getProps: o } = Uae(), { getSlots: r } = Yae();
    function l(d) {
      t(lf.updateValue, d);
    }
    const { isMultipleRef: a, checkboxValueCp: i, checkboxIndeterminateCp: s, handleCheckAllChange: c } = Zae(
      Te(e, "mode"),
      Te(e, "value"),
      Te(e, "options"),
      Te(e, "fieldNames"),
      t
    );
    return n({}), {
      getProps: o,
      getSlots: r,
      handleUpdateValue: l,
      isMultipleRef: a,
      checkboxValueCp: i,
      checkboxIndeterminateCp: s,
      handleCheckAllChange: c
    };
  }
}), Jae = { class: "m-select" };
function eie(e, t, n, o, r, l) {
  const a = st("a-select"), i = st("a-checkbox"), s = st("a-tooltip"), c = st("a-form-item-rest");
  return Ne(), it("div", Jae, [
    f(a, Ft(e.getProps(e.$attrs), {
      value: e.value,
      class: [e.$attrs.class],
      style: e.$attrs.style,
      mode: e.mode,
      options: e.options,
      fieldNames: e.fieldNames,
      "onUpdate:value": e.handleUpdateValue
    }), Sr({ _: 2 }, [
      ln(e.getSlots(e.$slots), (u, d) => ({
        name: d,
        fn: pt((p) => [
          Bn(e.$slots, d, Ft(p, { key: d }), void 0, !0)
        ])
      }))
    ]), 1040, ["value", "class", "style", "mode", "options", "fieldNames", "onUpdate:value"]),
    f(c, null, {
      default: pt(() => [
        e.enableSelectAll && e.isMultipleRef ? (Ne(), Et(s, { key: 0 }, {
          title: pt(() => [
            Ot("是否多选？")
          ]),
          default: pt(() => [
            f(i, {
              checked: e.checkboxValueCp,
              class: "ml-8px",
              indeterminate: e.checkboxIndeterminateCp,
              onChange: e.handleCheckAllChange
            }, null, 8, ["checked", "indeterminate", "onChange"])
          ]),
          _: 1
        })) : ht("", !0)
      ]),
      _: 1
    })
  ]);
}
const tie = /* @__PURE__ */ _n(Qae, [["render", eie], ["__scopeId", "data-v-b84323e0"]]), nie = {
  // 默认均开启搜索
  showSearch: !0
}, oie = {}, rie = {}, lie = {}, af = {
  ...lie,
  updateValue: "update:value"
}, aie = Object.values(af), iie = {
  value: {
    required: !1,
    type: [Number, String, Array]
  },
  options: {
    required: !1,
    type: Array
  },
  fieldNames: {
    required: !1,
    type: Object
  },
  multiple: {
    required: !1,
    type: Boolean
  },
  showCheckedStrategy: {
    required: !1,
    type: String,
    default() {
      return "SHOW_PARENT";
    }
  },
  // 多选时，是否开启全选功能
  enableSelectAll: {
    required: !1,
    type: Boolean,
    default() {
      return !0;
    }
  }
};
function sie() {
  function e(t) {
    const { style: n, ...o } = t;
    delete o.class;
    for (const r of Object.values(oie))
      delete o[r];
    return Object.assign(
      _e(o),
      _e(nie),
      _e(o)
    );
  }
  return {
    getProps: e
  };
}
function cie() {
  function e(t) {
    const { ...n } = t;
    for (const o of Object.values(rie))
      delete n[o];
    return n;
  }
  return {
    getSlots: e
  };
}
const Qi = {
  none: 0,
  // 未选中
  part: 1,
  // 部分选中
  all: 2
  // 全选
};
function ka(e, t) {
  return e.value && e.value[t] || t;
}
function uie(e, t, n, o, r, l) {
  function a(v, h = [], g = []) {
    return v.forEach((b) => {
      b[ka(o, "children")] && b[ka(o, "children")].length > 0 ? (h.push(b[ka(o, "value")]), a(b[ka(o, "children")], h, g), h.pop()) : (h.push(b[ka(o, "value")]), g.push([...h]), h.pop());
    }), g;
  }
  function i(v, h = []) {
    return r.value === Vd.SHOW_CHILD ? h.push(...a(n.value)) : v.forEach((g) => {
      h.push([g[ka(o, "value")]]);
    }), h;
  }
  const s = P(() => e.value), c = P(() => t.value.length === 0 ? Qi.none : r.value === Vd.SHOW_CHILD && t.value.length === i(n.value).length || t.value.length === i(n.value).length && t.value.every((v) => v.length === 1) ? Qi.all : Qi.part), u = P(() => s.value ? c.value === Qi.all : !1), d = P(() => s.value ? c.value === Qi.part : !1);
  function p() {
    if (!s)
      return !1;
    const v = i(n.value);
    u.value ? l(af.updateValue, []) : l(af.updateValue, v);
  }
  return {
    isMultipleRef: s,
    checkboxValueCp: u,
    checkboxIndeterminateCp: d,
    handleCheckAllChange: p
  };
}
const die = Z({
  components: {
    aFormItemRest: Si,
    aCascader: Vd,
    aCheckbox: io,
    aTooltip: Ln
  },
  inheritAttrs: !1,
  props: iie,
  emits: aie,
  setup(e, { emit: t, expose: n }) {
    const { getProps: o } = sie(), { getSlots: r } = cie();
    function l(d) {
      t(af.updateValue, d);
    }
    const { isMultipleRef: a, checkboxValueCp: i, checkboxIndeterminateCp: s, handleCheckAllChange: c } = uie(
      Te(e, "multiple"),
      Te(e, "value"),
      Te(e, "options"),
      Te(e, "fieldNames"),
      Te(e, "showCheckedStrategy"),
      t
    );
    return n({}), {
      getProps: o,
      getSlots: r,
      handleUpdateValue: l,
      isMultipleRef: a,
      checkboxValueCp: i,
      checkboxIndeterminateCp: s,
      handleCheckAllChange: c
    };
  }
}), fie = { class: "m-cascader" };
function pie(e, t, n, o, r, l) {
  const a = st("a-cascader"), i = st("a-checkbox"), s = st("a-tooltip"), c = st("a-form-item-rest");
  return Ne(), it("div", fie, [
    f(a, Ft(e.getProps(e.$attrs), {
      value: e.value,
      class: [e.$attrs.class],
      style: e.$attrs.style,
      multiple: e.multiple,
      options: e.options,
      fieldNames: e.fieldNames,
      showCheckedStrategy: e.showCheckedStrategy,
      "onUpdate:value": e.handleUpdateValue
    }), Sr({ _: 2 }, [
      ln(e.getSlots(e.$slots), (u, d) => ({
        name: d,
        fn: pt((p) => [
          Bn(e.$slots, d, Ft(p, { key: d }), void 0, !0)
        ])
      }))
    ]), 1040, ["value", "class", "style", "multiple", "options", "fieldNames", "showCheckedStrategy", "onUpdate:value"]),
    f(c, null, {
      default: pt(() => [
        e.enableSelectAll && e.isMultipleRef ? (Ne(), Et(s, { key: 0 }, {
          title: pt(() => [
            Ot("是否多选？")
          ]),
          default: pt(() => [
            f(i, {
              checked: e.checkboxValueCp,
              class: "ml-8px",
              indeterminate: e.checkboxIndeterminateCp,
              onChange: e.handleCheckAllChange
            }, null, 8, ["checked", "indeterminate", "onChange"])
          ]),
          _: 1
        })) : ht("", !0)
      ]),
      _: 1
    })
  ]);
}
const vie = /* @__PURE__ */ _n(die, [["render", pie], ["__scopeId", "data-v-130186d2"]]), gie = {
  componentName: "mInput",
  vModelKey: "value",
  defaultValue: "",
  // 作为page的条件时的配置
  condition: {
    enableEnterQuery: !0
    // 默认开启回车搜索功能
  },
  componentProps: {
    allowClear: !0
  }
}, mie = {
  componentName: "mSelect",
  vModelKey: "value",
  defaultValue: "",
  // 作为page的条件时的配置
  condition: {},
  componentProps: {
    allowClear: !0
  }
}, hie = {
  componentName: "mCascader",
  vModelKey: "value",
  defaultValue: [],
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, bie = {
  componentName: "mCheckbox",
  vModelKey: "checked",
  defaultValue: !1,
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, yie = {
  componentName: "mCheckboxGroup",
  vModelKey: "value",
  defaultValue: [],
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Sie = {
  componentName: "mDatePicker",
  vModelKey: "value",
  defaultValue: null,
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Cie = {
  componentName: "mRangePicker",
  vModelKey: "value",
  defaultValue: [],
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, $ie = {
  componentName: "mInputNumber",
  vModelKey: "value",
  defaultValue: void 0,
  // 作为page的条件时的配置
  condition: {
    enableEnterQuery: !0
    // 默认开启回车搜索功能
  },
  componentProps: {}
}, wie = {
  componentName: "mInputPassword",
  vModelKey: "value",
  defaultValue: void 0,
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, xie = {
  componentName: "mInputSearch",
  vModelKey: "value",
  defaultValue: void 0,
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Oie = {
  componentName: "mTextarea",
  vModelKey: "value",
  defaultValue: "",
  // 作为page的条件时的配置
  condition: {},
  componentProps: {
    allowClear: !0
  }
}, Pie = {
  componentName: "mMentions",
  vModelKey: "value",
  defaultValue: "",
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Iie = {
  componentName: "mRadioGroup",
  vModelKey: "value",
  defaultValue: "",
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Eie = {
  componentName: "mRate",
  vModelKey: "value",
  defaultValue: void 0,
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Tie = {
  componentName: "mSlider",
  vModelKey: "value",
  defaultValue: void 0,
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Mie = {
  componentName: "mSwitch",
  vModelKey: "checked",
  defaultValue: !1,
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, _ie = {
  componentName: "mTimePicker",
  vModelKey: "value",
  defaultValue: null,
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Aie = {
  componentName: "mTimeRangePicker",
  vModelKey: "value",
  defaultValue: [],
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Die = {
  componentName: "mTreeSelect",
  vModelKey: "value",
  defaultValue: "",
  // 作为page的条件时的配置
  condition: {},
  componentProps: {
    allowClear: !0
  }
}, Nie = {
  componentName: "mAutoComplete",
  vModelKey: "value",
  defaultValue: "",
  // 作为page的条件时的配置
  condition: {},
  componentProps: {
    allowClear: !0
  }
}, Rie = {
  componentName: "mUpload",
  vModelKey: "fileList",
  defaultValue: [],
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, kie = {
  componentName: "mPreviewDownload",
  vModelKey: "url",
  defaultValue: "",
  // 作为page的条件时的配置
  condition: {},
  componentProps: {}
}, Bie = {
  componentName: "mFormItemDes",
  vModelKey: "value",
  // 作为page的条件时的配置
  condition: {},
  defaultValue: ""
}, hy = {
  mInput: gie,
  mSelect: mie,
  mCascader: hie,
  mCheckbox: bie,
  mCheckboxGroup: yie,
  mDatePicker: Sie,
  mRangePicker: Cie,
  mInputNumber: $ie,
  mInputPassword: wie,
  mInputSearch: xie,
  textarea: Oie,
  mMentions: Pie,
  mRadioGroup: Iie,
  mRate: Eie,
  mSlider: Tie,
  mSwitch: Mie,
  mTimePicker: _ie,
  mTimeRangePicker: Aie,
  mTreeSelect: Die,
  mAutoComplete: Nie,
  mUpload: Rie,
  mPreviewDownload: kie,
  // form 组件部分
  mFormItemDes: Bie
}, Ia = {
  tableCondition: "tableCondition",
  normal: "normal"
}, by = {
  horizontal: "horizontal",
  vertical: "vertical"
}, Fie = "value", Lie = {
  // label 默认靠右侧对齐
  labelAlign: "right",
  // label与展示组件是左右排列还是上下排列
  layout: by.horizontal,
  // 文字后面是否自动加冒号
  colon: !0,
  // 提交失败是否自动滚动到第一个错误
  scrollToFirstError: !0
}, zie = {
  model: "model"
}, Hie = {
  default: "default"
}, jie = {};
function Vie(e) {
  const t = {
    // label与展示组件左右排列时，labelCol的宽度占比 6 / 24
    labelCol: {
      span: 6
    },
    // label与展示组件左右排列时，展示组件的宽度占比 18 / 24
    wrapperCol: {
      span: 18
    }
  }, n = {
    labelCol: {
      span: 24
    },
    wrapperCol: {
      span: 24
    }
  }, o = e === by.vertical ? n : t;
  return {
    ...Lie,
    ...o
  };
}
const Wie = {}, Kie = (e) => {
  let t = {
    name: "name"
  };
  return e && e.label && (t = {
    ...t,
    label: "label"
  }), t;
}, Gie = {
  default: "default"
}, Xie = {}, bx = {}, Uie = {}, Yie = {}, qie = {}, Wa = {
  ...jie,
  ...Xie,
  ...qie,
  query: "query",
  reset: "reset",
  change: "change",
  pressEnter: "pressEnter"
}, Zie = Object.values(Wa), Qie = {
  // 绑定的值
  modelValue: {
    required: !0,
    type: Object
  },
  // 内容项数组
  items: {
    required: !0,
    type: Array
  },
  // 值有 form 或者 tableCondition，作为form表单还是页面的查询条件
  type: {
    required: !1,
    type: String,
    default() {
      return Ia.normal;
    }
  },
  // 列的数量，值有1、2、3、4、5五种情况
  columnsNumber: {
    required: !1,
    type: Number,
    default() {
      return 3;
    }
  },
  // label与组件的排列
  layout: {
    required: !1,
    type: String,
    default() {
      return by.horizontal;
    }
  }
};
function hE(e) {
  return !hy[e];
}
function Jie() {
  function e(o, r) {
    let { style: l, ...a } = o;
    delete a.class;
    for (const i of Object.values(zie))
      delete a[i];
    return Object.assign(
      _e(a),
      _e(Vie(r)),
      _e(a)
    );
  }
  function t(o) {
    const r = _e(o);
    for (const l of Object.values(Kie(o)))
      delete r[l];
    return Object.assign(
      _e(r),
      _e(Wie),
      _e(r)
    );
  }
  function n(o) {
    let r = o.componentProps;
    for (const l of Object.values(Uie))
      delete r[l];
    if (hE(o.componentName))
      return Object.assign(
        r,
        _e(bx),
        _e(r)
      );
    {
      const l = hy[yO(o.componentName)].componentProps;
      return Object.assign(
        r,
        _e(bx),
        _e(l),
        _e(r)
      );
    }
  }
  return {
    getFormProps: e,
    getFormItemProps: t,
    getFormItemComponentProps: n
  };
}
function ese(e) {
  return {
    gridClassCp: P(() => {
      if (e.value === 5)
        return {
          display: "grid",
          "grid-template-columns": "calc((100% - 8 * 4px)/5) calc((100% - 8 * 4px)/5) calc((100% - 8 * 4px)/5) calc((100% - 8 * 3px)/4) calc((100% - 8 * 3px)/4)",
          "grid-column-gap": "8px"
        };
      if (e.value === 4)
        return {
          display: "grid",
          "grid-template-columns": "calc((100% - 8 * 3px)/4) calc((100% - 8 * 3px)/4) calc((100% - 8 * 3px)/4) calc((100% - 8 * 3px)/4)",
          "grid-column-gap": "8px"
        };
      if (e.value === 3)
        return {
          display: "grid",
          "grid-template-columns": "calc((100% - 8 * 2px)/3) calc((100% - 8 * 2px)/3) calc((100% - 8 * 2px)/3)",
          "grid-column-gap": "8px"
        };
      if (e.value === 2)
        return {
          display: "grid",
          "grid-template-columns": "calc((100% - 8px)/2) calc((100% - 8px)/2)",
          "grid-column-gap": "8px"
        };
      if (e.value === 1)
        return {
          display: "grid",
          "grid-template-columns": "100%"
        };
    })
  };
}
function tse(e) {
  const t = Y(e.value !== Ia.tableCondition), n = P(() => t.value ? "auto" : "32px"), o = P(() => t.value ? "visible" : "hidden");
  function r() {
    t.value = !t.value;
  }
  return {
    isExpandRef: t,
    formHeightCp: n,
    overflowCp: o,
    handleToggleExpand: r
  };
}
typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope;
const nse = (e) => typeof e < "u";
function ose(e) {
  return JSON.parse(JSON.stringify(e));
}
function Ap(e, t, n, o = {}) {
  var r, l, a;
  const {
    clone: i = !1,
    passive: s = !1,
    eventName: c,
    deep: u = !1,
    defaultValue: d,
    shouldEmit: p
  } = o, v = Wn(), h = n || (v == null ? void 0 : v.emit) || ((r = v == null ? void 0 : v.$emit) == null ? void 0 : r.bind(v)) || ((a = (l = v == null ? void 0 : v.proxy) == null ? void 0 : l.$emit) == null ? void 0 : a.bind(v == null ? void 0 : v.proxy));
  let g = c;
  t || (t = "modelValue"), g = g || `update:${t.toString()}`;
  const b = (C) => i ? typeof i == "function" ? i(C) : ose(C) : C, y = () => nse(e[t]) ? b(e[t]) : d, S = (C) => {
    p ? p(C) && h(g, C) : h(g, C);
  };
  if (s) {
    const C = y(), w = Y(C);
    let $ = !1;
    return ie(
      () => e[t],
      (O) => {
        $ || ($ = !0, w.value = b(O), rt(() => $ = !1));
      }
    ), ie(
      w,
      (O) => {
        !$ && (O !== e[t] || u) && S(O);
      },
      { deep: u }
    ), w;
  } else
    return P({
      get() {
        return y();
      },
      set(C) {
        S(C);
      }
    });
}
function yx(e, t) {
  let n = e.value[t.uploadKey];
  [null, void 0].includes(n) && (n = t.defaultValue), e.value[t.uploadKey] = n;
}
function rse(e, t, n) {
  const o = Ap(n, "modelValue", t);
  function r() {
    e.value.forEach((a) => {
      !a.uploadKey || a.hidden || yx(o, a);
    });
  }
  function l(a) {
    a.hidden ? delete o.value[a.uploadKey] : o.value.hasOwnProperty(a.uploadKey) || yx(o, a);
  }
  return ie(
    [() => n.modelValue],
    () => {
      r();
    },
    {
      immediate: !0
    }
  ), ie(
    e,
    () => {
      e.value.forEach((a) => {
        l(a);
      });
    },
    {
      deep: !0
    }
  ), {
    antFormModelVM: o
  };
}
function lse() {
  function e(o) {
    const { ...r } = o;
    for (const l of Object.values(Hie))
      delete r[l];
    return r;
  }
  function t(o) {
    const { ...r } = o;
    for (const l of Object.values(Gie))
      delete r[l];
    return r;
  }
  function n(o) {
    const { ...r } = o;
    for (const l of Object.values(Yie))
      delete r[l];
    return r;
  }
  return {
    getFormSlots: e,
    getFormItemSlots: t,
    getFormItemComponentSlots: n
  };
}
const Vt = {
  number: "number",
  boolean: "boolean",
  string: "string",
  null: "null",
  undefined: "undefined",
  function: "function",
  array: "array",
  object: "object"
}, Sx = {
  type: Ia.tableCondition,
  formItemProps: {
    labelCol: {
      span: 0
    },
    wrapperCol: {
      span: 24
    }
  }
}, ase = {
  // 组件名称
  componentName: {
    required: !0,
    // string为函数名称，object为引用的组件实例，function为render函数
    type: [Vt.string, Vt.object, Vt.function]
  },
  // 上传所需要的字段
  uploadKey: {
    required: !0,
    type: [Vt.string]
  },
  // v-model绑定的内容，默认为value，checkbox为checked，具体内容看注释
  vModelKey: {
    required: !1,
    type: [Vt.number, Vt.string]
  },
  // 默认值
  defaultValue: {
    required: !1,
    type: [Vt.number, Vt.boolean, Vt.string, Vt.array, Vt.object]
  },
  // 表单是否不展示
  hidden: {
    required: !1,
    type: [Vt.boolean],
    default() {
      return !1;
    }
  },
  // enableChangeQuery： 当type类型为 tableCondition，数据改变时触发搜索功能
  // enableEnterQuery： 当type类型为 tableCondition，回车时触发搜索功能，目前仅支持input和InputNumber组件
  condition: {
    required: !1,
    type: [Vt.object],
    default() {
      return {};
    }
  },
  // ant-design-vue form-item属性
  formItemProps: {
    required: !1,
    type: [Vt.object],
    default() {
      return {};
    }
  },
  // ant-design vue 组件内容属性
  componentProps: {
    required: !1,
    type: [Vt.object],
    default() {
      return {};
    }
  }
};
function ise(e) {
  return typeof e == "number" ? Vt.number : typeof e == "boolean" ? Vt.boolean : typeof e == "string" ? Vt.string : e === null ? Vt.null : e === void 0 ? Vt.undefined : Array.isArray(e) ? Vt.array : Vt.object;
}
function ng(e, t) {
  return e.hasOwnProperty(t);
}
function sse(e, t) {
  return t.some((n) => ise(e) === n);
}
function bE(e, t) {
  for (const [n, o] of Object.entries(t)) {
    if (o.required && !ng(e, n))
      throw new Error(`${n}字段为必填项！`);
    if (ng(e, n) && !sse(e[n], o.type))
      throw new Error(`${n}字段类型错误！支持${o.type}`);
    !ng(e, n) && o.default && (e[n] = o.default());
  }
}
function cse(e, t) {
  e === Ia.tableCondition && (t.length <= 2 ? t.splice(t.length, 0, Sx) : t.splice(2, 0, Sx));
}
function use(e, t) {
  return {
    itemsCp: P(() => {
      if (e.value.length === 0)
        return [];
      const o = _e(e.value);
      return o.forEach((r, l) => {
        if (r.type !== Ia.tableCondition)
          if (bE(r, ase), hE(r.componentName))
            r.vModelKey = r.vModelKey || Fie;
          else {
            const a = _e(hy[yO(o[l].componentName)]), i = a.componentProps;
            delete a.componentProps, Object.assign(r, _e(a), _e(r)), Object.assign(
              r.componentProps,
              _e(i),
              _e(r.componentProps)
            );
          }
      }), cse(t.value, o), o;
    })
  };
}
function dse(e, t, n) {
  function o() {
    const i = _e(e.value), s = t.value;
    n(Wa.reset, i, s);
  }
  function r() {
    const i = _e(e.value), s = t.value;
    n(Wa.query, i, s);
  }
  function l(i, ...s) {
    i.condition.enableChangeQuery && r(), n(Wa.change, ...s);
  }
  function a(i, ...s) {
    if (!i.condition.enableEnterQuery) {
      n(Wa.pressEnter, ...s);
      return;
    }
    r(), n(Wa.pressEnter, ...s);
  }
  return {
    handleReset: o,
    handleQuery: r,
    handleComponentChange: l,
    handlePressEnter: a
  };
}
const fse = Z({
  components: {
    aForm: kr,
    aFormItem: EP,
    DownOutlined: Or
  },
  inheritAttrs: !1,
  props: Qie,
  emits: Zie,
  setup(e, { emit: t, expose: n }) {
    const o = Y(), { getFormProps: r, getFormItemProps: l, getFormItemComponentProps: a } = Jie(), { getFormSlots: i, getFormItemSlots: s, getFormItemComponentSlots: c } = lse(), { itemsCp: u } = use(Te(e, "items"), Te(e, "type")), { gridClassCp: d } = ese(Te(e, "columnsNumber")), { isExpandRef: p, formHeightCp: v, overflowCp: h, handleToggleExpand: g } = tse(
      Te(e, "type")
    ), { antFormModelVM: b } = rse(u, t, e), { handleReset: y, handleQuery: S, handleComponentChange: C, handlePressEnter: w } = dse(
      b,
      o,
      t
    );
    return n({
      antFormComponent: o,
      antFormModel: b,
      handleQuery: S
    }), {
      TYPE: Ia,
      formCompRef: o,
      itemsCp: u,
      handleReset: y,
      handleQuery: S,
      antFormModelVM: b,
      gridClassCp: d,
      isExpandRef: p,
      formHeightCp: v,
      overflowCp: h,
      handleToggleExpand: g,
      getFormProps: r,
      getFormItemProps: l,
      getFormItemComponentProps: a,
      handleComponentChange: C,
      getFormSlots: i,
      getFormItemSlots: s,
      getFormItemComponentSlots: c,
      handlePressEnter: w
    };
  }
}), pse = {
  key: 0,
  class: "flex justify-end"
};
function vse(e, t, n, o, r, l) {
  const a = st("m-button"), i = st("down-outlined"), s = st("a-form-item"), c = st("a-form");
  return e.items.length > 0 ? (Ne(), it("div", {
    key: 0,
    class: aa(["m-form", e.$attrs.class]),
    style: Fr({
      ...e.$attrs.style,
      height: e.formHeightCp,
      overflow: e.overflowCp
    })
  }, [
    f(c, Ft({ ref: "formCompRef" }, e.getFormProps(e.$attrs, e.layout), {
      model: e.antFormModelVM,
      layout: e.layout
    }), {
      default: pt(() => [
        rn("div", {
          style: Fr({ ...e.gridClassCp })
        }, [
          (Ne(!0), it(Fe, null, ln(e.itemsCp, (u, d) => Tn((Ne(), Et(s, Ft({
            key: d,
            name: u.uploadKey,
            ref_for: !0
          }, e.getFormItemProps(u.formItemProps || {})), Sr({
            default: pt(() => [
              u.type === e.TYPE.tableCondition ? (Ne(), it("div", pse, [
                f(a, {
                  size: "middle",
                  onClick: e.handleReset
                }, {
                  default: pt(() => [
                    Ot("重置")
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                f(a, {
                  type: "primary",
                  class: "ml-8px",
                  size: "middle",
                  mode: "success",
                  onClick: e.handleQuery
                }, {
                  default: pt(() => [
                    Ot("查询")
                  ]),
                  _: 1
                }, 8, ["onClick"]),
                e.itemsCp.length > 3 ? (Ne(), Et(i, {
                  key: 0,
                  class: aa(["drop-icon", e.isExpandRef ? "rotate" : ""]),
                  onClick: e.handleToggleExpand
                }, null, 8, ["class", "onClick"])) : ht("", !0)
              ])) : (Ne(), it(Fe, { key: 1 }, [
                u.componentName === "mCascader" ? (Ne(), Et(Dy(u.componentName), Ft({
                  key: 0,
                  ref_for: !0
                }, e.getFormItemComponentProps(u), {
                  [u.vModelKey]: e.antFormModelVM[u.uploadKey],
                  ["onUpdate:" + u.vModelKey]: (p) => e.antFormModelVM[u.uploadKey] = p,
                  onChange: (...p) => e.handleComponentChange(u, ...p)
                }), null, 16, ["onChange"])) : (Ne(), Et(Dy(u.componentName), Ft({
                  key: 1,
                  ref_for: !0
                }, e.getFormItemComponentProps(u), {
                  [u.vModelKey]: e.antFormModelVM[u.uploadKey],
                  ["onUpdate:" + u.vModelKey]: (p) => e.antFormModelVM[u.uploadKey] = p,
                  onPressEnter: (p) => e.handlePressEnter(u),
                  onChange: (...p) => e.handleComponentChange(u, ...p)
                }), Sr({ _: 2 }, [
                  ln(e.getFormItemComponentSlots(e.$slots), (p, v) => ({
                    name: v,
                    fn: pt((h) => [
                      Bn(e.$slots, v, Ft({ ref_for: !0 }, { ...h, ...u }, { key: v }), void 0, !0)
                    ])
                  }))
                ]), 1040, ["onPressEnter", "onChange"]))
              ], 64))
            ]),
            _: 2
          }, [
            u.type !== e.TYPE.tableCondition ? {
              name: "label",
              fn: pt(() => [
                rn("div", null, dn(u.formItemProps && u.formItemProps.label), 1)
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["name"])), [
            [Hn, !u.hidden]
          ])), 128))
        ], 4)
      ]),
      _: 3
    }, 16, ["model", "layout"])
  ], 6)) : ht("", !0);
}
const gse = /* @__PURE__ */ _n(fse, [["render", vse], ["__scopeId", "data-v-ee6f1f1d"]]), mse = 100, Um = {
  current: 1,
  pageSize: 10,
  total: 0,
  pageSizeOptions: ["10", "20", "50", "100"],
  showSizeChanger: !0,
  showQuickJumper: !0,
  showTotal: (e) => `共有 ${e} 条数据`
}, yE = {
  current: "pageNumber",
  // 当前页数
  pageSize: "pageSize",
  // 每页数量
  total: "totalElements",
  // 总页数
  currentFromNumber: 0
  // current上传的值与实际值的区别，从0开始为-1，从1开始为0
}, wi = {
  content: {
    // 是否展示
    visible: !1,
    // 跨页面是否包含之前内容
    enableCrossPage: !1,
    // 多选是否禁止操作函数
    /* eslint-disable-next-line */
    getCheckboxProps(e) {
      return {
        disabled: !1
      };
    }
  },
  // 底部按钮区域
  items: {
    // 是否不展示
    hidden: !1,
    // 是否禁止操作
    disabled: !1,
    label: void 0,
    loading: !1,
    // 点击回调
    confirmAsync() {
      console.error("未提供必输confirmAsync函数");
    },
    // 按钮类型
    mode: Pc.normal
  }
}, SE = {
  title: "序号",
  dataIndex: "index",
  fixed: "left",
  width: 70
}, yy = {
  title: "操作",
  dataIndex: "operationsColumn",
  fixed: "right",
  width: void 0,
  ellipsis: !1
}, Sy = {
  normal: "normal",
  drop: "drop"
}, hse = {
  // 展示按钮还是在dropdown中展示
  type: Sy.normal,
  // 获取是否不展示函数
  getHidden() {
    return !1;
  },
  // 获取是否禁止操作函数
  getDisabled() {
    return !1;
  },
  label: void 0,
  // 是否展示modal
  isShowModal: !1,
  // modal的title
  modalTitle: "提示",
  // 获取modal content的函数；如果不传入，modal的提示内容为  确定${label}？ 为准
  getModalContent: void 0,
  // 操作回调
  confirmAsync() {
    console.error("用户未提供必输confirmAsync函数");
  },
  // 内部，不展示
  _hidden: void 0,
  // 内部，禁止操作
  _disabled: void 0
}, Ji = {
  typeConfig: "typeConfig"
}, Dr = {
  button: "button",
  // 操作，比如打开弹窗
  copy: "copy",
  // 赋值操作
  jump: "jump",
  // a标签效果，打开新页面
  switch: "switch",
  // 状态切换
  status: "status",
  // 带有原型标识和文字描述的状态
  previewDownload: "previewDownload",
  // 预览或下载功能
  words: "words"
  // 普通文字类型
}, bse = {
  init: "init",
  process: "process",
  success: "success",
  fail: "fail"
}, Cx = {
  button: {
    type: Dr.button,
    /* eslint-disable-next-line */
    getDisabled(e) {
      return !1;
    },
    /* eslint-disable-next-line */
    click(e) {
    }
  },
  copy: {
    type: Dr.copy,
    /* eslint-disable-next-line */
    getEnable(e) {
      return !0;
    }
  },
  jump: {
    type: Dr.jump,
    /* eslint-disable-next-line */
    getDisabled(e) {
      return !1;
    },
    /* eslint-disable-next-line */
    click(e) {
    }
  },
  switch: {
    type: Dr.switch,
    /* eslint-disable-next-line */
    getChecked(e) {
    },
    /* eslint-disable-next-line */
    getDisabled(e) {
      return !1;
    },
    /* eslint-disable-next-line */
    getLeftLabel(e) {
      return "关闭";
    },
    /* eslint-disable-next-line */
    getRightLabel(e) {
      return "开启";
    },
    /* eslint-disable-next-line */
    getTitle(e) {
      return "确定切换？";
    },
    /* eslint-disable-next-line */
    getContent(e) {
      return "";
    },
    // 点击确定
    confirmAsync(e) {
      console.error("未提供必填的confirmAsync函数", e);
    }
  },
  status: {
    type: Dr.status,
    /* eslint-disable-next-line */
    getStatus(e) {
      return bse.init;
    },
    init: {
      chartColor: "#d9d9d9",
      color: "rgba(0, 0, 0, 0.88)"
    },
    process: {
      chartColor: "#1677ff",
      color: "rgba(0, 0, 0, 0.88)"
    },
    success: {
      chartColor: "#389e0d",
      color: "rgba(0, 0, 0, 0.88)"
    },
    fail: {
      chartColor: "red",
      color: "rgba(0, 0, 0, 0.88)"
    }
  },
  previewDownload: {
    type: Dr.previewDownload,
    getEnablePreview: function() {
      return !0;
    },
    getEnableDownload: function() {
      return !0;
    },
    /* eslint-disable-next-line */
    getUrl(e) {
      return "";
    }
  },
  words: {
    type: Dr.words
  }
}, yse = {
  bordered: !0
}, Sse = {}, Cse = {
  bodyCell: "bodyCell"
}, $se = {
  change: "change",
  // 当外部调用reize时，即使没有改过条件，也会触发change事件
  resizeColumn: "resizeColumn"
  // 内部自动处理了宽度问题，但还会触发相关事件作为提醒
};
function wse(e) {
  let t = {
    ellipsis: !0
  };
  return e.width && (t = {
    ...t,
    resizable: !0
  }), t;
}
const xse = {}, Zu = {
  ...$se,
  cancelMultiple: "cancelMultiple",
  updatePaginationParams: "update:paginationParams"
}, Ose = Object.values(Zu), Pse = {
  // ant-design-vue的columns内容
  columns: {
    required: !0,
    type: Array
  },
  // 展示数据
  dataSource: {
    required: !0,
    type: Array
  },
  sticky: {
    required: !1,
    type: [Object, void 0]
  },
  // 是否显示loading
  loading: {
    required: !1,
    type: Boolean
  },
  // 操作列配置项
  operationsColumn: {
    required: !1,
    type: Object,
    default() {
      return {};
    }
  },
  // 多选内容
  multiple: {
    required: !1,
    type: Object,
    default() {
      return {};
    }
  },
  // 分页配置
  pagination: {
    required: !1,
    type: [Object, Boolean],
    default() {
      return {};
    }
  },
  // 分页接口字段对应关系
  paginationMap: {
    required: !1,
    type: Object,
    default() {
      return yE;
    }
  }
};
function Ise() {
  function e(t) {
    const { style: n, ...o } = t;
    delete o.class;
    for (const r of Object.values(Sse))
      delete o[r];
    return Object.assign(
      _e(o),
      _e(yse),
      _e(o)
    );
  }
  return {
    getProps: e
  };
}
function CE(e, t) {
  e.forEach((n) => {
    t.push(n.key), n.children && CE(n.children, t);
  });
}
function Ese(e, t, n, o) {
  const r = Y({}), l = Y([]), a = Y([]), i = P(() => {
    const S = [];
    return CE(t.value, S), S;
  }), s = P(
    () => r.value.visible && r.value.items.some((S) => !S.hidden)
  );
  function c() {
    const S = _e(e.value);
    Object.assign(S, _e(wi.content), _e(S)), S.items && Object.assign(S.items, _e(wi.items), _e(S.items)), r.value = S;
  }
  function u(S) {
    for (let C = i.value.length - 1; C >= 0; C--) {
      const w = S.includes(i.value[C]), $ = i.value[C];
      if (w)
        l.value.findIndex((x) => x === $) === -1 && (l.value.push($), a.value.push(t.value.find((x) => x.key === $)));
      else {
        const O = l.value.findIndex((x) => x === $);
        O !== -1 && (l.value.splice(O, 1), a.value.splice(O, 1));
      }
    }
  }
  function d(S) {
    return r.value.getCheckboxProps ? r.value.getCheckboxProps(S) : {
      disabled: !1
    };
  }
  const p = P(() => r.value.visible ? {
    selectedRowKeys: l.value,
    onChange: u,
    getCheckboxProps: d,
    selections: [
      Zb.SELECTION_INVERT,
      {
        key: "clearCurrentPage",
        text: "清空当页",
        onSelect: () => {
          u([]);
        }
      }
    ]
  } : null);
  function v() {
    r.value.enableCrossPage || (l.value = [], a.value = []);
  }
  function h() {
    l.value = [], a.value = [];
  }
  function g(S) {
    S.loading = !0, S.confirmAsync(_e(a.value), _e(l.value)).then(() => {
      l.value = [], a.value = [];
    }).finally(() => {
      S.loading = !1;
    });
  }
  function b(S) {
    return l.value.length === 0 || S.disabled;
  }
  function y() {
    l.value = [], a.value = [], n(o.cancelMultiple);
  }
  return ie(
    e,
    () => {
      c();
    },
    {
      immediate: !0,
      deep: !0
    }
  ), {
    multipleConfigRef: r,
    rowSelectionConfig: p,
    mulSelectedRowKeysRef: l,
    changeSelectByPagination: v,
    resetSelectByPagination: h,
    isFooterShowCp: s,
    handleMulSelectionBtn: g,
    getIsMulFooterBtnDisabled: b,
    handleMulSelectionCancel: y
  };
}
function Tse(e) {
  const t = Y(100), n = Hf(() => {
    t.value = e.value.offsetWidth;
  }, 60), o = new ResizeObserver(() => {
    n();
  });
  return Ke(() => {
    o.observe(e.value);
  }), et(() => {
    o.unobserve(e.value);
  }), {
    tablePartWidthRef: t
  };
}
function Mse(e) {
  return !(!e || Object.values(e).length === 0);
}
function $E(e) {
  if ([document, null].includes(e))
    return null;
  const t = getComputedStyle(e).overflow;
  return ["scroll", "auto"].includes(t) ? e : $E(e.parentNode);
}
function _se(e) {
  let t = null;
  return e && (t = $E(e.parentNode)), t;
}
function Ase(e) {
  function t(n) {
    if (Mse(e.value))
      return e.value;
    {
      const o = _se(
        n && n.table && n.table.$el
      );
      return o === null ? !1 : {
        getContainer: () => o
      };
    }
  }
  return {
    getSticky: t
  };
}
function Dse(e) {
  const t = e.filter((o) => o.width === void 0);
  if (t.length === e.length)
    throw new Error("columns中设置width的项至少有一个");
  if (!t || t.length < 1)
    throw new Error("columns中不设置width的项至少有一个");
  const n = e.filter(
    (o) => o.width !== void 0 && typeof o.width != "number"
  );
  if (n && n.length > 0)
    throw new Error("columns如果设置宽度，宽度的类型必须为数字");
}
function Nse(e) {
  const t = {
    1: 30,
    2: 48,
    3: 58,
    space: 14
  }, n = 8, o = 8, r = 10, l = 16 * 2;
  let a = 0;
  const i = e.length < 3 ? e : e.slice(0, 2);
  return i.forEach((s, c) => {
    String(s.label).length <= 3 ? a = a + t[String(s.label).length] : a = a + t[3] + (String(s.label).length - 3) * t.space, c > 0 && (a = a + n);
  }), i.length < e.length && (a = a + o + r), a = a + l, a;
}
function Rse(e) {
  if (!e || e.length === 0)
    return [];
  Dse(e), e.forEach((t, n) => {
    const o = _e(t);
    for (const r of Object.values(xse))
      delete o[r];
    Object.assign(o, wse(t), _e(o)), o[Ji.typeConfig] || (o[Ji.typeConfig] = Cx[Dr.words]), Object.assign(
      o[Ji.typeConfig],
      Cx[o[Ji.typeConfig].type],
      _e(o[Ji.typeConfig])
    ), e[n] = o;
  });
}
function kse(e, t) {
  if (e.unshift(SE), t.value.items && t.value.items.length > 0) {
    const n = t.value.width || Nse(t.value.items);
    e.push({
      ...yy,
      width: n
    });
  }
}
function Bse(e, t) {
  const n = Y([]);
  function o() {
    let r = _e(e.value);
    Rse(r), kse(r, t), n.value = r;
  }
  return ie(
    e,
    () => {
      o();
    },
    {
      deep: !0,
      immediate: !0
    }
  ), {
    columnsRef: n
  };
}
const Fse = (e) => e + 1;
function Lse(e) {
  return e ? e.map((t, n) => Object.assign(
    e[n],
    _e(hse),
    _e(e[n])
  )) : [];
}
function wE(e, t, n = 1) {
  e.forEach((o, r) => {
    t ? o.key || (e[r].key = `${(t.current - 1) * t.pageSize + r}${n}`) : e[r].key = `${r}${n}`, o.children && wE(o.children, t, ++n);
  });
}
function xE(e, t) {
  for (const n of Object.values(e.value)) {
    let o = Lse(
      _e(t.value.items)
    );
    for (const r of Object.values(o))
      r.getHidden ? r._hidden = r.getHidden(
        _e(n)
      ) : r._hidden = !1, r.getDisabled ? r._disabled = r.getDisabled(
        _e(n)
      ) : r._disabled = !1;
    if (o = o.filter((r) => !r._hidden), o.length > 2) {
      const r = o.slice(2);
      o = o.slice(0, 2), o.push({
        type: Sy.drop,
        items: r
      });
    }
    n[yy.dataIndex] = o, n.children && xE(n.children, t.value);
  }
}
function zse(e, t, n) {
  const o = Y([]);
  function r() {
    if (o.value = _e(e.value), wE(o.value, n.value), !t.value || !t.value.items || t.value.items.length === 0)
      return o.value;
    xE(o, t);
  }
  return ie(
    e,
    () => {
      r();
    },
    {
      immediate: !0,
      deep: !0
    }
  ), {
    calcIndex: Fse,
    dataSourceRef: o
  };
}
function Hse(e, t) {
  const n = Y({}), o = P(() => Object.assign(_e(yE), _e(t.value)));
  function r() {
    if (e.value === !1)
      return n.value = !1;
    const l = _e(e.value);
    l && l[o.value.current] && (l.current = l[o.value.current], o.value.current !== "current" && delete l[o.value.current]), l && l[o.value.pageSize] && (l.pageSize = l[o.value.pageSize], o.value.pageSize !== "pageSize" && delete l[o.value.pageSize]), l && l[o.value.total] && (l.total = l[o.value.total], o.value.total !== "total" && delete l[o.value.total]), Object.assign(n.value, _e(Um), l);
  }
  return ie(
    [() => e.value[o.value.total]],
    () => {
      n.value.total = e.value[o.value.total];
    },
    {
      immediate: !0
    }
  ), r(), {
    paginationConfigRef: n,
    paginationMapCp: o
  };
}
function jse() {
  function e(t) {
    const { ...n } = t;
    for (const o of Object.values(Cse))
      delete n[o];
    return n;
  }
  return {
    getSlots: e
  };
}
function Vse(e, t, n, o) {
  function r(l, a) {
    const i = e.value.findIndex(
      (s) => s.dataIndex === a.dataIndex
    );
    e.value[i].width = l, n(o.resizeColumn, l, a), t();
  }
  return {
    handleResizeColumn: r
  };
}
function Wse(e, t, n, o, r, l) {
  const a = Y(!0), i = Y({}), s = Y({}), c = Y({});
  function u() {
    const v = _e(e.value), h = _e(i.value), g = _e(s.value), b = _e(c.value), y = {
      pagination: {
        [t.value.current]: v.current,
        [t.value.pageSize]: v.pageSize
      },
      filters: h,
      sorter: g,
      extra: b
    };
    r(l.updatePaginationParams, y), r(l.change, y);
  }
  function d(v, h, g, b) {
    e.value.current = v.current, e.value.pageSize = v.pageSize, i.value = h, s.value = g, c.value = b, u(), n();
  }
  function p() {
    e.value.current !== Um.current && (e.value.current = Um.current), a.value = !1, rt(() => {
      a.value = !0;
    }), u(), o();
  }
  return vf(() => {
    u();
  }), {
    isTableShowRef: a,
    handleChange: d,
    filtersRef: i,
    sorterRef: s,
    extraRef: c,
    reset: p
  };
}
function Kse() {
  function e(s) {
    return s.column.typeConfig.getDisabled(s);
  }
  function t(s) {
    s.column.typeConfig.click(s);
  }
  function n(s) {
    if (!s)
      return;
    const c = window.navigator;
    c && c.clipboard && c.clipboard.writeText(s), xn.success("已复制");
  }
  function o(s) {
    return s.column.typeConfig.getDisabled(s);
  }
  function r(s) {
    s.column.typeConfig.click(s);
  }
  function l(s) {
    return s.column.typeConfig.getChecked(s);
  }
  function a(s) {
    return s.column.typeConfig.getDisabled(s);
  }
  async function i(s) {
    const c = s.column.typeConfig.getTitle(s), u = s.column.typeConfig.getContent(s);
    zn.confirm({
      title: c,
      content: u,
      onOk() {
        s.column.typeConfig.confirmAsync(s).then(() => {
        });
      }
    });
  }
  return {
    handleColumnBtnDisabled: e,
    handleColumnBtnClick: t,
    handleColumnCopy: n,
    handleColumnJumpDisabled: o,
    handleColumnJumpClick: r,
    handleColumnSwitchChecked: l,
    handleColumnSwitchDisabled: a,
    handleColumnSwitchClick: i
  };
}
function Gse() {
  function e(t, n) {
    if (t.isShowModal) {
      let o = t.getModalContent ? t.getModalContent(n) : `确定${t.label}？`;
      zn.confirm({
        title: t.modalTitle,
        content: o,
        onOk() {
          t.confirmAsync(n).then(() => {
          });
        }
      });
    } else
      t.confirmAsync(n).then(() => {
      });
  }
  return {
    handleOpeItemClick: e
  };
}
function Xse(e) {
  const t = Y(0);
  function n() {
    t.value = 0, e.value.forEach((o) => {
      o.width && typeof o.width == "number" ? t.value += o.width : o.width || (t.value += mse);
    });
  }
  return n(), {
    scrollWidthRef: t,
    setScrollWidth: n
  };
}
const Use = Z({
  components: {
    aTable: Zb,
    DownOutlined: Or
  },
  inheritAttrs: !1,
  props: Pse,
  emits: Ose,
  setup(e, { emit: t, expose: n }) {
    const o = Y(null), r = Y(null), {
      handleColumnBtnDisabled: l,
      handleColumnBtnClick: a,
      handleColumnCopy: i,
      handleColumnJumpDisabled: s,
      handleColumnJumpClick: c,
      handleColumnSwitchChecked: u,
      handleColumnSwitchDisabled: d,
      handleColumnSwitchClick: p
    } = Kse(), { getProps: v } = Ise(), { paginationConfigRef: h, paginationMapCp: g } = Hse(
      Te(e, "pagination"),
      Te(e, "paginationMap")
    ), { columnsRef: b } = Bse(Te(e, "columns"), Te(e, "operationsColumn")), { scrollWidthRef: y, setScrollWidth: S } = Xse(b), { calcIndex: C, dataSourceRef: w } = zse(
      Te(e, "dataSource"),
      Te(e, "operationsColumn"),
      h
    ), { handleOpeItemClick: $ } = Gse(), { getSticky: O } = Ase(Te(e, "sticky")), { getSlots: x } = jse(), { handleResizeColumn: I } = Vse(b, S, t, Zu), {
      multipleConfigRef: E,
      rowSelectionConfig: _,
      mulSelectedRowKeysRef: M,
      changeSelectByPagination: R,
      resetSelectByPagination: A,
      isFooterShowCp: z,
      handleMulSelectionBtn: T,
      getIsMulFooterBtnDisabled: N,
      handleMulSelectionCancel: k
    } = Ese(Te(e, "multiple"), w, t, Zu), { isTableShowRef: B, handleChange: F, reset: L } = Wse(
      h,
      g,
      R,
      A,
      t,
      Zu
    ), { tablePartWidthRef: j } = Tse(o);
    return n({
      antTableComponent: r,
      reset: L,
      paginationMap: g
    }), {
      antTableComponentRef: r,
      columnsRef: b,
      dataSourceRef: w,
      rowSelectionConfig: _,
      mulSelectedRowKeysRef: M,
      handleChange: F,
      tableDomRef: o,
      OPERATIONS_COLUMN: yy,
      INDEX_COLUMN: SE,
      COLUMN_TYPE: Dr,
      calcIndex: C,
      OPERATIONS_COLUMN_BTN_TYPE: Sy,
      isFooterShowCp: z,
      handleMulSelectionBtn: T,
      getIsMulFooterBtnDisabled: N,
      handleMulSelectionCancel: k,
      MODE: Pc,
      scrollWidthRef: y,
      paginationConfigRef: h,
      tablePartWidthRef: j,
      getProps: v,
      getSticky: O,
      multipleConfigRef: E,
      getSlots: x,
      handleResizeColumn: I,
      isTableShowRef: B,
      handleColumnBtnDisabled: l,
      handleColumnBtnClick: a,
      handleColumnCopy: i,
      handleColumnJumpDisabled: s,
      handleColumnJumpClick: c,
      handleColumnSwitchChecked: u,
      handleColumnSwitchDisabled: d,
      handleColumnSwitchClick: p,
      handleOpeItemClick: $
    };
  }
}), Yse = { key: 0 }, qse = {
  key: 4,
  class: "flex items-center"
}, Zse = {
  key: 5,
  class: "flex items-center"
}, Qse = {
  key: 0,
  class: "footer"
}, Jse = { class: "des" }, ece = { class: "operations" };
function tce(e, t, n, o, r, l) {
  const a = st("m-button"), i = st("down-outlined"), s = st("m-menuItem"), c = st("m-menu"), u = st("m-dropdown"), d = st("m-link"), p = st("m-switch"), v = st("m-preview-download"), h = st("a-table");
  return Ne(), it("div", {
    ref: "tableDomRef",
    class: aa(["m-table-part", e.$attrs.class]),
    style: Fr({
      ...e.$attrs.style
    })
  }, [
    rn("div", {
      class: "table-content",
      style: Fr({ width: `${e.tablePartWidthRef}px` })
    }, [
      e.isTableShowRef ? (Ne(), Et(h, Ft({
        key: 0,
        ref: "antTableComponentRef"
      }, e.getProps(e.$attrs), {
        loading: e.loading,
        columns: e.columnsRef,
        "data-source": e.dataSourceRef,
        "row-selection": e.rowSelectionConfig,
        pagination: e.paginationConfigRef,
        sticky: e.getSticky(e.antTableComponentRef),
        scroll: { x: e.scrollWidthRef },
        onChange: e.handleChange,
        onResizeColumn: e.handleResizeColumn
      }), Sr({
        bodyCell: pt((g) => [
          g.column.dataIndex === e.INDEX_COLUMN.dataIndex ? (Ne(), it("div", Yse, dn(e.calcIndex(g.index)), 1)) : ht("", !0),
          g.column.dataIndex === e.OPERATIONS_COLUMN.dataIndex ? (Ne(), it(Fe, { key: 1 }, [
            (Ne(!0), it(Fe, null, ln(g.record[e.OPERATIONS_COLUMN.dataIndex], (b, y) => (Ne(), it(Fe, null, [
              b.type === e.OPERATIONS_COLUMN_BTN_TYPE.normal ? (Ne(), Et(a, {
                key: y,
                class: "operation-button",
                disabled: b._disabled,
                size: "small",
                onClick: (S) => e.handleOpeItemClick(b, g)
              }, {
                default: pt(() => [
                  Ot(dn(b.label), 1)
                ]),
                _: 2
              }, 1032, ["disabled", "onClick"])) : ht("", !0)
            ], 64))), 256)),
            (Ne(!0), it(Fe, null, ln(g.record[e.OPERATIONS_COLUMN.dataIndex], (b, y) => (Ne(), it(Fe, null, [
              b.type === e.OPERATIONS_COLUMN_BTN_TYPE.drop ? (Ne(), Et(u, { key: y }, {
                overlay: pt(() => [
                  f(c, null, {
                    default: pt(() => [
                      (Ne(!0), it(Fe, null, ln(b.items, (S, C) => (Ne(), it(Fe, { key: C }, [
                        S._hidden ? ht("", !0) : (Ne(), Et(s, {
                          key: 0,
                          disabled: S._disabled,
                          onClick: (w) => e.handleOpeItemClick(S, g)
                        }, {
                          default: pt(() => [
                            Ot(dn(S.label), 1)
                          ]),
                          _: 2
                        }, 1032, ["disabled", "onClick"]))
                      ], 64))), 128))
                    ]),
                    _: 2
                  }, 1024)
                ]),
                default: pt(() => [
                  f(i, { class: "drop-icon" })
                ]),
                _: 2
              }, 1024)) : ht("", !0)
            ], 64))), 256))
          ], 64)) : ht("", !0),
          g.column.typeConfig && g.column.typeConfig.type !== e.COLUMN_TYPE.words ? (Ne(), it(Fe, { key: 2 }, [
            g.column.typeConfig.type === e.COLUMN_TYPE.button ? (Ne(), Et(a, {
              key: 0,
              size: "small",
              disabled: e.handleColumnBtnDisabled(g),
              onClick: (b) => e.handleColumnBtnClick(g)
            }, {
              default: pt(() => [
                Ot(dn(g.text), 1)
              ]),
              _: 2
            }, 1032, ["disabled", "onClick"])) : ht("", !0),
            g.column.typeConfig.type === e.COLUMN_TYPE.copy && (!g.column.typeConfig.getEnable || g.column.typeConfig.getEnable(g)) ? (Ne(), Et(a, {
              key: 1,
              size: "small",
              onClick: (b) => e.handleColumnCopy(g.text)
            }, {
              default: pt(() => [
                Ot(dn(g.text), 1)
              ]),
              _: 2
            }, 1032, ["onClick"])) : ht("", !0),
            g.column.typeConfig.type === e.COLUMN_TYPE.jump ? (Ne(), Et(d, {
              key: 2,
              type: "link",
              disabled: e.handleColumnJumpDisabled(g),
              onClick: (b) => e.handleColumnJumpClick(g)
            }, {
              default: pt(() => [
                Ot(dn(g.text), 1)
              ]),
              _: 2
            }, 1032, ["disabled", "onClick"])) : ht("", !0),
            g.column.typeConfig.type === e.COLUMN_TYPE.switch ? (Ne(), it(Fe, { key: 3 }, [
              Ot(dn(g.column.typeConfig.getLeftLabel(g)) + " ", 1),
              f(p, {
                checked: e.handleColumnSwitchChecked(g),
                disabled: e.handleColumnSwitchDisabled(g),
                onClick: (b) => e.handleColumnSwitchClick(g)
              }, null, 8, ["checked", "disabled", "onClick"]),
              Ot(" " + dn(g.column.typeConfig.getRightLabel(g)), 1)
            ], 64)) : ht("", !0),
            g.column.typeConfig.type === e.COLUMN_TYPE.status ? (Ne(), it("div", qse, [
              rn("div", {
                style: Fr({
                  width: "10px",
                  height: "10px",
                  "border-radius": "50%",
                  "background-color": g.column.typeConfig[g.column.typeConfig.getStatus(g)].chartColor
                })
              }, null, 4),
              rn("span", {
                class: "ml-8px",
                style: Fr({
                  color: g.column.typeConfig[g.column.typeConfig.getStatus(g)].color
                })
              }, dn(g.text), 5)
            ])) : ht("", !0),
            g.column.typeConfig.type === e.COLUMN_TYPE.previewDownload ? (Ne(), it("div", Zse, [
              f(v, Ft({
                url: g.column.typeConfig.getUrl(g),
                enablePreview: g.column.typeConfig.getEnablePreview(g),
                enableDownload: g.column.typeConfig.getEnableDownload(g)
              }, g.column.typeConfig), null, 16, ["url", "enablePreview", "enableDownload"])
            ])) : ht("", !0)
          ], 64)) : ht("", !0),
          e.$slots.bodyCell ? Bn(e.$slots, "bodyCell", cT(Ft({ key: 3 }, g)), void 0, !0) : ht("", !0)
        ]),
        _: 2
      }, [
        ln(e.getSlots(e.$slots), (g, b) => ({
          name: b,
          fn: pt((y) => [
            Bn(e.$slots, b, Ft(y, { key: b }), void 0, !0)
          ])
        }))
      ]), 1040, ["loading", "columns", "data-source", "row-selection", "pagination", "sticky", "scroll", "onChange", "onResizeColumn"])) : ht("", !0)
    ], 4),
    e.isFooterShowCp ? (Ne(), it("div", Qse, [
      rn("span", Jse, "已选中" + dn(e.mulSelectedRowKeysRef.length) + "条数据", 1),
      rn("div", ece, [
        f(a, { onClick: e.handleMulSelectionCancel }, {
          default: pt(() => [
            Ot("取消")
          ]),
          _: 1
        }, 8, ["onClick"]),
        (Ne(!0), it(Fe, null, ln(e.multipleConfigRef.items, (g) => (Ne(), it(Fe, null, [
          g.hidden ? ht("", !0) : (Ne(), Et(a, {
            key: g.label,
            mode: g.mode,
            disabled: e.getIsMulFooterBtnDisabled(g),
            loading: g.loading,
            onClick: (b) => e.handleMulSelectionBtn(g)
          }, {
            default: pt(() => [
              Ot(dn(g.label), 1)
            ]),
            _: 2
          }, 1032, ["mode", "disabled", "loading", "onClick"]))
        ], 64))), 256))
      ])
    ])) : ht("", !0)
  ], 6);
}
const nce = /* @__PURE__ */ _n(Use, [["render", tce], ["__scopeId", "data-v-13b83771"]]), oce = {
  // 点击蒙层不关闭弹窗
  maskClosable: !1
}, rce = {}, lce = {}, ace = {}, ice = {
  ...ace
}, sce = Object.values(ice), cce = {};
function uce() {
  function e(t) {
    const { style: n, ...o } = t;
    delete o.class;
    for (const r of Object.values(rce))
      delete o[r];
    return Object.assign(
      _e(o),
      _e(oce),
      _e(o)
    );
  }
  return {
    getProps: e
  };
}
function dce() {
  function e(t) {
    const { ...n } = t;
    for (const o of Object.values(lce))
      delete n[o];
    return n;
  }
  return {
    getSlots: e
  };
}
const fce = Z({
  components: {
    aModal: zn
  },
  inheritAttrs: !1,
  props: cce,
  emits: sce,
  setup(e, { expose: t }) {
    const { getProps: n } = uce(), { getSlots: o } = dce();
    return t({}), {
      getProps: n,
      getSlots: o
    };
  }
});
function pce(e, t, n, o, r, l) {
  const a = st("a-modal");
  return Ne(), Et(a, Ft({
    class: [e.$attrs.class, "m-modal"],
    style: e.$attrs.style
  }, e.getProps(e.$attrs)), Sr({ _: 2 }, [
    ln(e.getSlots(e.$slots), (i, s) => ({
      name: s,
      fn: pt((c) => [
        Bn(e.$slots, s, Ft(c, { key: s }))
      ])
    }))
  ]), 1040, ["class", "style"]);
}
const vce = /* @__PURE__ */ _n(fce, [["render", pce]]), gce = {
  // 点击蒙层不关闭弹窗
  maskClosable: !1
}, mce = {}, hce = {}, bce = {}, yce = {
  ...bce
}, Sce = Object.values(yce), Cce = {};
function $ce() {
  function e(t) {
    const { style: n, ...o } = t;
    delete o.class;
    for (const r of Object.values(mce))
      delete o[r];
    return Object.assign(
      _e(o),
      _e(gce),
      _e(o)
    );
  }
  return {
    getProps: e
  };
}
function wce() {
  function e(t) {
    const { ...n } = t;
    for (const o of Object.values(hce))
      delete n[o];
    return n;
  }
  return {
    getSlots: e
  };
}
const xce = Z({
  components: {
    aDrawer: pI
  },
  inheritAttrs: !1,
  props: Cce,
  emits: Sce,
  setup(e, { expose: t }) {
    const { getProps: n } = $ce(), { getSlots: o } = wce();
    return t({}), {
      getProps: n,
      getSlots: o
    };
  }
});
function Oce(e, t, n, o, r, l) {
  const a = st("a-drawer");
  return Ne(), Et(a, Ft({
    class: [e.$attrs.class, "m-drawer"],
    style: e.$attrs.style
  }, e.getProps(e.$attrs)), Sr({ _: 2 }, [
    ln(e.getSlots(e.$slots), (i, s) => ({
      name: s,
      fn: pt((c) => [
        Bn(e.$slots, s, Ft(c, { key: s }))
      ])
    }))
  ]), 1040, ["class", "style"]);
}
const Pce = /* @__PURE__ */ _n(xce, [["render", Oce]]), Ice = {
  // listType: 'picture-card'
}, Ece = {
  accept: "accept",
  listType: "listType",
  action: "action",
  beforeUpload: "beforeUpload",
  customRequest: "customRequest",
  data: "data",
  directory: "directory",
  headers: "headers",
  method: "method",
  name: "name",
  openFileDialogOnClick: "openFileDialogOnClick",
  withCredentials: "withCredentials"
}, Tce = {}, Mce = {}, _ce = {
  ...Mce,
  updateFileList: "update:fileList"
}, Ace = Object.values(_ce), Dce = {
  fileList: {
    required: !0,
    type: Array,
    default() {
      return [];
    }
  },
  // 上传文件类型1：图片，2：文档 3：视频 4：压缩包
  fileType: {
    required: !1,
    type: Array,
    default() {
      return ["1", "2", "3", "4"];
    }
  },
  // 自定义文件类型
  customFileType: {
    required: !1,
    type: Array
  },
  // 支持上传的最大数量
  maxCount: {
    required: !1,
    type: Number,
    default: 100
  },
  // 上传回调事件
  uploadAsync: {
    required: !0,
    type: Function
  },
  // 删除回调事件
  deleteFileAsync: {
    required: !1,
    type: Function
  },
  // 下载函数
  downloadAsync: {
    required: !1,
    type: Function
  }
};
function Nce(e, t) {
  const n = Ap(e, "fileList", t);
  return ie(
    [() => e.fileList],
    () => {
      n.value.forEach((o) => {
        o.status || (o.status = "done");
      });
    },
    {
      immediate: !0
    }
  ), {
    fileListVM: n
  };
}
function Rce() {
  function e(t) {
    const { style: n, ...o } = t;
    delete o.class;
    for (const r of Object.values(Ece))
      delete o[r];
    return Object.assign(
      _e(o),
      _e(Ice),
      _e(o)
    );
  }
  return {
    getProps: e
  };
}
function kce() {
  function e(t) {
    const { ...n } = t;
    for (const o of Object.values(Tce))
      delete n[o];
    return n;
  }
  return {
    getSlots: e
  };
}
function Bce(e, t = 0) {
  const n = Number.parseInt(e.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(n))
    return !1;
  let o = 8 * 32;
  for (let r = t; r < t + 148; r++)
    o += e[r];
  for (let r = t + 156; r < t + 512; r++)
    o += e[r];
  return n === o;
}
function Fce(e) {
  return [...e].map((t) => t.charCodeAt(0));
}
function Lce(e, t) {
  const n = {
    offset: 0
  };
  for (const [o, r] of t.entries())
    if (r !== e[o + n.offset])
      return !1;
  return !0;
}
function zce(e) {
  const t = new Uint8Array(e), n = (r) => Lce(t, r), o = (r) => n(Fce(r));
  if (n([82, 97, 114, 33, 26, 7]))
    return {
      ext: "rar",
      mime: "application/x-rar-compressed"
    };
  if (Bce(e))
    return {
      ext: "tar",
      mime: "application/x-tar"
    };
  if (n([253, 55, 122, 88, 90, 0]))
    return {
      ext: "xz",
      mime: "application/x-xz"
    };
  if (n([55, 122, 188, 175, 39, 28]))
    return {
      ext: "7z",
      mime: "application/x-7z-compressed"
    };
  if (n([31, 139, 8]))
    return {
      ext: "gz",
      mime: "application/gzip"
    };
  if (o("MSCF") || o("ISc("))
    return {
      ext: "cab",
      mime: "application/vnd.ms-cab-compressed"
    };
  if (o("!<arch>"))
    return {
      ext: "ar",
      mime: "application/x-unix-archive"
    };
}
function Hce(e) {
  return new Promise((t) => {
    const n = new FileReader();
    n.onload = () => {
      let o = zce(n.result);
      t(o && o.mime || void 0);
    }, n.readAsArrayBuffer(e);
  });
}
async function jce(e) {
  let t = await Hce(e);
  return t || (t = e.type), t;
}
const Qu = {
  maxSize: 5242880,
  // 5m
  errorTip: "图片大小不能大于5M；仅支持image/png、image/jpeg格式！",
  content: ["image/png", "image/jpeg"]
}, Ju = {
  maxSize: 52428800,
  // 50m
  errorTip: "文档大小不能大于50M；仅支持msword、document、excel、sheet、powerpoint、pdf格式！",
  content: [
    "application/msword",
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "application/vnd.ms-excel",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "application/vnd.ms-powerpoint",
    "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "application/pdf"
  ]
}, ed = {
  maxSize: 157286400,
  // 150m
  errorTip: "视频大小不能大于150M；仅支持mp4格式！",
  content: ["video/mp4"]
}, td = {
  maxSize: 209715200,
  // 200m
  errorTip: "资源文件大小不能大于500M；仅支持zip、rar、7z、tar、gzip格式！",
  content: [
    "application/x-zip-compressed",
    "application/x-rar-compressed",
    "application/zip",
    "application/x-7z-compressed",
    "application/vnd.ms-cab-compressed",
    "application/x-unix-archive",
    "application/x-tar",
    "application/gzip"
  ]
}, OE = {
  1: Qu,
  2: Ju,
  3: ed,
  4: td
};
function Vce(e, t, n, o, r, l) {
  function a(u) {
    const d = l.value.every((p) => p !== u);
    if (d)
      if (o.value && o.value.length > 0) {
        const p = [];
        o.value.forEach((v) => {
          p.push(v.errorTip);
        }), xn.error({
          content() {
            return vr(
              "div",
              {
                style: {
                  "text-align": "left"
                }
              },
              p.map((v) => vr("p", null, v))
            );
          }
        });
      } else {
        const p = [];
        return n.value.forEach((v) => {
          p.push(OE[v].errorTip);
        }), xn.error({
          content() {
            return vr(
              "div",
              {
                style: {
                  "text-align": "left"
                }
              },
              p.map((v) => vr("p", null, v))
            );
          }
        }), !0;
      }
    return d;
  }
  function i(u, d) {
    if (o.value && o.value.length > 0) {
      const p = o.value.find(
        (v) => v.content.includes(u) && v.maxSize < d
      );
      if (p)
        return xn.error(p.errorTip), !0;
    } else {
      if (d === 0)
        return xn.error("上传文件不能为空！"), !0;
      if (Ju.content.includes(u) && Ju.maxSize < d)
        return xn.error(Ju.errorTip), !0;
      if (Qu.content.includes(u) && Qu.maxSize < d)
        return xn.error(Qu.errorTip), !0;
      if (ed.content.includes(u) && ed.maxSize < d)
        return xn.error(ed.errorTip), !0;
      if (td.content.includes(u) && td.maxSize < d)
        return xn.error(td.errorTip), !0;
    }
    return !1;
  }
  async function s(u) {
    return new Promise(async (d) => {
      const p = await jce(u), v = u.size;
      if (r.value.length >= t.value)
        return xn.error(`文件最大上传数量为${t.value}！`), !1;
      if (a(p) || i(p, v))
        return !1;
      d();
    });
  }
  async function c(u) {
    const d = new FormData();
    d.append("file", u.file);
    const p = r.value.findIndex((v) => v === u.file);
    e(d).then(async (v) => {
      u.onSuccess({
        ...v
      });
    }).catch(() => {
      r.value.splice(p, 1);
    });
  }
  return {
    handleBeforeUpload: s,
    handleCustomRequest: c
  };
}
function Wce(e) {
  function t(n) {
    e(n).then(() => {
    });
  }
  return {
    handleDownload: t
  };
}
function Kce() {
  const e = Y({
    visible: !1,
    url: null
  });
  function t() {
    e.value.visible = !1;
  }
  async function n(o) {
    e.value.visible = !0, e.value.url = o.url || o.thumbUrl;
  }
  return {
    previewRef: e,
    handlePreviewCancel: t,
    handlePreview: n
  };
}
function Gce(e, t) {
  function n(o) {
    return t(o).then(() => {
      const r = e.value.findIndex((l) => l === o);
      e.value.splice(r, 1);
    }), Promise.reject();
  }
  return {
    handleRemove: n
  };
}
function Xce(e, t) {
  const n = P(() => {
    var l;
    const r = [];
    return t.value && t.value.length > 0 ? t.value.forEach((a) => {
      r.push(...a.content);
    }) : (l = e.value) == null || l.forEach((a) => {
      r.push(...OE[a].content);
    }), r;
  }), o = P(() => n.value.join(","));
  return {
    acceptCp: n,
    acceptStrCp: o
  };
}
const Uce = {
  maxSize: {
    required: !0,
    type: [Vt.number]
  },
  errorTip: {
    required: !0,
    type: [Vt.string]
  },
  content: {
    required: !0,
    type: [Vt.array]
  }
};
function Yce(e) {
  e.value && e.value.forEach((t) => {
    bE(t, Uce);
  });
}
const qce = Z({
  components: {
    aUpload: J6,
    PlusOutlined: op
  },
  inheritAttrs: !1,
  props: Dce,
  emits: Ace,
  setup(e, { emit: t, expose: n }) {
    const { getProps: o } = Rce(), { getSlots: r } = kce();
    Yce(Te(e, "customFileType"));
    const { fileListVM: l } = Nce(e, t), { acceptCp: a, acceptStrCp: i } = Xce(
      Te(e, "fileType"),
      Te(e, "customFileType")
    ), { handleDownload: s } = Wce(e.downloadAsync), { previewRef: c, handlePreviewCancel: u, handlePreview: d } = Kce(), { handleBeforeUpload: p, handleCustomRequest: v } = Vce(
      e.uploadAsync,
      Te(e, "maxCount"),
      Te(e, "fileType"),
      Te(e, "customFileType"),
      l,
      a
    ), { handleRemove: h } = Gce(l, e.deleteFileAsync);
    return n({}), {
      getProps: o,
      getSlots: r,
      handlePreviewCancel: u,
      handlePreview: d,
      fileListVM: l,
      handleBeforeUpload: p,
      handleRemove: h,
      previewRef: c,
      handleCustomRequest: v,
      acceptStrCp: i,
      handleDownload: s
    };
  }
}), Zce = (e) => (uT("data-v-0b42ec95"), e = e(), dT(), e), Qce = /* @__PURE__ */ Zce(() => /* @__PURE__ */ rn("div", null, "上传", -1));
function Jce(e, t, n, o, r, l) {
  const a = st("plus-outlined"), i = st("a-upload"), s = st("m-image");
  return Ne(), it("div", {
    class: aa(["m-uploda", e.$attrs.class]),
    style: Fr(e.$attrs.style)
  }, [
    f(i, Ft({
      fileList: e.fileListVM,
      "onUpdate:fileList": t[0] || (t[0] = (c) => e.fileListVM = c),
      maxCount: e.maxCount,
      accept: e.acceptStrCp,
      customRequest: e.handleCustomRequest,
      beforeUpload: e.handleBeforeUpload,
      listType: "picture-card"
    }, e.getProps(e.$attrs), {
      onPreview: e.handlePreview,
      onRemove: e.handleRemove,
      onDownload: e.handleDownload
    }), Sr({
      default: pt(() => [
        rn("div", null, [
          f(a),
          Qce
        ])
      ]),
      _: 2
    }, [
      ln(e.getSlots(e.$slots), (c, u) => ({
        name: u,
        fn: pt((d) => [
          Bn(e.$slots, u, Ft(d, { key: u }), void 0, !0)
        ])
      }))
    ]), 1040, ["fileList", "maxCount", "accept", "customRequest", "beforeUpload", "onPreview", "onRemove", "onDownload"]),
    f(s, {
      class: "hidden",
      preview: {
        visible: e.previewRef.visible,
        onVisibleChange: e.handlePreviewCancel
      },
      src: e.previewRef.url
    }, null, 8, ["preview", "src"])
  ], 6);
}
const eue = /* @__PURE__ */ _n(qce, [["render", Jce], ["__scopeId", "data-v-0b42ec95"]]), tue = {
  // form内部集成组件
  FormItemDes: Eae,
  // 内部组件
  Button: Hae,
  Select: tie,
  Cascader: vie,
  Form: gse,
  Table: nce,
  Modal: vce,
  Drawer: Pce,
  Upload: eue
}, nue = {}, oue = Object.values(nue), rue = {
  // 获取数据接口
  getTableDataAsync: {
    required: !0,
    type: Function
  },
  // 全部接入为ant-design-vue的内容
  columns: {
    required: !0,
    type: Array
  },
  // 首次获取数据的延时函数
  delayFirstAsync: {
    required: !1,
    type: Function
  },
  // 获取数据接口的其它参数
  getTableDataExtraParamsAsync: {
    required: !1,
    type: Function
  },
  // 顶部切换内容
  pageTopTabs: {
    required: !1,
    type: Object
  },
  // 搜索条件
  condition: {
    required: !1,
    type: Object
  },
  // 功能区
  ability: {
    required: !1,
    type: Object
  },
  // 位于table上方，搜索条件下方的切换，结构与topTabs相同
  tableAboveTabs: {
    required: !1,
    type: Object
  },
  // 操作列配置
  operationsColumn: {
    required: !1,
    type: Object
  },
  // 分页配置
  pagination: {
    required: !1,
    type: Object
  },
  // 分页上传字段对应关系
  paginationMap: {
    required: !1,
    type: Object
  }
};
function lue() {
  return {
    formCompRef: Y(null)
  };
}
function aue() {
  const e = Y(null);
  function t(n) {
    const { style: o, condition: r, ...l } = n;
    return delete l.class, _e(l);
  }
  return {
    antTableComponentRef: e,
    getProps: t
  };
}
const PE = {
  updateModelValue: "update:modelValue",
  openResizeModal: "openResizeModal",
  fullScreen: "fullScreen"
}, iue = Object.values(PE), sue = {
  modelValue: {
    required: !0,
    type: Object
  },
  // 功能区
  ability: {
    required: !1,
    type: Object,
    default() {
      return {};
    }
  },
  // 获取参数函数
  getParamsAsync: {
    required: !1,
    type: Function
  }
}, Cl = {
  normal: "normal",
  multiple: "multiple"
}, IE = {
  ...wi.content
};
delete IE.visible;
const $x = {
  align: "right",
  config: {
    download: {
      enable: !1,
      getBlobAsync: null
    }
  },
  normal: {
    type: Cl.normal,
    label: void 0,
    disabled: !1,
    hidden: !1,
    loading: !1,
    confirmAsync: function(e) {
      console.error("必填函数", e);
    }
  },
  multiple: {
    content: {
      type: Cl.multiple,
      label: void 0,
      disabled: !1,
      hidden: !1,
      ...IE
    },
    items: wi.items
  }
}, cue = {
  type: Cl.normal,
  label: "自定义列",
  disabled: !1,
  hidden: !1,
  loading: !1
}, uue = {
  type: Cl.normal,
  label: "全屏展示",
  disabled: !1,
  hidden: !1,
  loading: !1
}, due = {
  type: Cl.normal,
  label: "导出",
  disabled: !1,
  hidden: !1,
  loading: !1
};
function fue(e, t) {
  const n = document.createElement("a");
  n.href = URL.createObjectURL(e), n.target = "_blank", n.download = t, document.body.appendChild(n), n.click(), URL.revokeObjectURL(n.href), document.body.removeChild(n);
}
function pue(e, t, n, o) {
  const r = Y({
    ...wi.content,
    items: []
  }), l = {
    ..._e(cue),
    async confirmAsync() {
      n(o.openResizeModal);
    }
  }, a = {
    ..._e(uue),
    async confirmAsync() {
      n(o.fullScreen);
    }
  };
  function i(v) {
    return {
      ..._e(due),
      async confirmAsync() {
        const h = await t(), { blob: g, name: b } = await v(h);
        fue(g, b), xn.success({ content: "下载成功" });
      }
    };
  }
  const s = P(() => e.value.align || $x.align), c = P(() => {
    const v = _e(e.value.items) || [], h = [a, l];
    return e.value && e.value.download && e.value.download.enable && h.push(i(e.value.download.getBlobAsync)), !v || v.length === 0 ? h : (v.unshift(...h), v.forEach((g, b) => {
      !g.type || g.type === Cl.normal ? Object.assign(
        v[b],
        _e($x[Cl.normal]),
        _e(v[b])
      ) : v[b].items.forEach((y, S) => {
        const C = _e(y);
        delete C.label, delete C.disabled, delete C.hidden, delete C.type, C.items = C.items || [], C.items.forEach((w, $) => {
          Object.assign(
            C.items[$],
            _e(wi.items),
            _e(C.items[$])
          );
          const O = C.items[$].confirmAsync;
          C.items[$].confirmAsync = async function(...x) {
            r.value.visible = !1;
            const I = await t();
            return O(I, ...x);
          };
        }), v[b].items[S] = {
          label: y.label,
          disabled: y.disabled,
          hidden: y.hidden,
          type: y.type,
          multiple: C
        };
      });
    }), v);
  });
  function u(v) {
    r.value.visible = !0, Object.assign(
      r.value,
      _e(v.multiple),
      _e(r.value)
    ), r.value.items = v.multiple.items, n(o.updateModelValue, r.value);
  }
  function d() {
    r.value.visible = !1, n(o.updateModelValue, r.value);
  }
  function p(v) {
    v.loading = !0, v.confirmAsync(v).then(() => {
    }).finally(() => {
      v.loading = !1;
    });
  }
  return ie(e, () => {
    r.value.visible = !1;
  }), {
    alignCp: s,
    abilityItemsCp: c,
    multipleConfigRef: r,
    handleAbilityMulClick: u,
    handleCancelMultiple: d,
    handleNormalBtnClick: p
  };
}
const vue = Z({
  components: {
    DownOutlined: Or
  },
  props: sue,
  emits: iue,
  setup(e, { emit: t, expose: n }) {
    const {
      alignCp: o,
      abilityItemsCp: r,
      handleAbilityMulClick: l,
      handleCancelMultiple: a,
      multipleConfigRef: i,
      handleNormalBtnClick: s
    } = pue(Te(e, "ability"), e.getParamsAsync, t, PE);
    return n({
      handleCancelMultiple: a,
      multipleConfig: i
    }), {
      alignCp: o,
      abilityItemsCp: r,
      handleAbilityMulClick: l,
      ABILITY_ITEM_TYPE: Cl,
      handleNormalBtnClick: s
    };
  }
});
function gue(e, t, n, o, r, l) {
  const a = st("m-button"), i = st("m-menu-item"), s = st("m-menu"), c = st("down-outlined"), u = st("m-dropdown");
  return Ne(), it("div", {
    class: aa(["ability", e.$attrs.class, e.alignCp === "right" ? "right" : "left"]),
    style: Fr(e.$attrs.style)
  }, [
    (Ne(!0), it(Fe, null, ln(e.abilityItemsCp, (d, p) => (Ne(), it(Fe, null, [
      d.type === e.ABILITY_ITEM_TYPE.normal && !d.hidden ? (Ne(), Et(a, {
        key: p,
        disabled: d.disabled,
        loading: d.loading,
        size: "middle",
        onClick: (v) => e.handleNormalBtnClick(d)
      }, {
        default: pt(() => [
          Ot(dn(d.label), 1)
        ]),
        _: 2
      }, 1032, ["disabled", "loading", "onClick"])) : ht("", !0),
      d.type === e.ABILITY_ITEM_TYPE.multiple ? (Ne(), Et(u, { key: p }, {
        overlay: pt(() => [
          f(s, null, {
            default: pt(() => [
              (Ne(!0), it(Fe, null, ln(d.items, (v, h) => (Ne(), it(Fe, null, [
                v.hidden ? ht("", !0) : (Ne(), Et(i, {
                  key: h,
                  disabled: v.disabled,
                  onClick: (g) => e.handleAbilityMulClick(v)
                }, {
                  default: pt(() => [
                    Ot(dn(v.label), 1)
                  ]),
                  _: 2
                }, 1032, ["disabled", "onClick"]))
              ], 64))), 256))
            ]),
            _: 2
          }, 1024)
        ]),
        default: pt(() => [
          f(a, { size: "middle" }, {
            default: pt(() => [
              Ot(" 批量选择 "),
              f(c)
            ]),
            _: 1
          })
        ]),
        _: 2
      }, 1024)) : ht("", !0)
    ], 64))), 256))
  ], 6);
}
const mue = /* @__PURE__ */ _n(vue, [["render", gue], ["__scopeId", "data-v-86b0d07d"]]);
/**!
 * Sortable 1.15.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function wx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    t && (o = o.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, o);
  }
  return n;
}
function xr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wx(Object(n), !0).forEach(function(o) {
      hue(e, o, n[o]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wx(Object(n)).forEach(function(o) {
      Object.defineProperty(e, o, Object.getOwnPropertyDescriptor(n, o));
    });
  }
  return e;
}
function nd(e) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? nd = function(t) {
    return typeof t;
  } : nd = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nd(e);
}
function hue(e, t, n) {
  return t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Yr() {
  return Yr = Object.assign || function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var n = arguments[t];
      for (var o in n)
        Object.prototype.hasOwnProperty.call(n, o) && (e[o] = n[o]);
    }
    return e;
  }, Yr.apply(this, arguments);
}
function bue(e, t) {
  if (e == null)
    return {};
  var n = {}, o = Object.keys(e), r, l;
  for (l = 0; l < o.length; l++)
    r = o[l], !(t.indexOf(r) >= 0) && (n[r] = e[r]);
  return n;
}
function yue(e, t) {
  if (e == null)
    return {};
  var n = bue(e, t), o, r;
  if (Object.getOwnPropertySymbols) {
    var l = Object.getOwnPropertySymbols(e);
    for (r = 0; r < l.length; r++)
      o = l[r], !(t.indexOf(o) >= 0) && Object.prototype.propertyIsEnumerable.call(e, o) && (n[o] = e[o]);
  }
  return n;
}
var Sue = "1.15.2";
function Wr(e) {
  if (typeof window < "u" && window.navigator)
    return !!/* @__PURE__ */ navigator.userAgent.match(e);
}
var el = Wr(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i), Ic = Wr(/Edge/i), xx = Wr(/firefox/i), Is = Wr(/safari/i) && !Wr(/chrome/i) && !Wr(/android/i), EE = Wr(/iP(ad|od|hone)/i), TE = Wr(/chrome/i) && Wr(/android/i), ME = {
  capture: !1,
  passive: !1
};
function Nt(e, t, n) {
  e.addEventListener(t, n, !el && ME);
}
function At(e, t, n) {
  e.removeEventListener(t, n, !el && ME);
}
function sf(e, t) {
  if (t) {
    if (t[0] === ">" && (t = t.substring(1)), e)
      try {
        if (e.matches)
          return e.matches(t);
        if (e.msMatchesSelector)
          return e.msMatchesSelector(t);
        if (e.webkitMatchesSelector)
          return e.webkitMatchesSelector(t);
      } catch {
        return !1;
      }
    return !1;
  }
}
function Cue(e) {
  return e.host && e !== document && e.host.nodeType ? e.host : e.parentNode;
}
function qo(e, t, n, o) {
  if (e) {
    n = n || document;
    do {
      if (t != null && (t[0] === ">" ? e.parentNode === n && sf(e, t) : sf(e, t)) || o && e === n)
        return e;
      if (e === n)
        break;
    } while (e = Cue(e));
  }
  return null;
}
var Ox = /\s+/g;
function bo(e, t, n) {
  if (e && t)
    if (e.classList)
      e.classList[n ? "add" : "remove"](t);
    else {
      var o = (" " + e.className + " ").replace(Ox, " ").replace(" " + t + " ", " ");
      e.className = (o + (n ? " " + t : "")).replace(Ox, " ");
    }
}
function dt(e, t, n) {
  var o = e && e.style;
  if (o) {
    if (n === void 0)
      return document.defaultView && document.defaultView.getComputedStyle ? n = document.defaultView.getComputedStyle(e, "") : e.currentStyle && (n = e.currentStyle), t === void 0 ? n : n[t];
    !(t in o) && t.indexOf("webkit") === -1 && (t = "-webkit-" + t), o[t] = n + (typeof n == "string" ? "" : "px");
  }
}
function fi(e, t) {
  var n = "";
  if (typeof e == "string")
    n = e;
  else
    do {
      var o = dt(e, "transform");
      o && o !== "none" && (n = o + " " + n);
    } while (!t && (e = e.parentNode));
  var r = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return r && new r(n);
}
function _E(e, t, n) {
  if (e) {
    var o = e.getElementsByTagName(t), r = 0, l = o.length;
    if (n)
      for (; r < l; r++)
        n(o[r], r);
    return o;
  }
  return [];
}
function yr() {
  var e = document.scrollingElement;
  return e || document.documentElement;
}
function pn(e, t, n, o, r) {
  if (!(!e.getBoundingClientRect && e !== window)) {
    var l, a, i, s, c, u, d;
    if (e !== window && e.parentNode && e !== yr() ? (l = e.getBoundingClientRect(), a = l.top, i = l.left, s = l.bottom, c = l.right, u = l.height, d = l.width) : (a = 0, i = 0, s = window.innerHeight, c = window.innerWidth, u = window.innerHeight, d = window.innerWidth), (t || n) && e !== window && (r = r || e.parentNode, !el))
      do
        if (r && r.getBoundingClientRect && (dt(r, "transform") !== "none" || n && dt(r, "position") !== "static")) {
          var p = r.getBoundingClientRect();
          a -= p.top + parseInt(dt(r, "border-top-width")), i -= p.left + parseInt(dt(r, "border-left-width")), s = a + l.height, c = i + l.width;
          break;
        }
      while (r = r.parentNode);
    if (o && e !== window) {
      var v = fi(r || e), h = v && v.a, g = v && v.d;
      v && (a /= g, i /= h, d /= h, u /= g, s = a + u, c = i + d);
    }
    return {
      top: a,
      left: i,
      bottom: s,
      right: c,
      width: d,
      height: u
    };
  }
}
function Px(e, t, n) {
  for (var o = vl(e, !0), r = pn(e)[t]; o; ) {
    var l = pn(o)[n], a = void 0;
    if (a = r >= l, !a)
      return o;
    if (o === yr())
      break;
    o = vl(o, !1);
  }
  return !1;
}
function xi(e, t, n, o) {
  for (var r = 0, l = 0, a = e.children; l < a.length; ) {
    if (a[l].style.display !== "none" && a[l] !== ft.ghost && (o || a[l] !== ft.dragged) && qo(a[l], n.draggable, e, !1)) {
      if (r === t)
        return a[l];
      r++;
    }
    l++;
  }
  return null;
}
function Cy(e, t) {
  for (var n = e.lastElementChild; n && (n === ft.ghost || dt(n, "display") === "none" || t && !sf(n, t)); )
    n = n.previousElementSibling;
  return n || null;
}
function No(e, t) {
  var n = 0;
  if (!e || !e.parentNode)
    return -1;
  for (; e = e.previousElementSibling; )
    e.nodeName.toUpperCase() !== "TEMPLATE" && e !== ft.clone && (!t || sf(e, t)) && n++;
  return n;
}
function Ix(e) {
  var t = 0, n = 0, o = yr();
  if (e)
    do {
      var r = fi(e), l = r.a, a = r.d;
      t += e.scrollLeft * l, n += e.scrollTop * a;
    } while (e !== o && (e = e.parentNode));
  return [t, n];
}
function $ue(e, t) {
  for (var n in e)
    if (e.hasOwnProperty(n)) {
      for (var o in t)
        if (t.hasOwnProperty(o) && t[o] === e[n][o])
          return Number(n);
    }
  return -1;
}
function vl(e, t) {
  if (!e || !e.getBoundingClientRect)
    return yr();
  var n = e, o = !1;
  do
    if (n.clientWidth < n.scrollWidth || n.clientHeight < n.scrollHeight) {
      var r = dt(n);
      if (n.clientWidth < n.scrollWidth && (r.overflowX == "auto" || r.overflowX == "scroll") || n.clientHeight < n.scrollHeight && (r.overflowY == "auto" || r.overflowY == "scroll")) {
        if (!n.getBoundingClientRect || n === document.body)
          return yr();
        if (o || t)
          return n;
        o = !0;
      }
    }
  while (n = n.parentNode);
  return yr();
}
function wue(e, t) {
  if (e && t)
    for (var n in t)
      t.hasOwnProperty(n) && (e[n] = t[n]);
  return e;
}
function og(e, t) {
  return Math.round(e.top) === Math.round(t.top) && Math.round(e.left) === Math.round(t.left) && Math.round(e.height) === Math.round(t.height) && Math.round(e.width) === Math.round(t.width);
}
var Es;
function AE(e, t) {
  return function() {
    if (!Es) {
      var n = arguments, o = this;
      n.length === 1 ? e.call(o, n[0]) : e.apply(o, n), Es = setTimeout(function() {
        Es = void 0;
      }, t);
    }
  };
}
function xue() {
  clearTimeout(Es), Es = void 0;
}
function DE(e, t, n) {
  e.scrollLeft += t, e.scrollTop += n;
}
function NE(e) {
  var t = window.Polymer, n = window.jQuery || window.Zepto;
  return t && t.dom ? t.dom(e).cloneNode(!0) : n ? n(e).clone(!0)[0] : e.cloneNode(!0);
}
function RE(e, t, n) {
  var o = {};
  return Array.from(e.children).forEach(function(r) {
    var l, a, i, s;
    if (!(!qo(r, t.draggable, e, !1) || r.animated || r === n)) {
      var c = pn(r);
      o.left = Math.min((l = o.left) !== null && l !== void 0 ? l : 1 / 0, c.left), o.top = Math.min((a = o.top) !== null && a !== void 0 ? a : 1 / 0, c.top), o.right = Math.max((i = o.right) !== null && i !== void 0 ? i : -1 / 0, c.right), o.bottom = Math.max((s = o.bottom) !== null && s !== void 0 ? s : -1 / 0, c.bottom);
    }
  }), o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o;
}
var $o = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
function Oue() {
  var e = [], t;
  return {
    captureAnimationState: function() {
      if (e = [], !!this.options.animation) {
        var o = [].slice.call(this.el.children);
        o.forEach(function(r) {
          if (!(dt(r, "display") === "none" || r === ft.ghost)) {
            e.push({
              target: r,
              rect: pn(r)
            });
            var l = xr({}, e[e.length - 1].rect);
            if (r.thisAnimationDuration) {
              var a = fi(r, !0);
              a && (l.top -= a.f, l.left -= a.e);
            }
            r.fromRect = l;
          }
        });
      }
    },
    addAnimationState: function(o) {
      e.push(o);
    },
    removeAnimationState: function(o) {
      e.splice($ue(e, {
        target: o
      }), 1);
    },
    animateAll: function(o) {
      var r = this;
      if (!this.options.animation) {
        clearTimeout(t), typeof o == "function" && o();
        return;
      }
      var l = !1, a = 0;
      e.forEach(function(i) {
        var s = 0, c = i.target, u = c.fromRect, d = pn(c), p = c.prevFromRect, v = c.prevToRect, h = i.rect, g = fi(c, !0);
        g && (d.top -= g.f, d.left -= g.e), c.toRect = d, c.thisAnimationDuration && og(p, d) && !og(u, d) && // Make sure animatingRect is on line between toRect & fromRect
        (h.top - d.top) / (h.left - d.left) === (u.top - d.top) / (u.left - d.left) && (s = Iue(h, p, v, r.options)), og(d, u) || (c.prevFromRect = u, c.prevToRect = d, s || (s = r.options.animation), r.animate(c, h, d, s)), s && (l = !0, a = Math.max(a, s), clearTimeout(c.animationResetTimer), c.animationResetTimer = setTimeout(function() {
          c.animationTime = 0, c.prevFromRect = null, c.fromRect = null, c.prevToRect = null, c.thisAnimationDuration = null;
        }, s), c.thisAnimationDuration = s);
      }), clearTimeout(t), l ? t = setTimeout(function() {
        typeof o == "function" && o();
      }, a) : typeof o == "function" && o(), e = [];
    },
    animate: function(o, r, l, a) {
      if (a) {
        dt(o, "transition", ""), dt(o, "transform", "");
        var i = fi(this.el), s = i && i.a, c = i && i.d, u = (r.left - l.left) / (s || 1), d = (r.top - l.top) / (c || 1);
        o.animatingX = !!u, o.animatingY = !!d, dt(o, "transform", "translate3d(" + u + "px," + d + "px,0)"), this.forRepaintDummy = Pue(o), dt(o, "transition", "transform " + a + "ms" + (this.options.easing ? " " + this.options.easing : "")), dt(o, "transform", "translate3d(0,0,0)"), typeof o.animated == "number" && clearTimeout(o.animated), o.animated = setTimeout(function() {
          dt(o, "transition", ""), dt(o, "transform", ""), o.animated = !1, o.animatingX = !1, o.animatingY = !1;
        }, a);
      }
    }
  };
}
function Pue(e) {
  return e.offsetWidth;
}
function Iue(e, t, n, o) {
  return Math.sqrt(Math.pow(t.top - e.top, 2) + Math.pow(t.left - e.left, 2)) / Math.sqrt(Math.pow(t.top - n.top, 2) + Math.pow(t.left - n.left, 2)) * o.animation;
}
var Ba = [], rg = {
  initializeByDefault: !0
}, Ec = {
  mount: function(t) {
    for (var n in rg)
      rg.hasOwnProperty(n) && !(n in t) && (t[n] = rg[n]);
    Ba.forEach(function(o) {
      if (o.pluginName === t.pluginName)
        throw "Sortable: Cannot mount plugin ".concat(t.pluginName, " more than once");
    }), Ba.push(t);
  },
  pluginEvent: function(t, n, o) {
    var r = this;
    this.eventCanceled = !1, o.cancel = function() {
      r.eventCanceled = !0;
    };
    var l = t + "Global";
    Ba.forEach(function(a) {
      n[a.pluginName] && (n[a.pluginName][l] && n[a.pluginName][l](xr({
        sortable: n
      }, o)), n.options[a.pluginName] && n[a.pluginName][t] && n[a.pluginName][t](xr({
        sortable: n
      }, o)));
    });
  },
  initializePlugins: function(t, n, o, r) {
    Ba.forEach(function(i) {
      var s = i.pluginName;
      if (!(!t.options[s] && !i.initializeByDefault)) {
        var c = new i(t, n, t.options);
        c.sortable = t, c.options = t.options, t[s] = c, Yr(o, c.defaults);
      }
    });
    for (var l in t.options)
      if (t.options.hasOwnProperty(l)) {
        var a = this.modifyOption(t, l, t.options[l]);
        typeof a < "u" && (t.options[l] = a);
      }
  },
  getEventProperties: function(t, n) {
    var o = {};
    return Ba.forEach(function(r) {
      typeof r.eventProperties == "function" && Yr(o, r.eventProperties.call(n[r.pluginName], t));
    }), o;
  },
  modifyOption: function(t, n, o) {
    var r;
    return Ba.forEach(function(l) {
      t[l.pluginName] && l.optionListeners && typeof l.optionListeners[n] == "function" && (r = l.optionListeners[n].call(t[l.pluginName], o));
    }), r;
  }
};
function Eue(e) {
  var t = e.sortable, n = e.rootEl, o = e.name, r = e.targetEl, l = e.cloneEl, a = e.toEl, i = e.fromEl, s = e.oldIndex, c = e.newIndex, u = e.oldDraggableIndex, d = e.newDraggableIndex, p = e.originalEvent, v = e.putSortable, h = e.extraEventProperties;
  if (t = t || n && n[$o], !!t) {
    var g, b = t.options, y = "on" + o.charAt(0).toUpperCase() + o.substr(1);
    window.CustomEvent && !el && !Ic ? g = new CustomEvent(o, {
      bubbles: !0,
      cancelable: !0
    }) : (g = document.createEvent("Event"), g.initEvent(o, !0, !0)), g.to = a || n, g.from = i || n, g.item = r || n, g.clone = l, g.oldIndex = s, g.newIndex = c, g.oldDraggableIndex = u, g.newDraggableIndex = d, g.originalEvent = p, g.pullMode = v ? v.lastPutMode : void 0;
    var S = xr(xr({}, h), Ec.getEventProperties(o, t));
    for (var C in S)
      g[C] = S[C];
    n && n.dispatchEvent(g), b[y] && b[y].call(t, g);
  }
}
var Tue = ["evt"], ro = function(t, n) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, r = o.evt, l = yue(o, Tue);
  Ec.pluginEvent.bind(ft)(t, n, xr({
    dragEl: Be,
    parentEl: Jt,
    ghostEl: mt,
    rootEl: Wt,
    nextEl: zl,
    lastDownEl: od,
    cloneEl: Ut,
    cloneHidden: ul,
    dragStarted: as,
    putSortable: wn,
    activeSortable: ft.active,
    originalEvent: r,
    oldIndex: Qa,
    oldDraggableIndex: Ts,
    newIndex: yo,
    newDraggableIndex: il,
    hideGhostForTarget: LE,
    unhideGhostForTarget: zE,
    cloneNowHidden: function() {
      ul = !0;
    },
    cloneNowShown: function() {
      ul = !1;
    },
    dispatchSortableEvent: function(i) {
      Xn({
        sortable: n,
        name: i,
        originalEvent: r
      });
    }
  }, l));
};
function Xn(e) {
  Eue(xr({
    putSortable: wn,
    cloneEl: Ut,
    targetEl: Be,
    rootEl: Wt,
    oldIndex: Qa,
    oldDraggableIndex: Ts,
    newIndex: yo,
    newDraggableIndex: il
  }, e));
}
var Be, Jt, mt, Wt, zl, od, Ut, ul, Qa, yo, Ts, il, cu, wn, Ka = !1, cf = !1, uf = [], Bl, Xo, lg, ag, Ex, Tx, as, Fa, Ms, _s = !1, uu = !1, rd, Dn, ig = [], Ym = !1, df = [], Dp = typeof document < "u", du = EE, Mx = Ic || el ? "cssFloat" : "float", Mue = Dp && !TE && !EE && "draggable" in document.createElement("div"), kE = function() {
  if (Dp) {
    if (el)
      return !1;
    var e = document.createElement("x");
    return e.style.cssText = "pointer-events:auto", e.style.pointerEvents === "auto";
  }
}(), BE = function(t, n) {
  var o = dt(t), r = parseInt(o.width) - parseInt(o.paddingLeft) - parseInt(o.paddingRight) - parseInt(o.borderLeftWidth) - parseInt(o.borderRightWidth), l = xi(t, 0, n), a = xi(t, 1, n), i = l && dt(l), s = a && dt(a), c = i && parseInt(i.marginLeft) + parseInt(i.marginRight) + pn(l).width, u = s && parseInt(s.marginLeft) + parseInt(s.marginRight) + pn(a).width;
  if (o.display === "flex")
    return o.flexDirection === "column" || o.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  if (o.display === "grid")
    return o.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  if (l && i.float && i.float !== "none") {
    var d = i.float === "left" ? "left" : "right";
    return a && (s.clear === "both" || s.clear === d) ? "vertical" : "horizontal";
  }
  return l && (i.display === "block" || i.display === "flex" || i.display === "table" || i.display === "grid" || c >= r && o[Mx] === "none" || a && o[Mx] === "none" && c + u > r) ? "vertical" : "horizontal";
}, _ue = function(t, n, o) {
  var r = o ? t.left : t.top, l = o ? t.right : t.bottom, a = o ? t.width : t.height, i = o ? n.left : n.top, s = o ? n.right : n.bottom, c = o ? n.width : n.height;
  return r === i || l === s || r + a / 2 === i + c / 2;
}, Aue = function(t, n) {
  var o;
  return uf.some(function(r) {
    var l = r[$o].options.emptyInsertThreshold;
    if (!(!l || Cy(r))) {
      var a = pn(r), i = t >= a.left - l && t <= a.right + l, s = n >= a.top - l && n <= a.bottom + l;
      if (i && s)
        return o = r;
    }
  }), o;
}, FE = function(t) {
  function n(l, a) {
    return function(i, s, c, u) {
      var d = i.options.group.name && s.options.group.name && i.options.group.name === s.options.group.name;
      if (l == null && (a || d))
        return !0;
      if (l == null || l === !1)
        return !1;
      if (a && l === "clone")
        return l;
      if (typeof l == "function")
        return n(l(i, s, c, u), a)(i, s, c, u);
      var p = (a ? i : s).options.group.name;
      return l === !0 || typeof l == "string" && l === p || l.join && l.indexOf(p) > -1;
    };
  }
  var o = {}, r = t.group;
  (!r || nd(r) != "object") && (r = {
    name: r
  }), o.name = r.name, o.checkPull = n(r.pull, !0), o.checkPut = n(r.put), o.revertClone = r.revertClone, t.group = o;
}, LE = function() {
  !kE && mt && dt(mt, "display", "none");
}, zE = function() {
  !kE && mt && dt(mt, "display", "");
};
Dp && !TE && document.addEventListener("click", function(e) {
  if (cf)
    return e.preventDefault(), e.stopPropagation && e.stopPropagation(), e.stopImmediatePropagation && e.stopImmediatePropagation(), cf = !1, !1;
}, !0);
var Fl = function(t) {
  if (Be) {
    t = t.touches ? t.touches[0] : t;
    var n = Aue(t.clientX, t.clientY);
    if (n) {
      var o = {};
      for (var r in t)
        t.hasOwnProperty(r) && (o[r] = t[r]);
      o.target = o.rootEl = n, o.preventDefault = void 0, o.stopPropagation = void 0, n[$o]._onDragOver(o);
    }
  }
}, Due = function(t) {
  Be && Be.parentNode[$o]._isOutsideThisEl(t.target);
};
function ft(e, t) {
  if (!(e && e.nodeType && e.nodeType === 1))
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(e));
  this.el = e, this.options = t = Yr({}, t), e[$o] = this;
  var n = {
    group: null,
    sort: !0,
    disabled: !1,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(e.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: !1,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: !0,
    direction: function() {
      return BE(e, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: !0,
    animation: 0,
    easing: null,
    setData: function(a, i) {
      a.setData("Text", i.textContent);
    },
    dropBubble: !1,
    dragoverBubble: !1,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: !1,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: !1,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: !1,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: ft.supportPointer !== !1 && "PointerEvent" in window && !Is,
    emptyInsertThreshold: 5
  };
  Ec.initializePlugins(this, e, n);
  for (var o in n)
    !(o in t) && (t[o] = n[o]);
  FE(t);
  for (var r in this)
    r.charAt(0) === "_" && typeof this[r] == "function" && (this[r] = this[r].bind(this));
  this.nativeDraggable = t.forceFallback ? !1 : Mue, this.nativeDraggable && (this.options.touchStartThreshold = 1), t.supportPointer ? Nt(e, "pointerdown", this._onTapStart) : (Nt(e, "mousedown", this._onTapStart), Nt(e, "touchstart", this._onTapStart)), this.nativeDraggable && (Nt(e, "dragover", this), Nt(e, "dragenter", this)), uf.push(this.el), t.store && t.store.get && this.sort(t.store.get(this) || []), Yr(this, Oue());
}
ft.prototype = /** @lends Sortable.prototype */
{
  constructor: ft,
  _isOutsideThisEl: function(t) {
    !this.el.contains(t) && t !== this.el && (Fa = null);
  },
  _getDirection: function(t, n) {
    return typeof this.options.direction == "function" ? this.options.direction.call(this, t, n, Be) : this.options.direction;
  },
  _onTapStart: function(t) {
    if (t.cancelable) {
      var n = this, o = this.el, r = this.options, l = r.preventOnFilter, a = t.type, i = t.touches && t.touches[0] || t.pointerType && t.pointerType === "touch" && t, s = (i || t).target, c = t.target.shadowRoot && (t.path && t.path[0] || t.composedPath && t.composedPath()[0]) || s, u = r.filter;
      if (Hue(o), !Be && !(/mousedown|pointerdown/.test(a) && t.button !== 0 || r.disabled) && !c.isContentEditable && !(!this.nativeDraggable && Is && s && s.tagName.toUpperCase() === "SELECT") && (s = qo(s, r.draggable, o, !1), !(s && s.animated) && od !== s)) {
        if (Qa = No(s), Ts = No(s, r.draggable), typeof u == "function") {
          if (u.call(this, t, s, this)) {
            Xn({
              sortable: n,
              rootEl: c,
              name: "filter",
              targetEl: s,
              toEl: o,
              fromEl: o
            }), ro("filter", n, {
              evt: t
            }), l && t.cancelable && t.preventDefault();
            return;
          }
        } else if (u && (u = u.split(",").some(function(d) {
          if (d = qo(c, d.trim(), o, !1), d)
            return Xn({
              sortable: n,
              rootEl: d,
              name: "filter",
              targetEl: s,
              fromEl: o,
              toEl: o
            }), ro("filter", n, {
              evt: t
            }), !0;
        }), u)) {
          l && t.cancelable && t.preventDefault();
          return;
        }
        r.handle && !qo(c, r.handle, o, !1) || this._prepareDragStart(t, i, s);
      }
    }
  },
  _prepareDragStart: function(t, n, o) {
    var r = this, l = r.el, a = r.options, i = l.ownerDocument, s;
    if (o && !Be && o.parentNode === l) {
      var c = pn(o);
      if (Wt = l, Be = o, Jt = Be.parentNode, zl = Be.nextSibling, od = o, cu = a.group, ft.dragged = Be, Bl = {
        target: Be,
        clientX: (n || t).clientX,
        clientY: (n || t).clientY
      }, Ex = Bl.clientX - c.left, Tx = Bl.clientY - c.top, this._lastX = (n || t).clientX, this._lastY = (n || t).clientY, Be.style["will-change"] = "all", s = function() {
        if (ro("delayEnded", r, {
          evt: t
        }), ft.eventCanceled) {
          r._onDrop();
          return;
        }
        r._disableDelayedDragEvents(), !xx && r.nativeDraggable && (Be.draggable = !0), r._triggerDragStart(t, n), Xn({
          sortable: r,
          name: "choose",
          originalEvent: t
        }), bo(Be, a.chosenClass, !0);
      }, a.ignore.split(",").forEach(function(u) {
        _E(Be, u.trim(), sg);
      }), Nt(i, "dragover", Fl), Nt(i, "mousemove", Fl), Nt(i, "touchmove", Fl), Nt(i, "mouseup", r._onDrop), Nt(i, "touchend", r._onDrop), Nt(i, "touchcancel", r._onDrop), xx && this.nativeDraggable && (this.options.touchStartThreshold = 4, Be.draggable = !0), ro("delayStart", this, {
        evt: t
      }), a.delay && (!a.delayOnTouchOnly || n) && (!this.nativeDraggable || !(Ic || el))) {
        if (ft.eventCanceled) {
          this._onDrop();
          return;
        }
        Nt(i, "mouseup", r._disableDelayedDrag), Nt(i, "touchend", r._disableDelayedDrag), Nt(i, "touchcancel", r._disableDelayedDrag), Nt(i, "mousemove", r._delayedDragTouchMoveHandler), Nt(i, "touchmove", r._delayedDragTouchMoveHandler), a.supportPointer && Nt(i, "pointermove", r._delayedDragTouchMoveHandler), r._dragStartTimer = setTimeout(s, a.delay);
      } else
        s();
    }
  },
  _delayedDragTouchMoveHandler: function(t) {
    var n = t.touches ? t.touches[0] : t;
    Math.max(Math.abs(n.clientX - this._lastX), Math.abs(n.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag();
  },
  _disableDelayedDrag: function() {
    Be && sg(Be), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function() {
    var t = this.el.ownerDocument;
    At(t, "mouseup", this._disableDelayedDrag), At(t, "touchend", this._disableDelayedDrag), At(t, "touchcancel", this._disableDelayedDrag), At(t, "mousemove", this._delayedDragTouchMoveHandler), At(t, "touchmove", this._delayedDragTouchMoveHandler), At(t, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function(t, n) {
    n = n || t.pointerType == "touch" && t, !this.nativeDraggable || n ? this.options.supportPointer ? Nt(document, "pointermove", this._onTouchMove) : n ? Nt(document, "touchmove", this._onTouchMove) : Nt(document, "mousemove", this._onTouchMove) : (Nt(Be, "dragend", this), Nt(Wt, "dragstart", this._onDragStart));
    try {
      document.selection ? ld(function() {
        document.selection.empty();
      }) : window.getSelection().removeAllRanges();
    } catch {
    }
  },
  _dragStarted: function(t, n) {
    if (Ka = !1, Wt && Be) {
      ro("dragStarted", this, {
        evt: n
      }), this.nativeDraggable && Nt(document, "dragover", Due);
      var o = this.options;
      !t && bo(Be, o.dragClass, !1), bo(Be, o.ghostClass, !0), ft.active = this, t && this._appendGhost(), Xn({
        sortable: this,
        name: "start",
        originalEvent: n
      });
    } else
      this._nulling();
  },
  _emulateDragOver: function() {
    if (Xo) {
      this._lastX = Xo.clientX, this._lastY = Xo.clientY, LE();
      for (var t = document.elementFromPoint(Xo.clientX, Xo.clientY), n = t; t && t.shadowRoot && (t = t.shadowRoot.elementFromPoint(Xo.clientX, Xo.clientY), t !== n); )
        n = t;
      if (Be.parentNode[$o]._isOutsideThisEl(t), n)
        do {
          if (n[$o]) {
            var o = void 0;
            if (o = n[$o]._onDragOver({
              clientX: Xo.clientX,
              clientY: Xo.clientY,
              target: t,
              rootEl: n
            }), o && !this.options.dragoverBubble)
              break;
          }
          t = n;
        } while (n = n.parentNode);
      zE();
    }
  },
  _onTouchMove: function(t) {
    if (Bl) {
      var n = this.options, o = n.fallbackTolerance, r = n.fallbackOffset, l = t.touches ? t.touches[0] : t, a = mt && fi(mt, !0), i = mt && a && a.a, s = mt && a && a.d, c = du && Dn && Ix(Dn), u = (l.clientX - Bl.clientX + r.x) / (i || 1) + (c ? c[0] - ig[0] : 0) / (i || 1), d = (l.clientY - Bl.clientY + r.y) / (s || 1) + (c ? c[1] - ig[1] : 0) / (s || 1);
      if (!ft.active && !Ka) {
        if (o && Math.max(Math.abs(l.clientX - this._lastX), Math.abs(l.clientY - this._lastY)) < o)
          return;
        this._onDragStart(t, !0);
      }
      if (mt) {
        a ? (a.e += u - (lg || 0), a.f += d - (ag || 0)) : a = {
          a: 1,
          b: 0,
          c: 0,
          d: 1,
          e: u,
          f: d
        };
        var p = "matrix(".concat(a.a, ",").concat(a.b, ",").concat(a.c, ",").concat(a.d, ",").concat(a.e, ",").concat(a.f, ")");
        dt(mt, "webkitTransform", p), dt(mt, "mozTransform", p), dt(mt, "msTransform", p), dt(mt, "transform", p), lg = u, ag = d, Xo = l;
      }
      t.cancelable && t.preventDefault();
    }
  },
  _appendGhost: function() {
    if (!mt) {
      var t = this.options.fallbackOnBody ? document.body : Wt, n = pn(Be, !0, du, !0, t), o = this.options;
      if (du) {
        for (Dn = t; dt(Dn, "position") === "static" && dt(Dn, "transform") === "none" && Dn !== document; )
          Dn = Dn.parentNode;
        Dn !== document.body && Dn !== document.documentElement ? (Dn === document && (Dn = yr()), n.top += Dn.scrollTop, n.left += Dn.scrollLeft) : Dn = yr(), ig = Ix(Dn);
      }
      mt = Be.cloneNode(!0), bo(mt, o.ghostClass, !1), bo(mt, o.fallbackClass, !0), bo(mt, o.dragClass, !0), dt(mt, "transition", ""), dt(mt, "transform", ""), dt(mt, "box-sizing", "border-box"), dt(mt, "margin", 0), dt(mt, "top", n.top), dt(mt, "left", n.left), dt(mt, "width", n.width), dt(mt, "height", n.height), dt(mt, "opacity", "0.8"), dt(mt, "position", du ? "absolute" : "fixed"), dt(mt, "zIndex", "100000"), dt(mt, "pointerEvents", "none"), ft.ghost = mt, t.appendChild(mt), dt(mt, "transform-origin", Ex / parseInt(mt.style.width) * 100 + "% " + Tx / parseInt(mt.style.height) * 100 + "%");
    }
  },
  _onDragStart: function(t, n) {
    var o = this, r = t.dataTransfer, l = o.options;
    if (ro("dragStart", this, {
      evt: t
    }), ft.eventCanceled) {
      this._onDrop();
      return;
    }
    ro("setupClone", this), ft.eventCanceled || (Ut = NE(Be), Ut.removeAttribute("id"), Ut.draggable = !1, Ut.style["will-change"] = "", this._hideClone(), bo(Ut, this.options.chosenClass, !1), ft.clone = Ut), o.cloneId = ld(function() {
      ro("clone", o), !ft.eventCanceled && (o.options.removeCloneOnHide || Wt.insertBefore(Ut, Be), o._hideClone(), Xn({
        sortable: o,
        name: "clone"
      }));
    }), !n && bo(Be, l.dragClass, !0), n ? (cf = !0, o._loopId = setInterval(o._emulateDragOver, 50)) : (At(document, "mouseup", o._onDrop), At(document, "touchend", o._onDrop), At(document, "touchcancel", o._onDrop), r && (r.effectAllowed = "move", l.setData && l.setData.call(o, r, Be)), Nt(document, "drop", o), dt(Be, "transform", "translateZ(0)")), Ka = !0, o._dragStartId = ld(o._dragStarted.bind(o, n, t)), Nt(document, "selectstart", o), as = !0, Is && dt(document.body, "user-select", "none");
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function(t) {
    var n = this.el, o = t.target, r, l, a, i = this.options, s = i.group, c = ft.active, u = cu === s, d = i.sort, p = wn || c, v, h = this, g = !1;
    if (Ym)
      return;
    function b(B, F) {
      ro(B, h, xr({
        evt: t,
        isOwner: u,
        axis: v ? "vertical" : "horizontal",
        revert: a,
        dragRect: r,
        targetRect: l,
        canSort: d,
        fromSortable: p,
        target: o,
        completed: S,
        onMove: function(j, H) {
          return fu(Wt, n, Be, r, j, pn(j), t, H);
        },
        changed: C
      }, F));
    }
    function y() {
      b("dragOverAnimationCapture"), h.captureAnimationState(), h !== p && p.captureAnimationState();
    }
    function S(B) {
      return b("dragOverCompleted", {
        insertion: B
      }), B && (u ? c._hideClone() : c._showClone(h), h !== p && (bo(Be, wn ? wn.options.ghostClass : c.options.ghostClass, !1), bo(Be, i.ghostClass, !0)), wn !== h && h !== ft.active ? wn = h : h === ft.active && wn && (wn = null), p === h && (h._ignoreWhileAnimating = o), h.animateAll(function() {
        b("dragOverAnimationComplete"), h._ignoreWhileAnimating = null;
      }), h !== p && (p.animateAll(), p._ignoreWhileAnimating = null)), (o === Be && !Be.animated || o === n && !o.animated) && (Fa = null), !i.dragoverBubble && !t.rootEl && o !== document && (Be.parentNode[$o]._isOutsideThisEl(t.target), !B && Fl(t)), !i.dragoverBubble && t.stopPropagation && t.stopPropagation(), g = !0;
    }
    function C() {
      yo = No(Be), il = No(Be, i.draggable), Xn({
        sortable: h,
        name: "change",
        toEl: n,
        newIndex: yo,
        newDraggableIndex: il,
        originalEvent: t
      });
    }
    if (t.preventDefault !== void 0 && t.cancelable && t.preventDefault(), o = qo(o, i.draggable, n, !0), b("dragOver"), ft.eventCanceled)
      return g;
    if (Be.contains(t.target) || o.animated && o.animatingX && o.animatingY || h._ignoreWhileAnimating === o)
      return S(!1);
    if (cf = !1, c && !i.disabled && (u ? d || (a = Jt !== Wt) : wn === this || (this.lastPutMode = cu.checkPull(this, c, Be, t)) && s.checkPut(this, c, Be, t))) {
      if (v = this._getDirection(t, o) === "vertical", r = pn(Be), b("dragOverValid"), ft.eventCanceled)
        return g;
      if (a)
        return Jt = Wt, y(), this._hideClone(), b("revert"), ft.eventCanceled || (zl ? Wt.insertBefore(Be, zl) : Wt.appendChild(Be)), S(!0);
      var w = Cy(n, i.draggable);
      if (!w || Bue(t, v, this) && !w.animated) {
        if (w === Be)
          return S(!1);
        if (w && n === t.target && (o = w), o && (l = pn(o)), fu(Wt, n, Be, r, o, l, t, !!o) !== !1)
          return y(), w && w.nextSibling ? n.insertBefore(Be, w.nextSibling) : n.appendChild(Be), Jt = n, C(), S(!0);
      } else if (w && kue(t, v, this)) {
        var $ = xi(n, 0, i, !0);
        if ($ === Be)
          return S(!1);
        if (o = $, l = pn(o), fu(Wt, n, Be, r, o, l, t, !1) !== !1)
          return y(), n.insertBefore(Be, $), Jt = n, C(), S(!0);
      } else if (o.parentNode === n) {
        l = pn(o);
        var O = 0, x, I = Be.parentNode !== n, E = !_ue(Be.animated && Be.toRect || r, o.animated && o.toRect || l, v), _ = v ? "top" : "left", M = Px(o, "top", "top") || Px(Be, "top", "top"), R = M ? M.scrollTop : void 0;
        Fa !== o && (x = l[_], _s = !1, uu = !E && i.invertSwap || I), O = Fue(t, o, l, v, E ? 1 : i.swapThreshold, i.invertedSwapThreshold == null ? i.swapThreshold : i.invertedSwapThreshold, uu, Fa === o);
        var A;
        if (O !== 0) {
          var z = No(Be);
          do
            z -= O, A = Jt.children[z];
          while (A && (dt(A, "display") === "none" || A === mt));
        }
        if (O === 0 || A === o)
          return S(!1);
        Fa = o, Ms = O;
        var T = o.nextElementSibling, N = !1;
        N = O === 1;
        var k = fu(Wt, n, Be, r, o, l, t, N);
        if (k !== !1)
          return (k === 1 || k === -1) && (N = k === 1), Ym = !0, setTimeout(Rue, 30), y(), N && !T ? n.appendChild(Be) : o.parentNode.insertBefore(Be, N ? T : o), M && DE(M, 0, R - M.scrollTop), Jt = Be.parentNode, x !== void 0 && !uu && (rd = Math.abs(x - pn(o)[_])), C(), S(!0);
      }
      if (n.contains(Be))
        return S(!1);
    }
    return !1;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function() {
    At(document, "mousemove", this._onTouchMove), At(document, "touchmove", this._onTouchMove), At(document, "pointermove", this._onTouchMove), At(document, "dragover", Fl), At(document, "mousemove", Fl), At(document, "touchmove", Fl);
  },
  _offUpEvents: function() {
    var t = this.el.ownerDocument;
    At(t, "mouseup", this._onDrop), At(t, "touchend", this._onDrop), At(t, "pointerup", this._onDrop), At(t, "touchcancel", this._onDrop), At(document, "selectstart", this);
  },
  _onDrop: function(t) {
    var n = this.el, o = this.options;
    if (yo = No(Be), il = No(Be, o.draggable), ro("drop", this, {
      evt: t
    }), Jt = Be && Be.parentNode, yo = No(Be), il = No(Be, o.draggable), ft.eventCanceled) {
      this._nulling();
      return;
    }
    Ka = !1, uu = !1, _s = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), qm(this.cloneId), qm(this._dragStartId), this.nativeDraggable && (At(document, "drop", this), At(n, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), Is && dt(document.body, "user-select", ""), dt(Be, "transform", ""), t && (as && (t.cancelable && t.preventDefault(), !o.dropBubble && t.stopPropagation()), mt && mt.parentNode && mt.parentNode.removeChild(mt), (Wt === Jt || wn && wn.lastPutMode !== "clone") && Ut && Ut.parentNode && Ut.parentNode.removeChild(Ut), Be && (this.nativeDraggable && At(Be, "dragend", this), sg(Be), Be.style["will-change"] = "", as && !Ka && bo(Be, wn ? wn.options.ghostClass : this.options.ghostClass, !1), bo(Be, this.options.chosenClass, !1), Xn({
      sortable: this,
      name: "unchoose",
      toEl: Jt,
      newIndex: null,
      newDraggableIndex: null,
      originalEvent: t
    }), Wt !== Jt ? (yo >= 0 && (Xn({
      rootEl: Jt,
      name: "add",
      toEl: Jt,
      fromEl: Wt,
      originalEvent: t
    }), Xn({
      sortable: this,
      name: "remove",
      toEl: Jt,
      originalEvent: t
    }), Xn({
      rootEl: Jt,
      name: "sort",
      toEl: Jt,
      fromEl: Wt,
      originalEvent: t
    }), Xn({
      sortable: this,
      name: "sort",
      toEl: Jt,
      originalEvent: t
    })), wn && wn.save()) : yo !== Qa && yo >= 0 && (Xn({
      sortable: this,
      name: "update",
      toEl: Jt,
      originalEvent: t
    }), Xn({
      sortable: this,
      name: "sort",
      toEl: Jt,
      originalEvent: t
    })), ft.active && ((yo == null || yo === -1) && (yo = Qa, il = Ts), Xn({
      sortable: this,
      name: "end",
      toEl: Jt,
      originalEvent: t
    }), this.save()))), this._nulling();
  },
  _nulling: function() {
    ro("nulling", this), Wt = Be = Jt = mt = zl = Ut = od = ul = Bl = Xo = as = yo = il = Qa = Ts = Fa = Ms = wn = cu = ft.dragged = ft.ghost = ft.clone = ft.active = null, df.forEach(function(t) {
      t.checked = !0;
    }), df.length = lg = ag = 0;
  },
  handleEvent: function(t) {
    switch (t.type) {
      case "drop":
      case "dragend":
        this._onDrop(t);
        break;
      case "dragenter":
      case "dragover":
        Be && (this._onDragOver(t), Nue(t));
        break;
      case "selectstart":
        t.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function() {
    for (var t = [], n, o = this.el.children, r = 0, l = o.length, a = this.options; r < l; r++)
      n = o[r], qo(n, a.draggable, this.el, !1) && t.push(n.getAttribute(a.dataIdAttr) || zue(n));
    return t;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function(t, n) {
    var o = {}, r = this.el;
    this.toArray().forEach(function(l, a) {
      var i = r.children[a];
      qo(i, this.options.draggable, r, !1) && (o[l] = i);
    }, this), n && this.captureAnimationState(), t.forEach(function(l) {
      o[l] && (r.removeChild(o[l]), r.appendChild(o[l]));
    }), n && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function() {
    var t = this.options.store;
    t && t.set && t.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function(t, n) {
    return qo(t, n || this.options.draggable, this.el, !1);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function(t, n) {
    var o = this.options;
    if (n === void 0)
      return o[t];
    var r = Ec.modifyOption(this, t, n);
    typeof r < "u" ? o[t] = r : o[t] = n, t === "group" && FE(o);
  },
  /**
   * Destroy
   */
  destroy: function() {
    ro("destroy", this);
    var t = this.el;
    t[$o] = null, At(t, "mousedown", this._onTapStart), At(t, "touchstart", this._onTapStart), At(t, "pointerdown", this._onTapStart), this.nativeDraggable && (At(t, "dragover", this), At(t, "dragenter", this)), Array.prototype.forEach.call(t.querySelectorAll("[draggable]"), function(n) {
      n.removeAttribute("draggable");
    }), this._onDrop(), this._disableDelayedDragEvents(), uf.splice(uf.indexOf(this.el), 1), this.el = t = null;
  },
  _hideClone: function() {
    if (!ul) {
      if (ro("hideClone", this), ft.eventCanceled)
        return;
      dt(Ut, "display", "none"), this.options.removeCloneOnHide && Ut.parentNode && Ut.parentNode.removeChild(Ut), ul = !0;
    }
  },
  _showClone: function(t) {
    if (t.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (ul) {
      if (ro("showClone", this), ft.eventCanceled)
        return;
      Be.parentNode == Wt && !this.options.group.revertClone ? Wt.insertBefore(Ut, Be) : zl ? Wt.insertBefore(Ut, zl) : Wt.appendChild(Ut), this.options.group.revertClone && this.animate(Be, Ut), dt(Ut, "display", ""), ul = !1;
    }
  }
};
function Nue(e) {
  e.dataTransfer && (e.dataTransfer.dropEffect = "move"), e.cancelable && e.preventDefault();
}
function fu(e, t, n, o, r, l, a, i) {
  var s, c = e[$o], u = c.options.onMove, d;
  return window.CustomEvent && !el && !Ic ? s = new CustomEvent("move", {
    bubbles: !0,
    cancelable: !0
  }) : (s = document.createEvent("Event"), s.initEvent("move", !0, !0)), s.to = t, s.from = e, s.dragged = n, s.draggedRect = o, s.related = r || t, s.relatedRect = l || pn(t), s.willInsertAfter = i, s.originalEvent = a, e.dispatchEvent(s), u && (d = u.call(c, s, a)), d;
}
function sg(e) {
  e.draggable = !1;
}
function Rue() {
  Ym = !1;
}
function kue(e, t, n) {
  var o = pn(xi(n.el, 0, n.options, !0)), r = RE(n.el, n.options, mt), l = 10;
  return t ? e.clientX < r.left - l || e.clientY < o.top && e.clientX < o.right : e.clientY < r.top - l || e.clientY < o.bottom && e.clientX < o.left;
}
function Bue(e, t, n) {
  var o = pn(Cy(n.el, n.options.draggable)), r = RE(n.el, n.options, mt), l = 10;
  return t ? e.clientX > r.right + l || e.clientY > o.bottom && e.clientX > o.left : e.clientY > r.bottom + l || e.clientX > o.right && e.clientY > o.top;
}
function Fue(e, t, n, o, r, l, a, i) {
  var s = o ? e.clientY : e.clientX, c = o ? n.height : n.width, u = o ? n.top : n.left, d = o ? n.bottom : n.right, p = !1;
  if (!a) {
    if (i && rd < c * r) {
      if (!_s && (Ms === 1 ? s > u + c * l / 2 : s < d - c * l / 2) && (_s = !0), _s)
        p = !0;
      else if (Ms === 1 ? s < u + rd : s > d - rd)
        return -Ms;
    } else if (s > u + c * (1 - r) / 2 && s < d - c * (1 - r) / 2)
      return Lue(t);
  }
  return p = p || a, p && (s < u + c * l / 2 || s > d - c * l / 2) ? s > u + c / 2 ? 1 : -1 : 0;
}
function Lue(e) {
  return No(Be) < No(e) ? 1 : -1;
}
function zue(e) {
  for (var t = e.tagName + e.className + e.src + e.href + e.textContent, n = t.length, o = 0; n--; )
    o += t.charCodeAt(n);
  return o.toString(36);
}
function Hue(e) {
  df.length = 0;
  for (var t = e.getElementsByTagName("input"), n = t.length; n--; ) {
    var o = t[n];
    o.checked && df.push(o);
  }
}
function ld(e) {
  return setTimeout(e, 0);
}
function qm(e) {
  return clearTimeout(e);
}
Dp && Nt(document, "touchmove", function(e) {
  (ft.active || Ka) && e.cancelable && e.preventDefault();
});
ft.utils = {
  on: Nt,
  off: At,
  css: dt,
  find: _E,
  is: function(t, n) {
    return !!qo(t, n, t, !1);
  },
  extend: wue,
  throttle: AE,
  closest: qo,
  toggleClass: bo,
  clone: NE,
  index: No,
  nextTick: ld,
  cancelNextTick: qm,
  detectDirection: BE,
  getChild: xi
};
ft.get = function(e) {
  return e[$o];
};
ft.mount = function() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  t[0].constructor === Array && (t = t[0]), t.forEach(function(o) {
    if (!o.prototype || !o.prototype.constructor)
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(o));
    o.utils && (ft.utils = xr(xr({}, ft.utils), o.utils)), Ec.mount(o);
  });
};
ft.create = function(e, t) {
  return new ft(e, t);
};
ft.version = Sue;
var un = [], is, Zm, Qm = !1, cg, ug, ff, ss;
function jue() {
  function e() {
    this.defaults = {
      scroll: !0,
      forceAutoScrollFallback: !1,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: !0
    };
    for (var t in this)
      t.charAt(0) === "_" && typeof this[t] == "function" && (this[t] = this[t].bind(this));
  }
  return e.prototype = {
    dragStarted: function(n) {
      var o = n.originalEvent;
      this.sortable.nativeDraggable ? Nt(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? Nt(document, "pointermove", this._handleFallbackAutoScroll) : o.touches ? Nt(document, "touchmove", this._handleFallbackAutoScroll) : Nt(document, "mousemove", this._handleFallbackAutoScroll);
    },
    dragOverCompleted: function(n) {
      var o = n.originalEvent;
      !this.options.dragOverBubble && !o.rootEl && this._handleAutoScroll(o);
    },
    drop: function() {
      this.sortable.nativeDraggable ? At(document, "dragover", this._handleAutoScroll) : (At(document, "pointermove", this._handleFallbackAutoScroll), At(document, "touchmove", this._handleFallbackAutoScroll), At(document, "mousemove", this._handleFallbackAutoScroll)), _x(), ad(), xue();
    },
    nulling: function() {
      ff = Zm = is = Qm = ss = cg = ug = null, un.length = 0;
    },
    _handleFallbackAutoScroll: function(n) {
      this._handleAutoScroll(n, !0);
    },
    _handleAutoScroll: function(n, o) {
      var r = this, l = (n.touches ? n.touches[0] : n).clientX, a = (n.touches ? n.touches[0] : n).clientY, i = document.elementFromPoint(l, a);
      if (ff = n, o || this.options.forceAutoScrollFallback || Ic || el || Is) {
        dg(n, this.options, i, o);
        var s = vl(i, !0);
        Qm && (!ss || l !== cg || a !== ug) && (ss && _x(), ss = setInterval(function() {
          var c = vl(document.elementFromPoint(l, a), !0);
          c !== s && (s = c, ad()), dg(n, r.options, c, o);
        }, 10), cg = l, ug = a);
      } else {
        if (!this.options.bubbleScroll || vl(i, !0) === yr()) {
          ad();
          return;
        }
        dg(n, this.options, vl(i, !1), !1);
      }
    }
  }, Yr(e, {
    pluginName: "scroll",
    initializeByDefault: !0
  });
}
function ad() {
  un.forEach(function(e) {
    clearInterval(e.pid);
  }), un = [];
}
function _x() {
  clearInterval(ss);
}
var dg = AE(function(e, t, n, o) {
  if (t.scroll) {
    var r = (e.touches ? e.touches[0] : e).clientX, l = (e.touches ? e.touches[0] : e).clientY, a = t.scrollSensitivity, i = t.scrollSpeed, s = yr(), c = !1, u;
    Zm !== n && (Zm = n, ad(), is = t.scroll, u = t.scrollFn, is === !0 && (is = vl(n, !0)));
    var d = 0, p = is;
    do {
      var v = p, h = pn(v), g = h.top, b = h.bottom, y = h.left, S = h.right, C = h.width, w = h.height, $ = void 0, O = void 0, x = v.scrollWidth, I = v.scrollHeight, E = dt(v), _ = v.scrollLeft, M = v.scrollTop;
      v === s ? ($ = C < x && (E.overflowX === "auto" || E.overflowX === "scroll" || E.overflowX === "visible"), O = w < I && (E.overflowY === "auto" || E.overflowY === "scroll" || E.overflowY === "visible")) : ($ = C < x && (E.overflowX === "auto" || E.overflowX === "scroll"), O = w < I && (E.overflowY === "auto" || E.overflowY === "scroll"));
      var R = $ && (Math.abs(S - r) <= a && _ + C < x) - (Math.abs(y - r) <= a && !!_), A = O && (Math.abs(b - l) <= a && M + w < I) - (Math.abs(g - l) <= a && !!M);
      if (!un[d])
        for (var z = 0; z <= d; z++)
          un[z] || (un[z] = {});
      (un[d].vx != R || un[d].vy != A || un[d].el !== v) && (un[d].el = v, un[d].vx = R, un[d].vy = A, clearInterval(un[d].pid), (R != 0 || A != 0) && (c = !0, un[d].pid = setInterval((function() {
        o && this.layer === 0 && ft.active._onTouchMove(ff);
        var T = un[this.layer].vy ? un[this.layer].vy * i : 0, N = un[this.layer].vx ? un[this.layer].vx * i : 0;
        typeof u == "function" && u.call(ft.dragged.parentNode[$o], N, T, e, ff, un[this.layer].el) !== "continue" || DE(un[this.layer].el, N, T);
      }).bind({
        layer: d
      }), 24))), d++;
    } while (t.bubbleScroll && p !== s && (p = vl(p, !1)));
    Qm = c;
  }
}, 30), HE = function(t) {
  var n = t.originalEvent, o = t.putSortable, r = t.dragEl, l = t.activeSortable, a = t.dispatchSortableEvent, i = t.hideGhostForTarget, s = t.unhideGhostForTarget;
  if (n) {
    var c = o || l;
    i();
    var u = n.changedTouches && n.changedTouches.length ? n.changedTouches[0] : n, d = document.elementFromPoint(u.clientX, u.clientY);
    s(), c && !c.el.contains(d) && (a("spill"), this.onSpill({
      dragEl: r,
      putSortable: o
    }));
  }
};
function $y() {
}
$y.prototype = {
  startIndex: null,
  dragStart: function(t) {
    var n = t.oldDraggableIndex;
    this.startIndex = n;
  },
  onSpill: function(t) {
    var n = t.dragEl, o = t.putSortable;
    this.sortable.captureAnimationState(), o && o.captureAnimationState();
    var r = xi(this.sortable.el, this.startIndex, this.options);
    r ? this.sortable.el.insertBefore(n, r) : this.sortable.el.appendChild(n), this.sortable.animateAll(), o && o.animateAll();
  },
  drop: HE
};
Yr($y, {
  pluginName: "revertOnSpill"
});
function wy() {
}
wy.prototype = {
  onSpill: function(t) {
    var n = t.dragEl, o = t.putSortable, r = o || this.sortable;
    r.captureAnimationState(), n.parentNode && n.parentNode.removeChild(n), r.animateAll();
  },
  drop: HE
};
Yr(wy, {
  pluginName: "removeOnSpill"
});
ft.mount(new jue());
ft.mount(wy, $y);
const jE = {
  change: "change",
  updateOpen: "update:open"
}, Vue = Object.values(jE), Wue = {
  open: {
    required: !0,
    type: Boolean
  },
  config: {
    required: !0,
    type: Object
  }
}, Kue = Z({
  components: {
    DragOutlined: uy
  },
  inheritAttrs: !1,
  props: Wue,
  emits: Vue,
  setup(e, { emit: t }) {
    const n = Ap(e, "open", t), o = Y(), r = Y([]), l = Y([]), a = Y([]), i = Y({
      checkAll: P(() => [
        ...r.value.filter((d) => d.checked),
        ...l.value.filter((d) => d.checked),
        ...a.value.filter((d) => d.checked)
      ].length === r.value.length + l.value.length + a.value.length),
      indeterminate: P(() => {
        const d = [
          ...r.value.filter((v) => v.checked),
          ...l.value.filter((v) => v.checked),
          ...a.value.filter((v) => v.checked)
        ].length, p = r.value.length + l.value.length + a.value.length;
        return !(d === 0 || d === p);
      })
    });
    function s() {
      const d = o.value;
      ft.create(d, {
        animation: 200,
        //拖拽动画过渡时间
        group: "name",
        sort: !0,
        onEnd: function(p) {
          const v = p.oldIndex, h = p.newIndex;
          let g = l.value[v];
          if (v < h)
            for (let b = v; b < h; b++)
              l.value[b] = l.value[b + 1];
          else if (v > h)
            for (let b = v; b > h; b--)
              l.value[b] = l.value[b - 1];
          l.value[h] = g;
        }
      });
    }
    function c() {
      n.value = !1, t(jE.change, {
        fixedLeftColumns: r.value,
        activeColumns: l.value,
        fixedRightColumns: a.value
      });
    }
    function u() {
      i.value.checkAll ? (r.value.forEach((d) => d.checked = !1), l.value.forEach((d) => d.checked = !1), a.value.forEach((d) => d.checked = !1)) : (r.value.forEach((d) => d.checked = !0), l.value.forEach((d) => d.checked = !0), a.value.forEach((d) => d.checked = !0));
    }
    return ie(
      [() => e.config],
      () => {
        r.value = _e(e.config.fixedLeftColumns), l.value = _e(e.config.activeColumns), a.value = _e(e.config.fixedRightColumns);
      },
      {
        immediate: !0,
        deep: !0
      }
    ), Ke(() => {
      s();
    }), {
      sortableBoxCompRef: o,
      handleOk: c,
      fixedLeftColumnsRef: r,
      activeColumnsRef: l,
      fixedRightColumnsRef: a,
      openVM: n,
      checkConfigRf: i,
      handleCheckChange: u
    };
  }
}), Gue = { class: "no-drag-item" }, Xue = { class: "checkbox" }, Uue = { class: "checkbox" }, Yue = {
  key: 1,
  ref: "sortableBoxCompRef"
}, que = { class: "checkbox" }, Zue = { class: "checkbox" };
function Que(e, t, n, o, r, l) {
  const a = st("m-checkbox"), i = st("drag-outlined"), s = st("m-modal");
  return Ne(), Et(s, {
    open: e.openVM,
    "onUpdate:open": t[0] || (t[0] = (c) => e.openVM = c),
    title: "自定义列",
    onOk: e.handleOk
  }, {
    default: pt(() => [
      rn("div", Gue, [
        rn("div", Xue, [
          f(a, {
            checked: e.checkConfigRf.checkAll,
            indeterminate: e.checkConfigRf.indeterminate,
            onChange: e.handleCheckChange
          }, {
            default: pt(() => [
              Ot(" 全选/反选 ")
            ]),
            _: 1
          }, 8, ["checked", "indeterminate", "onChange"])
        ])
      ]),
      e.fixedLeftColumnsRef.length > 0 ? (Ne(!0), it(Fe, { key: 0 }, ln(e.fixedLeftColumnsRef, (c, u) => (Ne(), it("div", {
        key: u,
        class: "no-drag-item"
      }, [
        rn("div", Uue, [
          f(a, {
            checked: c.checked,
            "onUpdate:checked": (d) => c.checked = d
          }, {
            default: pt(() => [
              Ot(dn(c.title), 1)
            ]),
            _: 2
          }, 1032, ["checked", "onUpdate:checked"])
        ])
      ]))), 128)) : ht("", !0),
      e.activeColumnsRef.length > 0 ? (Ne(), it("div", Yue, [
        (Ne(!0), it(Fe, null, ln(e.activeColumnsRef, (c) => (Ne(), it("div", {
          key: c.dataIndex,
          class: "drag-item"
        }, [
          f(i, { class: "drag-icon" }),
          rn("div", que, [
            f(a, {
              checked: c.checked,
              "onUpdate:checked": (u) => c.checked = u
            }, {
              default: pt(() => [
                Ot(dn(c.title), 1)
              ]),
              _: 2
            }, 1032, ["checked", "onUpdate:checked"])
          ])
        ]))), 128))
      ], 512)) : ht("", !0),
      e.fixedRightColumnsRef.length > 0 ? (Ne(!0), it(Fe, { key: 2 }, ln(e.fixedRightColumnsRef, (c, u) => (Ne(), it("div", {
        key: u,
        class: "no-drag-item"
      }, [
        rn("div", Zue, [
          f(a, {
            checked: c.checked,
            "onUpdate:checked": (d) => c.checked = d
          }, {
            default: pt(() => [
              Ot(dn(c.title), 1)
            ]),
            _: 2
          }, 1032, ["checked", "onUpdate:checked"])
        ])
      ]))), 128)) : ht("", !0)
    ]),
    _: 1
  }, 8, ["open", "onOk"]);
}
const Jue = /* @__PURE__ */ _n(Kue, [["render", Que], ["__scopeId", "data-v-33794367"]]), VE = {
  change: "change",
  updateModelValue: "update:modelValue"
}, ede = Object.values(VE), tde = {
  modelValue: {
    required: !0,
    type: [String, Number]
  },
  tabsConfig: {
    required: !1,
    type: Object
  }
}, nde = Z({
  props: tde,
  emits: ede,
  setup(e, { emit: t }) {
    const n = Ap(e, "modelValue", t);
    function o(r) {
      n.value = r, t(VE.change);
    }
    return ie(
      [() => e.tabsConfig.defaultValue],
      () => {
        e.tabsConfig.defaultValue ? n.value = e.tabsConfig.defaultValue : n.value = e.tabsConfig.items && e.tabsConfig.items[0] && e.tabsConfig.items[0].key || "";
      },
      {
        immediate: !0
      }
    ), {
      activeKeyVM: n,
      handleChange: o
    };
  }
});
function ode(e, t, n, o, r, l) {
  const a = st("m-tab-pane"), i = st("m-tabs");
  return e.tabsConfig.items && e.tabsConfig.items.length > 0 ? (Ne(), Et(i, {
    key: 0,
    activeKey: e.activeKeyVM,
    type: "card",
    onChange: e.handleChange
  }, {
    default: pt(() => [
      (Ne(!0), it(Fe, null, ln(e.tabsConfig.items, (s) => (Ne(), Et(a, {
        key: s.key,
        tab: s.tab
      }, null, 8, ["tab"]))), 128))
    ]),
    _: 1
  }, 8, ["activeKey", "onChange"])) : ht("", !0);
}
const rde = /* @__PURE__ */ _n(nde, [["render", ode], ["__scopeId", "data-v-d3a3fcf0"]]), Ax = [
  [
    "requestFullscreen",
    "exitFullscreen",
    "fullscreenElement",
    "fullscreenEnabled",
    "fullscreenchange",
    "fullscreenerror"
  ],
  // New WebKit
  [
    "webkitRequestFullscreen",
    "webkitExitFullscreen",
    "webkitFullscreenElement",
    "webkitFullscreenEnabled",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  // Old WebKit
  [
    "webkitRequestFullScreen",
    "webkitCancelFullScreen",
    "webkitCurrentFullScreenElement",
    "webkitCancelFullScreen",
    "webkitfullscreenchange",
    "webkitfullscreenerror"
  ],
  [
    "mozRequestFullScreen",
    "mozCancelFullScreen",
    "mozFullScreenElement",
    "mozFullScreenEnabled",
    "mozfullscreenchange",
    "mozfullscreenerror"
  ],
  [
    "msRequestFullscreen",
    "msExitFullscreen",
    "msFullscreenElement",
    "msFullscreenEnabled",
    "MSFullscreenChange",
    "MSFullscreenError"
  ]
], Kr = (() => {
  if (typeof document > "u")
    return !1;
  const e = Ax[0], t = {};
  for (const n of Ax)
    if ((n == null ? void 0 : n[1]) in document) {
      for (const [r, l] of n.entries())
        t[e[r]] = l;
      return t;
    }
  return !1;
})(), Dx = {
  change: Kr.fullscreenchange,
  error: Kr.fullscreenerror
};
let Co = {
  // eslint-disable-next-line default-param-last
  request(e = document.documentElement, t) {
    return new Promise((n, o) => {
      const r = () => {
        Co.off("change", r), n();
      };
      Co.on("change", r);
      const l = e[Kr.requestFullscreen](t);
      l instanceof Promise && l.then(r).catch(o);
    });
  },
  exit() {
    return new Promise((e, t) => {
      if (!Co.isFullscreen) {
        e();
        return;
      }
      const n = () => {
        Co.off("change", n), e();
      };
      Co.on("change", n);
      const o = document[Kr.exitFullscreen]();
      o instanceof Promise && o.then(n).catch(t);
    });
  },
  toggle(e, t) {
    return Co.isFullscreen ? Co.exit() : Co.request(e, t);
  },
  onchange(e) {
    Co.on("change", e);
  },
  onerror(e) {
    Co.on("error", e);
  },
  on(e, t) {
    const n = Dx[e];
    n && document.addEventListener(n, t, !1);
  },
  off(e, t) {
    const n = Dx[e];
    n && document.removeEventListener(n, t, !1);
  },
  raw: Kr
};
Object.defineProperties(Co, {
  isFullscreen: {
    get: () => !!document[Kr.fullscreenElement]
  },
  element: {
    enumerable: !0,
    get: () => document[Kr.fullscreenElement] ?? void 0
  },
  isEnabled: {
    enumerable: !0,
    // Coerce to boolean in case of old WebKit.
    get: () => !!document[Kr.fullscreenEnabled]
  }
});
Kr || (Co = { isEnabled: !1 });
const es = Co, fg = Y({});
function lde() {
  const e = Y(null);
  function t() {
    es.isFullscreen ? (fg.value = {
      getContainer: () => e.value
    }, e.value.classList.add("m-overflow-auto")) : (fg.value = void 0, e.value.classList.remove("m-overflow-auto"));
  }
  function n() {
    const o = e.value;
    es.isEnabled && es.request(o);
  }
  return Ke(() => {
    es.on("change", t);
  }), et(() => {
    es.off("change", t);
  }), {
    tableContainerDomRef: e,
    handleFullScreen: n,
    stickyRef: fg
  };
}
function WE(e, t) {
  e.shownColumns.forEach((n) => {
    const o = t.find((r) => r.dataIndex === n.dataIndex);
    n && n.typeConfig && (n.typeConfig = o.typeConfig);
  });
}
const cs = "m-components", Hl = "table-columns", Ja = Y(""), ade = {
  oriColumns: [],
  // 输入的columns
  config: {
    fixedLeftColumns: [],
    // 不可以拖拽，可以多选
    activeColumns: [],
    // 可以拖拽，可以多选
    fixedRightColumns: []
    // 不可以拖拽，可以多选
  },
  // 拖拽及多选的columns
  shownColumns: []
  // 展示的columns
};
function ide() {
  Ja.value = location.href;
}
function KE(e, t, n) {
  return [
    ...e.filter((r) => r.checked).map((r) => {
      const l = { ...r };
      return delete l.checked, l;
    }),
    ...t.filter((r) => r.checked).map((r) => {
      const l = { ...r };
      return delete l.checked, l;
    }),
    ...n.filter((r) => r.checked).map((r) => {
      const l = { ...r };
      return delete l.checked, l;
    })
  ];
}
function sde(e) {
  const t = e.findLastIndex(
    (r) => ["left", !0].includes(r.fixed)
  );
  let n = e.findIndex((r) => ["right"].includes(r.fixed));
  n = n === -1 ? e.length : n;
  const o = {
    oriColumns: [],
    // 输入的columns
    config: {
      fixedLeftColumns: e.slice(0, t + 1),
      // 不可以拖拽，可以多选
      activeColumns: e.slice(t + 1, n),
      // 可以拖拽，可以多选
      fixedRightColumns: e.slice(n)
      // 不可以拖拽，可以多选
    },
    // 拖拽及多选的columns
    shownColumns: []
    // 展示的columns
  };
  return o.config.fixedLeftColumns.forEach((r) => r.checked = !0), o.config.activeColumns.forEach((r) => r.checked = !0), o.config.fixedRightColumns.forEach((r) => r.checked = !0), o.oriColumns = e, o.shownColumns = KE(
    o.config.fixedLeftColumns,
    o.config.activeColumns,
    o.config.fixedRightColumns
  ), o;
}
function cde(e, t) {
  if (e.value.shownColumns = KE(
    e.value.config.fixedLeftColumns,
    e.value.config.activeColumns,
    e.value.config.fixedRightColumns
  ), WE(e.value, t), !localStorage.getItem(cs))
    localStorage.setItem(
      cs,
      JSON.stringify({
        [Hl]: {
          [Ja.value]: e.value
        }
      })
    );
  else {
    const o = JSON.parse(localStorage.getItem(cs));
    o[Hl] || (o[Hl] = {}), o[Hl][Ja.value] ? o[Hl][Ja.value] = e.value : o[Hl][Ja.value] = {}, localStorage.setItem(cs, JSON.stringify(o));
  }
}
function ude(e) {
  ide();
  const t = Y(), n = Y();
  function o() {
    let a = _e(ade);
    const i = sde(e.value);
    let s = localStorage.getItem(cs);
    if (!s)
      a = i;
    else {
      s = JSON.parse(s);
      const c = s[Hl];
      if (!c)
        a = i;
      else {
        const u = c[Ja.value];
        u ? JSON.stringify(u.oriColumns) !== JSON.stringify(e.value) ? a = i : (a = u, WE(a, e.value)) : a = i;
      }
    }
    return {
      isShowCustomColumnsModal: !1,
      pageConfig: a
    };
  }
  function r(l) {
    n.value.config = l, cde(n, e.value);
  }
  return ie(
    e,
    () => {
      const { isShowCustomColumnsModal: l, pageConfig: a } = o();
      t.value = l, n.value = a;
    },
    {
      immediate: !0
    }
  ), {
    pageConfigRef: n,
    isShowCustomColumnsModalRef: t,
    handleCustomColumnsChange: r
  };
}
const dde = Z({
  components: {
    pageTabs: rde,
    ability: mue,
    customColumnsModal: Jue
  },
  inheritAttrs: !1,
  props: rue,
  emits: oue,
  setup(e, { expose: t }) {
    const { pageConfigRef: n, isShowCustomColumnsModalRef: o, handleCustomColumnsChange: r } = ude(Te(e, "columns")), { formCompRef: l } = lue(), { antTableComponentRef: a, getProps: i } = aue(), { tableContainerDomRef: s, stickyRef: c, handleFullScreen: u } = lde(), d = Y({
      data: ""
    }), p = Y({
      data: {}
    }), v = Y(null), h = Y({
      multipleConfig: {}
    }), g = Y({
      data: ""
    }), b = Y({
      isFirstGetTable: !0,
      isLoading: !1,
      table: {
        data: [],
        pageable: {}
      },
      condition: {}
    });
    async function y() {
      let _ = {};
      if (d.value.data) {
        const M = {
          [e.pageTopTabs.uploadKey]: d.value.data
        };
        Object.assign(_, M);
      }
      if (p.value.data) {
        const M = _e(p.value.data);
        Object.assign(_, _e(M));
      }
      if (g.value.data) {
        const M = {
          [e.tableAboveTabs.uploadKey]: g.value.data
        };
        Object.assign(_, M);
      }
      return b.value.condition.pagination && Object.assign(_, b.value.condition.pagination), e.getTableDataExtraParamsAsync && (_ = await e.getTableDataExtraParamsAsync(_)), Promise.resolve(_);
    }
    async function S() {
      b.value.isLoading = !0;
      try {
        b.value.isFirstGetTable && e.delayFirstAsync && (await e.delayFirstAsync(), b.value.isFirstGetTable = !1);
        const _ = await y(), M = await e.getTableDataAsync(_);
        b.value.table.data = M.data, b.value.table.pageable = M.pageable;
      } catch {
        b.value.table.data = [];
      } finally {
        b.value.isLoading = !1;
      }
    }
    function C(..._) {
      v.value.handleCancelMultiple(..._);
    }
    function w() {
      p.value.data = {}, rt(() => {
        a.value.reset();
      });
    }
    function $() {
      a.value.reset();
    }
    function O() {
      a.value.reset();
    }
    function x() {
      p.value.data = {}, rt(() => {
        a.value.reset();
      });
    }
    function I() {
      S();
    }
    function E() {
      o.value = !0;
    }
    return t({
      antFormComponent: P(() => l.value && l.value.antFormComponent || null),
      antTableComponent: P(() => a.value.antTableComponent),
      handleFormQuery: O,
      // 点击搜索
      getTableData: S
      // 获取table数据
    }), {
      formCompRef: l,
      antTableComponentRef: a,
      tableConfigRef: b,
      formConfigRef: p,
      getProps: i,
      handleFormQuery: O,
      handleFormReset: x,
      handleCancelMultiple: C,
      pageTopTabsConfigRf: d,
      tableAboveTabsConfigRef: g,
      FORM_TYPE: Ia,
      abilityConfigRef: h,
      handlePaginationChange: I,
      handlePageTopTabChange: w,
      handleTableAboveTabChange: $,
      pageConfigRef: n,
      isShowCustomColumnsModalRef: o,
      handleOpenResizeModal: E,
      handleCustomColumnsChange: r,
      abilityRef: v,
      handleFullScreen: u,
      stickyRef: c,
      tableContainerDomRef: s,
      getParamsAsync: y
    };
  }
}), fde = {
  key: 3,
  class: "mt-8px"
}, pde = {
  ref: "tableContainerDomRef",
  class: "table-container"
}, vde = {
  key: 0,
  class: "table-slot"
}, gde = {
  key: 1,
  class: "table-slot"
};
function mde(e, t, n, o, r, l) {
  const a = st("page-tabs"), i = st("m-form"), s = st("ability"), c = st("m-table"), u = st("custom-columns-modal");
  return Ne(), it("div", {
    class: aa(["m-page", e.$attrs.class]),
    style: Fr(e.$attrs.style)
  }, [
    e.pageTopTabs ? (Ne(), Et(a, {
      key: 0,
      modelValue: e.pageTopTabsConfigRf.data,
      "onUpdate:modelValue": t[0] || (t[0] = (d) => e.pageTopTabsConfigRf.data = d),
      tabsConfig: e.pageTopTabs,
      onChange: e.handlePageTopTabChange
    }, null, 8, ["modelValue", "tabsConfig", "onChange"])) : ht("", !0),
    e.condition ? (Ne(), Et(i, Ft({
      key: 1,
      ref: "formCompRef",
      modelValue: e.formConfigRef.data,
      "onUpdate:modelValue": t[1] || (t[1] = (d) => e.formConfigRef.data = d)
    }, e.condition, {
      type: e.FORM_TYPE.tableCondition,
      onQuery: e.handleFormQuery,
      onReset: e.handleFormReset
    }), null, 16, ["modelValue", "type", "onQuery", "onReset"])) : ht("", !0),
    f(s, {
      ref: "abilityRef",
      modelValue: e.abilityConfigRef.multipleConfig,
      "onUpdate:modelValue": t[2] || (t[2] = (d) => e.abilityConfigRef.multipleConfig = d),
      class: "ability mt-8px",
      ability: e.ability,
      getParamsAsync: e.getParamsAsync,
      onOpenResizeModal: e.handleOpenResizeModal,
      onFullScreen: e.handleFullScreen
    }, null, 8, ["modelValue", "ability", "getParamsAsync", "onOpenResizeModal", "onFullScreen"]),
    e.tableAboveTabs ? (Ne(), Et(a, {
      key: 2,
      modelValue: e.tableAboveTabsConfigRef.data,
      "onUpdate:modelValue": t[3] || (t[3] = (d) => e.tableAboveTabsConfigRef.data = d),
      class: "mt-8px",
      tabsConfig: e.tableAboveTabs,
      onChange: e.handleTableAboveTabChange
    }, null, 8, ["modelValue", "tabsConfig", "onChange"])) : ht("", !0),
    e.$slots.tableAbove ? (Ne(), it("div", fde, [
      Bn(e.$slots, "tableAbove", {}, void 0, !0)
    ])) : ht("", !0),
    rn("div", pde, [
      e.$slots.tableLeft ? (Ne(), it("div", vde, [
        Bn(e.$slots, "tableLeft", {}, void 0, !0)
      ])) : ht("", !0),
      f(c, Ft({
        ref: "antTableComponentRef",
        paginationParams: e.tableConfigRef.condition,
        "onUpdate:paginationParams": t[4] || (t[4] = (d) => e.tableConfigRef.condition = d),
        class: "flex-1"
      }, e.getProps(e.$attrs), {
        sticky: e.stickyRef,
        columns: e.pageConfigRef.shownColumns,
        operationsColumn: e.operationsColumn,
        dataSource: e.tableConfigRef.table.data,
        loading: e.tableConfigRef.isLoading,
        multiple: e.abilityConfigRef.multipleConfig,
        pagination: e.tableConfigRef.table.pageable,
        paginationMap: e.paginationMap,
        onChange: e.handlePaginationChange,
        onCancelMultiple: e.handleCancelMultiple
      }), Sr({ _: 2 }, [
        ln(e.$slots, (d, p) => ({
          name: p,
          fn: pt((v) => [
            Bn(e.$slots, p, Ft(v, { key: p }), void 0, !0)
          ])
        }))
      ]), 1040, ["paginationParams", "sticky", "columns", "operationsColumn", "dataSource", "loading", "multiple", "pagination", "paginationMap", "onChange", "onCancelMultiple"]),
      e.$slots.tableRight ? (Ne(), it("div", gde, [
        Bn(e.$slots, "tableRight", {}, void 0, !0)
      ])) : ht("", !0)
    ], 512),
    e.isShowCustomColumnsModalRef ? (Ne(), Et(u, {
      key: 4,
      open: e.isShowCustomColumnsModalRef,
      "onUpdate:open": t[5] || (t[5] = (d) => e.isShowCustomColumnsModalRef = d),
      config: e.pageConfigRef.config,
      onChange: e.handleCustomColumnsChange
    }, null, 8, ["open", "config", "onChange"])) : ht("", !0)
  ], 6);
}
const hde = /* @__PURE__ */ _n(dde, [["render", mde], ["__scopeId", "data-v-0c928e9f"]]), bde = {}, yde = Object.values(bde), Sde = {};
function Cde() {
  function e(t) {
    const { style: n, ...o } = t;
    return delete o.class, o;
  }
  return {
    getProps: e
  };
}
const $de = Z({
  inheritAttrs: !1,
  props: Sde,
  emits: yde,
  setup(e, { expose: t }) {
    const { getProps: n } = Cde();
    return t({}), {
      getProps: n
    };
  }
}), wde = {
  key: 0,
  class: "description"
};
function xde(e, t, n, o, r, l) {
  return Ne(), it("div", Ft({ class: ["m-title"] }, e.getProps(e.$attrs), {
    style: e.$attrs.style
  }), [
    Bn(e.$slots, "default", {}, void 0, !0),
    e.$slots.description ? (Ne(), it("span", wde, [
      Bn(e.$slots, "description", {}, void 0, !0)
    ])) : ht("", !0)
  ], 16);
}
const Ode = /* @__PURE__ */ _n($de, [["render", xde], ["__scopeId", "data-v-88d3edb7"]]), Pde = {}, Ide = {}, Ede = {}, Tde = {}, Mde = {
  ...Tde
}, _de = Object.values(Mde), Ade = {
  // 底部按钮
  items: {
    required: !1,
    type: Array,
    default() {
      return [];
    }
  }
};
function Dde() {
  function e(t) {
    const { style: n, ...o } = t;
    delete o.class;
    for (const r of Object.values(Ide))
      delete o[r];
    return Object.assign(
      _e(o),
      _e(Pde),
      _e(o)
    );
  }
  return {
    getProps: e
  };
}
function Nde() {
  function e(t) {
    const { ...n } = t;
    for (const o of Object.values(Ede))
      delete n[o];
    return n;
  }
  return {
    getSlots: e
  };
}
const Rde = {
  // 获取是否为disabled
  disabled: !1,
  // 获取是否为hidden
  hidden: !1,
  // 点击回调
  async confirmAsync() {
    console.error("未提供必输confirmAsync函数");
  },
  // 文字描述
  label: "",
  // 按钮类型
  mode: Pc.normal,
  // 是否为loading状态
  loading: !1
};
function kde(e) {
  const t = Y([]);
  function n() {
    t.value = _e(e.value), t.value.forEach((o, r) => {
      Object.assign(t.value[r], _e(Rde), _e(t.value[r]));
    });
  }
  return ie(
    e,
    () => {
      n();
    },
    {
      immediate: !0,
      deep: !0
    }
  ), {
    itemsRef: t
  };
}
const Bde = Z({
  inheritAttrs: !1,
  props: Ade,
  emits: _de,
  setup(e, { expose: t }) {
    const { getProps: n } = Dde(), { getSlots: o } = Nde(), { itemsRef: r } = kde(Te(e, "items"));
    function l(i) {
      i.loading = !0, i.confirmAsync().then(() => {
      }).finally(() => {
        i.loading = !1;
      });
    }
    return t({}), {
      getProps: n,
      getSlots: o,
      itemsRef: r,
      handleClick: l
    };
  }
});
function Fde(e, t, n, o, r, l) {
  const a = st("m-button");
  return Ne(), it("div", Ft(e.getProps(e.$attrs), {
    class: ["m-footer", e.$attrs.class],
    style: e.$attrs.style
  }), [
    (Ne(!0), it(Fe, null, ln(e.itemsRef, (i, s) => (Ne(), it(Fe, { key: s }, [
      i.hidden ? ht("", !0) : (Ne(), Et(a, {
        key: 0,
        mode: i.mode,
        loading: i.loading,
        disabled: i.disabled,
        onClick: (c) => e.handleClick(i)
      }, {
        default: pt(() => [
          Ot(dn(i.label), 1)
        ]),
        _: 2
      }, 1032, ["mode", "loading", "disabled", "onClick"]))
    ], 64))), 128))
  ], 16);
}
const Lde = /* @__PURE__ */ _n(Bde, [["render", Fde], ["__scopeId", "data-v-3f974934"]]), GE = {
  click: "click"
}, zde = Object.values(GE), Hde = {
  type: {
    required: !1,
    type: String,
    default: "primary"
  },
  disabled: {
    required: !1,
    type: Boolean,
    default: !1
  },
  href: {
    required: !1,
    type: String,
    default: ""
  }
}, jde = Z({
  props: Hde,
  emits: zde,
  setup(e, { emit: t, expose: n }) {
    const o = P(() => !e.disabled && e.href ? e.href : "javascript:void(0);");
    function r(a) {
      e.disabled || t(GE.click, a);
    }
    const l = {};
    return n(l), {
      ...l,
      hrefCp: o,
      handleClick: r
    };
  }
}), Vde = ["href"];
function Wde(e, t, n, o, r, l) {
  return Ne(), it("a", {
    href: e.hrefCp,
    class: aa([
      "m-link",
      e.type,
      {
        disabled: e.disabled
      }
    ]),
    onClick: t[0] || (t[0] = (...a) => e.handleClick && e.handleClick(...a))
  }, [
    Bn(e.$slots, "default", {}, void 0, !0)
  ], 10, Vde);
}
const Kde = /* @__PURE__ */ _n(jde, [["render", Wde], ["__scopeId", "data-v-24f79ee6"]]), Gde = {}, Xde = {}, Ude = {}, Yde = {};
function qde() {
  function e(t) {
    const { style: n, ...o } = t;
    delete o.class;
    for (const r of Object.values(Xde))
      delete o[r];
    return Object.assign(
      _e(o),
      _e(Gde),
      _e(o)
    );
  }
  return {
    getProps: e
  };
}
function Zde() {
  function e(t) {
    const { ...n } = t;
    for (const o of Object.values(Ude))
      delete n[o];
    return n;
  }
  return {
    getSlots: e
  };
}
const Qde = {
  ...Yde
}, Jde = Object.values(Qde), efe = {
  // 展示内容的url
  url: {
    required: !0,
    type: String
  },
  enablePreview: {
    required: !1,
    type: Boolean,
    default() {
      return !0;
    }
  },
  enableDownload: {
    required: !1,
    type: Boolean,
    default() {
      return !0;
    }
  },
  // 下载接口
  downloadAsync: {
    required: !1,
    type: Function
  }
}, La = {
  PIC: "PIC",
  AUDIO: "AUDIO",
  VIDEO: "VIDEO",
  OFFICE: "OFFICE",
  PDF: "PDF"
}, tfe = [".png", ".jpg", ".jpeg"], nfe = [".audio", ".mp3", ".ogg"], ofe = [".video", ".mp4"], rfe = [".docx", ".xlsx", ".ppt"], lfe = Z({
  components: {
    AudioOutlined: sy,
    VideoCameraOutlined: vy,
    FileWordOutlined: fy,
    FilePdfOutlined: dy,
    CompressOutlined: cy,
    ArrowDownOutlined: iy
  },
  inheritAttrs: !1,
  props: efe,
  emits: Jde,
  setup(e, { expose: t }) {
    const { getProps: n } = qde(), { getSlots: o } = Zde(), r = Y(!1), l = P(() => tfe.find((u) => e.url.includes(u)) ? La.PIC : nfe.find((u) => e.url.includes(u)) ? La.AUDIO : ofe.find((u) => e.url.includes(u)) ? La.VIDEO : rfe.find((u) => e.url.includes(u)) ? La.OFFICE : La.PDF);
    function a() {
      r.value = !0;
    }
    function i() {
      r.value = !1;
    }
    async function s() {
      e.downloadAsync(e.url).then(() => {
      });
    }
    return t({}), {
      getProps: n,
      getSlots: o,
      TYPE: La,
      currentTypeCp: l,
      visibleRef: r,
      handlePreview: a,
      handlePreviewCancel: i,
      handleDownload: s
    };
  }
}), afe = { class: "inline-flex items-center" }, ife = ["src"], sfe = {
  key: 0,
  controls: "",
  controlsList: "nodownload",
  class: "w-100%"
}, cfe = /* @__PURE__ */ rn("track", { kind: "captions" }, null, -1), ufe = ["src"], dfe = {
  key: 1,
  controls: "",
  muted: "",
  controlsList: "nodownload"
}, ffe = /* @__PURE__ */ rn("track", { kind: "captions" }, null, -1), pfe = ["src"], vfe = ["src"], gfe = ["src"];
function mfe(e, t, n, o, r, l) {
  const a = st("AudioOutlined"), i = st("VideoCameraOutlined"), s = st("FileWordOutlined"), c = st("FilePdfOutlined"), u = st("CompressOutlined"), d = st("ArrowDownOutlined"), p = st("m-image"), v = st("m-modal");
  return Ne(), it("div", Ft(e.getProps(e.$attrs), {
    class: ["m-preview-download", e.$attrs.class],
    style: e.$attrs.style
  }), [
    rn("div", afe, [
      e.currentTypeCp === e.TYPE.PIC ? (Ne(), it("img", {
        key: 0,
        src: e.url,
        class: "w-24px h-24px"
      }, null, 8, ife)) : e.currentTypeCp === e.TYPE.AUDIO ? (Ne(), Et(a, {
        key: 1,
        class: "text-24px"
      })) : e.currentTypeCp === e.TYPE.VIDEO ? (Ne(), Et(i, {
        key: 2,
        class: "text-24px"
      })) : e.currentTypeCp === e.TYPE.OFFICE ? (Ne(), Et(s, {
        key: 3,
        class: "text-24px"
      })) : e.currentTypeCp === e.TYPE.PDF ? (Ne(), Et(c, {
        key: 4,
        class: "text-24px"
      })) : ht("", !0),
      e.enablePreview ? (Ne(), Et(u, {
        key: 5,
        class: "ml-8px cursor-pointer text-14px",
        onClick: e.handlePreview
      }, null, 8, ["onClick"])) : ht("", !0),
      e.enableDownload ? (Ne(), Et(d, {
        key: 6,
        class: "ml-8px cursor-pointer text-14px",
        onClick: e.handleDownload
      }, null, 8, ["onClick"])) : ht("", !0)
    ]),
    f(p, {
      class: "hidden",
      preview: {
        visible: e.currentTypeCp === e.TYPE.PIC && e.visibleRef,
        onVisibleChange: e.handlePreviewCancel
      },
      src: e.url
    }, null, 8, ["preview", "src"]),
    e.currentTypeCp !== e.TYPE.PIC && e.visibleRef ? (Ne(), Et(v, {
      key: 0,
      title: "预览",
      footer: null,
      visible: !0,
      width: "100%",
      "wrap-class-name": "full-modal",
      onCancel: e.handlePreviewCancel
    }, {
      default: pt(() => [
        e.currentTypeCp === e.TYPE.AUDIO ? (Ne(), it("audio", sfe, [
          cfe,
          rn("source", {
            src: e.url,
            type: "audio/mpeg"
          }, null, 8, ufe)
        ])) : ht("", !0),
        e.currentTypeCp === e.TYPE.VIDEO ? (Ne(), it("video", dfe, [
          ffe,
          rn("source", {
            src: e.url,
            type: "video/mp4"
          }, null, 8, pfe)
        ])) : ht("", !0),
        e.currentTypeCp === e.TYPE.OFFICE ? (Ne(), it("iframe", {
          key: 2,
          src: "https://view.officeapps.live.com/op/view.aspx?src=" + e.url,
          class: "w-100% h-100%"
        }, null, 8, vfe)) : ht("", !0),
        e.currentTypeCp === e.TYPE.PDF ? (Ne(), it("iframe", {
          key: 3,
          src: e.url,
          class: "w-100% h-100%"
        }, null, 8, gfe)) : ht("", !0)
      ]),
      _: 1
    }, 8, ["onCancel"])) : ht("", !0)
  ], 16);
}
const hfe = /* @__PURE__ */ _n(lfe, [["render", mfe]]), bfe = {
  Page: hde,
  Title: Ode,
  Footer: Lde,
  Link: Kde,
  PreviewDownload: hfe
}, yfe = Object.assign({}, Sae, tue, bfe);
function wfe(e) {
  for (const [t, n] of Object.entries(yfe))
    e.component(`m${t}`, n);
}
export {
  zn as Modal,
  wfe as default,
  xn as message,
  pa as notification,
  $fe as zhCN
};
//# sourceMappingURL=mo-web-components.js.map
